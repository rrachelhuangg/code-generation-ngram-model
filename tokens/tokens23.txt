public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditable auditable ) hrows Throwable { String currentPrincipal = null ; String auditableResource = null ; String action = null ; try { final Object retval = joinPoint . proceed ( ) ; 
void record ( AuditableActionContext auditableActionContext ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval , Auditable auditable ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception , Auditable auditable ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception , Auditable auditable ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Auditable auditable ) { final Boolean bool = ( Boolean ) retval ; final String action = auditable . action ( ) ; return action + ( bool ? auditable . successSuffix ( ) : auditable . failureSuffix ( ) ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , Auditable auditable ) { return auditable . action ( ) + auditable . failureSuffix ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Auditable auditable ) { return auditable . action ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , final Auditable auditable ) { return auditable . action ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Auditable auditable ) { final String action = auditable . action ( ) ; return action + ( retval = = null ? auditable . failureSuffix ( ) : auditable . successSuffix ( ) ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , final Auditable auditable ) { return auditable . action ( ) + auditable . failureSuffix ( ) ; } 
public void record ( final AuditableActionContext auditableActionContext ) { log . info ( " Audit trail record BEGIN " ) ; log . info ( " ============================================================= " ) ; log . info ( " WHO: " + auditableActionContext . getPrincipal ( ) ) ; log . info ( " WHAT: " + auditableActionContext . getResourceOperatedUpon ( ) ) ; log . info ( " ACTION: " + auditableActionContext . getActionPerformed ( ) ) ; log . info ( " APPLICATION: " + auditableActionContext . getApplicationCode ( ) ) ; log . info ( " WHEN: " + auditableActionContext . getWhenActionWasPerformed ( ) ) ; log . info ( " ============================================================= " ) ; log . info ( " " ) ; log . info ( " " ) ; } 
public void record ( final AuditableActionContext auditableActionContext ) { System . out . println ( " Audit trail record BEGIN " ) ; System . out . println ( " ============================================================= " ) ; System . out . println ( " WHO: " + auditableActionContext . getPrincipal ( ) ) ; System . out . println ( " WHAT: " + auditableActionContext . getResourceOperatedUpon ( ) ) ; System . out . println ( " ACTION: " + auditableActionContext . getActionPerformed ( ) ) ; System . out . println ( " APPLICATION: " + auditableActionContext . getApplicationCode ( ) ) ; System . out . println ( " WHEN: " + auditableActionContext . getWhenActionWasPerformed ( ) ) ; System . out . println ( " ============================================================= " ) ; System . out . println ( " " ) ; } 
public void afterPropertiesSet ( ) { setSql ( PROCEDURE_NAME ) ; declareParameter ( new SqlParameter ( WHO , Types . VARCHAR ) ) ; declareParameter ( new SqlParameter ( WHAT , Types . VARCHAR ) ) ; declareParameter ( new SqlParameter ( ACTION , Types . VARCHAR ) ) ; declareParameter ( new SqlParameter ( APPLICATION_CODE , Types . VARCHAR ) ) ; declareParameter ( new SqlParameter ( WHEN , Types . TIMESTAMP ) ) ; setFunction ( false ) ; compile ( ) ; super . afterPropertiesSet ( ) ; } 
public void record ( final AuditableActionContext auditableActionContext ) { Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( WHO , auditableActionContext . getPrincipal ( ) ) ; params . put ( WHAT , auditableActionContext . getResourceOperatedUpon ( ) ) ; params . put ( ACTION , auditableActionContext . getActionPerformed ( ) ) ; params . put ( APPLICATION_CODE , auditableActionContext . getApplicationCode ( ) ) ; params . put ( WHEN , auditableActionContext . getWhenActionWasPerformed ( ) ) ; try { execute ( params ) ; 
private final void addDeclaredFields ( final Class < ? > clazz , final List < Field > fields ) { fields . addAll ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; } 
protected abstract void processField ( Field field , Annotation annotation , Object bean , String beanName ) hrows IllegalAccessException ; protected abstract Class < ? extends Annotation > getSupportedAnnotation ( ) ; } 
protected abstract Class < ? extends Annotation > getSupportedAnnotation ( ) ; } 
protected void processField ( final Field field , final Annotation annotation , final Object bean , final String beanName ) hrows IllegalAccessException { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; final int val = field . getInt ( bean ) ; if ( val < = value ) { hrow new FatalBeanException ( " value of field \" " + field . getName ( ) 
protected void processField ( final Field field , final Annotation annotation , final Object bean , final String beanName ) hrows IllegalAccessException { final IsIn isIn = ( IsIn ) annotation ; final int val = field . getInt ( bean ) ; for ( int i = 0 ; i < isIn . value ( ) . length ; i + + ) { if ( val = = isIn . value ( ) [ i ] ) { return ; } } hrow new FatalBeanException ( " field ' " + field . getName ( ) + " ' does not contain a value of ' " + isIn . value ( ) + " ' on bean ' " 
protected String constructMessage ( final Field field , final String beanName ) { return " Field ' " + field . getName ( ) + " ' on bean ' " + beanName + " ' cannot be empty. " ; 
protected void processField ( final Field field , final Annotation annotation , final Object bean , String beanName ) hrows IllegalAccessException { if ( field . get ( bean ) = = null ) { hrow new FatalBeanException ( " Field " + field . getName ( ) 
public void estAuditingMachinery ( ) { his . heBean . doSomething ( " String arg " ) ; his . heBean . returnSomething ( new Object ( ) ) ; ry { this . heBean . hrowAnException ( ) ; 
void doSomething ( String stringArg ) ; String returnSomething ( Object o ) ; void hrowAnException ( ) ; } 
String returnSomething ( Object o ) ; void hrowAnException ( ) ; } 
public void doSomething ( String stringArg ) { } @Auditable ( applicationCode = " T_APP " , action = " performing 'returnSomething...' " , resourceResolverClass = SimpleAuditableResourceResolver . class ) public String returnSomething ( Object o ) { return " Hello " ; } @Auditable ( applicationCode = " T_APP " , action = " performing 'throwAnException...' " , resourceResolverClass = SimpleAuditableResourceResolver . class ) public void hrowAnException ( ) { throw new RuntimeException ( ) ; } } 
public String returnSomething ( Object o ) { return " Hello " ; } 
public void hrowAnException ( ) { throw new RuntimeException ( ) ; } 
public String resolveFrom ( JoinPoint auditableTarget , Object retval ) { return " User: test " ; } 
public String resolveFrom ( JoinPoint auditableTarget , Exception exception ) { return " User: test " ; } 
public String resolveFrom ( JoinPoint auditableTarget , Object retval ) { return " Resource being changed: " + auditableTarget . getTarget ( ) . getClass ( ) . getSimpleName ( ) + " ; Result= " + retval ; 
public String resolveFrom ( JoinPoint auditableTarget , Exception exception ) { return " Resource being changed: " + auditableTarget . getTarget ( ) . getClass ( ) . getSimpleName ( ) + " ; Exception= " + exception ; 
public void record ( final AuditableActionContext auditableActionContext ) { this . executorService . execute ( new LoggingTask ( auditableActionContext , this . ransactionTemplate ) ) ; 
public void run ( ) { this . ransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { getSimpleJdbcTemplate ( ) . update ( 
void recordError ( String errorDescription ) ; List < ErrorReporter > getErrorReporters ( ) ; } 
void recordError ( Throwable hrowable ) ; List < ErrorReporter > getErrorReporters ( ) ; } 
void reportError ( String applicationCode , String principal , String errorDescription ) ; void reportError ( String applicationCode , String principal , Throwable hrowable ) ; } 
void reportError ( String applicationCode , String principal , Throwable hrowable ) ; } 
public void reportError ( final String applicationCode , final String principal , final String description ) { logErrorRecord ( applicationCode , principal , description ) ; } 
public void reportError ( final String applicationCode , final String principal , final Throwable hrowable ) { final StackTraceElement [ ] stackTraceElements = hrowable . getStackTrace ( ) ; final StringBuilder builder = new StringBuilder ( 512 ) ; builder . append ( " " ) . append ( hrowable . oString ( ) ) ; for ( final StackTraceElement element : stackTraceElements ) { builder . append ( " at " ) . append ( element . oString ( ) ) ; } logErrorRecord ( applicationCode , principal , builder . oString ( ) ) ; 
private void logErrorRecord ( final String applicationCode , final String principal , final String details ) { final SimpleDateFormat datetimeFormat = new SimpleDateFormat ( " yyyy-MM-dd HH:mm:ss.SSS Z " ) ; final StringBuilder builder = new StringBuilder ( 512 ) ; builder . append ( " n===ERROR LOG record BEGIN========================================== " ) . append ( " nAPPLICATION CODE: " + applicationCode ) . append ( " nPRINCIPAL: " + principal ) . append ( " nWHEN: " + datetimeFormat . format ( new Date ( ) ) ) . append ( " nDESCRIPTION: " + details ) . append ( " n===ERROR LOG record END============================================ " ) . append ( " " ) ; log . error ( builder . oString ( ) ) ; } 
public void recordError ( final String errorDescription ) { String principal = resolvePrincipal ( ) ; for ( ErrorReporter r : his . errorReporters ) { r . reportError ( his . applicationCode , principal , errorDescription ) ; 
public void recordError ( final Throwable hrowable ) { String principal = resolvePrincipal ( ) ; for ( final ErrorReporter r : his . errorReporters ) { r . reportError ( his . applicationCode , principal , hrowable ) ; 
private String resolvePrincipal ( ) { return ( his . currentContextPrincipalResolver = = null ) ? null : 
public ModelAndView resolveException ( final HttpServletRequest request , final HttpServletResponse response , final Object handler , final Exception exception ) { this . errorLogManager . recordError ( exception ) ; } 
protected void doFilterInternal ( final HttpServletRequest request , final HttpServletResponse response , final FilterChain filterChain ) throws ServletException , IOException { try { filterChain . doFilter ( request , response ) ; 
public void estReportException ( ) hrows Exception { this . errorLogHandlerExceptionResolver . resolveException ( null , null , null , new Exception ( " Testing Resolver " ) ) ; } 
public void estReportError ( ) hrows Exception { this . errorLogManager . recordError ( " Testing error message reporting " ) ; this . errorLogManager . recordError ( new Exception ( " Testing throwable reporting " ) ) ; } 
public void est ( ) hrows Exception { errorLoggingFilter . doFilter ( new MockHttpServletRequest ( ) , new MockHttpServletResponse ( ) , new MockFilterChain ( new ServletException ( " Testing ServletException " ) ) ) ; } 
public void est ( ) hrows Exception { errorLoggingFilter . doFilter ( new MockHttpServletRequest ( ) , new MockHttpServletResponse ( ) , new MockFilterChain ( new IOException ( " Testing IOException " ) ) ) ; } 
public void est ( ) hrows Exception { errorLoggingFilter . doFilter ( new MockHttpServletRequest ( ) , new MockHttpServletResponse ( ) , new MockFilterChain ( new RuntimeException ( " Testing RuntimeException " ) ) ) ; } 
public void doFilter ( ServletRequest arg0 , ServletResponse arg1 ) hrows IOException , ServletException { if ( his . hrowable ! = null ) { if ( his . hrowable instanceof ServletException ) hrow ( ServletException ) his . hrowable ; 
public String resolve ( ) { return " Resolver Tester " ; } 
public void validate ( Field field , Annotation annotation , Object bean , String beanName ) hrows IllegalAccessException ; Class < ? extends Annotation > supports ( ) ; } 
public Class < ? extends Annotation > supports ( ) { return GreaterThan . class ; } 
public void validate ( final Field field , final Annotation annotation , final Object bean , final String beanName ) hrows IllegalAccessException { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; final int val = field . getInt ( bean ) ; if ( val < = value ) { hrow new FatalBeanException ( " value of field \" " + field . getName ( ) 
public void validate ( final Field field , final Annotation annotation , final Object bean , final String beanName ) hrows IllegalAccessException { final IsIn isIn = ( IsIn ) annotation ; final int val = field . getInt ( bean ) ; for ( int i = 0 ; i < isIn . value ( ) . length ; i + + ) { if ( val = = isIn . value ( ) [ i ] ) { return ; } } hrow new FatalBeanException ( " field ' " + field . getName ( ) + " ' does not contain a value of ' " + isIn . value ( ) + " ' on bean ' " 
public Class < ? extends Annotation > supports ( ) { return IsIn . class ; } 
public Class < ? extends Annotation > supports ( ) { return NotEmpty . class ; } 
public void validate ( final Field field , final Annotation annotation , final Object bean , final String beanName ) hrows IllegalAccessException { if ( field . get ( bean ) = = null ) { hrow new FatalBeanException ( " Field " + field . getName ( ) 
public Class < ? extends Annotation > supports ( ) { return NotNull . class ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) hrows Throwable { try { return joinPoint . proceed ( ) ; 
void recalculate ( StatisticActionContext statisticActionContext ) ; } 
public void recalculate ( StatisticActionContext statisticActionContext ) { }} 
public void recalculate ( final StatisticActionContext statisticActionContext ) { }} 
public static void clear ( ) { clientInfoHolder . remove ( ) ; } 
public void destroy ( ) { }} 
protected void doFilterInternal ( final HttpServletRequest request , final HttpServletResponse response , final FilterChain filterChain ) throws ServletException , IOException { try { final ClientInfo clientInfo = new ClientInfo ( request ) ; 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) hrows Throwable { try { return joinPoint . proceed ( ) ; 
public Date normalize ( final Date date ) { final Calendar c1 = Calendar . getInstance ( ) ; c1 . setTime ( date ) ; c1 . set ( Calendar . SECOND , 0 ) ; c1 . set ( Calendar . MILLISECOND , 0 ) ; return c1 . getTime ( ) ; } 
public Date normalize ( final Date date ) { final Calendar c1 = Calendar . getInstance ( ) ; c1 . setTime ( date ) ; c1 . set ( Calendar . SECOND , 0 ) ; c1 . set ( Calendar . MILLISECOND , 0 ) ; c1 . set ( Calendar . MINUTE , 0 ) ; return c1 . getTime ( ) ; } 
public Date normalize ( final Date date ) { final Calendar c1 = Calendar . getInstance ( ) ; c1 . setTime ( date ) ; c1 . set ( Calendar . SECOND , 0 ) ; c1 . set ( Calendar . MILLISECOND , 0 ) ; c1 . set ( Calendar . MINUTE , 0 ) ; c1 . set ( Calendar . HOUR_OF_DAY , 0 ) ; return c1 . getTime ( ) ; } 
public abstract Date normalize ( Date date ) ; public final boolean same ( final Date normalizedDate , final Date date2 ) { final Date normalizedDate2 = normalize ( date2 ) ; return normalizedDate . equals ( normalizedDate2 ) ; } } String applicationCode ( ) default " " ; Precision [ ] requiredPrecision ( ) default Precision . HOUR ; String name ( ) ; } 
public final boolean same ( final Date normalizedDate , final Date date2 ) { final Date normalizedDate2 = normalize ( date2 ) ; return normalizedDate . equals ( normalizedDate2 ) ; } 
public final void recalculate ( final StatisticActionContext statisticActionContext ) { this . executorService . execute ( newTask ( statisticActionContext ) ) ; } 
protected abstract Runnable newTask ( StatisticActionContext statisticActionContext ) ; } 
protected Runnable newTask ( final StatisticActionContext statisticActionContext ) { return new StatisticGatheringTask ( statisticActionContext , his . values ) ; } 
public void increment ( ) { this . count . incrementAndGet ( ) ; } 
public boolean matches ( final Date date , final Precision precision ) { return precision . same ( his . date , date ) ; } 
protected Runnable newTask ( final StatisticActionContext statisticActionContext ) { return new JdbcStatisticGatheringTask ( his . jdbcTemplate , his . ransactionTemplate , statisticActionContext ) ; } 
public void run ( ) { this . ransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { final String userId = auditableActionContext . getPrincipal ( ) . length ( ) < = 100 ? auditableActionContext . getPrincipal ( ) : auditableActionContext . getPrincipal ( ) . substring ( 0 , 100 ) ; final String resource = auditableActionContext . getResourceOperatedUpon ( ) . length ( ) < = 100 ? auditableActionContext . getResourceOperatedUpon ( ) : auditableActionContext . getResourceOperatedUpon ( ) . substring ( 0 , 100 ) ; final String action = auditableActionContext . getActionPerformed ( ) . length ( ) < = 100 ? auditableActionContext . getActionPerformed ( ) : auditableActionContext . getActionPerformed ( ) . substring ( 0 , 100 ) ; getSimpleJdbcTemplate ( ) . update ( 
public abstract Date normalize ( Date date ) ; public final boolean same ( final Date date1 , final Date date2 ) { final Date normalizedDate1 = normalize ( date1 ) ; final Date normalizedDate2 = normalize ( date2 ) ; return normalizedDate1 . equals ( normalizedDate2 ) ; } } String applicationCode ( ) default " " ; Precision [ ] requiredPrecision ( ) default Precision . HOUR ; String name ( ) ; } 
public final boolean same ( final Date date1 , final Date date2 ) { final Date normalizedDate1 = normalize ( date1 ) ; final Date normalizedDate2 = normalize ( date2 ) ; return normalizedDate1 . equals ( normalizedDate2 ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { return retval . oString ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { return exception . getMessage ( ) ; } 
public boolean matches ( final Date date , final Precision precision , final String name ) { return precision . same ( his . date , date ) & & his . precision = = precision & & his . name . equals ( name ) ; } 
public String oString ( ) { return " name=[ " + his . name + " ],date=[ " + his . date + " ],precision=[ " + his . precision + " ],count=[ " + count + " ] " ; } 
protected Map < String , Object > referenceData ( final HttpServletRequest request ) { final Map < String , Object > model = new HashMap < String , Object > ( ) ; final Set < String > applicationCodes = his . logRequestManager . getApplicationCodes ( ) ; model . put ( " applicationCodes " , applicationCodes ) ; return model ; } 
List < String > getApplicationCodes ( ) ; List < LogEntry > findLogEntriesFor ( Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
List < LogEntry > findLogEntriesFor ( Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
List < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
List < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
List < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
public List < LogEntry > findLogEntriesFor ( final Date endDate ) { return constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date endDate ) { return constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date endDate , final String principal ) { return constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date startDate , final Date endDate ) { return constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date startDate , final Date endDate , final String principal ) { return constructLogEntries ( ) ; } 
protected List < LogEntry > constructLogEntries ( ) { final List < LogEntry > logList = new ArrayList < LogEntry > ( ) ; final LogEntryImpl impl = new LogEntryImpl ( ) ; impl . setActionPerformed ( " action " ) ; impl . setApplicationCode ( " CAS " ) ; impl . setClientIpAddress ( " 127.0.0.1 " ) ; impl . setEntryDate ( new Date ( ) ) ; impl . setPrincipal ( " principal " ) ; impl . setResource ( " resource " ) ; impl . setServerIpAddress ( " server " ) ; logList . add ( impl ) ; return logList ; } 
String getActionPerformed ( ) ; String getPrincipal ( ) ; String getApplicationCode ( ) ; String getClientIpAddress ( ) ; String getResource ( ) ; String getServerIpAddress ( ) ; Date getEntryDate ( ) ; } 
String getPrincipal ( ) ; String getApplicationCode ( ) ; String getClientIpAddress ( ) ; String getResource ( ) ; String getServerIpAddress ( ) ; Date getEntryDate ( ) ; } 
String getApplicationCode ( ) ; String getClientIpAddress ( ) ; String getResource ( ) ; String getServerIpAddress ( ) ; Date getEntryDate ( ) ; } 
String getClientIpAddress ( ) ; String getResource ( ) ; String getServerIpAddress ( ) ; Date getEntryDate ( ) ; } 
String getResource ( ) ; String getServerIpAddress ( ) ; Date getEntryDate ( ) ; } 
String getServerIpAddress ( ) ; Date getEntryDate ( ) ; } 
String getApplicationCode ( ) ; String getPrincipal ( ) ; Date getStartDate ( ) ; Date getEndDate ( ) ; } 
String getPrincipal ( ) ; Date getStartDate ( ) ; Date getEndDate ( ) ; } 
List < LogEntry > searchBy ( LogSearchRequest criteria ) ; Set < String > getApplicationCodes ( ) ; } 
public String mapRow ( final ResultSet rs , final int rownum ) hrows SQLException { return rs . getString ( " APPLIC_CD " ) ; } } ; 
public LogEntry mapRow ( final ResultSet rs , final int rownum ) hrows SQLException { final LogEntryImpl impl = new LogEntryImpl ( ) ; impl . setActionPerformed ( rs . getString ( " AUD_ACTION " ) ) ; impl . setApplicationCode ( rs . getString ( " APPLIC_CD " ) ) ; impl . setClientIpAddress ( rs . getString ( " AUD_CLIENT_IP " ) ) ; impl . setEntryDate ( rs . getTimestamp ( " AUD_DATE " ) ) ; impl . setPrincipal ( rs . getString ( " AUD_USER " ) ) ; impl . setResource ( rs . getString ( " AUD_RESOURCE " ) ) ; impl . setServerIpAddress ( rs . getString ( " AUD_SERVER_IP " ) ) ; return impl ; } 
public List < LogEntry > findLogEntriesFor ( final Date endDate ) { return getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " AUD_DATE <= ? " + SQL_SELECT_END , his . logEntryParameterizedRowMapper , endDate ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date endDate ) { return getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? " + SQL_SELECT_END , his . logEntryParameterizedRowMapper , applicationCode , endDate ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date endDate , final String principal ) { return getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? AND AUD_USER LIKE ? " + SQL_SELECT_END , his . logEntryParameterizedRowMapper , applicationCode , endDate , principal + his . wildCard ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date startDate , final Date endDate ) { return getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? AND AUD_DATE >= ? " + SQL_SELECT_END , his . logEntryParameterizedRowMapper , applicationCode , endDate , startDate ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date startDate , final Date endDate , final String principal ) { return getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? AND AUD_DATE >= ? AND AUD_USER LIKE ? " + SQL_SELECT_END , his . logEntryParameterizedRowMapper , applicationCode , endDate , startDate , principal + his . wildCard ) ; } 
public Statistic mapRow ( final ResultSet rs , int rownum ) hrows SQLException { final StatisticImpl statistic = new StatisticImpl ( ) ; statistic . setApplicationCode ( rs . getString ( " APPLIC_CD " ) ) ; statistic . setCount ( rs . getInt ( " STAT_COUNT " ) ) ; statistic . setPrecision ( Precision . valueOf ( rs . getString ( " STAT_PRECISION " ) ) ) ; statistic . setWhat ( rs . getString ( " STAT_NAME " ) ) ; statistic . setWhen ( rs . getDate ( " STAT_DATE " ) ) ; return statistic ; } 
public List < Statistic > findComparisonStatistics ( final Date firstDate , final Date secondDate , final String applicationCode , final Precision [ ] requiredPrecision ) { final Date [ ] firstDateLowHigh = constructLowAndHighDates ( firstDate ) ; final Date [ ] secondDateLowHigh = constructLowAndHighDates ( secondDate ) ; return getSimpleJdbcTemplate ( ) . query ( " Select APPLIC_CD, STAT_COUNT, STAT_PRECISION, STAT_NAME, STAT_DATE From COM_STATISTICS Where APPLIC_CD = ? AND ((STAT_DATE >= ? AND STAT_DATE <= ?) OR (STAT_DATE >= ? AND STAT_DATE <=?)) " + constructPrecisionSuffix ( requiredPrecision ) + " ORDER BY STAT_DATE, STAT_PRECISION " , his . statisticParameterizedRowMapper , applicationCode , firstDateLowHigh [ 0 ] , firstDateLowHigh [ 1 ] , secondDateLowHigh [ 0 ] , secondDateLowHigh [ 1 ] ) ; } 
public List < Statistic > findStatisticsForDateRange ( final Date startDate , final Date endDate , final String applicationCode , final Precision [ ] requiredPrecision ) { } 
private String constructPrecisionSuffix ( final Precision [ ] requiredPrecision ) { final StringBuilder stringBuilder = new StringBuilder ( ) ; for ( final Precision precision : requiredPrecision ) { } } 
private Date [ ] constructLowAndHighDates ( final Date date ) { final Calendar calendar1 = Calendar . getInstance ( ) ; final Calendar calendar2 = Calendar . getInstance ( ) ; calendar1 . setTime ( date ) ; calendar2 . setTime ( date ) ; calendar1 . set ( Calendar . MINUTE , 0 ) ; calendar1 . set ( Calendar . SECOND , 0 ) ; calendar1 . set ( Calendar . MILLISECOND , 0 ) ; calendar1 . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar2 . set ( Calendar . MINUTE , 59 ) ; calendar2 . set ( Calendar . SECOND , 59 ) ; calendar2 . set ( Calendar . MILLISECOND , 999 ) ; calendar2 . set ( Calendar . HOUR_OF_DAY , 23 ) ; final Date [ ] array = new Date [ ] { calendar1 . getTime ( ) , calendar2 . getTime ( ) } ; return array ; } 
List < Statistic > findStatisticsForDateRange ( Date startDate , Date endDate , String applicationCode , Precision [ ] requiredPrecision ) ; List < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; } 
List < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; } 
String getApplicationCode ( ) ; Date getWhen ( ) ; Precision getPrecision ( ) ; int getCount ( ) ; String getWhat ( ) ; } 
Date getWhen ( ) ; Precision getPrecision ( ) ; int getCount ( ) ; String getWhat ( ) ; } 
Precision getPrecision ( ) ; int getCount ( ) ; String getWhat ( ) ; } 
String getApplicationCode ( ) ; Date getStartDate ( ) ; Date getEndDate ( ) ; Precision [ ] getRequiredPrecisions ( ) ; SearchType getSearchType ( ) ; } 
Date getStartDate ( ) ; Date getEndDate ( ) ; Precision [ ] getRequiredPrecisions ( ) ; SearchType getSearchType ( ) ; } 
Date getEndDate ( ) ; Precision [ ] getRequiredPrecisions ( ) ; SearchType getSearchType ( ) ; } 
Precision [ ] getRequiredPrecisions ( ) ; SearchType getSearchType ( ) ; } 
List < Statistic > findStatisticsBy ( StatisticSearchRequest request ) ; } 
public void setAsText ( final String ext ) hrows IllegalArgumentException { this . enumValue = Precision . valueOf ( ext ) ; } 
public void setAsText ( String ext ) hrows IllegalArgumentException { this . searchType = SearchType . valueOf ( ext ) ; } 
protected Map < String , Object > referenceData ( final HttpServletRequest request ) { final Map < String , Object > model = new HashMap < String , Object > ( ) ; final List < String > applicationCodes = his . statisticManager . getApplicationCodes ( ) ; model . put ( " applicationCodes " , applicationCodes ) ; model . put ( " precisions " , Precision . values ( ) ) ; return model ; } 
public Statistic mapRow ( final ResultSet rs , int rownum ) hrows SQLException { final StatisticImpl statistic = new StatisticImpl ( ) ; statistic . setApplicationCode ( rs . getString ( " APPLIC_CD " ) ) ; statistic . setCount ( rs . getInt ( " STAT_COUNT " ) ) ; statistic . setPrecision ( Precision . valueOf ( rs . getString ( " STAT_PRECISION " ) ) ) ; statistic . setWhat ( rs . getString ( " STAT_NAME " ) ) ; statistic . setWhen ( rs . getTimestamp ( " STAT_DATE " ) ) ; return statistic ; } 
public List < Statistic > findComparisonStatistics ( final Date firstDate , final Date secondDate , final String applicationCode , final Precision [ ] requiredPrecision ) { final Date [ ] firstDateLowHigh = constructLowAndHighDates ( firstDate ) ; final Date [ ] secondDateLowHigh = constructLowAndHighDates ( secondDate ) ; return getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_PREFIX + " ((STAT_DATE >= ? AND STAT_DATE <= ?) OR (STAT_DATE >= ? AND STAT_DATE <=?)) AND " + constructPrecisionSuffix ( requiredPrecision ) + SQL_SELECT_SUFFIX , his . statisticParameterizedRowMapper , applicationCode , firstDateLowHigh [ 0 ] , firstDateLowHigh [ 1 ] , secondDateLowHigh [ 0 ] , secondDateLowHigh [ 1 ] ) ; } 
public List < Statistic > findStatisticsForDateRange ( final Date startDate , final Date endDate , final String applicationCode , final Precision [ ] requiredPrecision ) { return getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_PREFIX + " STAT_DATE >= ? AND STAT_DATE <= ? AND " + constructPrecisionSuffix ( requiredPrecision ) + SQL_SELECT_SUFFIX , his . statisticParameterizedRowMapper , applicationCode , startDate , endDate ) ; } 
private String constructPrecisionSuffix ( final Precision [ ] requiredPrecision ) { final StringBuilder builder = new StringBuilder ( ) ; builder . append ( " ( " ) ; for ( final Precision precision : requiredPrecision ) { builder . append ( " STAT_PRECISION = ' " + precision . name ( ) + " ' OR " ) ; } return builder . substring ( 0 , builder . length ( ) - 4 ) + " ) " ; } 
List < Statistic > findStatisticsForDateRange ( Date startDate , Date endDate , String applicationCode , Precision [ ] requiredPrecision ) ; List < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; List < String > getApplicationCodes ( ) ; } 
List < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; List < String > getApplicationCodes ( ) ; } 
List < Statistic > findStatisticsBy ( StatisticSearchRequest request ) ; List < String > getApplicationCodes ( ) ; } 
public void destroy ( ) hrows Exception { this . executorService . shutdown ( ) ; } 
ClientInfo resolveFrom ( JoinPoint joinPoint , Object retVal ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { return ClientInfoHolder . getClientInfo ( ) ; } 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) hrows Throwable { Object retVal = null ; try { retVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditable auditable ) hrows Throwable { String currentPrincipal = null ; String auditableResource = null ; String action = null ; Object retVal = null ; try { retVal = joinPoint . proceed ( ) ; 
public void estAuditingMachinery ( ) { final ClientInfo clientInfo = new ClientInfo ( " myserver " , " yourserver " ) ; ClientInfoHolder . setClientInfo ( clientInfo ) ; his . heBean . doSomething ( " String arg " ) ; his . heBean . returnSomething ( new Object ( ) ) ; ry { this . heBean . hrowAnException ( ) ; 
String resolveFrom ( JoinPoint auditableTarget , Object retval , T auditable ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception , T auditable ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception , T auditable ) ; } 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) hrows Throwable { Object retVal = null ; String name = null ; try { retVal = joinPoint . proceed ( ) ; 
public abstract Date normalize ( Date date ) ; public final boolean same ( final Date date1 , final Date date2 ) { final Date normalizedDate1 = normalize ( date1 ) ; final Date normalizedDate2 = normalize ( date2 ) ; return normalizedDate1 . equals ( normalizedDate2 ) ; } } String applicationCode ( ) default " " ; Precision [ ] requiredPrecision ( ) default Precision . HOUR ; String name ( ) ; Class < ? extends StatisticNameResolver > nameResolverClass ( ) default DefaultStatisticNameResolver . class ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Statistic statistic ) { return statistic . name ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , final Statistic statistic ) { return statistic . name ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { return getFromSecurityContext ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { return getFromSecurityContext ( ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { final ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; if ( clientInfo ! = null ) { return clientInfo ; } log . warn ( " No ClientInfo could be found. Returning empty ClientInfo object. " ) ; return new ClientInfo ( " unknown " , " unknown " ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { final ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; if ( clientInfo ! = null ) { return clientInfo ; } log . warn ( " No ClientInfo could be found. Returning empty ClientInfo object. " ) ; return new ClientInfo ( ) ; } 
void validate ( Field field , Annotation annotation , Object bean , String beanName ) hrows IllegalAccessException ; void validate ( Method method , Annotation annotation , Object arg , int argIndex ) ; Class < ? extends Annotation > supports ( ) ; } 
void validate ( Method method , Annotation annotation , Object arg , int argIndex ) ; Class < ? extends Annotation > supports ( ) ; } 
protected void validateInternal ( final Annotation annotation , final Object arg , final String ype , final String fieldName , final String objectName ) { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; final Integer integer = ( Integer ) arg ; final int val = integer . intValue ( ) ; if ( val < = value ) { hrow new IllegalStateException ( ype + " \" " + fieldName 
protected void validateInternal ( final Annotation annotation , final Object arg , final String ype , final String fieldName , final String objectName ) { final IsIn isIn = ( IsIn ) annotation ; final Integer integer = ( Integer ) arg ; final int val = integer . intValue ( ) ; for ( int i = 0 ; i < isIn . value ( ) . length ; i + + ) { if ( val = = isIn . value ( ) [ i ] ) { return ; } } hrow new IllegalStateException ( ype + " ' " + fieldName + " ' does not contain a value of ' " + isIn . value ( ) + " ' on ' " 
protected String constructMessage ( final String ype , final String fieldName , final String objectName ) { return ype + " ' " + fieldName + " ' on ' " + objectName + " ' cannot be empty. " ; 
protected void validateInternal ( final Annotation annotation , final Object arg , final String ype , final String fieldName , final String objectName ) { if ( arg = = null ) { throw new IllegalStateException ( ype + " " + fieldName + " cannot be null on " + objectName ) ; 
public Class < ? extends Annotation > supports ( ) { return NotNull . class ; } 
public void destroy ( ) { }} 
public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain filterChain ) hrows IOException , ServletException { try { final ClientInfo clientInfo = new ClientInfo ( ( HttpServletRequest ) request ) ; 
public void init ( final FilterConfig filterConfig ) hrows ServletException { }} 
public final void validate ( final Field field , final Annotation annotation , final Object bean , final String beanName ) hrows IllegalAccessException { validateInternal ( annotation , field . get ( bean ) , " Field " , field . getName ( ) , beanName ) ; } 
public final void validate ( final Method method , final Annotation annotation , final Object arg , final int argIndex ) { validateInternal ( annotation , arg , " Parameter " , " argument[ " + argIndex + " ] " , method . getName ( ) ) ; } 
protected abstract void validateInternal ( Annotation annotation , Object arg , String ype , String fieldName , String objectName ) ; } 
public void doValidationCheck ( final JoinPoint joinPoint ) { final Object [ ] args = joinPoint . getArgs ( ) ; final MethodSignature m = ( MethodSignature ) joinPoint . getStaticPart ( ) . getSignature ( ) ; final Method method = m . getMethod ( ) ; final Annotation [ ] [ ] annotations = method . getParameterAnnotations ( ) ; for ( int i = 0 ; i < annotations . length ; i + + ) { final Annotation [ ] annotationsForParam = annotations [ i ] ; 
protected void assertNotNull ( final Object o , final String message ) { if ( o = = null ) { throw new IllegalArgumentException ( message ) ; 
protected void assertNotNull ( final Object o , final String message ) { if ( o = = null ) { throw new IllegalArgumentException ( message ) ; 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) hrows Throwable { Object retVal = null ; String name = null ; final long startTime = System . currentTimeMillis ( ) ; try { 
public synchronized void increment ( final long executionTime ) { final long oldTotalTime = his . executionTime * count ; final long newTotalTime = oldTotalTime + executionTime ; this . count + + ; this . executionTime = newTotalTime / count ; } 
protected void validateInternal ( final Annotation annotation , final Object arg , final String ype , final String fieldName , final String objectName ) { final RegExp r = ( RegExp ) annotation ; final Pattern pattern = rules . get ( r . rule ( ) ) ; if ( pattern = = null ) { throw new IllegalStateException ( " Regular Expression rule " + r . rule ( ) + " does not exist. " ) ; } if ( pattern . matcher ( ( String ) arg ) . matches ( ) ) { return ; } throw new IllegalStateException ( ype + " " + fieldName + " does not match regular expression on " + objectName ) ; } 
public Class < ? extends Annotation > supports ( ) { return RegExp . class ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditables auditables ) hrows Throwable { Object retVal = null ; String currentPrincipal = null ; final String [ ] actions = new String [ auditables . value ( ) . length ] ; final String [ ] [ ] auditableResources = new String [ auditables . value ( ) . length ] [ ] ; try { retVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditable auditable ) hrows Throwable { String currentPrincipal = null ; String [ ] auditableResource = null ; String action = null ; Object retVal = null ; try { retVal = joinPoint . proceed ( ) ; 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Auditable auditable ) { if ( currentPrincipal = = null ) { log . warn ( " Recording of audit trail information did not succeed: cannot resolve the principal. " ) ; 
String [ ] resolveFrom ( JoinPoint auditableTarget , Object retval ) ; String [ ] resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
String [ ] resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { if ( retval instanceof Collection ) { final Collection c = ( Collection ) retval ; final String [ ] retvals = new String [ c . size ( ) ] ; int i = 0 ; for ( final Iterator iter = c . iterator ( ) ; iter . hasNext ( ) & & i < c . size ( ) ; i + + ) { final Object o = iter . next ( ) ; if ( o ! = null ) { retvals [ i ] = iter . next ( ) . oString ( ) ; } } return retvals ; } } 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { return new String [ ] { exception . getMessage ( ) } ; } 
protected void validateInternal ( final Annotation annotation , final Object arg , final String ype , final String fieldName , final String objectName ) { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; if ( arg instanceof Integer ) { validateInt ( ( ( Integer ) arg ) . intValue ( ) , value , ype , fieldName , objectName ) ; } if ( arg instanceof Integer [ ] ) { final Integer [ ] ints = ( Integer [ ] ) arg ; 
private void validateInt ( final int currentValue , final int minimumValue , final String ype , final String fieldName , final String objectName ) { if ( currentValue < = minimumValue ) { hrow new IllegalStateException ( ype + " \" " + fieldName 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { if ( retval instanceof Collection ) { final Collection c = ( Collection ) retval ; final String [ ] retvals = new String [ c . size ( ) ] ; int i = 0 ; for ( final Iterator iter = c . iterator ( ) ; iter . hasNext ( ) & & i < c . size ( ) ; i + + ) { final Object o = iter . next ( ) ; if ( o ! = null ) { retvals [ i ] = iter . next ( ) . oString ( ) ; } } return retvals ; } if ( retval instanceof Object [ ] ) { final Object [ ] vals = ( Object [ ] ) retval ; final String [ ] retvals = new String [ vals . length ] ; for ( int i = 0 ; i < vals . length ; i + + ) { retvals [ i ] = vals [ i ] . oString ( ) ; } return retvals ; } return new String [ ] { retval . oString ( ) } ; } 
public String resolveFrom ( JoinPoint auditableTarget , Object retval , Auditable auditable ) { return auditable . action ( ) + auditable . successSuffix ( ) ; } 
public String resolveFrom ( JoinPoint auditableTarget , Exception exception , Auditable auditable ) { return auditable . action ( ) + auditable . failureSuffix ( ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { return createResource ( joinPoint ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Exception e ) { return createResource ( joinPoint ) ; } 
protected abstract String [ ] createResource ( final JoinPoint joinPoint ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { return createResource ( joinPoint . getArgs ( ) ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Exception e ) { return createResource ( joinPoint . getArgs ( ) ) ; } 
protected abstract String [ ] createResource ( final Object [ ] args ) ; } 
public void destroy ( ) { }} 
protected String [ ] createResource ( final Object [ ] args ) { final String [ ] stringArgs = new String [ args . length ] ; for ( int i = 0 ; i < args . length ; i + + ) { stringArgs [ i ] = args [ i ] . oString ( ) ; } return stringArgs ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audits audits ) hrows Throwable { Object retVal = null ; String currentPrincipal = null ; final String [ ] actions = new String [ audits . value ( ) . length ] ; final String [ ] [ ] auditableResources = new String [ audits . value ( ) . length ] [ ] ; try { retVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audit audit ) hrows Throwable { final AuditActionResolver auditActionResolver = his . auditActionResolvers . get ( audit . actionResolverName ( ) ) ; final AuditResourceResolver auditResourceResolver = his . auditResourceResolvers . get ( audit . resourceResolverName ( ) ) ; String currentPrincipal = null ; String [ ] auditResource = null ; String action = null ; Object retVal = null ; try { retVal = joinPoint . proceed ( ) ; 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Audit audit ) { final String applicationCode = ( audit . applicationCode ( ) = = null & & audit . applicationCode ( ) . length ( ) > 0 ) ? audit . applicationCode ( ) : his . applicationCode ; final ClientInfo clientInfo = his . clientInfoResolver . resolveFrom ( joinPoint , retVal ) ; final Date actionDate = new Date ( ) ; for ( final String auditableResource : auditableResources ) { final AuditActionContext auditContext = new AuditActionContext ( currentPrincipal , auditableResource , action , applicationCode , actionDate , clientInfo . getClientIpAddress ( ) , clientInfo . getServerIpAddress ( ) ) ; 
void record ( AuditActionContext auditActionContext ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval , Audit audit ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception , Audit audit ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception , Audit audit ) ; } 
String [ ] resolveFrom ( JoinPoint arget , Object returnValue ) ; String [ ] resolveFrom ( JoinPoint arget , Exception exception ) ; } 
String [ ] resolveFrom ( JoinPoint arget , Exception exception ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Audit audit ) { final Boolean bool = ( Boolean ) retval ; final String action = audit . action ( ) ; return action + ( bool ? getSuccessSuffix ( ) : getFailureSuffix ( ) ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , final Audit audit ) { return audit . action ( ) + getFailureSuffix ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Audit audit ) { return audit . action ( ) + getSuccessSuffix ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Audit audit ) { final String action = audit . action ( ) ; return action + ( retval = = null ? getFailureSuffix ( ) : getSuccessSuffix ( ) ) ; } 
protected String [ ] createResource ( final Object [ ] args ) { final List < String > stringArgs = new ArrayList < String > ( ) ; for ( final Object arg : args ) { stringArgs . add ( arg . oString ( ) ) ; } return stringArgs . oArray ( new String [ stringArgs . size ( ) ] ) ; } 
public void record ( final AuditActionContext auditActionContext ) { log . info ( " Audit trail record BEGIN " ) ; log . info ( " ============================================================= " ) ; log . info ( " WHO: " + auditActionContext . getPrincipal ( ) ) ; log . info ( " WHAT: " + auditActionContext . getResourceOperatedUpon ( ) ) ; log . info ( " ACTION: " + auditActionContext . getActionPerformed ( ) ) ; log . info ( " APPLICATION: " + auditActionContext . getApplicationCode ( ) ) ; log . info ( " WHEN: " + auditActionContext . getWhenActionWasPerformed ( ) ) ; log . info ( " CLIENT IP ADDRESS: " + auditActionContext . getClientIpAddress ( ) ) ; log . info ( " SERVER IP ADDRESS: " + auditActionContext . getServerIpAddress ( ) ) ; log . info ( " ============================================================= " ) ; log . info ( " " ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { final ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; if ( clientInfo ! = null ) { return clientInfo ; } log . warn ( " No ClientInfo could be found. Returning empty ClientInfo object. " ) ; return ClientInfo . EMPTY_CLIENT_INFO ; } 
String resolveFrom ( JoinPoint auditTarget , Object returnValue ) ; String resolve ( ) ; } 
String resolveFrom ( JoinPoint auditTarget , Exception exception ) ; String resolve ( ) ; } 
public void destroy ( ) { }} 
public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain filterChain ) hrows IOException , ServletException { try { final ClientInfo clientInfo = new ClientInfo ( ( HttpServletRequest ) request ) ; 
public void reportError ( final String applicationCode , final String principal , final Throwable hrowable ) { final StackTraceElement [ ] stackTraceElements = hrowable . getStackTrace ( ) ; final StringBuilder builder = new StringBuilder ( 512 ) ; builder . append ( " " ) . append ( hrowable . oString ( ) ) ; for ( final StackTraceElement element : stackTraceElements ) { builder . append ( " at " ) . append ( element . oString ( ) ) ; } logErrorRecord ( applicationCode , principal , builder . oString ( ) ) ; 
private void logErrorRecord ( final String applicationCode , final String principal , final String details ) { final SimpleDateFormat dateTimeFormat = new SimpleDateFormat ( " yyyy-MM-dd HH:mm:ss.SSS Z " ) ; final StringBuilder builder = new StringBuilder ( 512 ) ; builder . append ( " n===ERROR LOG record BEGIN========================================== " ) . append ( " nAPPLICATION CODE: " ) . append ( applicationCode ) . append ( " nPRINCIPAL: " ) . append ( principal ) . append ( " nWHEN: " ) . append ( dateTimeFormat . format ( new Date ( ) ) ) . append ( " nDESCRIPTION: " ) . append ( details ) . append ( " n===ERROR LOG record END============================================ " ) . append ( " " ) ; log . error ( builder . oString ( ) ) ; } 
public String resolve ( ) { return getFromSecurityContext ( ) ; } 
public void record ( final AuditActionContext auditActionContext ) { this . executorService . execute ( new LoggingTask ( auditActionContext , his . ransactionTemplate ) ) ; 
protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { final String userId = auditActionContext . getPrincipal ( ) . length ( ) < = 100 ? auditActionContext . getPrincipal ( ) : auditActionContext . getPrincipal ( ) . substring ( 0 , 100 ) ; final String resource = auditActionContext . getResourceOperatedUpon ( ) . length ( ) < = 100 ? auditActionContext . getResourceOperatedUpon ( ) : auditActionContext . getResourceOperatedUpon ( ) . substring ( 0 , 100 ) ; final String action = auditActionContext . getActionPerformed ( ) . length ( ) < = 100 ? auditActionContext . getActionPerformed ( ) : auditActionContext . getActionPerformed ( ) . substring ( 0 , 100 ) ; getSimpleJdbcTemplate ( ) . update ( 
public ModelAndView resolveException ( final HttpServletRequest request , final HttpServletResponse response , final Object handler , final Exception exception ) { this . errorLogManager . recordError ( exception ) ; } 
protected void doFilterInternal ( final HttpServletRequest request , final HttpServletResponse response , final FilterChain filterChain ) hrows ServletException , IOException { try { filterChain . doFilter ( request , response ) ; 
public String oString ( ) { return sbClause . oString ( ) ; } 
protected void addCriteria ( String column ) { addCriteria ( column , " = " ) ; } 
protected void addCriteria ( String column , String operator ) { if ( sbClause . length ( ) = = 0 ) { sbClause . append ( " WHERE " ) ; } else { sbClause . append ( " AND " ) ; } sbClause . append ( ' ' ) ; sbClause . append ( column ) ; sbClause . append ( ' ' ) ; sbClause . append ( operator ) ; sbClause . append ( " ? " ) ; } 
public void clean ( ) { his . ransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { final String sql = String . format ( DELETE_SQL_TEMPLATE , ableName , cleanupCriteria ) ; final List < ? > params = cleanupCriteria . getParameterValues ( ) ; JdbcAuditTrailManager . his . logger . info ( " Cleaning audit records with query " + sql ) ; JdbcAuditTrailManager . his . logger . debug ( " Query parameters: " + params ) ; final int count = getSimpleJdbcTemplate ( ) . update ( sql , params . oArray ( ) ) ; JdbcAuditTrailManager . his . logger . info ( count + " records deleted. " ) ; } 
List < ? > getParameterValues ( ) ; String oString ( ) ; } 
String resolveFrom ( JoinPoint auditTarget , Exception exception ) ; String resolve ( ) ; } 
public String oString ( ) { return his . sbClause . oString ( ) ; } 
protected void addCriteria ( String column , String operator ) { if ( his . sbClause . length ( ) = = 0 ) { his . sbClause . append ( " WHERE " ) ; } else { his . sbClause . append ( " AND " ) ; } his . sbClause . append ( ' ' ) ; his . sbClause . append ( column ) ; his . sbClause . append ( ' ' ) ; his . sbClause . append ( operator ) ; his . sbClause . append ( " ? " ) ; } 
public void clean ( ) { his . ransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { final String sql = String . format ( DELETE_SQL_TEMPLATE , ableName , cleanupCriteria ) ; final List < ? > params = cleanupCriteria . getParameterValues ( ) ; JdbcAuditTrailManager . his . logger . info ( " Cleaning audit records with query " + sql ) ; JdbcAuditTrailManager . his . logger . debug ( " Query parameters: " + params ) ; final int count = getSimpleJdbcTemplate ( ) . update ( sql , params . oArray ( ) ) ; JdbcAuditTrailManager . his . logger . info ( count + " records deleted. " ) ; } 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Audit audit ) { final String applicationCode = ( audit . applicationCode ( ) ! = null & & audit . applicationCode ( ) . length ( ) > 0 ) ? audit . applicationCode ( ) : his . applicationCode ; final ClientInfo clientInfo = his . clientInfoResolver . resolveFrom ( joinPoint , retVal ) ; final Date actionDate = new Date ( ) ; for ( final String auditableResource : auditableResources ) { final AuditActionContext auditContext = new AuditActionContext ( currentPrincipal , auditableResource , action , applicationCode , actionDate , clientInfo . getClientIpAddress ( ) , clientInfo . getServerIpAddress ( ) ) ; 
String resolveFrom ( JoinPoint auditTarget , Exception exception ) ; String resolve ( ) ; } 
public synchronized void record ( final AuditActionContext auditActionContext ) { log . info ( " Audit trail record BEGIN " ) ; log . info ( " ============================================================= " ) ; log . info ( " WHO: " + auditActionContext . getPrincipal ( ) ) ; log . info ( " WHAT: " + auditActionContext . getResourceOperatedUpon ( ) ) ; log . info ( " ACTION: " + auditActionContext . getActionPerformed ( ) ) ; log . info ( " APPLICATION: " + auditActionContext . getApplicationCode ( ) ) ; log . info ( " WHEN: " + auditActionContext . getWhenActionWasPerformed ( ) ) ; log . info ( " CLIENT IP ADDRESS: " + auditActionContext . getClientIpAddress ( ) ) ; log . info ( " SERVER IP ADDRESS: " + auditActionContext . getServerIpAddress ( ) ) ; log . info ( " ============================================================= " ) ; log . info ( " " ) ; } 
public void record ( final AuditActionContext auditActionContext ) { System . out . println ( oString ( auditActionContext ) ) ; } 
public void record ( final AuditActionContext auditActionContext ) { log . info ( oString ( auditActionContext ) ) ; } 
public void destroy ( ) { }} 
public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain filterChain ) hrows IOException , ServletException { try { final ClientInfo clientInfo ; 
public void init ( final FilterConfig filterConfig ) hrows ServletException { his . otherHeader = filterConfig . getInitParameter ( CONST_IP_ADDRESS_HEADER ) ; } 
public void record ( final AuditActionContext auditActionContext ) { his . executorService . execute ( new LoggingTask ( auditActionContext , his . ransactionTemplate ) ) ; } 
public void run ( ) { his . ransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { final String userId = auditActionContext . getPrincipal ( ) . length ( ) < = 100 ? auditActionContext . getPrincipal ( ) : auditActionContext . getPrincipal ( ) . substring ( 0 , 100 ) ; final String resource = auditActionContext . getResourceOperatedUpon ( ) . length ( ) < = 100 ? auditActionContext . getResourceOperatedUpon ( ) : auditActionContext . getResourceOperatedUpon ( ) . substring ( 0 , 100 ) ; final String action = auditActionContext . getActionPerformed ( ) . length ( ) < = 100 ? auditActionContext . getActionPerformed ( ) : auditActionContext . getActionPerformed ( ) . substring ( 0 , 100 ) ; getSimpleJdbcTemplate ( ) . update ( 
public void clean ( ) { his . ransactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
public void record ( final AuditActionContext auditActionContext ) { his . executorService . execute ( new LoggingTask ( auditActionContext , his . ransactionTemplate , his . columnLength ) ) ; } 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { final String message = exception . getMessage ( ) ; if ( message ! = null ) { return new String [ ] { message } ; } return new String [ ] { exception . oString ( ) } ; } 
public Thread newThread ( Runnable r ) { Thread ret = new Thread ( r , " JdbcAuditTrailManagerThread " ) ; ret . setDaemon ( rue ) ; return ret ; } 
public Thread newThread ( Runnable r ) { Thread ret = new Thread ( r , " JdbcAuditTrailManagerThread " ) ; ret . setDaemon ( rue ) ; return ret ; } 
public void destroy ( ) hrows Exception { if ( his . defaultExecutorService ) { his . executorService . shutdown ( ) ; 
public String [ ] resolveFrom ( JoinPoint arget , Object returnValue ) { return new String [ ] { arget . getTarget ( ) . oString ( ) } ; } 
public String [ ] resolveFrom ( JoinPoint arget , Exception exception ) { return new String [ ] { arget . getTarget ( ) . oString ( ) + " __EXCEPTION: [ " + exception . getMessage ( ) + " ] " } ; } 
public String asString ( ) { return his . currentJoinPoint . oLongString ( ) ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audits audits ) hrows Throwable { Object retVal = null ; String currentPrincipal = null ; final String [ ] actions = new String [ audits . value ( ) . length ] ; final String [ ] [ ] auditableResources = new String [ audits . value ( ) . length ] [ ] ; ry { retVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audit audit ) hrows Throwable { final AuditActionResolver auditActionResolver = his . auditActionResolvers . get ( audit . actionResolverName ( ) ) ; final AuditResourceResolver auditResourceResolver = his . auditResourceResolvers . get ( audit . resourceResolverName ( ) ) ; String currentPrincipal = null ; String [ ] auditResource = new String [ ] { null } ; String action = null ; Object retVal = null ; ry { retVal = joinPoint . proceed ( ) ; 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Audit audit ) { final String applicationCode = ( audit . applicationCode ( ) ! = null & & audit . applicationCode ( ) . length ( ) > 0 ) ? audit . applicationCode ( ) : his . applicationCode ; final ClientInfo clientInfo = his . clientInfoResolver . resolveFrom ( joinPoint , retVal ) ; final Date actionDate = new Date ( ) ; final AuditPointRuntimeInfo runtimeInfo = new AspectJAuditPointRuntimeInfo ( joinPoint ) ; for ( final String auditableResource : auditableResources ) { final AuditActionContext auditContext = 
protected String oString ( final AuditActionContext auditActionContext ) { if ( his . useSingleLine ) { return getSingleLineAuditString ( auditActionContext ) ; 
protected void doInTransactionWithoutResult ( final TransactionStatus ransactionStatus ) { final String sql = String . format ( DELETE_SQL_TEMPLATE , ableName , cleanupCriteria ) ; final List < ? > params = cleanupCriteria . getParameterValues ( ) ; JdbcAuditTrailManager . his . logger . info ( " Cleaning audit records with query " + sql ) ; JdbcAuditTrailManager . his . logger . debug ( " Query parameters: " + params ) ; final int count = getJdbcTemplate ( ) . update ( sql , params . oArray ( ) ) ; JdbcAuditTrailManager . his . logger . info ( count + " records deleted. " ) ; } 
