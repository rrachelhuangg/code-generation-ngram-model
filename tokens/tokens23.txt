public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditable auditable ) throws Throwable { tString currentPrincipal = null ; tString auditableResource = null ; tString action = null ; ttry { tfinal Object retval = joinPoint . proceed ( ) ; 
void record ( AuditableActionContext auditableActionContext ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval , Auditable auditable ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception , Auditable auditable ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception , Auditable auditable ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , tfinal Auditable auditable ) { tfinal Boolean bool = ( Boolean ) retval ; tfinal String action = auditable . action ( ) ; treturn action + ( bool ? auditable . successSuffix ( ) : auditable . failureSuffix ( ) ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , tAuditable auditable ) { treturn auditable . action ( ) + auditable . failureSuffix ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , tfinal Auditable auditable ) { treturn auditable . action ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , tfinal Auditable auditable ) { treturn auditable . action ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , tfinal Auditable auditable ) { tfinal String action = auditable . action ( ) ; treturn action + ( retval = = null ? auditable . failureSuffix ( ) : auditable . successSuffix ( ) ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , tfinal Auditable auditable ) { treturn auditable . action ( ) + auditable . failureSuffix ( ) ; } 
public void record ( final AuditableActionContext auditableActionContext ) { log . info ( " Audit trail record BEGIN " ) ; log . info ( " ============================================================= " ) ; log . info ( " WHO: " + auditableActionContext . getPrincipal ( ) ) ; log . info ( " WHAT: " + auditableActionContext . getResourceOperatedUpon ( ) ) ; log . info ( " ACTION: " + auditableActionContext . getActionPerformed ( ) ) ; log . info ( " APPLICATION: " + auditableActionContext . getApplicationCode ( ) ) ; log . info ( " WHEN: " + auditableActionContext . getWhenActionWasPerformed ( ) ) ; log . info ( " ============================================================= " ) ; log . info ( " " ) ; log . info ( " " ) ; } 
public void record ( final AuditableActionContext auditableActionContext ) { System . out . println ( " Audit trail record BEGIN " ) ; System . out . println ( " ============================================================= " ) ; System . out . println ( " WHO: " + auditableActionContext . getPrincipal ( ) ) ; System . out . println ( " WHAT: " + auditableActionContext . getResourceOperatedUpon ( ) ) ; System . out . println ( " ACTION: " + auditableActionContext . getActionPerformed ( ) ) ; System . out . println ( " APPLICATION: " + auditableActionContext . getApplicationCode ( ) ) ; System . out . println ( " WHEN: " + auditableActionContext . getWhenActionWasPerformed ( ) ) ; System . out . println ( " ============================================================= " ) ; System . out . println ( " " ) ; } 
public void afterPropertiesSet ( ) { tsetSql ( PROCEDURE_NAME ) ; tdeclareParameter ( new SqlParameter ( WHO , Types . VARCHAR ) ) ; tdeclareParameter ( new SqlParameter ( WHAT , Types . VARCHAR ) ) ; tdeclareParameter ( new SqlParameter ( ACTION , Types . VARCHAR ) ) ; tdeclareParameter ( new SqlParameter ( APPLICATION_CODE , Types . VARCHAR ) ) ; tdeclareParameter ( new SqlParameter ( WHEN , Types . TIMESTAMP ) ) ; tsetFunction ( false ) ; tcompile ( ) ; tsuper . afterPropertiesSet ( ) ; } 
public void record ( final AuditableActionContext auditableActionContext ) { tMap < String , Object > params = new HashMap < String , Object > ( ) ; tparams . put ( WHO , auditableActionContext . getPrincipal ( ) ) ; tparams . put ( WHAT , auditableActionContext . getResourceOperatedUpon ( ) ) ; tparams . put ( ACTION , auditableActionContext . getActionPerformed ( ) ) ; tparams . put ( APPLICATION_CODE , auditableActionContext . getApplicationCode ( ) ) ; tparams . put ( WHEN , auditableActionContext . getWhenActionWasPerformed ( ) ) ; ttry { texecute ( params ) ; 
private final void addDeclaredFields ( final Class < ? > clazz , final List < Field > fields ) { fields . addAll ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; } 
protected abstract void processField ( Field field , Annotation annotation , Object bean , String beanName ) throws IllegalAccessException ; protected abstract Class < ? extends Annotation > getSupportedAnnotation ( ) ; } 
protected abstract Class < ? extends Annotation > getSupportedAnnotation ( ) ; } 
protected void processField ( final Field field , final Annotation annotation , final Object bean , final String beanName ) throws IllegalAccessException { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; final int val = field . getInt ( bean ) ; if ( val < = value ) { throw new FatalBeanException ( " value of field \" " + field . getName ( ) 
protected void processField ( final Field field , final Annotation annotation , final Object bean , final String beanName ) throws IllegalAccessException { final IsIn isIn = ( IsIn ) annotation ; final int val = field . getInt ( bean ) ; for ( int i = 0 ; i < isIn . value ( ) . length ; i + + ) { if ( val = = isIn . value ( ) [ i ] ) { return ; } } throw new FatalBeanException ( " field ' " + field . getName ( ) + " ' does not contain a value of ' " + isIn . value ( ) + " ' on bean ' " 
protected String constructMessage ( final Field field , final String beanName ) { return " Field ' " + field . getName ( ) + " ' on bean ' " + beanName + " ' cannot be empty. " ; 
protected void processField ( final Field field , final Annotation annotation , final Object bean , String beanName ) throws IllegalAccessException { if ( field . get ( bean ) = = null ) { throw new FatalBeanException ( " Field " + field . getName ( ) 
public void testAuditingMachinery ( ) { this . theBean . doSomething ( " String arg " ) ; this . theBean . returnSomething ( new Object ( ) ) ; try { tthis . theBean . throwAnException ( ) ; 
void doSomething ( String stringArg ) ; String returnSomething ( Object o ) ; void throwAnException ( ) ; } 
String returnSomething ( Object o ) ; void throwAnException ( ) ; } 
public void doSomething ( String stringArg ) { } @Auditable ( applicationCode = " T_APP " , action = " performing 'returnSomething...' " , resourceResolverClass = SimpleAuditableResourceResolver . class ) public String returnSomething ( Object o ) { return " Hello " ; } @Auditable ( applicationCode = " T_APP " , action = " performing 'throwAnException...' " , resourceResolverClass = SimpleAuditableResourceResolver . class ) public void throwAnException ( ) { tthrow new RuntimeException ( ) ; } } 
public String returnSomething ( Object o ) { return " Hello " ; } 
public void throwAnException ( ) { tthrow new RuntimeException ( ) ; } 
public String resolveFrom ( JoinPoint auditableTarget , Object retval ) { return " User: test " ; } 
public String resolveFrom ( JoinPoint auditableTarget , Exception exception ) { treturn " User: test " ; } 
public String resolveFrom ( JoinPoint auditableTarget , Object retval ) { return " Resource being changed: " + auditableTarget . getTarget ( ) . getClass ( ) . getSimpleName ( ) + " ; Result= " + retval ; 
public String resolveFrom ( JoinPoint auditableTarget , Exception exception ) { treturn " Resource being changed: " + auditableTarget . getTarget ( ) . getClass ( ) . getSimpleName ( ) + " ; Exception= " + exception ; 
public void record ( final AuditableActionContext auditableActionContext ) { tthis . executorService . execute ( new LoggingTask ( auditableActionContext , tthis . transactionTemplate ) ) ; 
public void run ( ) { tthis . transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { tgetSimpleJdbcTemplate ( ) . update ( 
tvoid recordError ( String errorDescription ) ; tList < ErrorReporter > getErrorReporters ( ) ; } 
tvoid recordError ( Throwable throwable ) ; tList < ErrorReporter > getErrorReporters ( ) ; } 
tvoid reportError ( String applicationCode , String principal , String errorDescription ) ; tvoid reportError ( String applicationCode , String principal , Throwable throwable ) ; } 
tvoid reportError ( String applicationCode , String principal , Throwable throwable ) ; } 
public void reportError ( final String applicationCode , final String principal , tfinal String description ) { tlogErrorRecord ( applicationCode , principal , description ) ; } 
public void reportError ( final String applicationCode , final String principal , tfinal Throwable throwable ) { tfinal StackTraceElement [ ] stackTraceElements = throwable . getStackTrace ( ) ; tfinal StringBuilder builder = new StringBuilder ( 512 ) ; tbuilder . append ( " " ) . append ( throwable . toString ( ) ) ; tfor ( final StackTraceElement element : stackTraceElements ) { tbuilder . append ( " tat " ) . append ( element . toString ( ) ) ; } tlogErrorRecord ( applicationCode , principal , builder . toString ( ) ) ; 
private void logErrorRecord ( final String applicationCode , final String principal , final String details ) { tfinal SimpleDateFormat datetimeFormat = new SimpleDateFormat ( " yyyy-MM-dd HH:mm:ss.SSS Z " ) ; tfinal StringBuilder builder = new StringBuilder ( 512 ) ; tbuilder . append ( " n===ERROR LOG record BEGIN========================================== " ) . append ( " nAPPLICATION CODE: " + applicationCode ) . append ( " nPRINCIPAL: " + principal ) . append ( " nWHEN: " + datetimeFormat . format ( new Date ( ) ) ) . append ( " nDESCRIPTION: " + details ) . append ( " n===ERROR LOG record END============================================ " ) . append ( " " ) ; log . error ( builder . toString ( ) ) ; } 
public void recordError ( final String errorDescription ) { tString principal = resolvePrincipal ( ) ; tfor ( ErrorReporter r : this . errorReporters ) { tr . reportError ( this . applicationCode , principal , errorDescription ) ; 
public void recordError ( final Throwable throwable ) { tString principal = resolvePrincipal ( ) ; tfor ( final ErrorReporter r : this . errorReporters ) { tr . reportError ( this . applicationCode , principal , throwable ) ; 
private String resolvePrincipal ( ) { treturn ( this . currentContextPrincipalResolver = = null ) ? null : 
public ModelAndView resolveException ( final HttpServletRequest request , tfinal HttpServletResponse response , final Object handler , final Exception exception ) { tthis . errorLogManager . recordError ( exception ) ; } 
protected void doFilterInternal ( final HttpServletRequest request , tfinal HttpServletResponse response , final FilterChain filterChain ) tthrows ServletException , IOException { ttry { tfilterChain . doFilter ( request , response ) ; 
public void testReportException ( ) throws Exception { tthis . errorLogHandlerExceptionResolver . resolveException ( null , null , null , new Exception ( " Testing Resolver " ) ) ; } 
public void testReportError ( ) throws Exception { tthis . errorLogManager . recordError ( " Testing error message reporting " ) ; tthis . errorLogManager . recordError ( new Exception ( " Testing throwable reporting " ) ) ; } 
public void test ( ) throws Exception { terrorLoggingFilter . doFilter ( new MockHttpServletRequest ( ) , new MockHttpServletResponse ( ) , new MockFilterChain ( new ServletException ( " Testing ServletException " ) ) ) ; } 
public void test ( ) throws Exception { terrorLoggingFilter . doFilter ( new MockHttpServletRequest ( ) , new MockHttpServletResponse ( ) , new MockFilterChain ( new IOException ( " Testing IOException " ) ) ) ; } 
public void test ( ) throws Exception { terrorLoggingFilter . doFilter ( new MockHttpServletRequest ( ) , new MockHttpServletResponse ( ) , new MockFilterChain ( new RuntimeException ( " Testing RuntimeException " ) ) ) ; } 
public void doFilter ( ServletRequest arg0 , ServletResponse arg1 ) throws IOException , ServletException { if ( this . throwable ! = null ) { if ( this . throwable instanceof ServletException ) throw ( ServletException ) this . throwable ; 
public String resolve ( ) { treturn " Resolver Tester " ; } 
public void validate ( Field field , Annotation annotation , Object bean , String beanName ) throws IllegalAccessException ; tClass < ? extends Annotation > supports ( ) ; } 
public Class < ? extends Annotation > supports ( ) { treturn GreaterThan . class ; } 
public void validate ( final Field field , final Annotation annotation , final Object bean , final String beanName ) throws IllegalAccessException { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; final int val = field . getInt ( bean ) ; if ( val < = value ) { throw new FatalBeanException ( " value of field \" " + field . getName ( ) 
public void validate ( final Field field , final Annotation annotation , final Object bean , final String beanName ) throws IllegalAccessException { final IsIn isIn = ( IsIn ) annotation ; final int val = field . getInt ( bean ) ; for ( int i = 0 ; i < isIn . value ( ) . length ; i + + ) { if ( val = = isIn . value ( ) [ i ] ) { return ; } } throw new FatalBeanException ( " field ' " + field . getName ( ) + " ' does not contain a value of ' " + isIn . value ( ) + " ' on bean ' " 
public Class < ? extends Annotation > supports ( ) { treturn IsIn . class ; } 
public Class < ? extends Annotation > supports ( ) { return NotEmpty . class ; } 
public void validate ( final Field field , final Annotation annotation , final Object bean , final String beanName ) throws IllegalAccessException { if ( field . get ( bean ) = = null ) { throw new FatalBeanException ( " Field " + field . getName ( ) 
public Class < ? extends Annotation > supports ( ) { return NotNull . class ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) throws Throwable { ttry { treturn joinPoint . proceed ( ) ; 
tvoid recalculate ( StatisticActionContext statisticActionContext ) ; } 
public void recalculate ( StatisticActionContext statisticActionContext ) { }} 
public void recalculate ( final StatisticActionContext statisticActionContext ) { }} 
public static void clear ( ) { tclientInfoHolder . remove ( ) ; } 
public void destroy ( ) { }} 
protected void doFilterInternal ( final HttpServletRequest request , tfinal HttpServletResponse response , final FilterChain filterChain ) tthrows ServletException , IOException { ttry { tfinal ClientInfo clientInfo = new ClientInfo ( request ) ; 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) throws Throwable { ttry { treturn joinPoint . proceed ( ) ; 
public Date normalize ( final Date date ) { tfinal Calendar c1 = Calendar . getInstance ( ) ; tc1 . setTime ( date ) ; tc1 . set ( Calendar . SECOND , 0 ) ; tc1 . set ( Calendar . MILLISECOND , 0 ) ; treturn c1 . getTime ( ) ; } 
public Date normalize ( final Date date ) { tfinal Calendar c1 = Calendar . getInstance ( ) ; tc1 . setTime ( date ) ; tc1 . set ( Calendar . SECOND , 0 ) ; tc1 . set ( Calendar . MILLISECOND , 0 ) ; tc1 . set ( Calendar . MINUTE , 0 ) ; treturn c1 . getTime ( ) ; } 
public Date normalize ( final Date date ) { tfinal Calendar c1 = Calendar . getInstance ( ) ; tc1 . setTime ( date ) ; tc1 . set ( Calendar . SECOND , 0 ) ; tc1 . set ( Calendar . MILLISECOND , 0 ) ; tc1 . set ( Calendar . MINUTE , 0 ) ; tc1 . set ( Calendar . HOUR_OF_DAY , 0 ) ; treturn c1 . getTime ( ) ; } 
public abstract Date normalize ( Date date ) ; public final boolean same ( final Date normalizedDate , final Date date2 ) { tfinal Date normalizedDate2 = normalize ( date2 ) ; treturn normalizedDate . equals ( normalizedDate2 ) ; } } tString applicationCode ( ) default " " ; tPrecision [ ] requiredPrecision ( ) default Precision . HOUR ; tString name ( ) ; } 
public final boolean same ( final Date normalizedDate , final Date date2 ) { tfinal Date normalizedDate2 = normalize ( date2 ) ; treturn normalizedDate . equals ( normalizedDate2 ) ; } 
public final void recalculate ( final StatisticActionContext statisticActionContext ) { tthis . executorService . execute ( newTask ( statisticActionContext ) ) ; } 
protected abstract Runnable newTask ( StatisticActionContext statisticActionContext ) ; } 
protected Runnable newTask ( final StatisticActionContext statisticActionContext ) { treturn new StatisticGatheringTask ( statisticActionContext , this . values ) ; } 
public void increment ( ) { tthis . count . incrementAndGet ( ) ; } 
public boolean matches ( final Date date , final Precision precision ) { treturn precision . same ( this . date , date ) ; } 
protected Runnable newTask ( final StatisticActionContext statisticActionContext ) { treturn new JdbcStatisticGatheringTask ( this . jdbcTemplate , this . transactionTemplate , statisticActionContext ) ; } 
public void run ( ) { tthis . transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { tfinal String userId = auditableActionContext . getPrincipal ( ) . length ( ) < = 100 ? auditableActionContext . getPrincipal ( ) : auditableActionContext . getPrincipal ( ) . substring ( 0 , 100 ) ; tfinal String resource = auditableActionContext . getResourceOperatedUpon ( ) . length ( ) < = 100 ? auditableActionContext . getResourceOperatedUpon ( ) : auditableActionContext . getResourceOperatedUpon ( ) . substring ( 0 , 100 ) ; tfinal String action = auditableActionContext . getActionPerformed ( ) . length ( ) < = 100 ? auditableActionContext . getActionPerformed ( ) : auditableActionContext . getActionPerformed ( ) . substring ( 0 , 100 ) ; tgetSimpleJdbcTemplate ( ) . update ( 
public abstract Date normalize ( Date date ) ; public final boolean same ( final Date date1 , final Date date2 ) { tfinal Date normalizedDate1 = normalize ( date1 ) ; tfinal Date normalizedDate2 = normalize ( date2 ) ; treturn normalizedDate1 . equals ( normalizedDate2 ) ; } } tString applicationCode ( ) default " " ; tPrecision [ ] requiredPrecision ( ) default Precision . HOUR ; tString name ( ) ; } 
public final boolean same ( final Date date1 , final Date date2 ) { tfinal Date normalizedDate1 = normalize ( date1 ) ; tfinal Date normalizedDate2 = normalize ( date2 ) ; treturn normalizedDate1 . equals ( normalizedDate2 ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { treturn retval . toString ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { treturn exception . getMessage ( ) ; } 
public boolean matches ( final Date date , final Precision precision , final String name ) { treturn precision . same ( this . date , date ) & & this . precision = = precision & & this . name . equals ( name ) ; } 
public String toString ( ) { treturn " name=[ " + this . name + " ],date=[ " + this . date + " ],precision=[ " + this . precision + " ],count=[ " + count + " ] " ; } 
protected Map < String , Object > referenceData ( final HttpServletRequest request ) { tfinal Map < String , Object > model = new HashMap < String , Object > ( ) ; tfinal Set < String > applicationCodes = this . logRequestManager . getApplicationCodes ( ) ; tmodel . put ( " applicationCodes " , applicationCodes ) ; treturn model ; } 
tList < String > getApplicationCodes ( ) ; tList < LogEntry > findLogEntriesFor ( Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
tList < LogEntry > findLogEntriesFor ( Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
tList < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
tList < LogEntry > findLogEntriesFor ( String applicationCode , Date endDate , String principal ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate ) ; tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
tList < LogEntry > findLogEntriesFor ( String applicationCode , Date startDate , Date endDate , String principal ) ; } 
public List < LogEntry > findLogEntriesFor ( final Date endDate ) { treturn constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date endDate ) { treturn constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , tfinal Date endDate , final String principal ) { treturn constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , tfinal Date startDate , final Date endDate ) { treturn constructLogEntries ( ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , tfinal Date startDate , final Date endDate , final String principal ) { treturn constructLogEntries ( ) ; } 
protected List < LogEntry > constructLogEntries ( ) { tfinal List < LogEntry > logList = new ArrayList < LogEntry > ( ) ; tfinal LogEntryImpl impl = new LogEntryImpl ( ) ; timpl . setActionPerformed ( " action " ) ; timpl . setApplicationCode ( " CAS " ) ; timpl . setClientIpAddress ( " 127.0.0.1 " ) ; timpl . setEntryDate ( new Date ( ) ) ; timpl . setPrincipal ( " principal " ) ; timpl . setResource ( " resource " ) ; timpl . setServerIpAddress ( " server " ) ; tlogList . add ( impl ) ; treturn logList ; } 
tString getActionPerformed ( ) ; tString getPrincipal ( ) ; tString getApplicationCode ( ) ; tString getClientIpAddress ( ) ; tString getResource ( ) ; tString getServerIpAddress ( ) ; tDate getEntryDate ( ) ; } 
tString getPrincipal ( ) ; tString getApplicationCode ( ) ; tString getClientIpAddress ( ) ; tString getResource ( ) ; tString getServerIpAddress ( ) ; tDate getEntryDate ( ) ; } 
tString getApplicationCode ( ) ; tString getClientIpAddress ( ) ; tString getResource ( ) ; tString getServerIpAddress ( ) ; tDate getEntryDate ( ) ; } 
tString getClientIpAddress ( ) ; tString getResource ( ) ; tString getServerIpAddress ( ) ; tDate getEntryDate ( ) ; } 
tString getResource ( ) ; tString getServerIpAddress ( ) ; tDate getEntryDate ( ) ; } 
tString getServerIpAddress ( ) ; tDate getEntryDate ( ) ; } 
tString getApplicationCode ( ) ; tString getPrincipal ( ) ; tDate getStartDate ( ) ; tDate getEndDate ( ) ; } 
tString getPrincipal ( ) ; tDate getStartDate ( ) ; tDate getEndDate ( ) ; } 
tList < LogEntry > searchBy ( LogSearchRequest criteria ) ; tSet < String > getApplicationCodes ( ) ; } 
public String mapRow ( final ResultSet rs , final int rownum ) throws SQLException { treturn rs . getString ( " APPLIC_CD " ) ; } } ; 
public LogEntry mapRow ( final ResultSet rs , final int rownum ) throws SQLException { tfinal LogEntryImpl impl = new LogEntryImpl ( ) ; timpl . setActionPerformed ( rs . getString ( " AUD_ACTION " ) ) ; timpl . setApplicationCode ( rs . getString ( " APPLIC_CD " ) ) ; timpl . setClientIpAddress ( rs . getString ( " AUD_CLIENT_IP " ) ) ; timpl . setEntryDate ( rs . getTimestamp ( " AUD_DATE " ) ) ; timpl . setPrincipal ( rs . getString ( " AUD_USER " ) ) ; timpl . setResource ( rs . getString ( " AUD_RESOURCE " ) ) ; timpl . setServerIpAddress ( rs . getString ( " AUD_SERVER_IP " ) ) ; treturn impl ; } 
public List < LogEntry > findLogEntriesFor ( final Date endDate ) { treturn getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " AUD_DATE <= ? " + SQL_SELECT_END , this . logEntryParameterizedRowMapper , endDate ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , final Date endDate ) { treturn getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? " + SQL_SELECT_END , this . logEntryParameterizedRowMapper , applicationCode , endDate ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , tfinal Date endDate , final String principal ) { treturn getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? AND AUD_USER LIKE ? " + SQL_SELECT_END , this . logEntryParameterizedRowMapper , applicationCode , endDate , principal + this . wildCard ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , tfinal Date startDate , final Date endDate ) { treturn getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? AND AUD_DATE >= ? " + SQL_SELECT_END , this . logEntryParameterizedRowMapper , applicationCode , endDate , startDate ) ; } 
public List < LogEntry > findLogEntriesFor ( final String applicationCode , tfinal Date startDate , final Date endDate , final String principal ) { treturn getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_START + " APPLIC_CD = ? AND AUD_DATE <= ? AND AUD_DATE >= ? AND AUD_USER LIKE ? " + SQL_SELECT_END , this . logEntryParameterizedRowMapper , applicationCode , endDate , startDate , principal + this . wildCard ) ; } 
public Statistic mapRow ( final ResultSet rs , int rownum ) throws SQLException { tfinal StatisticImpl statistic = new StatisticImpl ( ) ; tstatistic . setApplicationCode ( rs . getString ( " APPLIC_CD " ) ) ; tstatistic . setCount ( rs . getInt ( " STAT_COUNT " ) ) ; tstatistic . setPrecision ( Precision . valueOf ( rs . getString ( " STAT_PRECISION " ) ) ) ; tstatistic . setWhat ( rs . getString ( " STAT_NAME " ) ) ; tstatistic . setWhen ( rs . getDate ( " STAT_DATE " ) ) ; treturn statistic ; } 
public List < Statistic > findComparisonStatistics ( final Date firstDate , tfinal Date secondDate , final String applicationCode , tfinal Precision [ ] requiredPrecision ) { tfinal Date [ ] firstDateLowHigh = constructLowAndHighDates ( firstDate ) ; tfinal Date [ ] secondDateLowHigh = constructLowAndHighDates ( secondDate ) ; treturn getSimpleJdbcTemplate ( ) . query ( " Select APPLIC_CD, STAT_COUNT, STAT_PRECISION, STAT_NAME, STAT_DATE From COM_STATISTICS Where APPLIC_CD = ? AND ((STAT_DATE >= ? AND STAT_DATE <= ?) OR (STAT_DATE >= ? AND STAT_DATE <=?)) " + constructPrecisionSuffix ( requiredPrecision ) + " ORDER BY STAT_DATE, STAT_PRECISION " , this . statisticParameterizedRowMapper , applicationCode , firstDateLowHigh [ 0 ] , firstDateLowHigh [ 1 ] , secondDateLowHigh [ 0 ] , secondDateLowHigh [ 1 ] ) ; } 
public List < Statistic > findStatisticsForDateRange ( final Date startDate , tfinal Date endDate , final String applicationCode , final Precision [ ] requiredPrecision ) { } 
private String constructPrecisionSuffix ( final Precision [ ] requiredPrecision ) { tfinal StringBuilder stringBuilder = new StringBuilder ( ) ; tfor ( final Precision precision : requiredPrecision ) { } } 
private Date [ ] constructLowAndHighDates ( final Date date ) { tfinal Calendar calendar1 = Calendar . getInstance ( ) ; tfinal Calendar calendar2 = Calendar . getInstance ( ) ; tcalendar1 . setTime ( date ) ; tcalendar2 . setTime ( date ) ; tcalendar1 . set ( Calendar . MINUTE , 0 ) ; tcalendar1 . set ( Calendar . SECOND , 0 ) ; tcalendar1 . set ( Calendar . MILLISECOND , 0 ) ; tcalendar1 . set ( Calendar . HOUR_OF_DAY , 0 ) ; tcalendar2 . set ( Calendar . MINUTE , 59 ) ; tcalendar2 . set ( Calendar . SECOND , 59 ) ; tcalendar2 . set ( Calendar . MILLISECOND , 999 ) ; tcalendar2 . set ( Calendar . HOUR_OF_DAY , 23 ) ; tfinal Date [ ] array = new Date [ ] { calendar1 . getTime ( ) , calendar2 . getTime ( ) } ; treturn array ; } 
tList < Statistic > findStatisticsForDateRange ( Date startDate , Date endDate , String applicationCode , Precision [ ] requiredPrecision ) ; tList < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; } 
tList < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; } 
tString getApplicationCode ( ) ; tDate getWhen ( ) ; tPrecision getPrecision ( ) ; tint getCount ( ) ; tString getWhat ( ) ; } 
tDate getWhen ( ) ; tPrecision getPrecision ( ) ; tint getCount ( ) ; tString getWhat ( ) ; } 
tPrecision getPrecision ( ) ; tint getCount ( ) ; tString getWhat ( ) ; } 
tString getApplicationCode ( ) ; tDate getStartDate ( ) ; tDate getEndDate ( ) ; tPrecision [ ] getRequiredPrecisions ( ) ; tSearchType getSearchType ( ) ; } 
tDate getStartDate ( ) ; tDate getEndDate ( ) ; tPrecision [ ] getRequiredPrecisions ( ) ; tSearchType getSearchType ( ) ; } 
tDate getEndDate ( ) ; tPrecision [ ] getRequiredPrecisions ( ) ; tSearchType getSearchType ( ) ; } 
tPrecision [ ] getRequiredPrecisions ( ) ; tSearchType getSearchType ( ) ; } 
tList < Statistic > findStatisticsBy ( StatisticSearchRequest request ) ; } 
public void setAsText ( final String text ) throws IllegalArgumentException { tthis . enumValue = Precision . valueOf ( text ) ; } 
public void setAsText ( String text ) throws IllegalArgumentException { tthis . searchType = SearchType . valueOf ( text ) ; } 
protected Map < String , Object > referenceData ( final HttpServletRequest request ) { tfinal Map < String , Object > model = new HashMap < String , Object > ( ) ; tfinal List < String > applicationCodes = this . statisticManager . getApplicationCodes ( ) ; tmodel . put ( " applicationCodes " , applicationCodes ) ; tmodel . put ( " precisions " , Precision . values ( ) ) ; treturn model ; } 
public Statistic mapRow ( final ResultSet rs , int rownum ) throws SQLException { tfinal StatisticImpl statistic = new StatisticImpl ( ) ; tstatistic . setApplicationCode ( rs . getString ( " APPLIC_CD " ) ) ; tstatistic . setCount ( rs . getInt ( " STAT_COUNT " ) ) ; tstatistic . setPrecision ( Precision . valueOf ( rs . getString ( " STAT_PRECISION " ) ) ) ; tstatistic . setWhat ( rs . getString ( " STAT_NAME " ) ) ; tstatistic . setWhen ( rs . getTimestamp ( " STAT_DATE " ) ) ; treturn statistic ; } 
public List < Statistic > findComparisonStatistics ( final Date firstDate , tfinal Date secondDate , final String applicationCode , tfinal Precision [ ] requiredPrecision ) { tfinal Date [ ] firstDateLowHigh = constructLowAndHighDates ( firstDate ) ; tfinal Date [ ] secondDateLowHigh = constructLowAndHighDates ( secondDate ) ; treturn getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_PREFIX + " ((STAT_DATE >= ? AND STAT_DATE <= ?) OR (STAT_DATE >= ? AND STAT_DATE <=?)) AND " + constructPrecisionSuffix ( requiredPrecision ) + SQL_SELECT_SUFFIX , this . statisticParameterizedRowMapper , applicationCode , firstDateLowHigh [ 0 ] , firstDateLowHigh [ 1 ] , secondDateLowHigh [ 0 ] , secondDateLowHigh [ 1 ] ) ; } 
public List < Statistic > findStatisticsForDateRange ( final Date startDate , tfinal Date endDate , final String applicationCode , final Precision [ ] requiredPrecision ) { treturn getSimpleJdbcTemplate ( ) . query ( SQL_SELECT_PREFIX + " STAT_DATE >= ? AND STAT_DATE <= ? AND " + constructPrecisionSuffix ( requiredPrecision ) + SQL_SELECT_SUFFIX , this . statisticParameterizedRowMapper , applicationCode , startDate , endDate ) ; } 
private String constructPrecisionSuffix ( final Precision [ ] requiredPrecision ) { tfinal StringBuilder builder = new StringBuilder ( ) ; tbuilder . append ( " ( " ) ; tfor ( final Precision precision : requiredPrecision ) { tbuilder . append ( " STAT_PRECISION = ' " + precision . name ( ) + " ' OR " ) ; } treturn builder . substring ( 0 , builder . length ( ) - 4 ) + " ) " ; } 
tList < Statistic > findStatisticsForDateRange ( Date startDate , Date endDate , String applicationCode , Precision [ ] requiredPrecision ) ; tList < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; tList < String > getApplicationCodes ( ) ; } 
tList < Statistic > findComparisonStatistics ( Date firstDate , Date secondDate , String applicationCode , Precision [ ] requiredPrecision ) ; tList < String > getApplicationCodes ( ) ; } 
tList < Statistic > findStatisticsBy ( StatisticSearchRequest request ) ; tList < String > getApplicationCodes ( ) ; } 
public void destroy ( ) throws Exception { tthis . executorService . shutdown ( ) ; } 
tClientInfo resolveFrom ( JoinPoint joinPoint , Object retVal ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { treturn ClientInfoHolder . getClientInfo ( ) ; } 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) throws Throwable { tObject retVal = null ; ttry { tretVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditable auditable ) throws Throwable { tString currentPrincipal = null ; tString auditableResource = null ; tString action = null ; tObject retVal = null ; ttry { tretVal = joinPoint . proceed ( ) ; 
public void testAuditingMachinery ( ) { tfinal ClientInfo clientInfo = new ClientInfo ( " myserver " , " yourserver " ) ; tClientInfoHolder . setClientInfo ( clientInfo ) ; this . theBean . doSomething ( " String arg " ) ; this . theBean . returnSomething ( new Object ( ) ) ; try { tthis . theBean . throwAnException ( ) ; 
String resolveFrom ( JoinPoint auditableTarget , Object retval , T auditable ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception , T auditable ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception , T auditable ) ; } 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) throws Throwable { tObject retVal = null ; tString name = null ; ttry { tretVal = joinPoint . proceed ( ) ; 
public abstract Date normalize ( Date date ) ; public final boolean same ( final Date date1 , final Date date2 ) { tfinal Date normalizedDate1 = normalize ( date1 ) ; tfinal Date normalizedDate2 = normalize ( date2 ) ; treturn normalizedDate1 . equals ( normalizedDate2 ) ; } } tString applicationCode ( ) default " " ; tPrecision [ ] requiredPrecision ( ) default Precision . HOUR ; tString name ( ) ; tClass < ? extends StatisticNameResolver > nameResolverClass ( ) default DefaultStatisticNameResolver . class ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , tfinal Statistic statistic ) { treturn statistic . name ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , tfinal Statistic statistic ) { treturn statistic . name ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { treturn getFromSecurityContext ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { treturn getFromSecurityContext ( ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { tfinal ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; if ( clientInfo ! = null ) { treturn clientInfo ; } tlog . warn ( " No ClientInfo could be found. Returning empty ClientInfo object. " ) ; treturn new ClientInfo ( " unknown " , " unknown " ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { tfinal ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; if ( clientInfo ! = null ) { treturn clientInfo ; } tlog . warn ( " No ClientInfo could be found. Returning empty ClientInfo object. " ) ; treturn new ClientInfo ( ) ; } 
tvoid validate ( Field field , Annotation annotation , Object bean , String beanName ) throws IllegalAccessException ; tvoid validate ( Method method , Annotation annotation , Object arg , int argIndex ) ; tClass < ? extends Annotation > supports ( ) ; } 
tvoid validate ( Method method , Annotation annotation , Object arg , int argIndex ) ; tClass < ? extends Annotation > supports ( ) ; } 
protected void validateInternal ( final Annotation annotation , final Object arg , tfinal String type , final String fieldName , final String objectName ) { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; final Integer integer = ( Integer ) arg ; final int val = integer . intValue ( ) ; if ( val < = value ) { throw new IllegalStateException ( type + " \" " + fieldName 
protected void validateInternal ( final Annotation annotation , final Object arg , tfinal String type , final String fieldName , final String objectName ) { final IsIn isIn = ( IsIn ) annotation ; final Integer integer = ( Integer ) arg ; final int val = integer . intValue ( ) ; for ( int i = 0 ; i < isIn . value ( ) . length ; i + + ) { if ( val = = isIn . value ( ) [ i ] ) { return ; } } throw new IllegalStateException ( type + " ' " + fieldName + " ' does not contain a value of ' " + isIn . value ( ) + " ' on ' " 
protected String constructMessage ( final String type , final String fieldName , final String objectName ) { return type + " ' " + fieldName + " ' on ' " + objectName + " ' cannot be empty. " ; 
protected void validateInternal ( final Annotation annotation , final Object arg , tfinal String type , final String fieldName , final String objectName ) { if ( arg = = null ) { tthrow new IllegalStateException ( type + " " + fieldName + " cannot be null on " + objectName ) ; 
public Class < ? extends Annotation > supports ( ) { return NotNull . class ; } 
public void destroy ( ) { }} 
public void doFilter ( final ServletRequest request , final ServletResponse response , tfinal FilterChain filterChain ) throws IOException , ServletException { ttry { tfinal ClientInfo clientInfo = new ClientInfo ( ( HttpServletRequest ) request ) ; 
public void init ( final FilterConfig filterConfig ) throws ServletException { }} 
public final void validate ( final Field field , final Annotation annotation , final Object bean , tfinal String beanName ) throws IllegalAccessException { tvalidateInternal ( annotation , field . get ( bean ) , " Field " , field . getName ( ) , beanName ) ; } 
public final void validate ( final Method method , final Annotation annotation , final Object arg , final int argIndex ) { tvalidateInternal ( annotation , arg , " Parameter " , " argument[ " + argIndex + " ] " , method . getName ( ) ) ; } 
protected abstract void validateInternal ( Annotation annotation , Object arg , String type , String fieldName , String objectName ) ; } 
public void doValidationCheck ( final JoinPoint joinPoint ) { tfinal Object [ ] args = joinPoint . getArgs ( ) ; tfinal MethodSignature m = ( MethodSignature ) joinPoint . getStaticPart ( ) . getSignature ( ) ; tfinal Method method = m . getMethod ( ) ; tfinal Annotation [ ] [ ] annotations = method . getParameterAnnotations ( ) ; tfor ( int i = 0 ; i < annotations . length ; i + + ) { tfinal Annotation [ ] annotationsForParam = annotations [ i ] ; 
protected void assertNotNull ( final Object o , final String message ) { if ( o = = null ) { tthrow new IllegalArgumentException ( message ) ; 
protected void assertNotNull ( final Object o , final String message ) { if ( o = = null ) { tthrow new IllegalArgumentException ( message ) ; 
public Object handleStatisticGathering ( final ProceedingJoinPoint joinPoint , final Statistic statistic ) throws Throwable { tObject retVal = null ; tString name = null ; tfinal long startTime = System . currentTimeMillis ( ) ; ttry { 
public synchronized void increment ( final long executionTime ) { tfinal long oldTotalTime = this . executionTime * count ; tfinal long newTotalTime = oldTotalTime + executionTime ; tthis . count + + ; tthis . executionTime = newTotalTime / count ; } 
protected void validateInternal ( final Annotation annotation , final Object arg , tfinal String type , final String fieldName , final String objectName ) { tfinal RegExp r = ( RegExp ) annotation ; tfinal Pattern pattern = rules . get ( r . rule ( ) ) ; if ( pattern = = null ) { tthrow new IllegalStateException ( " Regular Expression rule " + r . rule ( ) + " does not exist. " ) ; } if ( pattern . matcher ( ( String ) arg ) . matches ( ) ) { treturn ; } tthrow new IllegalStateException ( type + " " + fieldName + " does not match regular expression on " + objectName ) ; } 
public Class < ? extends Annotation > supports ( ) { treturn RegExp . class ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditables auditables ) throws Throwable { tObject retVal = null ; tString currentPrincipal = null ; tfinal String [ ] actions = new String [ auditables . value ( ) . length ] ; tfinal String [ ] [ ] auditableResources = new String [ auditables . value ( ) . length ] [ ] ; ttry { tretVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Auditable auditable ) throws Throwable { tString currentPrincipal = null ; tString [ ] auditableResource = null ; tString action = null ; tObject retVal = null ; ttry { tretVal = joinPoint . proceed ( ) ; 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Auditable auditable ) { if ( currentPrincipal = = null ) { log . warn ( " Recording of audit trail information did not succeed: cannot resolve the principal. " ) ; 
String [ ] resolveFrom ( JoinPoint auditableTarget , Object retval ) ; String [ ] resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
String [ ] resolveFrom ( JoinPoint auditableTarget , Exception exception ) ; } 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { if ( retval instanceof Collection ) { tfinal Collection c = ( Collection ) retval ; tfinal String [ ] retvals = new String [ c . size ( ) ] ; tint i = 0 ; tfor ( final Iterator iter = c . iterator ( ) ; iter . hasNext ( ) & & i < c . size ( ) ; i + + ) { tfinal Object o = iter . next ( ) ; if ( o ! = null ) { tretvals [ i ] = iter . next ( ) . toString ( ) ; } } treturn retvals ; } } 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { treturn new String [ ] { exception . getMessage ( ) } ; } 
protected void validateInternal ( final Annotation annotation , final Object arg , tfinal String type , final String fieldName , final String objectName ) { final GreaterThan greaterThan = ( GreaterThan ) annotation ; final int value = greaterThan . value ( ) ; if ( arg instanceof Integer ) { tvalidateInt ( ( ( Integer ) arg ) . intValue ( ) , value , type , fieldName , objectName ) ; } if ( arg instanceof Integer [ ] ) { tfinal Integer [ ] ints = ( Integer [ ] ) arg ; 
private void validateInt ( final int currentValue , final int minimumValue , final String type , final String fieldName , final String objectName ) { if ( currentValue < = minimumValue ) { throw new IllegalStateException ( type + " \" " + fieldName 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Object retval ) { if ( retval instanceof Collection ) { tfinal Collection c = ( Collection ) retval ; tfinal String [ ] retvals = new String [ c . size ( ) ] ; tint i = 0 ; tfor ( final Iterator iter = c . iterator ( ) ; iter . hasNext ( ) & & i < c . size ( ) ; i + + ) { tfinal Object o = iter . next ( ) ; if ( o ! = null ) { tretvals [ i ] = iter . next ( ) . toString ( ) ; } } treturn retvals ; } if ( retval instanceof Object [ ] ) { tfinal Object [ ] vals = ( Object [ ] ) retval ; tfinal String [ ] retvals = new String [ vals . length ] ; tfor ( int i = 0 ; i < vals . length ; i + + ) { tretvals [ i ] = vals [ i ] . toString ( ) ; } treturn retvals ; } treturn new String [ ] { retval . toString ( ) } ; } 
public String resolveFrom ( JoinPoint auditableTarget , Object retval , tAuditable auditable ) { treturn auditable . action ( ) + auditable . successSuffix ( ) ; } 
public String resolveFrom ( JoinPoint auditableTarget , Exception exception , tAuditable auditable ) { treturn auditable . action ( ) + auditable . failureSuffix ( ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { treturn createResource ( joinPoint ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Exception e ) { treturn createResource ( joinPoint ) ; } 
protected abstract String [ ] createResource ( final JoinPoint joinPoint ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { treturn createResource ( joinPoint . getArgs ( ) ) ; } 
public final String [ ] resolveFrom ( final JoinPoint joinPoint , final Exception e ) { treturn createResource ( joinPoint . getArgs ( ) ) ; } 
protected abstract String [ ] createResource ( final Object [ ] args ) ; } 
public void destroy ( ) { }} 
protected String [ ] createResource ( final Object [ ] args ) { final String [ ] stringArgs = new String [ args . length ] ; for ( int i = 0 ; i < args . length ; i + + ) { stringArgs [ i ] = args [ i ] . toString ( ) ; } return stringArgs ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audits audits ) throws Throwable { tObject retVal = null ; tString currentPrincipal = null ; tfinal String [ ] actions = new String [ audits . value ( ) . length ] ; tfinal String [ ] [ ] auditableResources = new String [ audits . value ( ) . length ] [ ] ; ttry { tretVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audit audit ) throws Throwable { final AuditActionResolver auditActionResolver = this . auditActionResolvers . get ( audit . actionResolverName ( ) ) ; final AuditResourceResolver auditResourceResolver = this . auditResourceResolvers . get ( audit . resourceResolverName ( ) ) ; tString currentPrincipal = null ; tString [ ] auditResource = null ; tString action = null ; tObject retVal = null ; ttry { tretVal = joinPoint . proceed ( ) ; 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Audit audit ) { final String applicationCode = ( audit . applicationCode ( ) = = null & & audit . applicationCode ( ) . length ( ) > 0 ) ? audit . applicationCode ( ) : this . applicationCode ; final ClientInfo clientInfo = this . clientInfoResolver . resolveFrom ( joinPoint , retVal ) ; final Date actionDate = new Date ( ) ; for ( final String auditableResource : auditableResources ) { final AuditActionContext auditContext = new AuditActionContext ( currentPrincipal , auditableResource , action , applicationCode , actionDate , clientInfo . getClientIpAddress ( ) , clientInfo . getServerIpAddress ( ) ) ; 
void record ( AuditActionContext auditActionContext ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Object retval , Audit audit ) ; String resolveFrom ( JoinPoint auditableTarget , Exception exception , Audit audit ) ; } 
String resolveFrom ( JoinPoint auditableTarget , Exception exception , Audit audit ) ; } 
String [ ] resolveFrom ( JoinPoint target , Object returnValue ) ; String [ ] resolveFrom ( JoinPoint target , Exception exception ) ; } 
String [ ] resolveFrom ( JoinPoint target , Exception exception ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Audit audit ) { tfinal Boolean bool = ( Boolean ) retval ; tfinal String action = audit . action ( ) ; treturn action + ( bool ? getSuccessSuffix ( ) : getFailureSuffix ( ) ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Exception exception , final Audit audit ) { treturn audit . action ( ) + getFailureSuffix ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Audit audit ) { treturn audit . action ( ) + getSuccessSuffix ( ) ; } 
public String resolveFrom ( final JoinPoint auditableTarget , final Object retval , final Audit audit ) { tfinal String action = audit . action ( ) ; treturn action + ( retval = = null ? getFailureSuffix ( ) : getSuccessSuffix ( ) ) ; } 
protected String [ ] createResource ( final Object [ ] args ) { final List < String > stringArgs = new ArrayList < String > ( ) ; for ( final Object arg : args ) { stringArgs . add ( arg . toString ( ) ) ; } return stringArgs . toArray ( new String [ stringArgs . size ( ) ] ) ; } 
public void record ( final AuditActionContext auditActionContext ) { log . info ( " Audit trail record BEGIN " ) ; log . info ( " ============================================================= " ) ; log . info ( " WHO: " + auditActionContext . getPrincipal ( ) ) ; log . info ( " WHAT: " + auditActionContext . getResourceOperatedUpon ( ) ) ; log . info ( " ACTION: " + auditActionContext . getActionPerformed ( ) ) ; log . info ( " APPLICATION: " + auditActionContext . getApplicationCode ( ) ) ; log . info ( " WHEN: " + auditActionContext . getWhenActionWasPerformed ( ) ) ; log . info ( " CLIENT IP ADDRESS: " + auditActionContext . getClientIpAddress ( ) ) ; log . info ( " SERVER IP ADDRESS: " + auditActionContext . getServerIpAddress ( ) ) ; log . info ( " ============================================================= " ) ; log . info ( " " ) ; } 
public ClientInfo resolveFrom ( final JoinPoint joinPoint , final Object retVal ) { tfinal ClientInfo clientInfo = ClientInfoHolder . getClientInfo ( ) ; if ( clientInfo ! = null ) { treturn clientInfo ; } tlog . warn ( " No ClientInfo could be found. Returning empty ClientInfo object. " ) ; treturn ClientInfo . EMPTY_CLIENT_INFO ; } 
String resolveFrom ( JoinPoint auditTarget , Object returnValue ) ; String resolve ( ) ; } 
String resolveFrom ( JoinPoint auditTarget , Exception exception ) ; String resolve ( ) ; } 
public void destroy ( ) { }} 
public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain filterChain ) throws IOException , ServletException { ttry { tfinal ClientInfo clientInfo = new ClientInfo ( ( HttpServletRequest ) request ) ; 
public void reportError ( final String applicationCode , final String principal , final Throwable throwable ) { tfinal StackTraceElement [ ] stackTraceElements = throwable . getStackTrace ( ) ; tfinal StringBuilder builder = new StringBuilder ( 512 ) ; tbuilder . append ( " " ) . append ( throwable . toString ( ) ) ; tfor ( final StackTraceElement element : stackTraceElements ) { tbuilder . append ( " tat " ) . append ( element . toString ( ) ) ; } tlogErrorRecord ( applicationCode , principal , builder . toString ( ) ) ; 
private void logErrorRecord ( final String applicationCode , final String principal , final String details ) { tfinal SimpleDateFormat dateTimeFormat = new SimpleDateFormat ( " yyyy-MM-dd HH:mm:ss.SSS Z " ) ; tfinal StringBuilder builder = new StringBuilder ( 512 ) ; tbuilder . append ( " n===ERROR LOG record BEGIN========================================== " ) . append ( " nAPPLICATION CODE: " ) . append ( applicationCode ) . append ( " nPRINCIPAL: " ) . append ( principal ) . append ( " nWHEN: " ) . append ( dateTimeFormat . format ( new Date ( ) ) ) . append ( " nDESCRIPTION: " ) . append ( details ) . append ( " n===ERROR LOG record END============================================ " ) . append ( " " ) ; log . error ( builder . toString ( ) ) ; } 
public String resolve ( ) { return getFromSecurityContext ( ) ; } 
public void record ( final AuditActionContext auditActionContext ) { tthis . executorService . execute ( new LoggingTask ( auditActionContext , this . transactionTemplate ) ) ; 
protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { tfinal String userId = auditActionContext . getPrincipal ( ) . length ( ) < = 100 ? auditActionContext . getPrincipal ( ) : auditActionContext . getPrincipal ( ) . substring ( 0 , 100 ) ; tfinal String resource = auditActionContext . getResourceOperatedUpon ( ) . length ( ) < = 100 ? auditActionContext . getResourceOperatedUpon ( ) : auditActionContext . getResourceOperatedUpon ( ) . substring ( 0 , 100 ) ; tfinal String action = auditActionContext . getActionPerformed ( ) . length ( ) < = 100 ? auditActionContext . getActionPerformed ( ) : auditActionContext . getActionPerformed ( ) . substring ( 0 , 100 ) ; tgetSimpleJdbcTemplate ( ) . update ( 
public ModelAndView resolveException ( final HttpServletRequest request , final HttpServletResponse response , final Object handler , final Exception exception ) { tthis . errorLogManager . recordError ( exception ) ; } 
protected void doFilterInternal ( final HttpServletRequest request , final HttpServletResponse response , final FilterChain filterChain ) throws ServletException , IOException { ttry { tfilterChain . doFilter ( request , response ) ; 
public String toString ( ) { return sbClause . toString ( ) ; } 
protected void addCriteria ( String column ) { addCriteria ( column , " = " ) ; } 
protected void addCriteria ( String column , String operator ) { if ( sbClause . length ( ) = = 0 ) { sbClause . append ( " WHERE " ) ; } else { sbClause . append ( " AND " ) ; } sbClause . append ( ' ' ) ; sbClause . append ( column ) ; sbClause . append ( ' ' ) ; sbClause . append ( operator ) ; sbClause . append ( " ? " ) ; } 
public void clean ( ) { this . transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { final String sql = String . format ( DELETE_SQL_TEMPLATE , tableName , cleanupCriteria ) ; final List < ? > params = cleanupCriteria . getParameterValues ( ) ; JdbcAuditTrailManager . this . logger . info ( " Cleaning audit records with query " + sql ) ; JdbcAuditTrailManager . this . logger . debug ( " Query parameters: " + params ) ; final int count = getSimpleJdbcTemplate ( ) . update ( sql , params . toArray ( ) ) ; JdbcAuditTrailManager . this . logger . info ( count + " records deleted. " ) ; } 
List < ? > getParameterValues ( ) ; String toString ( ) ; } 
String resolveFrom ( JoinPoint auditTarget , Exception exception ) ; String resolve ( ) ; } 
public String toString ( ) { return this . sbClause . toString ( ) ; } 
protected void addCriteria ( String column , String operator ) { if ( this . sbClause . length ( ) = = 0 ) { this . sbClause . append ( " WHERE " ) ; } else { this . sbClause . append ( " AND " ) ; } this . sbClause . append ( ' ' ) ; this . sbClause . append ( column ) ; this . sbClause . append ( ' ' ) ; this . sbClause . append ( operator ) ; this . sbClause . append ( " ? " ) ; } 
public void clean ( ) { this . transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { final String sql = String . format ( DELETE_SQL_TEMPLATE , tableName , cleanupCriteria ) ; final List < ? > params = cleanupCriteria . getParameterValues ( ) ; JdbcAuditTrailManager . this . logger . info ( " Cleaning audit records with query " + sql ) ; JdbcAuditTrailManager . this . logger . debug ( " Query parameters: " + params ) ; final int count = getSimpleJdbcTemplate ( ) . update ( sql , params . toArray ( ) ) ; JdbcAuditTrailManager . this . logger . info ( count + " records deleted. " ) ; } 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Audit audit ) { final String applicationCode = ( audit . applicationCode ( ) ! = null & & audit . applicationCode ( ) . length ( ) > 0 ) ? audit . applicationCode ( ) : this . applicationCode ; final ClientInfo clientInfo = this . clientInfoResolver . resolveFrom ( joinPoint , retVal ) ; final Date actionDate = new Date ( ) ; for ( final String auditableResource : auditableResources ) { final AuditActionContext auditContext = new AuditActionContext ( currentPrincipal , auditableResource , action , applicationCode , actionDate , clientInfo . getClientIpAddress ( ) , clientInfo . getServerIpAddress ( ) ) ; 
String resolveFrom ( JoinPoint auditTarget , Exception exception ) ; String resolve ( ) ; } 
public synchronized void record ( final AuditActionContext auditActionContext ) { log . info ( " Audit trail record BEGIN " ) ; log . info ( " ============================================================= " ) ; log . info ( " WHO: " + auditActionContext . getPrincipal ( ) ) ; log . info ( " WHAT: " + auditActionContext . getResourceOperatedUpon ( ) ) ; log . info ( " ACTION: " + auditActionContext . getActionPerformed ( ) ) ; log . info ( " APPLICATION: " + auditActionContext . getApplicationCode ( ) ) ; log . info ( " WHEN: " + auditActionContext . getWhenActionWasPerformed ( ) ) ; log . info ( " CLIENT IP ADDRESS: " + auditActionContext . getClientIpAddress ( ) ) ; log . info ( " SERVER IP ADDRESS: " + auditActionContext . getServerIpAddress ( ) ) ; log . info ( " ============================================================= " ) ; log . info ( " " ) ; } 
public void record ( final AuditActionContext auditActionContext ) { System . out . println ( toString ( auditActionContext ) ) ; } 
public void record ( final AuditActionContext auditActionContext ) { log . info ( toString ( auditActionContext ) ) ; } 
public void destroy ( ) { }} 
public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain filterChain ) throws IOException , ServletException { ttry { tfinal ClientInfo clientInfo ; 
public void init ( final FilterConfig filterConfig ) throws ServletException { this . otherHeader = filterConfig . getInitParameter ( CONST_IP_ADDRESS_HEADER ) ; } 
public void record ( final AuditActionContext auditActionContext ) { this . executorService . execute ( new LoggingTask ( auditActionContext , this . transactionTemplate ) ) ; } 
public void run ( ) { this . transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { final String userId = auditActionContext . getPrincipal ( ) . length ( ) < = 100 ? auditActionContext . getPrincipal ( ) : auditActionContext . getPrincipal ( ) . substring ( 0 , 100 ) ; final String resource = auditActionContext . getResourceOperatedUpon ( ) . length ( ) < = 100 ? auditActionContext . getResourceOperatedUpon ( ) : auditActionContext . getResourceOperatedUpon ( ) . substring ( 0 , 100 ) ; final String action = auditActionContext . getActionPerformed ( ) . length ( ) < = 100 ? auditActionContext . getActionPerformed ( ) : auditActionContext . getActionPerformed ( ) . substring ( 0 , 100 ) ; getSimpleJdbcTemplate ( ) . update ( 
public void clean ( ) { this . transactionTemplate . execute ( new TransactionCallbackWithoutResult ( ) { 
public void record ( final AuditActionContext auditActionContext ) { this . executorService . execute ( new LoggingTask ( auditActionContext , this . transactionTemplate , this . columnLength ) ) ; } 
public String [ ] resolveFrom ( final JoinPoint auditableTarget , final Exception exception ) { tfinal String message = exception . getMessage ( ) ; if ( message ! = null ) { treturn new String [ ] { message } ; } treturn new String [ ] { exception . toString ( ) } ; } 
public Thread newThread ( Runnable r ) { Thread ret = new Thread ( r , " JdbcAuditTrailManagerThread " ) ; ret . setDaemon ( true ) ; return ret ; } 
public Thread newThread ( Runnable r ) { Thread ret = new Thread ( r , " JdbcAuditTrailManagerThread " ) ; ret . setDaemon ( true ) ; return ret ; } 
public void destroy ( ) throws Exception { if ( this . defaultExecutorService ) { this . executorService . shutdown ( ) ; 
public String [ ] resolveFrom ( JoinPoint target , Object returnValue ) { return new String [ ] { target . getTarget ( ) . toString ( ) } ; } 
public String [ ] resolveFrom ( JoinPoint target , Exception exception ) { return new String [ ] { target . getTarget ( ) . toString ( ) + " __EXCEPTION: [ " + exception . getMessage ( ) + " ] " } ; } 
public String asString ( ) { return this . currentJoinPoint . toLongString ( ) ; } 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audits audits ) throws Throwable { Object retVal = null ; String currentPrincipal = null ; final String [ ] actions = new String [ audits . value ( ) . length ] ; final String [ ] [ ] auditableResources = new String [ audits . value ( ) . length ] [ ] ; try { retVal = joinPoint . proceed ( ) ; 
public Object handleAuditTrail ( final ProceedingJoinPoint joinPoint , final Audit audit ) throws Throwable { final AuditActionResolver auditActionResolver = this . auditActionResolvers . get ( audit . actionResolverName ( ) ) ; final AuditResourceResolver auditResourceResolver = this . auditResourceResolvers . get ( audit . resourceResolverName ( ) ) ; String currentPrincipal = null ; String [ ] auditResource = new String [ ] { null } ; String action = null ; Object retVal = null ; try { retVal = joinPoint . proceed ( ) ; 
private void executeAuditCode ( final String currentPrincipal , final String [ ] auditableResources , final ProceedingJoinPoint joinPoint , final Object retVal , final String action , final Audit audit ) { final String applicationCode = ( audit . applicationCode ( ) ! = null & & audit . applicationCode ( ) . length ( ) > 0 ) ? audit . applicationCode ( ) : this . applicationCode ; final ClientInfo clientInfo = this . clientInfoResolver . resolveFrom ( joinPoint , retVal ) ; final Date actionDate = new Date ( ) ; final AuditPointRuntimeInfo runtimeInfo = new AspectJAuditPointRuntimeInfo ( joinPoint ) ; for ( final String auditableResource : auditableResources ) { final AuditActionContext auditContext = 
protected String toString ( final AuditActionContext auditActionContext ) { if ( this . useSingleLine ) { return getSingleLineAuditString ( auditActionContext ) ; 
protected void doInTransactionWithoutResult ( final TransactionStatus transactionStatus ) { final String sql = String . format ( DELETE_SQL_TEMPLATE , tableName , cleanupCriteria ) ; final List < ? > params = cleanupCriteria . getParameterValues ( ) ; JdbcAuditTrailManager . this . logger . info ( " Cleaning audit records with query " + sql ) ; JdbcAuditTrailManager . this . logger . debug ( " Query parameters: " + params ) ; final int count = getJdbcTemplate ( ) . update ( sql , params . toArray ( ) ) ; JdbcAuditTrailManager . this . logger . info ( count + " records deleted. " ) ; } 
