static RPolygon intersection ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_INT , p1 , p2 , polyClass ) ; } 
static RPolygon union ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_UNION , p1 , p2 , polyClass ) ; } 
static RPolygon xor ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_XOR , p1 , p2 , polyClass ) ; } 
static RPolygon diff ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_DIFF , p1 , p2 , polyClass ) ; } 
static RPolygon intersection ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_INT , p1 , p2 , RPolygon . class ) ; } 
static RPolygon union ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_UNION , p1 , p2 , RPolygon . class ) ; } 
static RPolygon xor ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_XOR , p1 , p2 , RPolygon . class ) ; } 
static RPolygon diff ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_DIFF , p1 , p2 , RPolygon . class ) ; } 
static RPolygon update ( RPolygon p1 ) { return clip ( OperationType . GPC_DIFF , p1 , new RPolygon ( ) , RPolygon . class ) ; } 
private static RPolygon createNewPoly ( Class polyClass ) { try { 
public static RMesh polygonToMesh ( RPolygon s ) { RPolygon c = new RPolygon ( ) ; return clip ( OperationType . GPC_UNION , s , c ) ; } 
private static boolean EQ ( float a , float b ) { return ( Math . abs ( a - b ) < = GPC_EPSILON ) ; } 
private static int PREV_INDEX ( int i , int ) { return ( ( i - 1 + ) % ) ; } 
private static int NEXT_INDEX ( int i , int ) { return ( ( i + 1 ) % ) ; } 
private static boolean OPTIMAL ( RPolygon p , int i ) { return ( p . getY ( PREV_INDEX ( i , p . getNumPoints ( ) ) ) ! = p . getY ( i ) ) | | ( p . getY ( NEXT_INDEX ( i , p . getNumPoints ( ) ) ) ! = p . getY ( i ) ) ; 
private static void VERTEX ( EdgeNode e , int p , int s , float x , float y ) { e . outp [ p ] . v [ s ] = add_vertex ( e . outp [ p ] . v [ s ] , x , y ) ; e . outp [ p ] . active + + ; } 
private static float P_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { d = e ; do { td = d . prev ; } while ( d . outp [ p ] = = null ) ; return d . bot . x + d . dx * ( j - d . bot . y ) ; } 
private static float N_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { d = e ; do { td = d . next ; } while ( d . outp [ p ] = = null ) ; return d . bot . x + d . dx * ( j - d . bot . y ) ; } 
private static void minimax_test ( RPolygon subj , RPolygon clip , OperationType op ) { RRectangle [ ] s_bbox = create_contour_bboxes ( subj ) ; RRectangle [ ] c_bbox = create_contour_bboxes ( clip ) ; int subj_num_poly = subj . getNumInnerPoly ( ) ; int clip_num_poly = clip . getNumInnerPoly ( ) ; boolean [ ] [ ] o_table = new boolean [ subj_num_poly ] [ clip_num_poly ] ; for ( int c = 0 ; c < clip_num_poly ; c + + ) { boolean overlap = false ; for ( int s = 0 ; ! overlap & & ( s < subj_num_poly ) ; s + + ) { overlap = o_table [ s ] [ c ] ; } if ( ! overlap ) { clip . setContributing ( c , false ) ; Flag non contributing status } } if (op == OperationType.GPC_INT) { 
private static LmtNode bound_list ( LmtTable lmt_table , float y ) { if ( lmt_table . top_node = = null ) { 
private static void insert_bound ( LmtNode lmt_node , EdgeNode e ) { if ( lmt_node . first_bound = = null ) { 
private static void add_edge_to_aet ( AetTree aet , EdgeNode edge ) { if ( aet . top_node = = null ) { 
private static void add_to_sbtree ( ScanBeamTreeEntries sbte , float y ) { if ( sbte . sb_tree = = null ) { sbte . sb_tree = new ScanBeamTree ( y ) ; sbte . sbt_entries + + ; return ; } ScanBeamTree tree_node = sbte . sb_tree ; boolean done = false ; while ( ! done ) { 
private static StNode add_st_edge ( StNode st , ItNodeTable it , EdgeNode edge , float dy ) { if ( st = = null ) { st . prev = add_st_edge ( st . prev , it , edge , dy ) ; } } return st ; } 
private static ItNode add_intersection ( ItNode it_node , EdgeNode edge0 , EdgeNode edge1 , float x , float y ) { if ( it_node = = null ) { it_node . next = add_intersection ( it_node . next , edge0 , edge1 , x , y ) ; } } return it_node ; } 
private static int count_tristrips ( PolygonNode tn ) { int total ; for ( total = 0 ; tn ! = null ; tn = tn . next ) { if ( tn . active > 2 ) { ttotal + + ; } } return total ; } 
private static VertexNode add_vertex ( VertexNode ve_node , float x , float y ) { if ( ve_node = = null ) { ve_node . next = add_vertex ( ve_node . next , x , y ) ; } return ve_node ; } 
private static PolygonNode new_tristrip ( PolygonNode po_node , EdgeNode edge , float x , float y ) { if ( po_node = = null ) { po_node . next = new_tristrip ( po_node . next , edge , x , y ) ; } return po_node ; } 
public void add_right ( float x , float y ) { VertexNode nv = new VertexNode ( x , y ) ; proxy . v [ RIGHT ] = nv ; } 
public void add_left ( float x , float y ) { VertexNode nv = new VertexNode ( x , y ) ; proxy . v [ LEFT ] = nv ; } 
public PolygonNode add_local_min ( float x , float y ) { PolygonNode existing_min = top_node ; top_node = new PolygonNode ( existing_min , x , y ) ; return top_node ; } 
public void merge_left ( PolygonNode p , PolygonNode q ) { q . proxy . hole = true ; if ( p . proxy ! = q . proxy ) { 
public void merge_right ( PolygonNode p , PolygonNode q ) { q . proxy . hole = false ; if ( p . proxy ! = q . proxy ) { 
public int count_contours ( ) { int nc = 0 ; for ( PolygonNode polygon = top_node ; ( polygon ! = null ) ; polygon = polygon . next ) { if ( polygon . active ! = 0 ) { VertexNode nextv = null ; for (VertexNode v= polygon.proxy.v[LEFT]; (v != null); v = nextv) { nextv= v.next; v = null ; } polygon.active= 0; } } } return nc; } 
public void print ( ) { System . out . println ( " ---- out_poly ---- " ) ; int c = 0 ; PolygonNode npoly_node = null ; for ( PolygonNode poly_node = top_node ; ( poly_node ! = null ) ; poly_node = npoly_node ) { 
public void print ( ) { System . out . println ( " " ) ; System . out . println ( " aet " ) ; for ( EdgeNode edge = top_node ; ( edge ! = null ) ; edge = edge . next ) { 
public void addNode ( float x , float y ) { EdgeNode node = new EdgeNode ( ) ; node . vertex . x = x ; node . vertex . y = y ; m_List . add ( node ) ; } 
public boolean FWD_MIN ( int i ) { EdgeNode prev = ( EdgeNode ) m_List . get ( PREV_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode next = ( EdgeNode ) m_List . get ( NEXT_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( ( prev . vertex . getY ( ) > = ith . vertex . getY ( ) ) & & ( next . vertex . getY ( ) > ith . vertex . getY ( ) ) ) ; 
public boolean NOT_FMAX ( int i ) { EdgeNode next = ( EdgeNode ) m_List . get ( NEXT_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( next . vertex . getY ( ) > ith . vertex . getY ( ) ) ; } 
public boolean REV_MIN ( int i ) { EdgeNode prev = ( EdgeNode ) m_List . get ( PREV_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode next = ( EdgeNode ) m_List . get ( NEXT_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( ( prev . vertex . getY ( ) > ith . vertex . getY ( ) ) & & ( next . vertex . getY ( ) > = ith . vertex . getY ( ) ) ) ; 
public boolean NOT_RMAX ( int i ) { EdgeNode prev = ( EdgeNode ) m_List . get ( PREV_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( prev . vertex . getY ( ) > ith . vertex . getY ( ) ) ; } 
public void print ( ) { int = 0 ; LmtNode lmt = top_node ; while ( lmt ! = null ) { 
public float [ ] build_sbt ( ) { float [ ] sbt = new float [ sbt_entries ] ; int entries = 0 ; entries = inner_build_sbt ( entries , sbt , sb_tree ) ; if ( entries ! = sbt_entries ) { throw new IllegalStateException ( " Something went wrong buildign sbt from tree. " ) ; } return sbt ; } 
private int inner_build_sbt ( int entries , float [ ] sbt , ScanBeamTree sbt_node ) { if ( sbt_node . less ! = null ) { entries = inner_build_sbt ( entries , sbt , sbt_node . less ) ; } sbt [ entries ] = sbt_node . y ; entries + + ; if ( sbt_node . more ! = null ) { entries = inner_build_sbt ( entries , sbt , sbt_node . more ) ; } return entries ; } 
public void build_intersection_table ( AetTree aet , float dy ) { StNode st = null ; for ( EdgeNode edge = aet . top_node ; ( edge ! = null ) ; edge = edge . next ) { 
private static void print_sbt ( float [ ] sbt ) { System . out . println ( " " ) ; System . out . println ( " sbt.length= " + sbt . length ) ; for ( int i = 0 ; i < sbt . length ; i + + ) { 
static RCommand createLine ( RPoint start , RPoint end ) { RCommand result = new RCommand ( ) ; result . startPoint = start ; result . endPoint = end ; result . commandType = LINETO ; return result ; } 
static RCommand createLine ( float startx , float starty , float endx , float endy ) { return createLine ( new RPoint ( startx , starty ) , new RPoint ( endx , endy ) ) ; } 
static RCommand createBezier3 ( RPoint start , RPoint cp1 , RPoint end ) { RCommand result = new RCommand ( ) ; result . startPoint = start ; result . append ( cp1 ) ; result . endPoint = end ; result . commandType = QUADBEZIERTO ; return result ; } 
static RCommand createBezier3 ( float startx , float starty , float cp1x , float cp1y , float endx , float endy ) { return createBezier3 ( new RPoint ( startx , starty ) , new RPoint ( cp1x , cp1y ) , new RPoint ( endx , endy ) ) ; } 
static RCommand createBezier4 ( RPoint start , RPoint cp1 , RPoint cp2 , RPoint end ) { RCommand result = new RCommand ( ) ; result . startPoint = start ; result . append ( cp1 ) ; result . append ( cp2 ) ; result . endPoint = end ; result . commandType = CUBICBEZIERTO ; return result ; } 
static RCommand createBezier4 ( float startx , float starty , float cp1x , float cp1y , float cp2x , float cp2y , float endx , float endy ) { return createBezier4 ( new RPoint ( startx , starty ) , new RPoint ( cp1x , cp1y ) , new RPoint ( cp2x , cp2y ) , new RPoint ( endx , endy ) ) ; } 
public int countControlPoints ( ) { if ( controlPoints = = null ) { return 0 ; } return controlPoints . length ; } 
public void draw ( PGraphics g ) { RPoint [ ] points = getCurvePoints ( ) ; if ( points = = null ) { return ; } g . beginShape ( ) ; for ( int i = 0 ; i < points . length ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; } 
private void quadBezierAdaptative ( ) { addCurvePoint ( new RPoint ( startPoint ) ) ; quadBezierAdaptativeRecursive ( startPoint . x , startPoint . y , controlPoints [ 0 ] . x , controlPoints [ 0 ] . y , endPoint . x , endPoint . y , 0 ) ; addCurvePoint ( new RPoint ( endPoint ) ) ; } 
private void quadBezierAdaptativeRecursive ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , int level ) { if ( level > segmentRecursionLimit ) { return ; } Calculate all the mid-points of the line segments ---------------------- float x12 = (x1 + x2) / 2; float y12 = (y1 + y2) / 2; float x23 = (x2 + x3) / 2; float y23 = (y2 + y3) / 2; float x123 = (x12 + x23) / 2; float y123 = (y12 + y23) / 2; float dx = x3-x1; float dy = y3-y1; float d = Math.abs(((x2 - x3) * dy - (y2 - y3) * dx)); if(d > segmentCollinearityEpsilon) { Regular care ----------------- if(d * d <= segmentDistTolSqr * (dx*dx + dy*dy)) { If the curvature doesn't exceed the distance_tolerance value we tend to finish subdivisions. ---------------------- if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x123, y123)); return; } Angle & Cusp Condition ---------------------- float da = Math.abs((float)Math.atan2(y3 - y2, x3 - x2) - (float)Math.atan2(y2 - y1, x2 - x1)); if(da >= Math.PI) da = 2*(float)Math.PI - da; if(da < segmentAngleTol) { Finally we can stop the recursion ---------------------- addCurvePoint(new RPoint(x123, y123)); return; } } } else { if(Math.abs(x1 + x3 - x2 - x2) + Math.abs(y1 + y3 - y2 - y2) <= segmentDistTolMnhttn) { addCurvePoint(new RPoint(x123, y123)); return; } } Continue subdivision ---------------------- quadBezierAdaptativeRecursive(x1, y1, x12, y12, x123, y123, level + 1); quadBezierAdaptativeRecursive(x123, y123, x23, y23, x3, y3, level + 1); } 
private void cubicBezierAdaptative ( ) { addCurvePoint ( new RPoint ( startPoint ) ) ; cubicBezierAdaptativeRecursive ( startPoint . x , startPoint . y , controlPoints [ 0 ] . x , controlPoints [ 0 ] . y , controlPoints [ 1 ] . x , controlPoints [ 1 ] . y , endPoint . x , endPoint . y , 0 ) ; addCurvePoint ( new RPoint ( endPoint ) ) ; } 
private void cubicBezierAdaptativeRecursive ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , int level ) { if ( level > segmentRecursionLimit ) { return ; } Calculate all the mid-points of the line segments ---------------------- float x12 = (x1 + x2) / 2; float y12 = (y1 + y2) / 2; float x23 = (x2 + x3) / 2; float y23 = (y2 + y3) / 2; float x34 = (x3 + x4) / 2; float y34 = (y3 + y4) / 2; float x123 = (x12 + x23) / 2; float y123 = (y12 + y23) / 2; float x234 = (x23 + x34) / 2; float y234 = (y23 + y34) / 2; float x1234 = (x123 + x234) / 2; float y1234 = (y123 + y234) / 2; Try to approximate the full cubic curve by a single straight line ------------------ float dx = x4-x1; float dy = y4-y1; float d2 = Math.abs(((x2 - x4) * dy - (y2 - y4) * dx)); float d3 = Math.abs(((x3 - x4) * dy - (y3 - y4) * dx)); float da1, da2; int d2b = (d2 > segmentCollinearityEpsilon)?1:0; int d3b = (d3 > segmentCollinearityEpsilon)?1:0; switch((d2b << 1) + d3b){ case 0: All collinear OR p1==p4 ---------------------- if(Math.abs(x1 + x3 - x2 - x2) + Math.abs(y1 + y3 - y2 - y2) + Math.abs(x2 + x4 - x3 - x3) + Math.abs(y2 + y4 - y3 - y3) <= segmentDistTolMnhttn) { addCurvePoint(new RPoint(x1234, y1234)); return; } break; case 1: p1,p2,p4 are collinear, p3 is considerable ---------------------- if(d3 * d3 <= segmentDistTolSqr * (dx*dx + dy*dy)) { if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x23, y23)); return; } Angle Condition ---------------------- da1 = Math.abs((float)Math.atan2(y4 - y3, x4 - x3) - (float)Math.atan2(y3 - y2, x3 - x2)); if(da1 >= (float)Math.PI) da1 = 2*(float)Math.PI - da1; if(da1 < segmentAngleTol) { addCurvePoint(new RPoint(x2, y2)); addCurvePoint(new RPoint(x3, y3)); return; } if(segmentCuspLimit != 0.0) { if(da1 > segmentCuspLimit) { addCurvePoint(new RPoint(x3, y3)); return; } } } break; case 2: p1,p3,p4 are collinear, p2 is considerable ---------------------- if(d2 * d2 <= segmentDistTolSqr * (dx*dx + dy*dy)) { if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x23, y23)); return; } Angle Condition ---------------------- da1 = Math.abs((float)Math.atan2(y3 - y2, x3 - x2) - (float)Math.atan2(y2 - y1, x2 - x1)); if(da1 >= (float)Math.PI) da1 = 2*(float)Math.PI - da1; if(da1 < segmentAngleTol) { addCurvePoint(new RPoint(x2, y2)); addCurvePoint(new RPoint(x3, y3)); return; } if(segmentCuspLimit != 0.0) { if(da1 > segmentCuspLimit) { addCurvePoint(new RPoint(x2, y2)); return; } } } break; case 3: Regular care ----------------- if((d2 + d3)*(d2 + d3) <= segmentDistTolSqr * (dx*dx + dy*dy)) { If the curvature doesn't exceed the distance_tolerance value we tend to finish subdivisions. ---------------------- if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x23, y23)); return; } Angle & Cusp Condition ---------------------- float a23 = (float)Math.atan2(y3 - y2, x3 - x2); da1 = Math.abs(a23 - (float)Math.atan2(y2 - y1, x2 - x1)); da2 = Math.abs((float)Math.atan2(y4 - y3, x4 - x3) - a23); if(da1 >= (float)Math.PI) da1 = 2*(float)Math.PI - da1; if(da2 >= (float)Math.PI) da2 = 2*(float)Math.PI - da2; if(da1 + da2 < segmentAngleTol) { Finally we can stop the recursion ---------------------- addCurvePoint(new RPoint(x23, y23)); return; } if(segmentCuspLimit != 0.0) { if(da1 > segmentCuspLimit) { addCurvePoint(new RPoint(x2, y2)); return; } if(da2 > segmentCuspLimit) { addCurvePoint(new RPoint(x3, y3)); return; } } } break; } Continue subdivision ---------------------- cubicBezierAdaptativeRecursive(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1); cubicBezierAdaptativeRecursive(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1); } 
private void lineUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx = endPoint.x - startPoint.x; float dy = endPoint.y - startPoint.y; float len = (float)Math.sqrt(dx * dx + dy * dy); steps = (int)(len * 0.25); if(steps < 4) steps = 4; } float dt = 1F/steps; float fx, fy, fdx, fdy; float temp = dt * dt; fx = startPoint.x; fdx = (endPoint.x - startPoint.x) * dt; fy = startPoint.y; fdy = (endPoint.y - startPoint.y) * dt; for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx; fy = fy + fdy; } addCurvePoint(new RPoint(endPoint)); } 
private void cubicBezierUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx1 = controlPoints[0].x - startPoint.x; float dy1 = controlPoints[0].y - startPoint.y; float dx2 = controlPoints[1].x - controlPoints[0].x; float dy2 = controlPoints[1].y - controlPoints[0].y; float dx3 = endPoint.x - controlPoints[1].x; float dy3 = endPoint.y - controlPoints[1].y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1) + (float)Math.sqrt(dx2 * dx2 + dy2 * dy2) + (float)Math.sqrt(dx3 * dx3 + dy3 * dy3); steps = (int)(len * 0.25); if(steps < 4) { steps = 4; } } float dt = 1F/steps; float fx, fy, fdx, fdy, fddx, fddy, fdddx, fdddy, fdd_per_2x, fdd_per_2y, fddd_per_2x, fddd_per_2y, fddd_per_6x, fddd_per_6y; float temp = dt * dt; fx = startPoint.x; fdx = 3F * (controlPoints[0].x - startPoint.x) * dt; fdd_per_2x = 3F * (startPoint.x - 2F * controlPoints[0].x + controlPoints[1].x) * temp; fddd_per_2x = 3F * (3F * (controlPoints[0].x - controlPoints[1].x) + endPoint.x - startPoint.x) * temp * dt; fdddx = fddd_per_2x + fddd_per_2x; fddx = fdd_per_2x + fdd_per_2x; fddd_per_6x = fddd_per_2x * (1.0F / 3F); fy = startPoint.y; fdy = 3F * (controlPoints[0].y - startPoint.y) * dt; fdd_per_2y = 3F * (startPoint.y - 2F * controlPoints[0].y + controlPoints[1].y) * temp; fddd_per_2y = 3F * (3F * (controlPoints[0].y - controlPoints[1].y) + endPoint.y - startPoint.y) * temp * dt; fdddy = fddd_per_2y + fddd_per_2y; fddy = fdd_per_2y + fdd_per_2y; fddd_per_6y = fddd_per_2y * (1.0F / 3F); for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx + fdd_per_2x + fddd_per_6x; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fdy + fdd_per_2y + fddd_per_6y; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } addCurvePoint(new RPoint(endPoint)); } 
private void quadBezierUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx1 = controlPoints[0].x - startPoint.x; float dy1 = controlPoints[0].y - startPoint.y; float dx2 = endPoint.x - controlPoints[0].x; float dy2 = endPoint.y - controlPoints[0].y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1) + (float)Math.sqrt(dx2 * dx2 + dy2 * dy2); steps = (int)(len * 0.25); if(steps < 4) steps = 4; } float dt = 1F/steps; float fx, fy, fdx, fdy, fddx, fddy, fdd_per_2x, fdd_per_2y; float temp = dt * dt; fx = startPoint.x; fdx = 2F * (controlPoints[0].x - startPoint.x) * dt; fdd_per_2x = (startPoint.x - 2F * controlPoints[0].x + endPoint.x) * temp; fddx = fdd_per_2x + fdd_per_2x; fy = startPoint.y; fdy = 2F * (controlPoints[0].y - startPoint.y) * dt; fdd_per_2y = (startPoint.y - 2F * controlPoints[0].y + endPoint.y) * temp; fddy = fdd_per_2y + fdd_per_2y; for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx + fdd_per_2x; fdx = fdx + fddx; fy = fy + fdy + fdd_per_2y; fdy = fdy + fddy; } addCurvePoint(new RPoint(endPoint)); } 
private void lineUniformLength ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve float dx1 = endPoint.x - startPoint.x; float dy1 = endPoint.y - startPoint.y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1); float steps = (int)(len * 2); if(steps < 4) steps = 4; This holds the amount of steps used to calculate segment lengths float dt = 1F/steps; This holds how much length has to bee advanced until adding a point float untilPoint = RCommand.segmentAccOffset; float fx, fy, fdx, fdy; fx = startPoint.x; fdx = (endPoint.x - startPoint.x) * dt; fy = startPoint.y; fdy = (endPoint.y - startPoint.y) * dt; for (int loop=0; loop <= steps; loop++) { untilPoint -= (float)Math.sqrt(fdx*fdx + fdy*fdy); Eventually try other distance measures fx = fx + fdx; fy = fy + fdy; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
private void quadBezierUniformLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y , fix , fiy ; float temp = dt * dt ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop < = steps ; loop + + ) { fix = fdx + fdd_per_2x ; fiy = fdy + fdd_per_2y ; untilPoint - = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx; fy = fy + fiy; fdy = fdy + fddy; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
private void cubicBezierUniformLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y , fix , fiy ; float temp = dt * dt ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop + + ) { fix = fdx + fdd_per_2x + fddd_per_6x ; fiy = fdy + fdd_per_2y + fddd_per_6y ; untilPoint - = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fiy; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
private float quadBezierLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y , fix , fiy ; float temp = dt * dt ; float totallen = 0F ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop < = steps ; loop + + ) { fix = fdx + fdd_per_2x ; fiy = fdy + fdd_per_2y ; totallen + = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx; fy = fy + fiy; fdy = fdy + fddy; } return totallen; } 
private float cubicBezierLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y , fix , fiy ; float temp = dt * dt ; float totallen = 0F ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop + + ) { fix = fdx + fdd_per_2x + fddd_per_6x ; fiy = fdy + fdd_per_2y + fddd_per_6y ; totallen + = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fiy; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } return totallen; } 
void append ( RPoint nextcontrolpoint ) { RPoint [ ] newcontrolPoints ; if ( controlPoints = = null ) { newcontrolPoints = new RPoint [ 1 ] ; newcontrolPoints [ 0 ] = nextcontrolpoint ; } else { newcontrolPoints = new RPoint [ controlPoints . length + 1 ] ; System . arraycopy ( controlPoints , 0 , newcontrolPoints , 0 , controlPoints . length ) ; newcontrolPoints [ controlPoints . length ] = nextcontrolpoint ; } this . controlPoints = newcontrolPoints ; } 
private void addCurvePoint ( RPoint nextcurvepoint ) { RPoint [ ] newcurvePoints ; if ( curvePoints = = null ) { newcurvePoints = new RPoint [ 1 ] ; newcurvePoints [ 0 ] = nextcurvepoint ; } else { newcurvePoints = new RPoint [ curvePoints . length + 1 ] ; System . arraycopy ( curvePoints , 0 , newcurvePoints , 0 , curvePoints . length ) ; newcurvePoints [ curvePoints . length ] = nextcurvepoint ; } this . curvePoints = newcurvePoints ; } 
public int countPoints ( ) { if ( this . points = = null ) { return 0 ; } return this . points . length ; } 
public void draw ( PGraphics g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; if ( beforeFill ) g . fill ( g . fillColor ) ; 
public void draw ( PApplet g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { tg . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; if ( beforeFill ) g . fill ( g . g . fillColor ) ; 
public void addPoint ( float x , float y ) { tthis . append ( new RPoint ( x , y ) ) ; } 
public void addClose ( ) { if ( points = = null ) { return ; } if ( ( points [ 0 ] . x = = points [ points . length - 1 ] . x ) & & ( points [ 0 ] . y = = points [ points . length - 1 ] . y ) ) { return ; } addPoint ( new RPoint ( points [ 0 ] . x , points [ 0 ] . y ) ) ; } 
public RPolygon toPolygon ( ) { treturn new RPolygon ( this ) ; } 
public RShape toShape ( ) throws RuntimeException { tthrow new RuntimeException ( " Transforming a Contour to a Shape is not yet implemented. " ) ; } 
public RMesh toMesh ( ) { return this . toPolygon ( ) . toMesh ( ) ; } 
tvoid append ( RPoint nextpoint ) { RPoint [ ] newpoints ; if ( points = = null ) { tnewpoints = new RPoint [ 1 ] ; tnewpoints [ 0 ] = nextpoint ; } else { tnewpoints = new RPoint [ this . points . length + 1 ] ; tSystem . arraycopy ( this . points , 0 , newpoints , 0 , this . points . length ) ; tnewpoints [ this . points . length ] = nextpoint ; } this . points = newpoints ; } 
public void setAlign ( int align ) throws RuntimeException { if ( align ! = LEFT & & align ! = CENTER & & align ! = RIGHT ) { tthrow new RuntimeException ( " Alignement unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT " ) ; } tthis . align = align ; } 
public RShape toShape ( char character ) { tRGroup grp = toGroup ( Character . toString ( character ) ) ; if ( grp . countElements ( ) > 0 ) return ( RShape ) ( grp . elements [ 0 ] ) ; treturn new RShape ( ) ; } 
public RPolygon toPolygon ( char character ) { treturn toShape ( character ) . toPolygon ( ) ; } 
public RGroup toGroup ( String text ) throws RuntimeException { tRGroup result = new RGroup ( ) ; } 
public void draw ( char character , PGraphics g ) throws RuntimeException { tthis . toShape ( character ) . draw ( g ) ; } 
public void draw ( String text , PGraphics g ) throws RuntimeException { tthis . toGroup ( text ) . draw ( g ) ; } 
public void draw ( char character , PApplet g ) throws RuntimeException { tthis . toShape ( character ) . draw ( g ) ; } 
public void draw ( String text , PApplet g ) throws RuntimeException { tthis . toGroup ( text ) . draw ( g ) ; } 
public void draw ( String text ) throws RuntimeException { this . toGroup ( text ) . draw ( ) ; } 
public void draw ( char character ) throws RuntimeException { this . toShape ( character ) . draw ( ) ; } 
private static float midValue ( float a , float b ) { treturn a + ( b - a ) / 2 ; } 
public void draw ( ) { this . draw ( RGeomerative . parent ) ; } 
public void transform ( RMatrix m ) { RPoint [ ] ps = getPoints ( ) ; if ( ps ! = null ) { for ( int i = 0 ; i < ps . length ; i + + ) { 
public RMatrix getCenteringTransf ( PGraphics g , float margin , float sclDamping , float trnsDamping ) throws RuntimeException { RMatrix transf ; float mrgn = margin * 2 ; RContour c = getBounds ( ) ; float scl = ( float ) Math . min ( ( g . width - mrgn ) / ( float ) Math . abs ( c . points [ 0 ] . x - c . points [ 2 ] . x ) , ( g . height - mrgn ) / ( float ) Math . abs ( c . points [ 0 ] . y - c . points [ 2 ] . y ) ) ; RPoint trns = getCenter ( ) ; transf = new RMatrix ( ) ; if ( sclDamping ! = 0 ) { transf . scale ( 1 + ( scl - 1 ) * sclDamping ) ; } if ( trnsDamping ! = 0 ) { transf . translate ( - trns . x * trnsDamping , - trns . y * trnsDamping ) ; } return transf ; } 
public RMatrix getCenteringTransf ( PGraphics g ) throws RuntimeException { return getCenteringTransf ( g , 0 , 1 , 1 ) ; } 
public RMatrix getCenteringTransf ( PGraphics g , float margin ) throws RuntimeException { return getCenteringTransf ( g , margin , 1 , 1 ) ; } 
public void centerIn ( PGraphics g ) { transform ( getCenteringTransf ( g ) ) ; } 
public void centerIn ( PGraphics g , float margin , float sclDamping , float trnsDamping ) throws RuntimeException { transform ( getCenteringTransf ( g , margin , sclDamping , trnsDamping ) ) ; } 
public void translate ( float tx , float ty ) { RMatrix transf = new RMatrix ( ) ; transf . translate ( tx , ty ) ; transform ( transf ) ; } 
public void translate ( RPoint ) { RMatrix transf = new RMatrix ( ) ; transf . translate ( ) ; transform ( transf ) ; } 
public void rotate ( float angle ) { RMatrix transf = new RMatrix ( ) ; transf . rotate ( angle ) ; transform ( transf ) ; } 
public void rotate ( float angle , float vx , float vy ) { RMatrix transf = new RMatrix ( ) ; transf . rotate ( angle , vx , vy ) ; transform ( transf ) ; } 
public void rotate ( float angle , RPoint v ) { RMatrix transf = new RMatrix ( ) ; transf . rotate ( angle , v ) ; transform ( transf ) ; } 
public void scale ( float sx , float sy ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( sx , sy ) ; transform ( transf ) ; } 
public void scale ( float s ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( s ) ; transform ( transf ) ; } 
public static void init ( PApplet _parent ) { parent = _parent ; } 
public int countElements ( ) { if ( elements = = null ) return 0 ; return elements . length ; } 
public void print ( ) { System . out . println ( " group: " ) ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { 
public static void setAdaptorLengthOffset ( float adptorLengthOffset ) throws RuntimeException { if ( adptorLengthOffset > = 0F & & adptorLengthOffset < = 1F ) adaptorLengthOffset = adptorLengthOffset ; 
public void draw ( PGraphics g ) { for ( int i = 0 ; i < countElements ( ) ; i + + ) { elements [ i ] . draw ( g ) ; 
public void draw ( PApplet a ) { for ( int i = 0 ; i < countElements ( ) ; i + + ) { elements [ i ] . draw ( a ) ; 
public void addElement ( RGeomElem elem ) { this . append ( elem ) ; } 
public void addGroup ( RGroup grupo ) { for ( int i = 0 ; i < grupo . countElements ( ) ; i + + ) { this . addElement ( grupo . elements [ i ] ) ; 
public void removeElement ( int i ) throws RuntimeException { this . extract ( i ) ; } 
public RGroup toMeshGroup ( ) throws RuntimeException { RGroup result = new RGroup ( ) ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { result . addElement ( elements [ i ] . toMesh ( ) ) ; } return result ; } 
public RGroup toPolygonGroup ( ) throws RuntimeException { RGroup result = new RGroup ( ) ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { result . addElement ( elements [ i ] . toPolygon ( ) ) ; } return result ; } 
public RGroup toShapeGroup ( ) throws RuntimeException { RGroup result = new RGroup ( ) ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { result . addElement ( elements [ i ] . toShape ( ) ) ; } return result ; } 
public RMesh toMesh ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Mesh is not yet implemented."); RGroup meshGroup = toMeshGroup(); RMesh result = new RMesh(); for(int i=0;i<countElements();i++){ RMesh currentMesh = (RMesh)(meshGroup.elements[i]); for(int j=0;j<currentMesh.countStrips();j++){ result.addStrip(currentMesh.strips[j]); } } result.texture = this.texture; result.id = this.id; return result; } 
public RPolygon toPolygon ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Polygon is not yet implemented."); RGroup polygonGroup = toPolygonGroup(); RPolygon result = new RPolygon(); for(int i=0;i<countElements();i++){ RPolygon currentPolygon = (RPolygon)(polygonGroup.elements[i]); for(int j=0;j<currentPolygon.countContours();j++){ result.addContour(currentPolygon.contours[j]); } } result.texture = this.texture; result.id = this.id; return result; } 
public RShape toShape ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Shape is not yet implemented."); RGroup shapeGroup = toShapeGroup(); RShape result = new RShape(); for(int i=0;i<countElements();i++){ RShape currentShape = (RShape)(shapeGroup.elements[i]); for(int j=0;j<currentShape.countSubshapes();j++){ result.addSubshape(currentShape.subshapes[j]); } } result.texture = this.texture; result.id = this.id; return result; } 
RGroup adaptTo ( RSubshape sshp , float wght , float lngthOffset ) throws RuntimeException { RGroup result = new RGroup ( this ) ; RContour c = result . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; int numElements = result . countElements ( ) ; switch ( adaptorType ) { case BYPOINT : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RPoint [ ] ps = elem . getPoints ( ) ; if ( ps ! = null ) { for ( int k = 0 ; k < ps . length ; k + + ) { float px = ps [ k ] . x ; float py = ps [ k ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; float amp = ( ymax - py ) ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) - ( float ) Math . PI / 2F ; ps [ k ] . x = p . x + wght * amp * ( float ) Math . cos ( angle ) ; ps [ k ] . y = p . y + wght * amp * ( float ) Math . sin ( angle ) ; } } } break ; case BYELEMENTPOSITION : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; case BYELEMENTINDEX : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( float ) i / ( float ) numElements + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; default : throw new RuntimeException ( " Unknown adaptor type : " + adaptorType + " . The method setAdaptor() only accepts RGroup.BYPOINT or RGroup.BYELEMENT as parameter values. " ) ; } return result ; } 
public RGroup adaptTo ( RSubshape sshp ) throws RuntimeException { return adaptTo ( sshp , adaptorScale , adaptorLengthOffset ) ; } 
public RGroup adaptTo ( RShape shp ) throws RuntimeException { RGroup result = new RGroup ( ) ; int numSubshapes = shp . countSubshapes ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RGroup tempresult = adaptTo ( shp . subshapes [ i ] ) ; int numElements = tempresult . countElements ( ) ; for ( int j = 0 ; j < numElements ; j + + ) { result . addElement ( tempresult . elements [ j ] ) ; } } return result ; } 
void append ( RGeomElem elem ) { RGeomElem [ ] newelements ; if ( elements = = null ) { newelements = new RGeomElem [ 1 ] ; newelements [ 0 ] = elem ; } else { newelements = new RGeomElem [ this . elements . length + 1 ] ; System . arraycopy ( this . elements , 0 , newelements , 0 , this . elements . length ) ; newelements [ this . elements . length ] = elem ; } this . elements = newelements ; } 
void extract ( int i ) throws RuntimeException { RGeomElem [ ] newelements ; if ( elements = = null ) { throw new RuntimeException ( " The group is empty. No elements to remove. " ) ; } else { if ( i < 0 ) { throw new RuntimeException ( " Negative values for indexes are not valid. " ) ; } if ( i > elements . length - 1 ) { throw new RuntimeException ( " Index out of the bounds of the group. You are trying to erase an element with an index higher than the number of elements in the group. " ) ; } if ( elements . length = = 1 ) { newelements = null ; } else if ( i = = 0 ) { newelements = new RGeomElem [ this . elements . length - 1 ] ; System . arraycopy ( this . elements , 1 , newelements , 0 , this . elements . length - 1 ) ; } else if ( i = = elements . length - 1 ) { newelements = new RGeomElem [ this . elements . length - 1 ] ; System . arraycopy ( this . elements , 0 , newelements , 0 , this . elements . length - 1 ) ; } else { newelements = new RGeomElem [ this . elements . length - 1 ] ; System . arraycopy ( this . elements , 0 , newelements , 0 , i ) ; System . arraycopy ( this . elements , i + 1 , newelements , i , this . elements . length - i - 1 ) ; } } this . elements = newelements ; } 
private void set ( float m00 , float m01 , float m02 , float m10 , float m11 , float m12 ) { tthis . m00 = m00 ; tthis . m01 = m01 ; tthis . m02 = m02 ; tthis . m10 = m10 ; tthis . m11 = m11 ; tthis . m12 = m12 ; } 
public void apply ( RMatrix rhs ) { apply ( rhs . m00 , rhs . m01 , rhs . m02 , rhs . m10 , rhs . m11 , rhs . m12 ) ; 
public void apply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { float r00 = m00 * n00 + m01 * n10 ; float r01 = m00 * n01 + m01 * n11 ; float r02 = m00 * n02 + m01 * n12 + m02 ; float r10 = m10 * n00 + m11 * n10 ; float r11 = m10 * n01 + m11 * n11 ; float r12 = m10 * n02 + m11 * n12 + m12 ; m00 = r00 ; m01 = r01 ; m02 = r02 ; m10 = r10 ; m11 = r11 ; m12 = r12 ; } 
public void translate ( float tx , float ty ) { apply ( 1 , 0 , tx , 0 , 1 , ty ) ; } 
public void translate ( float tx ) { translate ( tx , 0 ) ; } 
public void translate ( RPoint ) { translate ( . x , . y ) ; } 
public void rotate ( float angle ) { float c = ( float ) Math . cos ( angle ) ; float s = ( float ) Math . sin ( angle ) ; apply ( c , - s , 0 , s , c , 0 ) ; } 
public void rotate ( float angle , float vx , float vy ) { translate ( vx , vy ) ; rotate ( angle ) ; translate ( - vx , - vy ) ; } 
public void rotate ( float angle , RPoint v ) { rotate ( angle , v . x , v . y ) ; } 
public void scale ( float sx , float sy ) { apply ( sx , 0 , 0 , 0 , sy , 0 ) ; } 
public void scale ( float s ) { apply ( s , 0 , 0 , 0 , s , 0 ) ; } 
public void scale ( float sx , float sy , float vx , float vy ) { translate ( vx , vy ) ; scale ( sx , sy ) ; translate ( - vx , - vy ) ; } 
public void scale ( float s , float vx , float vy ) { scale ( s , s , vx , vy ) ; } 
public void scale ( float sx , float sy , RPoint v ) { scale ( sx , sy , v . x , v . y ) ; } 
public void scale ( float s , RPoint v ) { scale ( s , s , v . x , v . y ) ; } 
public void skewX ( float angle ) { apply ( 1 , ( float ) Math . tan ( angle ) , 0 , 0 , 1 , 0 ) ; } 
public void skewY ( float angle ) { apply ( 1 , 0 , 0 , ( float ) Math . tan ( angle ) , 1 , 0 ) ; } 
public void shear ( float shx , float shy ) { apply ( 1 , - shx , 0 , shy , 1 , 0 ) ; } 
public int countStrips ( ) { if ( this . strips = = null ) { treturn 0 ; } treturn this . strips . length ; } 
public void addPoint ( RPoint p ) { if ( strips = = null ) { tthis . append ( new RStrip ( ) ) ; } tthis . strips [ currentStrip ] . append ( p ) ; } 
public void addPoint ( float x , float y ) { if ( strips = = null ) { tthis . append ( new RStrip ( ) ) ; } tthis . strips [ currentStrip ] . append ( new RPoint ( x , y ) ) ; } 
public void addPoint ( int indStrip , RPoint p ) { if ( strips = = null ) { tthis . append ( new RStrip ( ) ) ; } tthis . strips [ indStrip ] . append ( p ) ; } 
public void addPoint ( int indStrip , float x , float y ) { if ( strips = = null ) { tthis . append ( new RStrip ( ) ) ; } tthis . strips [ indStrip ] . append ( new RPoint ( x , y ) ) ; } 
public void draw ( PGraphics g ) { for ( int i = 0 ; i < this . countStrips ( ) ; i + + ) { g . beginShape ( g . TRIANGLE_STRIP ) ; 
public void draw ( PApplet g ) { tfor ( int i = 0 ; i < this . countStrips ( ) ; i + + ) { tg . beginShape ( g . TRIANGLE_STRIP ) ; 
public boolean isIn ( PGraphics g ) { tRContour c = getBounds ( ) ; tfloat x0 = g . screenX ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; tfloat y0 = g . screenY ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; tfloat x1 = g . screenX ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; tfloat y1 = g . screenY ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; tfloat x2 = g . screenX ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; tfloat y2 = g . screenY ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; tfloat x3 = g . screenX ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; tfloat y3 = g . screenY ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; treturn ( ( ( ( x0 > 0 & & x0 < g . width ) & & ( y0 > 0 & & y0 < g . height ) ) | | ( ( x1 > 0 & & x1 < g . width ) & & ( y1 > 0 & & y1 < g . height ) ) | | 
public void transform ( RMatrix m ) { tint numStrips = countStrips ( ) ; if ( numStrips ! = 0 ) { tfor ( int i = 0 ; i < numStrips ; i + + ) { 
public RPolygon toPolygon ( ) throws RuntimeException { tthrow new RuntimeException ( " Transforming a Mesh to a Polygon is not yet implemented. " ) ; } 
public RShape toShape ( ) throws RuntimeException { tthrow new RuntimeException ( " Transforming a Mesh to a Shape is not yet implemented. " ) ; } 
tvoid append ( RStrip nextstrip ) { RStrip [ ] newstrips ; if ( strips = = null ) { tnewstrips = new RStrip [ 1 ] ; tnewstrips [ 0 ] = nextstrip ; tcurrentStrip = 0 ; } else { tnewstrips = new RStrip [ this . strips . length + 1 ] ; tSystem . arraycopy ( this . strips , 0 , newstrips , 0 , this . strips . length ) ; tnewstrips [ this . strips . length ] = nextstrip ; tcurrentStrip + + ; } this . strips = newstrips ; } 
public void transform ( RMatrix m ) { tfloat tempx = m . m00 * x + m . m01 * y + m . m02 ; tfloat tempy = m . m10 * x + m . m11 * y + m . m12 ; tx = tempx ; ty = tempy ; } 
public void translate ( float tx , float ty ) { tx + = tx ; ty + = ty ; } 
public void translate ( RPoint ) { tx + = . x ; ty + = . y ; } 
public void rotate ( float angle ) { tfloat c = ( float ) Math . cos ( angle ) ; tfloat s = ( float ) Math . sin ( angle ) ; tfloat tempx = x ; tfloat tempy = y ; tx = tempx * c - tempy * s ; ty = tempx * s + tempy * c ; } 
public void rotate ( float angle , float vx , float vy ) { tfloat c = ( float ) Math . cos ( angle ) ; tfloat s = ( float ) Math . sin ( angle ) ; tx - = vx ; ty - = vy ; tfloat tempx = x ; tfloat tempy = y ; tx = tempx * c - tempy * s ; ty = tempx * s + tempy * c ; tx + = vx ; ty + = vy ; } 
public void rotate ( float angle , RPoint v ) { tfloat c = ( float ) Math . cos ( angle ) ; tfloat s = ( float ) Math . sin ( angle ) ; tx - = v . x ; ty - = v . y ; tfloat tempx = x ; tfloat tempy = y ; tx = tempx * c - tempy * s ; ty = tempx * s + tempy * c ; tx + = v . x ; ty + = v . y ; } 
public void scale ( float sx , float sy ) { tx * = sx ; ty * = sy ; } 
public void scale ( RPoint s ) { tx * = s . x ; ty * = s . y ; } 
public void normalize ( ) { tfloat norma = norm ( ) ; if ( norma ! = 0 ) scale ( 1 / norma ) ; } 
public void add ( RPoint p ) { tx + = p . x ; ty + = p . y ; } 
public float mult ( RPoint p ) { treturn ( x * p . x + y * p . y ) ; } 
public RPoint cross ( RPoint p ) { treturn new RPoint ( x * p . y - p . x * y , y * p . x - p . y * x ) ; } 
public float norm ( ) { treturn ( float ) Math . sqrt ( mult ( this ) ) ; } 
public float angle ( RPoint p ) { tfloat normp = p . norm ( ) ; tfloat normthis = norm ( ) ; treturn ( float ) Math . acos ( mult ( p ) / ( normp * normthis ) ) ; } 
public void print ( ) { System . out . print ( " ( " + x + " , " + y + " ) " ) ; } 
tstatic public RPolygon createCircle ( float x , float y , float radius , int detail ) { tRPolygon circle = new RPolygon ( ) ; tfor ( int i = 0 ; i < detail ; i + + ) { tcircle . addPoint ( ( float ) ( radius * Math . cos ( 2 * Math . PI * i / detail ) ) + x , ( float ) ( radius * Math . sin ( 2 * Math . PI * i / detail ) ) + y ) ; } treturn circle ; } 
tstatic public RPolygon createCircle ( float radius , int detail ) { treturn createCircle ( 0 , 0 , radius , detail ) ; } 
tstatic public RPolygon createCircle ( float x , float y , float radius ) { treturn createCircle ( x , y , radius , defaultDetail ) ; } 
tstatic public RPolygon createCircle ( float radius ) { treturn createCircle ( 0 , 0 , radius , defaultDetail ) ; } 
tstatic public RPolygon createRectangle ( float x , float y , float w , float h ) { tRPolygon rectangle = new RPolygon ( ) ; trectangle . addPoint ( x , y ) ; rectangle . addPoint ( x + w , y ) ; rectangle . addPoint ( x + w , y + h ) ; rectangle . addPoint ( x , y + h ) ; rectangle . addPoint ( x , y ) ; treturn rectangle ; } 
tstatic public RPolygon createRectangle ( float w , float h ) { treturn createRectangle ( 0 , 0 , w , h ) ; } 
tstatic public RPolygon createStar ( float x , float y , float radiusBig , float radiusSmall , int spikes ) { RPolygon star = new RPolygon ( ) ; for ( int i = 0 ; i < 2 * spikes ; i + = 2 ) { star . addPoint ( ( float ) ( radiusBig * Math . cos ( Math . PI * i / spikes ) ) + x , ( float ) ( radiusBig * Math . sin ( Math . PI * i / spikes ) ) + y ) ; star . addPoint ( ( float ) ( radiusSmall * Math . cos ( Math . PI * ( i + 1 ) / spikes ) ) + x , ( float ) ( radiusSmall * Math . sin ( Math . PI * ( i + 1 ) / spikes ) ) + y ) ; } star . addClose ( ) ; return star ; } 
tstatic public RPolygon createStar ( float radiusBig , float radiusSmall , int spikes ) { treturn createStar ( 0 , 0 , radiusBig , radiusSmall , spikes ) ; } 
static public RPolygon createRing ( float x , float y , float radiusBig , float radiusSmall , int detail ) { RPolygon ring = new RPolygon ( ) ; for ( int i = 0 ; i < detail ; i + + ) { ring . addPoint ( ( float ) ( radiusBig * Math . cos ( 2 * Math . PI * i / detail ) ) + x , ( float ) ( radiusBig * Math . sin ( 2 * Math . PI * i / detail ) ) + y ) ; } ring . addClose ( ) ; ring . addContour ( ) ; for ( int i = 0 ; i < detail ; i + + ) { ring . addPoint ( ( float ) ( radiusSmall * Math . cos ( 2 * Math . PI * i / detail ) ) + x , ( float ) ( radiusSmall * Math . sin ( 2 * Math . PI * i / detail ) ) + y ) ; } ring . addClose ( ) ; return ring ; } 
tstatic public RPolygon createRing ( float radiusBig , float radiusSmall , int detail ) { treturn createRing ( 0 , 0 , radiusBig , radiusSmall , detail ) ; } 
tstatic public RPolygon createRing ( float x , float y , float radiusBig , float radiusSmall ) { treturn createRing ( x , y , radiusBig , radiusSmall , defaultDetail ) ; } 
tstatic public RPolygon createRing ( float radiusBig , float radiusSmall ) { treturn createRing ( 0 , 0 , radiusBig , radiusSmall , defaultDetail ) ; } 
public int countContours ( ) { if ( this . contours = = null ) { treturn 0 ; } treturn this . contours . length ; } 
public void addContour ( ) { tthis . append ( new RContour ( ) ) ; } 
public void addPoint ( RPoint p ) { if ( contours = = null ) { tthis . append ( new RContour ( ) ) ; } tthis . contours [ currentContour ] . append ( p ) ; } 
public void addPoint ( float x , float y ) { if ( contours = = null ) { tthis . append ( new RContour ( ) ) ; } tthis . contours [ currentContour ] . append ( new RPoint ( x , y ) ) ; } 
public void addPoint ( int indContour , RPoint p ) { if ( contours = = null ) { tthis . append ( new RContour ( ) ) ; } tthis . contours [ indContour ] . append ( p ) ; } 
public void addPoint ( int indContour , float x , float y ) { if ( contours = = null ) { tthis . append ( new RContour ( ) ) ; } tthis . contours [ indContour ] . append ( new RPoint ( x , y ) ) ; } 
public void addClose ( ) { if ( contours = = null ) { return ; } contours [ contours . length - 1 ] . addClose ( ) ; } 
public RMesh toMesh ( ) { if ( contours = = null ) { treturn new RMesh ( ) ; } tRMesh mesh = RClip . polygonToMesh ( this ) ; mesh . texture = this . texture ; mesh . id = this . id ; return mesh ; } 
public RShape toShape ( ) throws RuntimeException { tthrow new RuntimeException ( " Transforming a Polygon to a Shape is not yet implemented. " ) ; } 
public void draw ( PGraphics g ) { int numContours = countContours ( ) ; if ( numContours ! = 0 ) { if ( isIn ( g ) ) { 
public void draw ( PApplet g ) { int numContours = countContours ( ) ; if ( numContours ! = 0 ) { if ( isIn ( g ) ) { 
public boolean isIn ( PGraphics g ) { tRContour c = getBounds ( ) ; tfloat x0 = g . screenX ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; tfloat y0 = g . screenY ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; tfloat x1 = g . screenX ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; tfloat y1 = g . screenY ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; tfloat x2 = g . screenX ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; tfloat y2 = g . screenY ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; tfloat x3 = g . screenX ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; tfloat y3 = g . screenY ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; tfloat xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; tfloat ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; tfloat xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; tfloat ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; treturn ! ( ( xmax < 0 | | xmin > g . width ) & & ( ymax < 0 | | ymin > g . height ) ) ; } 
public boolean isIn ( PApplet g ) { tRContour c = getBounds ( ) ; tfloat x0 = g . screenX ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; tfloat y0 = g . screenY ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; tfloat x1 = g . screenX ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; tfloat y1 = g . screenY ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; tfloat x2 = g . screenX ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; tfloat y2 = g . screenY ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; tfloat x3 = g . screenX ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; tfloat y3 = g . screenY ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; tfloat xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; tfloat ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; tfloat xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; tfloat ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; treturn ! ( ( xmax < 0 | | xmin > g . width ) & & ( ymax < 0 | | ymin > g . height ) ) ; } 
public RPolygon intersection ( RPolygon p ) { treturn RClip . intersection ( p , this ) ; } 
public RPolygon union ( RPolygon p ) { treturn RClip . union ( p , this ) ; } 
public RPolygon xor ( RPolygon p ) { treturn RClip . xor ( p , this ) ; } 
public RPolygon diff ( RPolygon p ) { treturn RClip . diff ( this , p ) ; } 
public RPolygon update ( ) { treturn RClip . update ( this ) ; } 
tvoid add ( float x , float y ) { if ( contours = = null ) { tthis . append ( new RContour ( ) ) ; } tthis . contours [ 0 ] . append ( new RPoint ( x , y ) ) ; } 
tvoid add ( RPoint p ) { if ( contours = = null ) { tthis . append ( new RContour ( ) ) ; } tthis . contours [ 0 ] . append ( p ) ; } 
tvoid add ( RContour c ) { tthis . append ( c ) ; } 
tboolean isHole ( ) { if ( this . contours = = null | | this . contours . length > 1 ) { tthrow new IllegalStateException ( " Cannot call on a poly made up of more than one poly. " ) ; } treturn this . contours [ 0 ] . isHole ; } 
tboolean isContributing ( int polyIndex ) { treturn this . contours [ polyIndex ] . isContributing ; } 
tvoid append ( RContour nextcontour ) { RContour [ ] newcontours ; if ( contours = = null ) { tnewcontours = new RContour [ 1 ] ; tnewcontours [ 0 ] = nextcontour ; tcurrentContour = 0 ; } else { tnewcontours = new RContour [ this . contours . length + 1 ] ; tSystem . arraycopy ( this . contours , 0 , newcontours , 0 , this . contours . length ) ; tnewcontours [ this . contours . length ] = nextcontour ; tcurrentContour + + ; } this . contours = newcontours ; } 
public void draw ( String filename , PGraphics g ) { this . toGroup ( filename ) . draw ( g ) ; } 
public void draw ( String filename , PApplet p ) { this . toGroup ( filename ) . draw ( p ) ; } 
public void draw ( String filename ) { this . toGroup ( filename ) . draw ( ) ; } 
public RShape toShape ( String filename ) { return toGroup ( filename ) . toShape ( ) ; } 
public RPolygon toPolygon ( String filename ) { return toGroup ( filename ) . toPolygon ( ) ; } 
public RMesh toMesh ( String filename ) { return toGroup ( filename ) . toMesh ( ) ; } 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else{ RGeomerative.parent.println("Element '"+name+"' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Get the style for the geometrical element grp.addElement(geomElem); } } Transform geometrical element if(elem.hasAttribute("transform")){ String transformString = elem.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); grp.transform(transf); } Get the id for the geometrical element if(elem.hasAttribute("id")){ grp.id = elem.getStringAttribute("id"); } Get the style for the geometrical element return grp; } 
public RPolygon elemToPolyline ( XMLElement elem ) { return getPolyline ( elem . getStringAttribute ( " points " ) . trim ( ) ) ; } 
public RPolygon elemToPolygon ( XMLElement elem ) { RPolygon poly = elemToPolyline ( elem ) ; poly . addClose ( ) ; return poly ; } 
public RShape elemToRect ( XMLElement elem ) { return getRect ( elem . getFloatAttribute ( " x " ) , elem . getFloatAttribute ( " y " ) , elem . getFloatAttribute ( " width " ) , elem . getFloatAttribute ( " height " ) ) ; } 
public RShape elemToEllipse ( XMLElement elem ) { return getEllipse ( elem . getFloatAttribute ( " cx " ) , elem . getFloatAttribute ( " cy " ) , elem . getFloatAttribute ( " rx " ) , elem . getFloatAttribute ( " ry " ) ) ; } 
public RShape elemToCircle ( XMLElement elem ) { float r = elem . getFloatAttribute ( " r " ) ; return getEllipse ( elem . getFloatAttribute ( " cx " ) , elem . getFloatAttribute ( " cy " ) , r , r ) ; } 
public RShape elemToShape ( XMLElement elem ) { return getShape ( elem . getStringAttribute ( " d " ) ) ; } 
static public RShape createRect ( float x , float y , float w , float h ) { tRShape rect = new RShape ( ) ; trect . addMoveTo ( x , y ) ; trect . addLineTo ( x + w , y ) ; trect . addLineTo ( x + w , y + h ) ; trect . addLineTo ( x , y + h ) ; trect . addLineTo ( x , y ) ; treturn rect ; } 
static public RShape createEllipse ( float x , float y , float rx , float ry ) { tRPoint center = new RPoint ( x , y ) ; tRShape circle = new RShape ( ) ; tfloat kx = ( ( ( 8F / ( float ) Math . sqrt ( 2F ) ) - 4F ) / 3F ) * rx ; tfloat ky = ( ( ( 8F / ( float ) Math . sqrt ( 2F ) ) - 4F ) / 3F ) * ry ; tcircle . addMoveTo ( center . x , center . y - ry ) ; tcircle . addBezierTo ( center . x + kx , center . y - ry , center . x + rx , center . y - ky , center . x + rx , center . y ) ; tcircle . addBezierTo ( center . x + rx , center . y + ky , center . x + kx , center . y + ry , center . x , center . y + ry ) ; tcircle . addBezierTo ( center . x - kx , center . y + ry , center . x - rx , center . y + ky , center . x - rx , center . y ) ; tcircle . addBezierTo ( center . x - rx , center . y - ky , center . x - kx , center . y - ry , center . x , center . y - ry ) ; circle . addClose ( ) ; treturn circle ; } 
static public RShape createCircle ( float x , float y , float r ) { return createEllipse ( x , y , r , r ) ; } 
public int countSubshapes ( ) { if ( this . subshapes = = null ) { treturn 0 ; } treturn this . subshapes . length ; } 
public void addShape ( RShape s ) { tfor ( int i = 0 ; i < s . countSubshapes ( ) ; i + + ) { tthis . append ( s . subshapes [ i ] ) ; 
public void addSubshape ( ) { tthis . append ( new RSubshape ( ) ) ; } 
public void addMoveTo ( float endx , float endy ) { if ( subshapes = = null ) { tthis . append ( new RSubshape ( endx , endy ) ) ; 
public void addLineTo ( float endx , float endy ) { if ( subshapes = = null ) { tthis . append ( new RSubshape ( ) ) ; } tthis . subshapes [ currentSubshape ] . addLineTo ( endx , endy ) ; } 
public void addQuadTo ( float cp1x , float cp1y , float endx , float endy ) { if ( subshapes = = null ) { tthis . append ( new RSubshape ( ) ) ; } tthis . subshapes [ currentSubshape ] . addQuadTo ( cp1x , cp1y , endx , endy ) ; } 
public void addBezierTo ( float cp1x , float cp1y , float cp2x , float cp2y , float endx , float endy ) { if ( subshapes = = null ) { tthis . append ( new RSubshape ( ) ) ; } tthis . subshapes [ currentSubshape ] . addBezierTo ( cp1x , cp1y , cp2x , cp2y , endx , endy ) ; } 
public void addClose ( ) { if ( subshapes = = null ) { this . append ( new RSubshape ( ) ) ; } this . subshapes [ currentSubshape ] . addClose ( ) ; } 
public RMesh toMesh ( ) { tRPolygon p = this . toPolygon ( ) ; treturn p . toMesh ( ) ; } 
public RPolygon toPolygon ( ) { tint numSubshapes = countSubshapes ( ) ; tRPolygon result = new RPolygon ( ) ; tfor ( int i = 0 ; i < numSubshapes ; i + + ) { tRPoint [ ] newpoints = this . subshapes [ i ] . getCurvePoints ( ) ; tresult . addContour ( new RContour ( newpoints ) ) ; } result . texture = this . texture ; result . id = this . id ; treturn result ; } 
public void print ( ) { System . out . println ( " subshapes: " ) ; for ( int i = 0 ; i < subshapes . length ; i + + ) { 
public void draw ( PGraphics g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
public void draw ( PApplet g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
tvoid append ( RSubshape nextsubshape ) { RSubshape [ ] newsubshapes ; if ( subshapes = = null ) { tnewsubshapes = new RSubshape [ 1 ] ; tnewsubshapes [ 0 ] = nextsubshape ; tcurrentSubshape = 0 ; } else { tnewsubshapes = new RSubshape [ this . subshapes . length + 1 ] ; tSystem . arraycopy ( this . subshapes , 0 , newsubshapes , 0 , this . subshapes . length ) ; tnewsubshapes [ this . subshapes . length ] = nextsubshape ; tcurrentSubshape + + ; } this . subshapes = newsubshapes ; } 
public int countVertices ( ) { if ( this . vertices = = null ) { treturn 0 ; } treturn this . vertices . length ; } 
public void draw ( PGraphics g ) { tint numVertices = countVertices ( ) ; tg . beginShape ( g . TRIANGLE_STRIP ) ; tfor ( int i = 0 ; i < numVertices ; i + + ) { tg . vertex ( vertices [ i ] . x , vertices [ i ] . y ) ; } tg . endShape ( ) ; } 
public void addVertex ( float x , float y ) { tthis . append ( new RPoint ( x , y ) ) ; } 
public void transform ( RMatrix m ) { tint numVertices = countVertices ( ) ; if ( numVertices ! = 0 ) { tfor ( int i = 0 ; i < numVertices ; i + + ) { 
tvoid add ( float x , float y ) { tthis . append ( new RPoint ( x , y ) ) ; } 
tvoid append ( RPoint nextvertex ) { RPoint [ ] newvertices ; if ( vertices = = null ) { tnewvertices = new RPoint [ 1 ] ; tnewvertices [ 0 ] = nextvertex ; } else { tnewvertices = new RPoint [ this . vertices . length + 1 ] ; tSystem . arraycopy ( this . vertices , 0 , newvertices , 0 , this . vertices . length ) ; tnewvertices [ this . vertices . length ] = nextvertex ; } this . vertices = newvertices ; } 
public int countCommands ( ) { if ( this . commands = = null ) { return 0 ; } return this . commands . length ; } 
public void draw ( PGraphics g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void draw ( PApplet g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); RCommand.setSegmentator(lastSegmentator); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void addCommand ( RCommand p ) { this . append ( p ) ; lastPoint = commands [ commands . length - 1 ] . endPoint ; } 
public void addBezierTo ( RPoint cp1 , RPoint cp2 , RPoint end ) { this . addCommand ( RCommand . createBezier4 ( lastPoint , cp1 , cp2 , end ) ) ; } 
public void addBezierTo ( float cp1x , float cp1y , float cp2x , float cp2y , float endx , float endy ) { RPoint cp1 = new RPoint ( cp1x , cp1y ) ; RPoint cp2 = new RPoint ( cp2x , cp2y ) ; RPoint end = new RPoint ( endx , endy ) ; addBezierTo ( cp1 , cp2 , end ) ; } 
public void addQuadTo ( RPoint cp1 , RPoint end ) { this . addCommand ( RCommand . createBezier3 ( lastPoint , cp1 , end ) ) ; } 
public void addQuadTo ( float cp1x , float cp1y , float endx , float endy ) { RPoint cp1 = new RPoint ( cp1x , cp1y ) ; RPoint end = new RPoint ( endx , endy ) ; addQuadTo ( cp1 , end ) ; } 
public void addLineTo ( RPoint end ) { this . addCommand ( RCommand . createLine ( lastPoint , end ) ) ; } 
public void addLineTo ( float endx , float endy ) { RPoint end = new RPoint ( endx , endy ) ; addLineTo ( end ) ; } 
public void addClose ( ) { if ( commands = = null ) { return ; } if ( ( commands [ commands . length - 1 ] . endPoint . x = = commands [ 0 ] . startPoint . x ) & & ( commands [ commands . length - 1 ] . endPoint . y = = commands [ 0 ] . startPoint . y ) ) { commands [ commands . length - 1 ] . endPoint = new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ; } else { addLineTo ( new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ) ; } lastPoint = commands [ commands . length - 1 ] . endPoint ; } 
public RPolygon toPolygon ( ) { return this . toShape ( ) . toPolygon ( ) ; } 
public RMesh toMesh ( ) { return this . toPolygon ( ) . toMesh ( ) ; } 
public void print ( ) { for ( int i = 0 ; i < commands . length ; i + + ) { String commandType = " " ; 
void append ( RCommand nextcommand ) { RCommand [ ] newcommands ; if ( commands = = null ) { newcommands = new RCommand [ 1 ] ; newcommands [ 0 ] = nextcommand ; } else { newcommands = new RCommand [ this . commands . length + 1 ] ; System . arraycopy ( this . commands , 0 , newcommands , 0 , this . commands . length ) ; newcommands [ this . commands . length ] = nextcommand ; } this . commands = newcommands ; } 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '"+name+"' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Get the style for the geometrical element grp.addElement(geomElem); } } Transform geometrical element if(elem.hasAttribute("transform")){ String transformString = elem.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); grp.transform(transf); } Get the id for the geometrical element if(elem.hasAttribute("id")){ grp.id = elem.getStringAttribute("id"); } Get the style for the geometrical element return grp; } 
public RShape elemToLine ( XMLElement elem ) { return getRect ( elem . getFloatAttribute ( " x1 " ) , elem . getFloatAttribute ( " y1 " ) , elem . getFloatAttribute ( " x2 " ) , elem . getFloatAttribute ( " y2 " ) ) ; } 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '"+name+"' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ String transformString = element.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); geomElem.transform(transf); } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Get the style for the geometrical element grp.addElement(geomElem); } } Get the style for the geometrical element return grp; } 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '"+name+"' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ String transformString = element.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); geomElem.transform(transf); } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Get the style for the geometrical element grp.addElement(geomElem); } } return grp; } 
protected void read ( byte [ ] fontInBytes ) { tbs = fontInBytes ; try { RandomAccessFileEmulator raf = new RandomAccessFileEmulator ( bs , " r " ) ; 
public static Font create ( ) { return new Font ( ) ; } 
public static Font create ( byte [ ] fontInBytes ) { Font f = new Font ( ) ; f . read ( fontInBytes ) ; return f ; } 
public void scale ( float factor ) { if ( points ! = null ) { tfor ( int i = 0 ; i < points . length ; i + + ) { tpoints [ i ] . x * = factor ; tpoints [ i ] . y * = - factor ; } } tleftSideBearing = ( short ) ( ( float ) leftSideBearing * factor ) ; tadvanceWidth = ( int ) ( ( float ) advanceWidth * factor ) ; } 
public void seek ( long ) throws IOException { treset ( ) ; tskip ( ) ; } 
public abstract int getFormat ( ) ; protected static ClassDef read ( RandomAccessFileEmulator raf ) throws IOException { ClassDef c = null ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { c = new ClassDefFormat1 ( raf ) ; } else if ( format = = 2 ) { c = new ClassDefFormat2 ( raf ) ; } return c ; } } 
protected static ClassDef read ( RandomAccessFileEmulator raf ) throws IOException { ClassDef c = null ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { c = new ClassDefFormat1 ( raf ) ; } else if ( format = = 2 ) { c = new ClassDefFormat2 ( raf ) ; } return c ; } 
protected static CmapFormat create ( int format , RandomAccessFileEmulator raf ) throws IOException { switch ( format ) { case 0 : return new CmapFormat0 ( raf ) ; case 2 : return new CmapFormat2 ( raf ) ; case 4 : return new CmapFormat4 ( raf ) ; case 6 : return new CmapFormat6 ( raf ) ; } return null ; } 
public abstract int mapCharCode ( int charCode ) ; public abstract int getFirst ( ) ; public abstract int getLast ( ) ; public String toString ( ) { return new StringBuffer ( ) . append ( " format: " ) . append ( format ) . append ( " , length: " ) . append ( length ) . append ( " , version: " ) . append ( version ) . toString ( ) ; } } 
public abstract int getFirst ( ) ; public abstract int getLast ( ) ; public String toString ( ) { return new StringBuffer ( ) . append ( " format: " ) . append ( format ) . append ( " , length: " ) . append ( length ) . append ( " , version: " ) . append ( version ) . toString ( ) ; } } 
public abstract int getLast ( ) ; public String toString ( ) { return new StringBuffer ( ) . append ( " format: " ) . append ( format ) . append ( " , length: " ) . append ( length ) . append ( " , version: " ) . append ( version ) . toString ( ) ; } } 
public String toString ( ) { return new StringBuffer ( ) . append ( " format: " ) 
public int mapCharCode ( int charCode ) { if ( 0 < = charCode & & charCode < 256 ) { return glyphIdArray [ charCode ] ; 
public int mapCharCode ( int charCode ) { return 0 ; } 
public int mapCharCode ( int charCode ) { try { if ( ( charCode < 0 ) | | ( charCode > = 0xFFFE ) ) return 0 ; for ( int i = 0 ; i < segCount ; i + + ) { if ( endCode [ i ] > = charCode ) { if ( startCode [ i ] < = charCode ) { if ( idRangeOffset [ i ] > 0 ) { return glyphIdArray [ idRangeOffset [ i ] / 2 + ( charCode - startCode [ i ] ) - ( segCount - i ) ] ; } else { return ( idDelta [ i ] + charCode ) % 65536 ; } } else { break ; } } } } catch ( ArrayIndexOutOfBoundsException e ) { System . err . println ( " error: Array out of bounds - " + e . getMessage ( ) ) ; } return 0 ; } 
public String toString ( ) { return new StringBuffer ( ) . append ( super . toString ( ) ) 
public String toString ( ) { String platform ; String encoding = " " ; switch ( platformId ) { case 1 : platform = " (Macintosh) " ; break ; case 3 : platform = " (Windows) " ; break ; default : platform = " " ; } if ( platformId = = 3 ) { Windows specific encodings switch (encodingId) { case 0: encoding = " (Symbol)"; break; case 1: encoding = " (Unicode)"; break; case 2: encoding = " (ShiftJIS)"; break; case 3: encoding = " (Big5)"; break; case 4: encoding = " (PRC)"; break; case 5: encoding = " (Wansung)"; break; case 6: encoding = " (Johab)"; break; default: encoding = ""; } } return new StringBuffer() .append( "platform id: " ) 
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) . append ( " cmap " ) ; ").append(formats[i].toString()).append(""); } return sb.toString(); } 
public abstract int getFormat ( ) ; public abstract int findGlyph ( int glyphId ) ; protected static Coverage read ( RandomAccessFileEmulator raf ) throws IOException { Coverage c = null ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { c = new CoverageFormat1 ( raf ) ; } else if ( format = = 2 ) { c = new CoverageFormat2 ( raf ) ; } return c ; } } 
public abstract int findGlyph ( int glyphId ) ; protected static Coverage read ( RandomAccessFileEmulator raf ) throws IOException { Coverage c = null ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { c = new CoverageFormat1 ( raf ) ; } else if ( format = = 2 ) { c = new CoverageFormat2 ( raf ) ; } return c ; } } 
protected static Coverage read ( RandomAccessFileEmulator raf ) throws IOException { Coverage c = null ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { c = new CoverageFormat1 ( raf ) ; } else if ( format = = 2 ) { c = new CoverageFormat2 ( raf ) ; } return c ; } 
public int findGlyph ( int glyphId ) { for ( int i = 0 ; i < glyphCount ; i + + ) { if ( glyphIds [ i ] = = glyphId ) { return i ; } } return - 1 ; } 
public int findGlyph ( int glyphId ) { for ( int i = 0 ; i < rangeCount ; i + + ) { int = rangeRecords [ i ] . getCoverageIndex ( glyphId ) ; if ( > - 1 ) { return ; } } return - 1 ; } 
public String toString ( ) { return new StringBuffer ( ) . append ( ( char ) ( ( tag > > 24 ) & 0xff ) ) 
public int scaleX ( int x , int y ) { return Math . round ( ( float ) ( x * xscale + y * scale10 ) ) ; } 
public int scaleY ( int x , int y ) { return Math . round ( ( float ) ( x * scale01 + y * yscale ) ) ; } 
public boolean isComposite ( ) { return true ; } 
public boolean isComposite ( ) { return false ; } 
private void readCoords ( int count , ByteArrayInputStream bais ) { short x = 0 ; short y = 0 ; for ( int i = 0 ; i < count ; i + + ) { if ( ( flags [ i ] & xDual ) ! = 0 ) { if ( ( flags [ i ] & xShortVector ) ! = 0 ) { x + = ( short ) bais . read ( ) ; } } else { if ( ( flags [ i ] & xShortVector ) ! = 0 ) { x + = ( short ) - ( ( short ) bais . read ( ) ) ; } else { x + = ( short ) ( bais . read ( ) < < 8 | bais . read ( ) ) ; } } xCoordinates [ i ] = x ; } for ( int i = 0 ; i < count ; i + + ) { if ( ( flags [ i ] & yDual ) ! = 0 ) { 
private void readFlags ( int flagCount , ByteArrayInputStream bais ) { try { for ( int index = 0 ; index < flagCount ; index + + ) { 
public void init ( int numGlyphs , LocaTable loca ) { if ( buf = = null ) { return ; } descript = new GlyfDescript [ numGlyphs ] ; ByteArrayInputStream bais = new ByteArrayInputStream ( buf ) ; for ( int i = 0 ; i < numGlyphs ; i + + ) { int len = loca . getOffset ( ( short ) ( i + 1 ) ) - loca . getOffset ( i ) ; if ( len > 0 ) { bais . reset ( ) ; bais . skip ( loca . getOffset ( i ) ) ; short numberOfContours = ( short ) ( bais . read ( ) < < 8 | bais . read ( ) ) ; if ( numberOfContours > = 0 ) { descript [ i ] = new GlyfSimpleDescript ( this , numberOfContours , bais ) ; } } else { descript [ i ] = null ; } } for ( int i = 0 ; i < numGlyphs ; i + + ) { int len = loca . getOffset ( ( short ) ( i + 1 ) ) - loca . getOffset ( i ) ; if ( len > 0 ) { bais . reset ( ) ; bais . skip ( loca . getOffset ( i ) ) ; short numberOfContours = ( short ) ( bais . read ( ) < < 8 | bais . read ( ) ) ; if ( numberOfContours < 0 ) { descript [ i ] = new GlyfCompositeDescript ( this , bais ) ; } } } buf = null ; } 
public int getEndPtOfContours ( int i ) ; public byte getFlags ( int i ) ; public short getXCoordinate ( int i ) ; public short getYCoordinate ( int i ) ; public short getXMaximum ( ) ; public short getXMinimum ( ) ; public short getYMaximum ( ) ; public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public byte getFlags ( int i ) ; public short getXCoordinate ( int i ) ; public short getYCoordinate ( int i ) ; public short getXMaximum ( ) ; public short getXMinimum ( ) ; public short getYMaximum ( ) ; public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public short getXCoordinate ( int i ) ; public short getYCoordinate ( int i ) ; public short getXMaximum ( ) ; public short getXMinimum ( ) ; public short getYMaximum ( ) ; public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public short getYCoordinate ( int i ) ; public short getXMaximum ( ) ; public short getXMinimum ( ) ; public short getYMaximum ( ) ; public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public short getXMaximum ( ) ; public short getXMinimum ( ) ; public short getYMaximum ( ) ; public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public short getXMinimum ( ) ; public short getYMaximum ( ) ; public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public short getYMaximum ( ) ; public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public short getYMinimum ( ) ; public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public boolean isComposite ( ) ; public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public int getPointCount ( ) ; public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public int getContourCount ( ) ; public int getComponentIndex(int c); public int getComponentCount();} 
public LookupSubtable read ( int type , RandomAccessFileEmulator raf , int offset ) throws IOException { LookupSubtable s = null ; switch ( type ) { case 1 : s = SingleSubst . read ( raf , offset ) ; break ; case 2 : s = MultipleSubst.read(raf, offset); break; case 3: s = AlternateSubst.read(raf, offset); break; case 4: s = LigatureSubst.read(raf, offset); break; case 5: s = ContextSubst.read(raf, offset); break; case 6: s = ChainingSubst.read(raf, offset); break; } return s; } 
public String toString ( ) { return new StringBuffer ( ) . append ( " head tversionNumber: " ) . append ( versionNumber ) 
public void init ( int numberOfHMetrics , int lsbCount ) { if ( buf = = null ) { return ; } hMetrics = new int [ numberOfHMetrics ] ; ByteArrayInputStream bais = new ByteArrayInputStream ( buf ) ; for ( int i = 0 ; i < numberOfHMetrics ; i + + ) { hMetrics [ i ] = ( bais . read ( ) < < 24 | bais . read ( ) < < 16 | bais . read ( ) < < 8 | bais . read ( ) ) ; } if ( lsbCount > 0 ) { leftSideBearing = new short [ lsbCount ] ; for ( int i = 0 ; i < lsbCount ; i + + ) { leftSideBearing [ i ] = ( short ) ( bais . read ( ) < < 8 | bais . read ( ) ) ; } } buf = null ; } 
public abstract int getKerningPairCount ( ) ; public abstract KerningPair getKerningPair ( int i ) ; public static KernSubtable read ( RandomAccessFileEmulator raf ) throws IOException { KernSubtable table = null ; raf . readUnsignedShort ( ) ; int coverage = raf . readUnsignedShort ( ) ; int format = coverage > > 8 ; switch ( format ) { case 0 : table = new KernSubtableFormat0 ( raf ) ; break ; case 2 : table = new KernSubtableFormat2 ( raf ) ; break ; default : break ; } return table ; } } 
public abstract KerningPair getKerningPair ( int i ) ; public static KernSubtable read ( RandomAccessFileEmulator raf ) throws IOException { KernSubtable table = null ; raf . readUnsignedShort ( ) ; int coverage = raf . readUnsignedShort ( ) ; int format = coverage > > 8 ; switch ( format ) { case 0 : table = new KernSubtableFormat0 ( raf ) ; break ; case 2 : table = new KernSubtableFormat2 ( raf ) ; break ; default : break ; } return table ; } } 
public static KernSubtable read ( RandomAccessFileEmulator raf ) throws IOException { KernSubtable table = null ; raf . readUnsignedShort ( ) ; int coverage = raf . readUnsignedShort ( ) ; int format = coverage > > 8 ; switch ( format ) { case 0 : table = new KernSubtableFormat0 ( raf ) ; break ; case 2 : table = new KernSubtableFormat2 ( raf ) ; break ; default : break ; } return table ; } 
protected boolean isFeatureIndexed ( int ) { for ( int i = 0 ; i < featureCount ; i + + ) { if ( featureIndex [ i ] = = ) { return true ; } } return false ; } 
public static LigatureSubst read ( RandomAccessFileEmulator raf , int offset ) throws IOException { LigatureSubst ls = null ; raf . seek ( offset ) ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { ls = new LigatureSubstFormat1 ( raf , offset ) ; } return ls ; } 
public void init ( int numGlyphs , boolean shortEntries ) { if ( buf = = null ) { return ; } offsets = new int [ numGlyphs + 1 ] ; ByteArrayInputStream bais = new ByteArrayInputStream ( buf ) ; if ( shortEntries ) { factor = 2 ; for ( int i = 0 ; i < = numGlyphs ; i + + ) { offsets [ i ] = ( bais . read ( ) < < 8 | bais . read ( ) ) ; } } else { factor = 1 ; for ( int i = 0 ; i < = numGlyphs ; i + + ) { offsets [ i ] = ( bais . read ( ) < < 24 | bais . read ( ) < < 16 | bais . read ( ) < < 8 | bais . read ( ) ) ; } } buf = null ; } 
public LookupSubtable read ( int type , RandomAccessFileEmulator raf , int offset ) throws IOException ; } 
protected void loadString ( RandomAccessFileEmulator raf , int stringStorageOffset ) throws IOException { StringBuffer sb = new StringBuffer ( ) ; raf . seek ( stringStorageOffset + stringOffset ) ; if ( platformId = = Table . platformAppleUnicode ) { Unicode (big-endian) for (int i = 0; i < stringLength/2; i++) { sb.append(raf.readChar()); } } else if (platformId == Table.platformMacintosh) { Macintosh encoding, ASCII for (int i = 0; i < stringLength; i++) { sb.append((char) raf.readByte()); } } else if (platformId == Table.platformISO) { ISO encoding, ASCII for (int i = 0; i < stringLength; i++) { sb.append((char) raf.readByte()); } } else if (platformId == Table.platformMicrosoft) { Microsoft encoding, Unicode char c; for (int i = 0; i < stringLength/2; i++) { c = raf.readChar(); sb.append(c); } } record = sb.toString(); } 
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( String . valueOf ( bFamilyType ) ) . append ( " " ) . append ( String . valueOf ( bSerifStyle ) ) . append ( " " ) . append ( String . valueOf ( bWeight ) ) . append ( " " ) . append ( String . valueOf ( bProportion ) ) . append ( " " ) . append ( String . valueOf ( bContrast ) ) . append ( " " ) . append ( String . valueOf ( bStrokeVariation ) ) . append ( " " ) . append ( String . valueOf ( bArmStyle ) ) . append ( " " ) . append ( String . valueOf ( bLetterform ) ) . append ( " " ) . append ( String . valueOf ( bMidline ) ) . append ( " " ) . append ( String . valueOf ( bXHeight ) ) ; return sb . toString ( ) ; } 
private int highestGlyphNameIndex ( ) { int high = 0 ; for ( int i = 0 ; i < numGlyphs ; i + + ) { if ( high < glyphNameIndex [ i ] ) { high = glyphNameIndex [ i ] ; } } return high ; } 
protected void readInstructions ( RandomAccessFileEmulator raf , int count ) throws IOException { instructions = new short [ count ] ; for ( int i = 0 ; i < count ; i + + ) { instructions [ i ] = ( short ) raf . readUnsignedByte ( ) ; 
protected void readInstructions ( ByteArrayInputStream bais , int count ) { instructions = new short [ count ] ; for ( int i = 0 ; i < count ; i + + ) { instructions [ i ] = ( short ) bais . read ( ) ; 
public boolean isInRange ( int glyphId ) { return ( start < = glyphId & & glyphId < = end ) ; } 
public abstract int getFormat ( ) ; public abstract int substitute ( int glyphId ) ; public static SingleSubst read ( RandomAccessFileEmulator raf , int offset ) throws IOException { SingleSubst s = null ; raf . seek ( offset ) ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { s = new SingleSubstFormat1 ( raf , offset ) ; } else if ( format = = 2 ) { s = new SingleSubstFormat2 ( raf , offset ) ; } return s ; } } 
public abstract int substitute ( int glyphId ) ; public static SingleSubst read ( RandomAccessFileEmulator raf , int offset ) throws IOException { SingleSubst s = null ; raf . seek ( offset ) ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { s = new SingleSubstFormat1 ( raf , offset ) ; } else if ( format = = 2 ) { s = new SingleSubstFormat2 ( raf , offset ) ; } return s ; } } 
public static SingleSubst read ( RandomAccessFileEmulator raf , int offset ) throws IOException { SingleSubst s = null ; raf . seek ( offset ) ; int format = raf . readUnsignedShort ( ) ; if ( format = = 1 ) { s = new SingleSubstFormat1 ( raf , offset ) ; } else if ( format = = 2 ) { s = new SingleSubstFormat2 ( raf , offset ) ; } return s ; } 
public int substitute ( int glyphId ) { int i = coverage . findGlyph ( glyphId ) ; if ( i > - 1 ) { return glyphId + deltaGlyphID ; } return glyphId ; } 
public int substitute ( int glyphId ) { int i = coverage . findGlyph ( glyphId ) ; if ( i > - 1 ) { return substitutes [ i ] ; } return glyphId ; } 
static RPolygon intersection ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_INT , p1 , p2 , polyClass ) ; } 
static RPolygon union ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_UNION , p1 , p2 , polyClass ) ; } 
static RPolygon xor ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_XOR , p1 , p2 , polyClass ) ; } 
static RPolygon diff ( RPolygon p1 , RPolygon p2 , Class polyClass ) { return clip ( OperationType . GPC_DIFF , p1 , p2 , polyClass ) ; } 
static RPolygon intersection ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_INT , p1 , p2 , RPolygon . class ) ; } 
static RPolygon union ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_UNION , p1 , p2 , RPolygon . class ) ; } 
static RPolygon xor ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_XOR , p1 , p2 , RPolygon . class ) ; } 
static RPolygon diff ( RPolygon p1 , RPolygon p2 ) { return clip ( OperationType . GPC_DIFF , p1 , p2 , RPolygon . class ) ; } 
static RPolygon update ( RPolygon p1 ) { return clip ( OperationType . GPC_DIFF , p1 , new RPolygon ( ) , RPolygon . class ) ; } 
private static RPolygon createNewPoly ( Class polyClass ) { try { 
public static RMesh polygonToMesh ( RPolygon s ) { RPolygon c = new RPolygon ( ) ; return clip ( OperationType . GPC_UNION , s , c ) ; } 
private static boolean EQ ( float a , float b ) { return ( Math . abs ( a - b ) < = GPC_EPSILON ) ; } 
private static int PREV_INDEX ( int i , int ) { return ( ( i - 1 + ) % ) ; } 
private static int NEXT_INDEX ( int i , int ) { return ( ( i + 1 ) % ) ; } 
private static boolean OPTIMAL ( RPolygon p , int i ) { return ( p . getY ( PREV_INDEX ( i , p . getNumPoints ( ) ) ) ! = p . getY ( i ) ) | | ( p . getY ( NEXT_INDEX ( i , p . getNumPoints ( ) ) ) ! = p . getY ( i ) ) ; 
private static void VERTEX ( EdgeNode e , int p , int s , float x , float y ) { e . outp [ p ] . v [ s ] = add_vertex ( e . outp [ p ] . v [ s ] , x , y ) ; e . outp [ p ] . active + + ; } 
private static float P_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { d = e ; do { td = d . prev ; } while ( d . outp [ p ] = = null ) ; return d . bot . x + d . dx * ( j - d . bot . y ) ; } 
private static float N_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { d = e ; do { td = d . next ; } while ( d . outp [ p ] = = null ) ; return d . bot . x + d . dx * ( j - d . bot . y ) ; } 
private static void minimax_test ( RPolygon subj , RPolygon clip , OperationType op ) { RRectangle [ ] s_bbox = create_contour_bboxes ( subj ) ; RRectangle [ ] c_bbox = create_contour_bboxes ( clip ) ; int subj_num_poly = subj . getNumInnerPoly ( ) ; int clip_num_poly = clip . getNumInnerPoly ( ) ; boolean [ ] [ ] o_table = new boolean [ subj_num_poly ] [ clip_num_poly ] ; for ( int c = 0 ; c < clip_num_poly ; c + + ) { boolean overlap = false ; for ( int s = 0 ; ! overlap & & ( s < subj_num_poly ) ; s + + ) { overlap = o_table [ s ] [ c ] ; } if ( ! overlap ) { clip . setContributing ( c , false ) ; Flag non contributing status } } if (op == OperationType.GPC_INT) { 
private static LmtNode bound_list ( LmtTable lmt_table , float y ) { if ( lmt_table . top_node = = null ) { 
private static void insert_bound ( LmtNode lmt_node , EdgeNode e ) { if ( lmt_node . first_bound = = null ) { 
private static void add_edge_to_aet ( AetTree aet , EdgeNode edge ) { if ( aet . top_node = = null ) { 
private static void add_to_sbtree ( ScanBeamTreeEntries sbte , float y ) { if ( sbte . sb_tree = = null ) { sbte . sb_tree = new ScanBeamTree ( y ) ; sbte . sbt_entries + + ; return ; } ScanBeamTree tree_node = sbte . sb_tree ; boolean done = false ; while ( ! done ) { 
private static StNode add_st_edge ( StNode st , ItNodeTable it , EdgeNode edge , float dy ) { if ( st = = null ) { st . prev = add_st_edge ( st . prev , it , edge , dy ) ; } } return st ; } 
private static ItNode add_intersection ( ItNode it_node , EdgeNode edge0 , EdgeNode edge1 , float x , float y ) { if ( it_node = = null ) { it_node . next = add_intersection ( it_node . next , edge0 , edge1 , x , y ) ; } } return it_node ; } 
private static int count_tristrips ( PolygonNode tn ) { int total ; for ( total = 0 ; tn ! = null ; tn = tn . next ) { if ( tn . active > 2 ) { total + + ; } } return total ; } 
private static VertexNode add_vertex ( VertexNode ve_node , float x , float y ) { if ( ve_node = = null ) { ve_node . next = add_vertex ( ve_node . next , x , y ) ; } return ve_node ; } 
private static PolygonNode new_tristrip ( PolygonNode po_node , EdgeNode edge , float x , float y ) { if ( po_node = = null ) { po_node . next = new_tristrip ( po_node . next , edge , x , y ) ; } return po_node ; } 
public void add_right ( float x , float y ) { VertexNode nv = new VertexNode ( x , y ) ; proxy . v [ RIGHT ] = nv ; } 
public void add_left ( float x , float y ) { VertexNode nv = new VertexNode ( x , y ) ; proxy . v [ LEFT ] = nv ; } 
public PolygonNode add_local_min ( float x , float y ) { PolygonNode existing_min = top_node ; top_node = new PolygonNode ( existing_min , x , y ) ; return top_node ; } 
public void merge_left ( PolygonNode p , PolygonNode q ) { q . proxy . hole = true ; if ( p . proxy ! = q . proxy ) { 
public void merge_right ( PolygonNode p , PolygonNode q ) { q . proxy . hole = false ; if ( p . proxy ! = q . proxy ) { 
public int count_contours ( ) { int nc = 0 ; for ( PolygonNode polygon = top_node ; ( polygon ! = null ) ; polygon = polygon . next ) { if ( polygon . active ! = 0 ) { VertexNode nextv = null ; for (VertexNode v= polygon.proxy.v[LEFT]; (v != null); v = nextv) { nextv= v.next; v = null ; } polygon.active= 0; } } } return nc; } 
public void print ( ) { System . out . println ( " ---- out_poly ---- " ) ; int c = 0 ; PolygonNode npoly_node = null ; for ( PolygonNode poly_node = top_node ; ( poly_node ! = null ) ; poly_node = npoly_node ) { 
public void print ( ) { System . out . println ( " " ) ; System . out . println ( " aet " ) ; for ( EdgeNode edge = top_node ; ( edge ! = null ) ; edge = edge . next ) { 
public void addNode ( float x , float y ) { EdgeNode node = new EdgeNode ( ) ; node . vertex . x = x ; node . vertex . y = y ; m_List . add ( node ) ; } 
public boolean FWD_MIN ( int i ) { EdgeNode prev = ( EdgeNode ) m_List . get ( PREV_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode next = ( EdgeNode ) m_List . get ( NEXT_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( ( prev . vertex . getY ( ) > = ith . vertex . getY ( ) ) & & ( next . vertex . getY ( ) > ith . vertex . getY ( ) ) ) ; 
public boolean NOT_FMAX ( int i ) { EdgeNode next = ( EdgeNode ) m_List . get ( NEXT_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( next . vertex . getY ( ) > ith . vertex . getY ( ) ) ; } 
public boolean REV_MIN ( int i ) { EdgeNode prev = ( EdgeNode ) m_List . get ( PREV_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode next = ( EdgeNode ) m_List . get ( NEXT_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( ( prev . vertex . getY ( ) > ith . vertex . getY ( ) ) & & ( next . vertex . getY ( ) > = ith . vertex . getY ( ) ) ) ; 
public boolean NOT_RMAX ( int i ) { EdgeNode prev = ( EdgeNode ) m_List . get ( PREV_INDEX ( i , m_List . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) m_List . get ( i ) ; return ( prev . vertex . getY ( ) > ith . vertex . getY ( ) ) ; } 
public void print ( ) { int = 0 ; LmtNode lmt = top_node ; while ( lmt ! = null ) { 
public float [ ] build_sbt ( ) { float [ ] sbt = new float [ sbt_entries ] ; int entries = 0 ; entries = inner_build_sbt ( entries , sbt , sb_tree ) ; if ( entries ! = sbt_entries ) { throw new IllegalStateException ( " Something went wrong buildign sbt from tree. " ) ; } return sbt ; } 
private int inner_build_sbt ( int entries , float [ ] sbt , ScanBeamTree sbt_node ) { if ( sbt_node . less ! = null ) { entries = inner_build_sbt ( entries , sbt , sbt_node . less ) ; } sbt [ entries ] = sbt_node . y ; entries + + ; if ( sbt_node . more ! = null ) { entries = inner_build_sbt ( entries , sbt , sbt_node . more ) ; } return entries ; } 
public void build_intersection_table ( AetTree aet , float dy ) { StNode st = null ; for ( EdgeNode edge = aet . top_node ; ( edge ! = null ) ; edge = edge . next ) { 
private static void print_sbt ( float [ ] sbt ) { System . out . println ( " " ) ; System . out . println ( " sbt.length= " + sbt . length ) ; for ( int i = 0 ; i < sbt . length ; i + + ) { 
private void lineUniformLength ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve float dx1 = endPoint.x - startPoint.x; float dy1 = endPoint.y - startPoint.y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1); float steps = (int)(len * 2); if(steps < 4) steps = 4; This holds the amount of steps used to calculate segment lengths float dt = 1F/steps; This holds how much length has to bee advanced until adding a point float untilPoint = RCommand.segmentAccOffset; float fx, fy, fdx, fdy; fx = startPoint.x; fdx = (endPoint.x - startPoint.x) * dt; fy = startPoint.y; fdy = (endPoint.y - startPoint.y) * dt; for (int loop=0; loop <= steps; loop++) { untilPoint -= (float)Math.sqrt(fdx*fdx + fdy*fdy); Eventually try other distance measures fx = fx + fdx; fy = fy + fdy; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
public int countPoints ( ) { if ( this . points = = null ) { return 0 ; } return this . points . length ; } 
public void draw ( PGraphics g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; if ( beforeFill ) g . fill ( g . fillColor ) ; 
public void draw ( PApplet g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; if ( beforeFill ) g . fill ( g . g . fillColor ) ; 
public void addPoint ( float x , float y ) { this . append ( new RPoint ( x , y ) ) ; } 
public void addClose ( ) { if ( points = = null ) { return ; } if ( ( points [ 0 ] . x = = points [ points . length - 1 ] . x ) & & ( points [ 0 ] . y = = points [ points . length - 1 ] . y ) ) { return ; } addPoint ( new RPoint ( points [ 0 ] . x , points [ 0 ] . y ) ) ; } 
public RPolygon toPolygon ( ) { return new RPolygon ( this ) ; } 
public RShape toShape ( ) throws RuntimeException { throw new RuntimeException ( " Transforming a Contour to a Shape is not yet implemented. " ) ; } 
void append ( RPoint nextpoint ) { RPoint [ ] newpoints ; if ( points = = null ) { newpoints = new RPoint [ 1 ] ; newpoints [ 0 ] = nextpoint ; } else { newpoints = new RPoint [ this . points . length + 1 ] ; System . arraycopy ( this . points , 0 , newpoints , 0 , this . points . length ) ; newpoints [ this . points . length ] = nextpoint ; } this . points = newpoints ; } 
public void setAlign ( int align ) throws RuntimeException { if ( align ! = LEFT & & align ! = CENTER & & align ! = RIGHT ) { throw new RuntimeException ( " Alignement unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT " ) ; } this . align = align ; } 
public RShape toShape ( char character ) { RGroup grp = toGroup ( Character . toString ( character ) ) ; if ( grp . countElements ( ) > 0 ) return ( RShape ) ( grp . elements [ 0 ] ) ; return new RShape ( ) ; } 
public RPolygon toPolygon ( char character ) { return toShape ( character ) . toPolygon ( ) ; } 
public RGroup toGroup ( String text ) throws RuntimeException { RGroup result = new RGroup ( ) ; if(cmapFmt != null) {}System.out.println("Loading Undefined cmap format..."); } } if (cmapFmt == null) { throw new RuntimeException("Cannot find a suitable cmap table"); } If this font includes arabic script, we want to specify substitutions for initial, medial, terminal & isolated cases. int x = 0; for (short i = 0; i < text.length(); i++) { int glyphIndex = cmapFmt.mapCharCode(text.charAt(i)); Glyph glyph = f.getGlyph(glyphIndex); int default_advance_x = f.getHmtxTable().getAdvanceWidth(glyphIndex); if (glyph != null) { glyph.scale(scaleFactor); Add the Glyph to the Shape with an horizontal offset of x result.addElement(getGlyphAsShape(f,glyph, glyphIndex,x)); x += glyph.getAdvanceWidth(); }else{ x += (int)((float)default_advance_x*scaleFactor); } } if(align!=LEFT && align!=CENTER && align!=RIGHT){ throw new RuntimeException("Alignement unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT"); } RContour r; switch(this.align){ case RFont.CENTER: r = result.getBounds(); if(r.points!=null){ RMatrix mattrans = new RMatrix(); mattrans.translate((r.points[0].x-r.points[2].x)/2,0); result.transform(mattrans); } break; case RFont.RIGHT: r = result.getBounds(); if(r.points!=null){ RMatrix mattrans = new RMatrix(); mattrans.translate((r.points[0].x-r.points[2].x),0); result.transform(mattrans); } break; case RFont.LEFT: break; } return result; } 
public void draw ( char character , PGraphics g ) throws RuntimeException { this . toShape ( character ) . draw ( g ) ; } 
public void draw ( String text , PGraphics g ) throws RuntimeException { this . toGroup ( text ) . draw ( g ) ; } 
public void draw ( char character , PApplet g ) throws RuntimeException { this . toShape ( character ) . draw ( g ) ; } 
public void draw ( String text , PApplet g ) throws RuntimeException { this . toGroup ( text ) . draw ( g ) ; } 
public void draw ( String text ) throws RuntimeException { this . toGroup ( text ) . draw ( ) ; } 
public void draw ( char character ) throws RuntimeException { this . toShape ( character ) . draw ( ) ; } 
private static float midValue ( float a , float b ) { return a + ( b - a ) / 2 ; } 
public void translate ( RPoint ) { RMatrix transf = new RMatrix ( ) ; transf . translate ( ) ; transform ( transf ) ; } 
RGroup adaptTo ( RSubshape sshp , float wght , float lngthOffset ) throws RuntimeException { RGroup result = new RGroup ( this ) ; RContour c = result . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; int numElements = result . countElements ( ) ; switch ( adaptorType ) { case BYPOINT : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RPoint [ ] ps = elem . getPoints ( ) ; if ( ps ! = null ) { for ( int k = 0 ; k < ps . length ; k + + ) { float px = ps [ k ] . x ; float py = ps [ k ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; float amp = ( ymax - py ) ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) - ( float ) Math . PI / 2F ; ps [ k ] . x = p . x + wght * amp * ( float ) Math . cos ( angle ) ; ps [ k ] . y = p . y + wght * amp * ( float ) Math . sin ( angle ) ; } } } break ; case BYELEMENTPOSITION : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; case BYELEMENTINDEX : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( float ) i / ( float ) numElements + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; default : throw new RuntimeException ( " Unknown adaptor type : " + adaptorType + " . The method setAdaptor() only accepts RGroup.BYPOINT or RGroup.BYELEMENT as parameter values. " ) ; } return result ; } 
private void set ( float m00 , float m01 , float m02 , float m10 , float m11 , float m12 ) { this . m00 = m00 ; this . m01 = m01 ; this . m02 = m02 ; this . m10 = m10 ; this . m11 = m11 ; this . m12 = m12 ; } 
public void apply ( float n00 , float n01 , float n02 , float n10 , float n11 , float n12 ) { float r00 = m00 * n00 + m01 * n10 ; float r01 = m00 * n01 + m01 * n11 ; float r02 = m00 * n02 + m01 * n12 + m02 ; float r10 = m10 * n00 + m11 * n10 ; float r11 = m10 * n01 + m11 * n11 ; float r12 = m10 * n02 + m11 * n12 + m12 ; m00 = r00 ; m01 = r01 ; m02 = r02 ; m10 = r10 ; m11 = r11 ; m12 = r12 ; } 
public int countStrips ( ) { if ( this . strips = = null ) { return 0 ; } return this . strips . length ; } 
public void addStrip ( ) { this . append ( new RStrip ( ) ) ; } 
public void addPoint ( RPoint p ) { if ( strips = = null ) { this . append ( new RStrip ( ) ) ; } this . strips [ currentStrip ] . append ( p ) ; } 
public void addPoint ( float x , float y ) { if ( strips = = null ) { this . append ( new RStrip ( ) ) ; } this . strips [ currentStrip ] . append ( new RPoint ( x , y ) ) ; } 
public void addPoint ( int indStrip , RPoint p ) { if ( strips = = null ) { this . append ( new RStrip ( ) ) ; } this . strips [ indStrip ] . append ( p ) ; } 
public void addPoint ( int indStrip , float x , float y ) { if ( strips = = null ) { this . append ( new RStrip ( ) ) ; } this . strips [ indStrip ] . append ( new RPoint ( x , y ) ) ; } 
public void draw ( PGraphics g ) { for ( int i = 0 ; i < this . countStrips ( ) ; i + + ) { g . beginShape ( g . TRIANGLE_STRIP ) ; 
public void draw ( PApplet g ) { for ( int i = 0 ; i < this . countStrips ( ) ; i + + ) { g . beginShape ( g . TRIANGLE_STRIP ) ; 
public boolean isIn ( PGraphics g ) { RContour c = getBounds ( ) ; float x0 = g . screenX ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; float y0 = g . screenY ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; float x1 = g . screenX ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; float y1 = g . screenY ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; float x2 = g . screenX ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; float y2 = g . screenY ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; float x3 = g . screenX ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; float y3 = g . screenY ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; return ( ( ( ( x0 > 0 & & x0 < g . width ) & & ( y0 > 0 & & y0 < g . height ) ) | | ( ( x1 > 0 & & x1 < g . width ) & & ( y1 > 0 & & y1 < g . height ) ) | | 
public void transform ( RMatrix m ) { int numStrips = countStrips ( ) ; if ( numStrips ! = 0 ) { for ( int i = 0 ; i < numStrips ; i + + ) { 
public RPolygon toPolygon ( ) throws RuntimeException { throw new RuntimeException ( " Transforming a Mesh to a Polygon is not yet implemented. " ) ; } 
public RShape toShape ( ) throws RuntimeException { throw new RuntimeException ( " Transforming a Mesh to a Shape is not yet implemented. " ) ; } 
void append ( RStrip nextstrip ) { RStrip [ ] newstrips ; if ( strips = = null ) { newstrips = new RStrip [ 1 ] ; newstrips [ 0 ] = nextstrip ; currentStrip = 0 ; } else { newstrips = new RStrip [ this . strips . length + 1 ] ; System . arraycopy ( this . strips , 0 , newstrips , 0 , this . strips . length ) ; newstrips [ this . strips . length ] = nextstrip ; currentStrip + + ; } this . strips = newstrips ; } 
public void transform ( RMatrix m ) { float tempx = m . m00 * x + m . m01 * y + m . m02 ; float tempy = m . m10 * x + m . m11 * y + m . m12 ; x = tempx ; y = tempy ; } 
public void translate ( float tx , float ty ) { x + = tx ; y + = ty ; } 
public void translate ( RPoint ) { x + = . x ; y + = . y ; } 
public void rotate ( float angle ) { float c = ( float ) Math . cos ( angle ) ; float s = ( float ) Math . sin ( angle ) ; float tempx = x ; float tempy = y ; x = tempx * c - tempy * s ; y = tempx * s + tempy * c ; } 
public void rotate ( float angle , float vx , float vy ) { float c = ( float ) Math . cos ( angle ) ; float s = ( float ) Math . sin ( angle ) ; x - = vx ; y - = vy ; float tempx = x ; float tempy = y ; x = tempx * c - tempy * s ; y = tempx * s + tempy * c ; x + = vx ; y + = vy ; } 
public void rotate ( float angle , RPoint v ) { float c = ( float ) Math . cos ( angle ) ; float s = ( float ) Math . sin ( angle ) ; x - = v . x ; y - = v . y ; float tempx = x ; float tempy = y ; x = tempx * c - tempy * s ; y = tempx * s + tempy * c ; x + = v . x ; y + = v . y ; } 
public void scale ( float sx , float sy ) { x * = sx ; y * = sy ; } 
public void scale ( float s ) { x * = s ; y * = s ; } 
public void scale ( RPoint s ) { x * = s . x ; y * = s . y ; } 
public void normalize ( ) { float norma = norm ( ) ; if ( norma ! = 0 ) scale ( 1 / norma ) ; } 
public void sub ( RPoint p ) { x - = p . x ; y - = p . y ; } 
public void add ( RPoint p ) { x + = p . x ; y + = p . y ; } 
public float mult ( RPoint p ) { return ( x * p . x + y * p . y ) ; } 
public RPoint cross ( RPoint p ) { return new RPoint ( x * p . y - p . x * y , y * p . x - p . y * x ) ; } 
public float norm ( ) { return ( float ) Math . sqrt ( mult ( this ) ) ; } 
public float angle ( RPoint p ) { float normp = p . norm ( ) ; float normthis = norm ( ) ; return ( float ) Math . acos ( mult ( p ) / ( normp * normthis ) ) ; } 
static public RPolygon createCircle ( float x , float y , float radius , int detail ) { RPolygon circle = new RPolygon ( ) ; for ( int i = 0 ; i < detail ; i + + ) { circle . addPoint ( ( float ) ( radius * Math . cos ( 2 * Math . PI * i / detail ) ) + x , ( float ) ( radius * Math . sin ( 2 * Math . PI * i / detail ) ) + y ) ; } return circle ; } 
static public RPolygon createCircle ( float radius , int detail ) { return createCircle ( 0 , 0 , radius , detail ) ; } 
static public RPolygon createCircle ( float x , float y , float radius ) { return createCircle ( x , y , radius , defaultDetail ) ; } 
static public RPolygon createCircle ( float radius ) { return createCircle ( 0 , 0 , radius , defaultDetail ) ; } 
static public RPolygon createRectangle ( float x , float y , float w , float h ) { RPolygon rectangle = new RPolygon ( ) ; rectangle . addPoint ( x , y ) ; rectangle . addPoint ( x + w , y ) ; rectangle . addPoint ( x + w , y + h ) ; rectangle . addPoint ( x , y + h ) ; rectangle . addPoint ( x , y ) ; return rectangle ; } 
static public RPolygon createRectangle ( float w , float h ) { return createRectangle ( 0 , 0 , w , h ) ; } 
static public RPolygon createStar ( float x , float y , float radiusBig , float radiusSmall , int spikes ) { RPolygon star = new RPolygon ( ) ; for ( int i = 0 ; i < 2 * spikes ; i + = 2 ) { star . addPoint ( ( float ) ( radiusBig * Math . cos ( Math . PI * i / spikes ) ) + x , ( float ) ( radiusBig * Math . sin ( Math . PI * i / spikes ) ) + y ) ; star . addPoint ( ( float ) ( radiusSmall * Math . cos ( Math . PI * ( i + 1 ) / spikes ) ) + x , ( float ) ( radiusSmall * Math . sin ( Math . PI * ( i + 1 ) / spikes ) ) + y ) ; } star . addClose ( ) ; return star ; } 
static public RPolygon createStar ( float radiusBig , float radiusSmall , int spikes ) { return createStar ( 0 , 0 , radiusBig , radiusSmall , spikes ) ; } 
static public RPolygon createRing ( float radiusBig , float radiusSmall , int detail ) { return createRing ( 0 , 0 , radiusBig , radiusSmall , detail ) ; } 
static public RPolygon createRing ( float x , float y , float radiusBig , float radiusSmall ) { return createRing ( x , y , radiusBig , radiusSmall , defaultDetail ) ; } 
static public RPolygon createRing ( float radiusBig , float radiusSmall ) { return createRing ( 0 , 0 , radiusBig , radiusSmall , defaultDetail ) ; } 
public int countContours ( ) { if ( this . contours = = null ) { return 0 ; } return this . contours . length ; } 
public void addContour ( ) { this . append ( new RContour ( ) ) ; } 
public void addContour ( RContour c ) { this . append ( c ) ; } 
public void addPoint ( RPoint p ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ currentContour ] . append ( p ) ; } 
public void addPoint ( float x , float y ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ currentContour ] . append ( new RPoint ( x , y ) ) ; } 
public void addPoint ( int indContour , RPoint p ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ indContour ] . append ( p ) ; } 
public void addPoint ( int indContour , float x , float y ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ indContour ] . append ( new RPoint ( x , y ) ) ; } 
public RMesh toMesh ( ) { if ( contours = = null ) { return new RMesh ( ) ; } RMesh mesh = RClip . polygonToMesh ( this ) ; mesh . texture = this . texture ; mesh . id = this . id ; return mesh ; } 
public RShape toShape ( ) throws RuntimeException { throw new RuntimeException ( " Transforming a Polygon to a Shape is not yet implemented. " ) ; } 
public void draw ( PGraphics g ) { int numContours = countContours ( ) ; if ( numContours ! = 0 ) { if ( isIn ( g ) ) { 
public void draw ( PApplet g ) { int numContours = countContours ( ) ; if ( numContours ! = 0 ) { if ( isIn ( g ) ) { 
public boolean isIn ( PGraphics g ) { RContour c = getBounds ( ) ; float x0 = g . screenX ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; float y0 = g . screenY ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; float x1 = g . screenX ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; float y1 = g . screenY ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; float x2 = g . screenX ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; float y2 = g . screenY ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; float x3 = g . screenX ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; float y3 = g . screenY ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; float xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; float ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; float xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; float ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; return ! ( ( xmax < 0 | | xmin > g . width ) & & ( ymax < 0 | | ymin > g . height ) ) ; } 
public boolean isIn ( PApplet g ) { RContour c = getBounds ( ) ; float x0 = g . screenX ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; float y0 = g . screenY ( c . points [ 0 ] . x , c . points [ 0 ] . y ) ; float x1 = g . screenX ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; float y1 = g . screenY ( c . points [ 1 ] . x , c . points [ 1 ] . y ) ; float x2 = g . screenX ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; float y2 = g . screenY ( c . points [ 2 ] . x , c . points [ 2 ] . y ) ; float x3 = g . screenX ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; float y3 = g . screenY ( c . points [ 3 ] . x , c . points [ 3 ] . y ) ; float xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; float ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; float xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; float ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; return ! ( ( xmax < 0 | | xmin > g . width ) & & ( ymax < 0 | | ymin > g . height ) ) ; } 
public RPolygon intersection ( RPolygon p ) { return RClip . intersection ( p , this ) ; } 
public RPolygon union ( RPolygon p ) { return RClip . union ( p , this ) ; } 
public RPolygon xor ( RPolygon p ) { return RClip . xor ( p , this ) ; } 
public RPolygon diff ( RPolygon p ) { return RClip . diff ( this , p ) ; } 
public RPolygon update ( ) { return RClip . update ( this ) ; } 
void add ( float x , float y ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ 0 ] . append ( new RPoint ( x , y ) ) ; } 
void add ( RPoint p ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ 0 ] . append ( p ) ; } 
void add ( RContour c ) { this . append ( c ) ; } 
boolean isEmpty ( ) { return ( this . contours = = null ) ; } 
boolean isHole ( ) { if ( this . contours = = null | | this . contours . length > 1 ) { throw new IllegalStateException ( " Cannot call on a poly made up of more than one poly. " ) ; } return this . contours [ 0 ] . isHole ; } 
boolean isContributing ( int polyIndex ) { return this . contours [ polyIndex ] . isContributing ; } 
void append ( RContour nextcontour ) { RContour [ ] newcontours ; if ( contours = = null ) { newcontours = new RContour [ 1 ] ; newcontours [ 0 ] = nextcontour ; currentContour = 0 ; } else { newcontours = new RContour [ this . contours . length + 1 ] ; System . arraycopy ( this . contours , 0 , newcontours , 0 , this . contours . length ) ; newcontours [ this . contours . length ] = nextcontour ; currentContour + + ; } this . contours = newcontours ; } 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '"+name+"' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ String transformString = element.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); geomElem.transform(transf); } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Get the style for the geometrical element grp.addElement(geomElem); } } return grp; } 
public RPolygon elemToPolygon ( XMLElement elem ) { RPolygon poly = elemToPolyline ( elem ) ; poly . addClose ( ) ; return poly ; } 
public RShape elemToShape ( XMLElement elem ) { return getShape ( elem . getStringAttribute ( " d " ) ) ; } 
static public RShape createRect ( float x , float y , float w , float h ) { RShape rect = new RShape ( ) ; rect . addMoveTo ( x , y ) ; rect . addLineTo ( x + w , y ) ; rect . addLineTo ( x + w , y + h ) ; rect . addLineTo ( x , y + h ) ; rect . addLineTo ( x , y ) ; return rect ; } 
static public RShape createEllipse ( float x , float y , float rx , float ry ) { RPoint center = new RPoint ( x , y ) ; RShape circle = new RShape ( ) ; float kx = ( ( ( 8F / ( float ) Math . sqrt ( 2F ) ) - 4F ) / 3F ) * rx ; float ky = ( ( ( 8F / ( float ) Math . sqrt ( 2F ) ) - 4F ) / 3F ) * ry ; circle . addMoveTo ( center . x , center . y - ry ) ; circle . addBezierTo ( center . x + kx , center . y - ry , center . x + rx , center . y - ky , center . x + rx , center . y ) ; circle . addBezierTo ( center . x + rx , center . y + ky , center . x + kx , center . y + ry , center . x , center . y + ry ) ; circle . addBezierTo ( center . x - kx , center . y + ry , center . x - rx , center . y + ky , center . x - rx , center . y ) ; circle . addBezierTo ( center . x - rx , center . y - ky , center . x - kx , center . y - ry , center . x , center . y - ry ) ; circle . addClose ( ) ; return circle ; } 
static public RShape createCircle ( float x , float y , float r ) { return createEllipse ( x , y , r , r ) ; } 
public int countSubshapes ( ) { if ( this . subshapes = = null ) { return 0 ; } return this . subshapes . length ; } 
public void addShape ( RShape s ) { for ( int i = 0 ; i < s . countSubshapes ( ) ; i + + ) { this . append ( s . subshapes [ i ] ) ; 
public void addSubshape ( ) { this . append ( new RSubshape ( ) ) ; } 
public void addSubshape ( RSubshape s ) { this . append ( s ) ; } 
public void addMoveTo ( float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RSubshape ( endx , endy ) ) ; 
public void addLineTo ( float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RSubshape ( ) ) ; } this . subshapes [ currentSubshape ] . addLineTo ( endx , endy ) ; } 
public void addQuadTo ( float cp1x , float cp1y , float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RSubshape ( ) ) ; } this . subshapes [ currentSubshape ] . addQuadTo ( cp1x , cp1y , endx , endy ) ; } 
public void addBezierTo ( float cp1x , float cp1y , float cp2x , float cp2y , float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RSubshape ( ) ) ; } this . subshapes [ currentSubshape ] . addBezierTo ( cp1x , cp1y , cp2x , cp2y , endx , endy ) ; } 
public RMesh toMesh ( ) { RPolygon p = this . toPolygon ( ) ; return p . toMesh ( ) ; } 
public RPolygon toPolygon ( ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getCurvePoints ( ) ; result . addContour ( new RContour ( newpoints ) ) ; } result . texture = this . texture ; result . id = this . id ; return result ; } 
public void print ( ) { System . out . println ( " subshapes: " ) ; for ( int i = 0 ; i < subshapes . length ; i + + ) { 
public void draw ( PGraphics g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
public void draw ( PApplet g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
void append ( RSubshape nextsubshape ) { RSubshape [ ] newsubshapes ; if ( subshapes = = null ) { newsubshapes = new RSubshape [ 1 ] ; newsubshapes [ 0 ] = nextsubshape ; currentSubshape = 0 ; } else { newsubshapes = new RSubshape [ this . subshapes . length + 1 ] ; System . arraycopy ( this . subshapes , 0 , newsubshapes , 0 , this . subshapes . length ) ; newsubshapes [ this . subshapes . length ] = nextsubshape ; currentSubshape + + ; } this . subshapes = newsubshapes ; } 
public int countVertices ( ) { if ( this . vertices = = null ) { return 0 ; } return this . vertices . length ; } 
public void draw ( PGraphics g ) { int numVertices = countVertices ( ) ; g . beginShape ( g . TRIANGLE_STRIP ) ; for ( int i = 0 ; i < numVertices ; i + + ) { g . vertex ( vertices [ i ] . x , vertices [ i ] . y ) ; } g . endShape ( ) ; } 
public void addVertex ( float x , float y ) { this . append ( new RPoint ( x , y ) ) ; } 
public void transform ( RMatrix m ) { int numVertices = countVertices ( ) ; if ( numVertices ! = 0 ) { for ( int i = 0 ; i < numVertices ; i + + ) { 
void add ( float x , float y ) { this . append ( new RPoint ( x , y ) ) ; } 
void append ( RPoint nextvertex ) { RPoint [ ] newvertices ; if ( vertices = = null ) { newvertices = new RPoint [ 1 ] ; newvertices [ 0 ] = nextvertex ; } else { newvertices = new RPoint [ this . vertices . length + 1 ] ; System . arraycopy ( this . vertices , 0 , newvertices , 0 , this . vertices . length ) ; newvertices [ this . vertices . length ] = nextvertex ; } this . vertices = newvertices ; } 
public int countCommands ( ) { if ( this . commands = = null ) { return 0 ; } return this . commands . length ; } 
public void draw ( PGraphics g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void draw ( PApplet g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); RCommand.setSegmentator(lastSegmentator); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void addClose ( ) { if ( commands = = null ) { return ; } if ( ( commands [ commands . length - 1 ] . endPoint . x = = commands [ 0 ] . startPoint . x ) & & ( commands [ commands . length - 1 ] . endPoint . y = = commands [ 0 ] . startPoint . y ) ) { commands [ commands . length - 1 ] . endPoint = new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ; } else { addLineTo ( new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ) ; } lastPoint = commands [ commands . length - 1 ] . endPoint ; } 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) . toLowerCase ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '" + name + "' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ String transformString = element.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); geomElem.transform(transf); } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Get the style for the geometrical element grp.addElement(geomElem); } } return grp; } 
protected void saveContext ( PGraphics g ) { oldFill = g . fill ; oldFillColor = g . fillColor ; oldStroke = g . stroke ; oldStrokeColor = g . strokeColor ; oldStrokeWeight = g . strokeWeight ; } 
protected void saveContext ( PApplet p ) { oldFill = p . g . fill ; oldFillColor = p . g . fillColor ; oldStroke = p . g . stroke ; oldStrokeColor = p . g . strokeColor ; oldStrokeWeight = p . g . strokeWeight ; } 
protected void saveContext ( ) { saveContext ( RGeomerative . parent ) ; } 
protected void restoreContext ( PGraphics g ) { g . fill ( oldFillColor ) ; if ( ! oldFill ) { g . noFill ( ) ; } g . stroke ( oldStrokeColor ) ; g . strokeWeight ( oldStrokeWeight ) ; if ( ! oldStroke ) { g . noStroke ( ) ; 
protected void restoreContext ( PApplet p ) { p . fill ( oldFillColor ) ; if ( ! oldFill ) { p . noFill ( ) ; } p . stroke ( oldStrokeColor ) ; p . strokeWeight ( oldStrokeWeight ) ; if ( ! oldStroke ) { p . noStroke ( ) ; 
protected void restoreContext ( ) { restoreContext ( RGeomerative . parent ) ; } 
public static void ignoreStyles ( ) { ignoreStyles = true ; } 
public static void ignoreStyles ( boolean _value ) { ignoreStyles = _value ; } 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) . toLowerCase ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '" + name + "' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ String transformString = element.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); geomElem.transform(transf); } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Get the style for the geometrical element if(element.hasAttribute("style")){ geomElem.setStyle(element.getStringAttribute("style")); } Get the fill for the geometrical element if(element.hasAttribute("fill")){ geomElem.setFill(element.getStringAttribute("fill")); } Get the stroke for the geometrical element if(element.hasAttribute("stroke")){ geomElem.setStroke(element.getStringAttribute("stroke")); } Get the stroke-width for the geometrical element if(element.hasAttribute("stroke-width")){ geomElem.setStrokeWeight(element.getStringAttribute("stroke-width")); } Get the style for the geometrical element grp.addElement(geomElem); } } return grp; } 
public void draw ( PGraphics g ) { for ( int i = 0 ; i < this . countStrips ( ) ; i + + ) { g . beginShape ( g . TRIANGLE_STRIP ) ; 
public RShape elemToLine ( XMLElement elem ) { return getLine ( elem . getFloatAttribute ( " x1 " ) , elem . getFloatAttribute ( " y1 " ) , elem . getFloatAttribute ( " x2 " ) , elem . getFloatAttribute ( " y2 " ) ) ; } 
protected void saveContext ( PGraphics g ) { oldFill = g . fill ; oldFillColor = g . fillColor ; oldStroke = g . stroke ; oldStrokeColor = g . strokeColor ; oldStrokeWeight = g . strokeWeight ; oldStrokeCap = g . strokeCap ; oldStrokeJoin = g . strokeJoin ; } 
protected void saveContext ( PApplet p ) { oldFill = p . g . fill ; oldFillColor = p . g . fillColor ; oldStroke = p . g . stroke ; oldStrokeColor = p . g . strokeColor ; oldStrokeWeight = p . g . strokeWeight ; oldStrokeCap = p . g . strokeCap ; oldStrokeJoin = p . g . strokeJoin ; } 
protected void restoreContext ( PGraphics g ) { g . fill ( oldFillColor ) ; if ( ! oldFill ) { g . noFill ( ) ; } g . stroke ( oldStrokeColor ) ; g . strokeWeight ( oldStrokeWeight ) ; try { g . strokeCap ( oldStrokeCap ) ; g . strokeJoin ( oldStrokeJoin ) ; } catch ( RuntimeException e ) { } if ( ! oldStroke ) { g . noStroke ( ) ; 
protected void restoreContext ( PApplet p ) { p . fill ( oldFillColor ) ; if ( ! oldFill ) { p . noFill ( ) ; } p . stroke ( oldStrokeColor ) ; p . strokeWeight ( oldStrokeWeight ) ; try { p . strokeCap ( oldStrokeCap ) ; p . strokeJoin ( oldStrokeJoin ) ; } catch ( RuntimeException e ) { } if ( ! oldStroke ) { p . noStroke ( ) ; 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) . toLowerCase ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '" + name + "' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ String transformString = element.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); geomElem.transform(transf); } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Set the defaults styles geomElem.setFill(0); By default in SVG it's black geomElem.setFillAlpha(255); By default in SVG it's 1 geomElem.setStroke(false); By default in SVG it's none geomElem.setStrokeWeight(1F); By default in SVG it's none geomElem.setStrokeCap("butt"); By default in SVG it's 'butt' geomElem.setStrokeJoin("miter"); By default in SVG it's 'miter' geomElem.setStrokeAlpha(255); By default in SVG it's 1 geomElem.setAlpha(255); By default in SVG it's 1F Get the style for the geometrical element if(element.hasAttribute("style")){ geomElem.setStyle(element.getStringAttribute("style")); } Get the fill for the geometrical element if(element.hasAttribute("fill")){ geomElem.setFill(element.getStringAttribute("fill")); } Get the fill-linejoin for the geometrical element if(element.hasAttribute("fill-opacity")){ geomElem.setFillAlpha(element.getStringAttribute("fill-opacity")); } Get the stroke for the geometrical element if(element.hasAttribute("stroke")){ geomElem.setStroke(element.getStringAttribute("stroke")); } Get the stroke-width for the geometrical element if(element.hasAttribute("stroke-width")){ geomElem.setStrokeWeight(element.getStringAttribute("stroke-width")); } Get the stroke-linecap for the geometrical element if(element.hasAttribute("stroke-linecap")){ geomElem.setStrokeCap(element.getStringAttribute("stroke-linecap")); } Get the stroke-linejoin for the geometrical element if(element.hasAttribute("stroke-linejoin")){ geomElem.setStrokeJoin(element.getStringAttribute("stroke-linejoin")); } Get the stroke-linejoin for the geometrical element if(element.hasAttribute("stroke-opacity")){ geomElem.setStrokeAlpha(element.getStringAttribute("stroke-opacity")); } Get the opacity for the geometrical element if(element.hasAttribute("opacity")){ geomElem.setAlpha(element.getStringAttribute("opacity")); } Get the style for the geometrical element grp.addElement(geomElem); } } return grp; } 
public void draw ( PApplet p ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( p ) ) { 
public void draw ( PGraphics g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void draw ( PGraphics g ) { if ( ! RGeomerative . ignoreStyles ) { saveContext ( g ) ; setContext ( g ) ; } for ( int i = 0 ; i < countElements ( ) ; i + + ) { elements [ i ] . draw ( g ) ; } if ( ! RGeomerative . ignoreStyles ) { restoreContext ( g ) ; 
public void draw ( PApplet a ) { if ( ! RGeomerative . ignoreStyles ) { saveContext ( a ) ; setContext ( a ) ; } for ( int i = 0 ; i < countElements ( ) ; i + + ) { elements [ i ] . draw ( a ) ; } if ( ! RGeomerative . ignoreStyles ) { restoreContext ( a ) ; 
public RGroup elemToGroup ( XMLElement elem ) { RGroup grp = new RGroup ( ) ; XMLElement elems [ ] = elem . getChildren ( ) ; for ( int i = 0 ; i < elems . length ; i + + ) { String name = elems [ i ] . getName ( ) . toLowerCase ( ) ; XMLElement element = elems [ i ] ; Parse and create the geometrical element RGeomElem geomElem = null; if(name.equals("g")){ geomElem = elemToGroup(element); }else if (name.equals("path")) { geomElem = elemToShape(element); }else if(name.equals("polygon")){ geomElem = elemToPolygon(element); }else if(name.equals("polyline")){ geomElem = elemToPolyline(element); }else if(name.equals("circle")){ geomElem = elemToCircle(element); }else if(name.equals("ellipse")){ geomElem = elemToEllipse(element); }else if(name.equals("rect")){ geomElem = elemToRect(element); }else if(name.equals("line")){ geomElem = elemToLine(element); }else{ RGeomerative.parent.println("Element '" + name + "' not know. Ignoring it."); } If the geometrical element has been correctly created if((geomElem != null)){ Transform geometrical element if(element.hasAttribute("transform")){ String transformString = element.getStringAttribute("transform"); RMatrix transf = new RMatrix(transformString); geomElem.transform(transf); } Get the id for the geometrical element if(element.hasAttribute("id")){ geomElem.id = element.getStringAttribute("id"); } Get the style for the geometrical element if(element.hasAttribute("style")){ geomElem.setStyle(element.getStringAttribute("style")); } Get the fill for the geometrical element if(element.hasAttribute("fill")){ geomElem.setFill(element.getStringAttribute("fill")); } Get the fill-linejoin for the geometrical element if(element.hasAttribute("fill-opacity")){ geomElem.setFillAlpha(element.getStringAttribute("fill-opacity")); } Get the stroke for the geometrical element if(element.hasAttribute("stroke")){ geomElem.setStroke(element.getStringAttribute("stroke")); } Get the stroke-width for the geometrical element if(element.hasAttribute("stroke-width")){ geomElem.setStrokeWeight(element.getStringAttribute("stroke-width")); } Get the stroke-linecap for the geometrical element if(element.hasAttribute("stroke-linecap")){ geomElem.setStrokeCap(element.getStringAttribute("stroke-linecap")); } Get the stroke-linejoin for the geometrical element if(element.hasAttribute("stroke-linejoin")){ geomElem.setStrokeJoin(element.getStringAttribute("stroke-linejoin")); } Get the stroke-linejoin for the geometrical element if(element.hasAttribute("stroke-opacity")){ geomElem.setStrokeAlpha(element.getStringAttribute("stroke-opacity")); } Get the opacity for the geometrical element if(element.hasAttribute("opacity")){ geomElem.setAlpha(element.getStringAttribute("opacity")); } Get the style for the geometrical element grp.addElement(geomElem); } } Set the defaults styles grp.setFill(0); By default in SVG it's black grp.setFillAlpha(255); By default in SVG it's 1 grp.setStroke(false); By default in SVG it's none grp.setStrokeWeight(1F); By default in SVG it's none grp.setStrokeCap("butt"); By default in SVG it's 'butt' grp.setStrokeJoin("miter"); By default in SVG it's 'miter' grp.setStrokeAlpha(255); By default in SVG it's 1 grp.setAlpha(255); By default in SVG it's 1F return grp; } 
public RMesh toMesh ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Mesh is not yet implemented."); RGroup meshGroup = toMeshGroup(); RMesh result = new RMesh(); for(int i=0;i<countElements();i++){ RMesh currentMesh = (RMesh)(meshGroup.elements[i]); for(int j=0;j<currentMesh.countStrips();j++){ result.addStrip(currentMesh.strips[j]); } } result.setStyle(this); return result; } 
public RPolygon toPolygon ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Polygon is not yet implemented."); RGroup polygonGroup = toPolygonGroup(); RPolygon result = new RPolygon(); for(int i=0;i<countElements();i++){ RPolygon currentPolygon = (RPolygon)(polygonGroup.elements[i]); for(int j=0;j<currentPolygon.countContours();j++){ result.addContour(currentPolygon.contours[j]); } } result.setStyle(this); return result; } 
public RShape toShape ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Shape is not yet implemented."); RGroup shapeGroup = toShapeGroup(); RShape result = new RShape(); for(int i=0;i<countElements();i++){ RShape currentShape = (RShape)(shapeGroup.elements[i]); for(int j=0;j<currentShape.countSubshapes();j++){ result.addSubshape(currentShape.subshapes[j]); } } result.setStyle(this); return result; } 
public RMesh toMesh ( ) { if ( contours = = null ) { return new RMesh ( ) ; } RMesh mesh = RClip . polygonToMesh ( this ) ; mesh . setStyle ( this ) ; return mesh ; } 
public RPolygon toPolygon ( ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getCurvePoints ( ) ; result . addContour ( new RContour ( newpoints ) ) ; } result . setStyle ( this ) ; return result ; } 
public void transform ( RMatrix m ) { RPoint [ ] ps = getPoints ( ) ; if ( ps ! = null ) { for ( int i = 0 ; i < ps . length ; i + + ) { 
public RShape elemToPolyline ( XMLElement elem ) { return getPolyline ( elem . getStringAttribute ( " points " ) . trim ( ) ) ; } 
public RShape elemToPolygon ( XMLElement elem ) { RShape poly = elemToPolyline ( elem ) ; poly . addClose ( ) ; return poly ; } 
public RPolygon toPolygon ( ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getCurvePoints ( ) ; result . addContour ( new RContour ( newpoints ) ) ; } result . setStyle ( this ) ; return result ; } 
public static RMesh polygonToMesh ( RPolygon s ) { RPolygon c = new RPolygon ( ) ; RPolygon s_clean = s . removeOpenContours ( ) ; return clip ( OperationType . GPC_UNION , s_clean , c ) ; } 
public void print ( ) { System . out . println ( " contour: " ) ; for ( int i = 0 ; i < countPoints ( ) ; i + + ) { 
public void print ( ) { System . out . print ( " ( " + x + " , " + y + " ) " ) ; } 
public void print ( ) { System . out . println ( " polygon: " ) ; for ( int i = 0 ; i < countContours ( ) ; i + + ) { 
protected RPolygon removeOpenContours ( ) { RPolygon clean = new RPolygon ( ) ; for ( int i = 0 ; i < countContours ( ) ; i + + ) { if ( contours [ i ] . countPoints ( ) > 3 ) { clean . addContour ( contours [ i ] ) ; } } clean . setStyle ( this ) ; return clean ; } 
private int move ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addMoveTo ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; strp . setLocation ( curp . x , curp . y ) ; relp.setLocation(0F, 0F); return i + 1; } 
private int curve ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 1 ] ) + relp . y , RGeomerative . parent . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 3 ] ) + relp . y , RGeomerative . parent . parseFloat ( tags [ i + 4 ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent . parseFloat ( tags [ i + 4 ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent . parseFloat ( tags [ i + 2 ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent . parseFloat ( tags [ i + 3 ] ) + relp . y ) ) ; return i + 5 ; } 
private int smooth ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( refp . x , refp . y , RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 1 ] ) + relp . y , RGeomerative . parent . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent . parseFloat ( tags [ i + 1 ] ) + relp . y ) ) ; return i + 3 ; } 
private int line ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i + 1 ; } 
private int horizontal ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , curp . y ) ; curp . setLocation ( RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . x , curp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i ; } 
private int vertical ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( curp . x , RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . y ) ; curp . setLocation ( curp . x , RGeomerative . parent . parseFloat ( tags [ i ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i ; } 
public void print ( ) { System . out . println ( " subshapes [count " + this . countSubshapes ( ) + " ]: " ) ; for ( int i = 0 ; i < subshapes . length ; i + + ) { 
public RShape toShape ( ) { return new RShape ( new RSubshape ( this ) ) ; } 
protected void saveSegmentatorContext ( ) { oldSegmentType = RCommand . segmentType ; oldSegmentSteps = RCommand . segmentSteps ; oldSegmentLines = RCommand . segmentLines ; } 
protected void restoreSegmentatorContext ( ) { RCommand . segmentType = oldSegmentType ; RCommand . segmentSteps = oldSegmentSteps ; RCommand . segmentLines = oldSegmentLines ; } 
public void draw ( PGraphics g ) { RPoint [ ] points = getCurvePoints ( ) ; if ( points = = null ) { return ; } g . beginShape ( ) ; for ( int i = 0 ; i < points . length ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; } 
public void draw ( PApplet a ) { RPoint [ ] points = getCurvePoints ( ) ; if ( points = = null ) { return ; } a . beginShape ( ) ; for ( int i = 0 ; i < points . length ; i + + ) { a . vertex ( points [ i ] . x , points [ i ] . y ) ; } a . endShape ( ) ; } 
public RCommand [ ] split ( float ) { RCommand [ ] result ; switch ( commandType ) { case LINETO : return splitLine ( ) ; case QUADBEZIERTO : return splitQuadBezier ( ) ; case CUBICBEZIERTO : return splitCubicBezier ( ) ; } return null ; } 
private RCommand [ ] splitCubicBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 4 ] [ 4 ] ; for ( int i = 0 ; i < = 3 ; i + + ) { for ( int j = 0 ; j < = 3 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getPoints ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 3; i++){ triangleMatrix[0][i].x = controlPoints[i].x; triangleMatrix[0][i].y = controlPoints[i].y; } Triangle computation for(int i = 1; i <= 3; i++){ for(int j = 0; j <= 3 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier4(triangleMatrix[0][0], triangleMatrix[1][0], triangleMatrix[2][0], triangleMatrix[3][0]); result[1] = createBezier4(triangleMatrix[3][0], triangleMatrix[2][1], triangleMatrix[1][2], triangleMatrix[0][3]); return result; } 
private RCommand [ ] splitQuadBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 3 ] [ 3 ] ; for ( int i = 0 ; i < = 2 ; i + + ) { for ( int j = 0 ; j < = 2 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getPoints ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 2; i++){ triangleMatrix[0][i] = controlPoints[i]; } Triangle computation for(int i = 1; i <= 2; i++){ for(int j = 0; j <= 2 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier3(triangleMatrix[0][0], triangleMatrix[1][0], triangleMatrix[2][0]); result[1] = createBezier3(triangleMatrix[2][0], triangleMatrix[1][1], triangleMatrix[0][2]); return result; } 
private RCommand [ ] splitLine ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 2 ] [ 2 ] ; for ( int i = 0 ; i < = 1 ; i + + ) { for ( int j = 0 ; j < = 1 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getPoints ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 1; i++){ triangleMatrix[0][i] = controlPoints[i]; } Triangle computation for(int i = 1; i <= 1; i++){ for(int j = 0; j <= 1 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createLine(triangleMatrix[0][0], triangleMatrix[1][0]); result[1] = createLine(triangleMatrix[1][0], triangleMatrix[0][1]); return result; } 
public RPolygon toPolygon ( ) { return toShape ( ) . toPolygon ( ) ; } 
public RMesh toMesh ( ) { return toShape ( ) . toPolygon ( ) . toMesh ( ) ; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; for ( int i = 0 ; i < countSubshapes ( ) ; i + + ) { RSubshape [ ] splittedSubshapes = subshapes [ i ] . split ( ) ; if ( splittedSubshapes ! = null ) { result [ 0 ] . addSubshape ( splittedSubshapes [ 0 ] ) ; result [ 1 ] . addSubshape ( splittedSubshapes [ 1 ] ) ; } } result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } 
public RSubshape [ ] split ( float ) { RSubshape [ ] result = new RSubshape [ 2 ] ; float advOfCommand ; int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } if ( = = 0.0F ) { return commands[0].split(0F); t=0.01F; } if(t==1.0F){ return commands[numCommands-1].split(1F); t=0.99F; } float[] lengthsCommands = getCurveLengths(); float lengthSubshape = getCurveLength(); while(t > accumulatedAdvancement){ indCommand++; prevAccumulatedAdvancement = accumulatedAdvancement; accumulatedAdvancement += (lengthsCommands[indCommand] / lengthSubshape); } advOfCommand = (t-prevAccumulatedAdvancement) / (lengthsCommands[indCommand] / lengthSubshape); RCommand[] splittedCommands = commands[indCommand].split(advOfCommand); result[0] = new RSubshape(); for(int i = 0; i<indCommand; i++){ result[0].addCommand(commands[i]); } result[0].addCommand(splittedCommands[0]); result[0].setStyle(this); result[1] = new RSubshape(); for(int i = indCommand + 1; i < countCommands(); i++){ result[1].addCommand(commands[i]); } result[1].addCommand(splittedCommands[1]); result[1].setStyle(this); return result; } 
public RSubshape [ ] split ( float ) { RSubshape [ ] result = new RSubshape [ 2 ] ; float advOfCommand ; int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } if ( = = 0.0F ) { return commands[0].split(0F); t=0.0001F; } if(t==1.0F){ return commands[numCommands-1].split(1F); t=0.9999F; } float[] lengthsCommands = getCurveLengths(); float lengthSubshape = getCurveLength(); while(t > accumulatedAdvancement){ indCommand++; prevAccumulatedAdvancement = accumulatedAdvancement; accumulatedAdvancement += (lengthsCommands[indCommand] / lengthSubshape); } advOfCommand = (t-prevAccumulatedAdvancement) / (lengthsCommands[indCommand] / lengthSubshape); RCommand[] splittedCommands = commands[indCommand].split(advOfCommand); result[0] = new RSubshape(); for(int i = 0; i<indCommand; i++){ result[0].addCommand(commands[i]); } result[0].addCommand(splittedCommands[0]); result[0].setStyle(this); result[1] = new RSubshape(); for(int i = indCommand + 1; i < countCommands(); i++){ result[1].addCommand(commands[i]); } result[1].addCommand(splittedCommands[1]); result[1].setStyle(this); return result; } 
public RSubshape [ ] split ( float ) { RSubshape [ ] result = new RSubshape [ 2 ] ; float advOfCommand ; int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RSubshape ( ) ; result [ 1 ] = new RSubshape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RSubshape ( this ) ; result [ 1 ] = new RSubshape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] lengthsCommands = getCurveLengths ( ) ; float lengthSubshape = getCurveLength ( ) ; int indCommand = 0 ; while ( > accumulatedAdvancement ) { indCommand + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCommands [ indCommand ] / lengthSubshape ) ; } advOfCommand = ( - prevAccumulatedAdvancement ) / ( lengthsCommands [ indCommand ] / lengthSubshape ) ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indCommand].split(advOfCommand); result[0] = new RSubshape(); for(int i = 0; i<indCommand; i++){ result[0].addCommand(commands[i]); } result[0].addCommand(splittedCommands[0]); result[0].setStyle(this); result[1] = new RSubshape(); for(int i = indCommand + 1; i < countCommands(); i++){ result[1].addCommand(commands[i]); } result[1].addCommand(splittedCommands[1]); result[1].setStyle(this); return result; } 
public RPolygon toPolygon ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Polygon is not yet implemented."); RGroup polygonGroup = toPolygonGroup(); RPolygon result = new RPolygon(); for(int i=0;i<countElements();i++){ RPolygon currentPolygon = elements[i].toPolygon(); for(int j=0;j<currentPolygon.countContours();j++){ result.addContour(currentPolygon.contours[j]); } } result.setStyle(this); return result; } 
public RShape toShape ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Shape is not yet implemented."); RShape result = new RShape(); for(int i=0;i<countElements();i++){ RShape currentShape = elements[i].toShape(); for(int j=0;j<currentShape.countSubshapes();j++){ result.addSubshape(currentShape.subshapes[j]); } } result.setStyle(this); return result; } 
public RSubshape [ ] split ( float ) { RSubshape [ ] result = new RSubshape [ 2 ] ; float advOfCommand ; int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RSubshape ( ) ; result [ 1 ] = new RSubshape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RSubshape ( this ) ; result [ 1 ] = new RSubshape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] lengthsCommands = getCurveLengths ( ) ; float lengthSubshape = getCurveLength ( ) ; int indCommand = 0 ; while ( > accumulatedAdvancement ) { indCommand + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCommands [ indCommand ] / lengthSubshape ) ; } advOfCommand = ( - prevAccumulatedAdvancement ) / ( lengthsCommands [ indCommand ] / lengthSubshape ) ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indCommand].split(advOfCommand); result[0] = new RSubshape(); for(int i = 0; i<indCommand; i++){ result[0].addCommand(new RCommand(commands[i])); } result[0].addCommand(new RCommand(splittedCommands[0])); result[0].setStyle(this); result[1] = new RSubshape(); for(int i = indCommand + 1; i < countCommands(); i++){ result[1].addCommand(new RCommand(commands[i])); } result[1].addCommand(new RCommand(splittedCommands[1])); result[1].setStyle(this); return result; } 
public void print ( ) { for ( int i = 0 ; i < countCommands ( ) ; i + + ) { String commandType = " " ; 
public static RMesh polygonToMesh ( RPolygon s ) { RPolygon c = new RPolygon ( ) ; RPolygon s_clean = s . removeOpenContours ( ) ; return clip ( OperationType . GPC_UNION , s_clean , c ) ; } 
protected void calculateCurveLengths ( ) { RGeomerative . parent . println ( " Feature not yet implemented for this class. " ) ; } 
protected void calculateCurveLengths ( ) { lenCurves = new float [ countElements ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { lenCurves [ i ] = elements [ i ] . getCurveLength ( ) ; 
public RMesh toMesh ( ) { return toPolygon ( ) . toMesh ( ) ; } 
public RPolygon toPolygon ( ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getCurvePoints ( ) ; result . addContour ( new RContour ( newpoints ) ) ; } result . setStyle ( this ) ; return result ; } 
public RShape [ ] splitAll ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; for ( int i = 0 ; i < countSubshapes ( ) ; i + + ) { RSubshape [ ] splittedSubshapes = subshapes [ i ] . split ( ) ; if ( splittedSubshapes ! = null ) { result [ 0 ] . addSubshape ( splittedSubshapes [ 0 ] ) ; result [ 1 ] . addSubshape ( splittedSubshapes [ 1 ] ) ; } } result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; float advOfCommand ; int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] lengthsSubshapes = getCurveLengths ( ) ; float lengthSubshape = getCurveLength ( ) ; int indSubshape = 0 ; while ( > accumulatedAdvancement ) { indSubshape + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsSubshapes [ indSubshape ] / lengthSubshape ) ; } float advOfSubshape = ( - prevAccumulatedAdvancement ) / ( lengthsSubshapes [ indSubshape ] / lengthSubshape ) ; RSubshape [ ] splittedShapes = subshapes [ indSubshape ] . split ( advOfSubshape ) ; result [ 0 ] = new RShape ( ) ; for ( int i = 0 ; i < indSubshape ; i + + ) { result [ 0 ] . addSubshape ( new RSubshape ( subshapes [ i ] ) ) ; } result [ 0 ] . addSubshape ( new RSubshape ( splittedShapes [ 0 ] ) ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . addSubshape ( new RSubshape ( splittedShapes [ 1 ] ) ) ; for ( int i = indSubshape + 1 ; i < countSubshapes ( ) ; i + + ) { result [ 1 ] . addSubshape ( new RSubshape ( subshapes [ i ] ) ) ; } result [ 1 ] . setStyle ( this ) ; return result ; } 
protected void calculateCurveLengths ( ) { lenCurves = new float [ countSubshapes ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countSubshapes ( ) ; i + + ) { lenCurves [ i ] = subshapes [ i ] . getCurveLength ( ) ; 
public void print ( ) { System . out . println ( " subshapes [count " + this . countSubshapes ( ) + " ]: " ) ; for ( int i = 0 ; i < countSubshapes ( ) ; i + + ) { 
protected void calculateCurveLengths ( ) { lenCurves = new float [ countCommands ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countCommands ( ) ; i + + ) { lenCurves [ i ] = commands [ i ] . getCurveLength ( ) ; 
public RSubshape [ ] split ( float ) { RSubshape [ ] result = new RSubshape [ 2 ] ; int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RSubshape ( ) ; result [ 1 ] = new RSubshape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RSubshape ( this ) ; result [ 1 ] = new RSubshape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] lengthsCommands = getCurveLengths ( ) ; float lengthSubshape = getCurveLength ( ) ; int indCommand = 0 ; while ( > accumulatedAdvancement ) { indCommand + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCommands [ indCommand ] / lengthSubshape ) ; } float advOfCommand = ( - prevAccumulatedAdvancement ) / ( lengthsCommands [ indCommand ] / lengthSubshape ) ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indCommand].split(advOfCommand); result[0] = new RSubshape(); for(int i = 0; i<indCommand; i++){ result[0].addCommand(new RCommand(commands[i])); } result[0].addCommand(new RCommand(splittedCommands[0])); result[0].setStyle(this); result[1] = new RSubshape(); for(int i = indCommand + 1; i < countCommands(); i++){ result[1].addCommand(new RCommand(commands[i])); } result[1].addCommand(new RCommand(splittedCommands[1])); result[1].setStyle(this); return result; } 
public void drawOld ( PApplet g ) { int numContours = countContours ( ) ; if ( numContours ! = 0 ) { if ( isIn ( g ) ) { 
public void drawUsingInternalTesselator ( PGraphics g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
public void drawUsingInternalTesselator ( PApplet p ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( p ) ) { 
public void drawUsingBreakShape ( PGraphics g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
public void drawUsingBreakShape ( PApplet g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
public void draw ( PGraphics g ) { try { Class declaringClass = g . getClass ( ) . getMethod ( " breakShape " , null ) . getDeclaringClass ( ) ; 
public void draw ( PApplet g ) { try { Class declaringClass = g . g . getClass ( ) . getMethod ( " breakShape " , null ) . getDeclaringClass ( ) ; 
public void draw ( PGraphics g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? RGeomerative.parent.CLOSE : RGeomerative.parent.OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void draw ( PApplet g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); RCommand.setSegmentator(lastSegmentator); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? RGeomerative.parent.CLOSE : RGeomerative.parent.OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void addClose ( ) { if ( commands = = null ) { return ; } if ( ( commands [ commands . length - 1 ] . endPoint . x = = commands [ 0 ] . startPoint . x ) & & ( commands [ commands . length - 1 ] . endPoint . y = = commands [ 0 ] . startPoint . y ) ) { commands [ commands . length - 1 ] . endPoint = new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ; } else { addLineTo ( new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ) ; } lastPoint = commands [ commands . length - 1 ] . endPoint ; closed = true ; } 
public void draw ( PGraphics g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( closed ? RGeomerative . parent . CLOSE : RGeomerative . parent . OPEN ) ; if ( beforeFill ) g . fill ( g . fillColor ) ; 
public void draw ( PApplet g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( closed ? RGeomerative . parent . CLOSE : RGeomerative . parent . OPEN ) ; if ( beforeFill ) g . fill ( g . g . fillColor ) ; 
public void addClose ( ) { if ( points = = null ) { return ; } if ( ( points [ 0 ] . x = = points [ points . length - 1 ] . x ) & & ( points [ 0 ] . y = = points [ points . length - 1 ] . y ) ) { return ; } addPoint ( new RPoint ( points [ 0 ] . x , points [ 0 ] . y ) ) ; closed = true ; } 
public RPolygon toPolygon ( ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getCurvePoints ( ) ; RContour c = new RContour ( newpoints ) ; c . closed = subshapes [ i ] . closed ; c . setStyle ( subshapes [ i ] ) ; result . addContour ( c ) ; } result . setStyle ( this ) ; return result ; } 
public void draw ( ) { this . draw ( RGeomerative . parent ( ) ) ; } 
protected void saveContext ( ) { saveContext ( RGeomerative . parent ( ) ) ; } 
protected void restoreContext ( ) { restoreContext ( RGeomerative . parent ( ) ) ; } 
protected void calculateCurveLengths ( ) { RGeomerative . parent ( ) . println ( " Feature not yet implemented for this class. " ) ; } 
protected static PApplet parent ( ) { if ( parent = = null ) { throw new LibraryNotInitializedException ( ) ; } return parent ; } 
private int move ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addMoveTo ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; strp . setLocation ( curp . x , curp . y ) ; relp.setLocation(0F, 0F); return i + 1; } 
private int curve ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i + 4 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 4 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ) ; return i + 5 ; } 
private int smooth ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( refp . x , refp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ) ; return i + 3 ; } 
private int line ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i + 1 ; } 
private int horizontal ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , curp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , curp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i ; } 
private int vertical ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( curp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . y ) ; curp . setLocation ( curp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i ; } 
public void draw ( PGraphics g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? RGeomerative.parent().CLOSE : RGeomerative.parent().OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void draw ( PApplet g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getCurvePoints(); RCommand.setSegmentator(lastSegmentator); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? RGeomerative.parent().CLOSE : RGeomerative.parent().OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public RShape toShape ( ) { int numContours = countContours ( ) ; RShape result = new RShape ( ) ; for ( int i = 0 ; i < numContours ; i + + ) { RPoint [ ] newpoints = this . contours [ i ] . getPoints ( ) ; if ( newpoints ! = null ) { result . addMoveTo ( newpoints [ 0 ] ) ; for ( int j = 1 ; j < newpoints . length ; j + + ) { result . addLineTo ( newpoints [ j ] ) ; } if ( contours [ i ] . closed ) { result . addClose ( ) ; } result . subshapes [ i ] . setStyle ( contours [ i ] ) ; } } result . setStyle ( this ) ; return result ; } 
static public RShape createRing ( float x , float y , float radiusBig , float radiusSmall ) { RShape ring = new RShape ( ) ; RShape outer = RShape . createCircle ( x , y , radiusBig ) ; RShape inner = RShape . createCircle ( x , y , - radiusSmall ) ; ring . addSubshape ( outer . subshapes [ 0 ] ) ; ring . addSubshape ( inner . subshapes [ 0 ] ) ; return ring ; } 
static public RShape createStar ( float x , float y , float radiusBig , float radiusSmall , int spikes ) { RShape star = new RShape ( ) ; star . addMoveTo ( x - radiusBig , y ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI / spikes ) ) ) ; for ( int i = 2 ; i < 2 * spikes ; i + = 2 ) { star . addLineTo ( x - ( float ) ( radiusBig * Math . cos ( Math . PI * i / spikes ) ) , y - ( float ) ( radiusBig * Math . sin ( Math . PI * i / spikes ) ) ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI * ( i + 1 ) / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI * ( i + 1 ) / spikes ) ) ) ; } star . addClose ( ) ; return star ; } 
public void addMoveTo ( RPoint p ) { addMoveTo ( p . x , p . y ) ; } 
public void addLineTo ( RPoint p ) { addLineTo ( p . x , p . y ) ; } 
public void addQuadTo ( RPoint p1 , RPoint p2 ) { addQuadTo ( p1 . x , p1 . y , p2 . x , p2 . y ) ; } 
public void addBezierTo ( RPoint p1 , RPoint p2 , RPoint p3 ) { addBezierTo ( p1 . x , p1 . y , p2 . x , p2 . y , p3 . x , p3 . y ) ; } 
public RShape intersection ( RShape p ) { return RClip . intersection ( p . toPolygon ( ) , this . toPolygon ( ) ) . toShape ( ) ; } 
public RShape union ( RShape p ) { return RClip . union ( p . toPolygon ( ) , this . toPolygon ( ) ) . toShape ( ) ; } 
public RShape xor ( RShape p ) { return RClip . xor ( p . toPolygon ( ) , this . toPolygon ( ) ) . toShape ( ) ; } 
public RShape diff ( RShape p ) { return RClip . diff ( this . toPolygon ( ) , p . toPolygon ( ) ) . toShape ( ) ; } 
public RPolygon toPolygon ( char character ) { return toShape ( character ) . toPolygon ( ) ; } 
public RGroup toGroup ( String text ) throws RuntimeException { RGroup result = new RGroup ( ) ; Decide upon a cmap table to use for our character to glyph look-up CmapFormat cmapFmt = getCmapFormat(); if (cmapFmt == null) { throw new RuntimeException("Cannot find a suitable cmap table"); } int x = 0; for (short i = 0; i < text.length(); i++) { int glyphIndex = cmapFmt.mapCharCode(text.charAt(i)); Glyph glyph = f.getGlyph(glyphIndex); int default_advance_x = f.getHmtxTable().getAdvanceWidth(glyphIndex); if (glyph != null) { glyph.scale(scaleFactor); Add the Glyph to the Shape with an horizontal offset of x result.addElement(getGlyphAsShape(f,glyph, glyphIndex,x)); x += glyph.getAdvanceWidth(); }else{ x += (int)((float)default_advance_x*scaleFactor); } } if(align!=LEFT && align!=CENTER && align!=RIGHT){ throw new RuntimeException("Alignement unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT"); } RContour r; switch(this.align){ case RFont.CENTER: r = result.getBounds(); if(r.points!=null){ RMatrix mattrans = new RMatrix(); mattrans.translate((r.points[0].x-r.points[2].x)/2,0); result.transform(mattrans); } break; case RFont.RIGHT: r = result.getBounds(); if(r.points!=null){ RMatrix mattrans = new RMatrix(); mattrans.translate((r.points[0].x-r.points[2].x),0); result.transform(mattrans); } break; case RFont.LEFT: break; } return result; } 
public RGroup toGroup ( String text ) throws RuntimeException { RGroup result = new RGroup ( ) ; Decide upon a cmap table to use for our character to glyph look-up CmapFormat cmapFmt = getCmapFormat(); if (cmapFmt == null) { throw new RuntimeException("Cannot find a suitable cmap table"); } If this font includes arabic script, we want to specify substitutions for initial, medial, terminal & isolated cases. int x = 0; for (short i = 0; i < text.length(); i++) { int glyphIndex = cmapFmt.mapCharCode(text.charAt(i)); Glyph glyph = f.getGlyph(glyphIndex); int default_advance_x = f.getHmtxTable().getAdvanceWidth(glyphIndex); if (glyph != null) { glyph.scale(scaleFactor); Add the Glyph to the Shape with an horizontal offset of x result.addElement(getGlyphAsShape(f,glyph, glyphIndex,x)); x += glyph.getAdvanceWidth(); }else{ x += (int)((float)default_advance_x*scaleFactor); } } if(align!=LEFT && align!=CENTER && align!=RIGHT){ throw new RuntimeException("Alignement unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT"); } RContour r; switch(this.align){ case RFont.CENTER: r = result.getBounds(); if(r.points!=null){ RMatrix mattrans = new RMatrix(); mattrans.translate((r.points[0].x-r.points[2].x)/2,0); result.transform(mattrans); } break; case RFont.RIGHT: r = result.getBounds(); if(r.points!=null){ RMatrix mattrans = new RMatrix(); mattrans.translate((r.points[0].x-r.points[2].x),0); result.transform(mattrans); } break; case RFont.LEFT: break; } return result; } 
public void draw ( PGraphics g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( closed ? RGeomerative . parent ( ) . CLOSE : RGeomerative . parent ( ) . OPEN ) ; if ( beforeFill ) g . fill ( g . fillColor ) ; 
public void draw ( PApplet g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( closed ? RGeomerative . parent ( ) . CLOSE : RGeomerative . parent ( ) . OPEN ) ; if ( beforeFill ) g . fill ( g . g . fillColor ) ; 
protected static PApplet parent ( ) { if ( parent = = null ) { throw new LibraryNotInitializedException ( ) ; } return parent ; } 
private void calculateCurveLengths ( ) { RGeomerative . parent ( ) . println ( " Feature not yet implemented for this class. " ) ; } 
static public RShape createRectangle ( float x , float y , float w , float h ) { RShape rect = new RShape ( ) ; rect . addMoveTo ( x , y ) ; rect . addLineTo ( x + w , y ) ; rect . addLineTo ( x + w , y + h ) ; rect . addLineTo ( x , y + h ) ; rect . addLineTo ( x , y ) ; return rect ; } 
private void calculateCurveLengths ( ) { lenCurves = new float [ countSubshapes ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countSubshapes ( ) ; i + + ) { lenCurves [ i ] = subshapes [ i ] . getCurveLength ( ) ; 
private void append ( RSubshape nextsubshape ) { RSubshape [ ] newsubshapes ; if ( subshapes = = null ) { newsubshapes = new RSubshape [ 1 ] ; newsubshapes [ 0 ] = nextsubshape ; currentSubshape = 0 ; } else { newsubshapes = new RSubshape [ this . subshapes . length + 1 ] ; System . arraycopy ( this . subshapes , 0 , newsubshapes , 0 , this . subshapes . length ) ; newsubshapes [ this . subshapes . length ] = nextsubshape ; currentSubshape + + ; } this . subshapes = newsubshapes ; } 
private void drawUsingInternalTesselator ( PGraphics g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
private void drawUsingInternalTesselator ( PApplet p ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( p ) ) { 
private void drawUsingBreakShape ( PGraphics g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
private void drawUsingBreakShape ( PApplet g ) { int numSubshapes = countSubshapes ( ) ; if ( numSubshapes ! = 0 ) { if ( isIn ( g ) ) { 
private void calculateCurveLengths ( ) { lenCurves = new float [ countElements ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { lenCurves [ i ] = elements [ i ] . getCurveLength ( ) ; 
public RGroup adaptTo ( RSubshape sshp , float wght , float lngthOffset ) throws RuntimeException { RGroup result = new RGroup ( this ) ; RContour c = result . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; int numElements = result . countElements ( ) ; switch ( adaptorType ) { case BYPOINT : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RPoint [ ] ps = elem . getPoints ( ) ; if ( ps ! = null ) { for ( int k = 0 ; k < ps . length ; k + + ) { float px = ps [ k ] . x ; float py = ps [ k ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; float amp = ( ymax - py ) ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) - ( float ) Math . PI / 2F ; ps [ k ] . x = p . x + wght * amp * ( float ) Math . cos ( angle ) ; ps [ k ] . y = p . y + wght * amp * ( float ) Math . sin ( angle ) ; } } } break ; case BYELEMENTPOSITION : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; case BYELEMENTINDEX : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( float ) i / ( float ) numElements + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; default : throw new RuntimeException ( " Unknown adaptor type : " + adaptorType + " . The method setAdaptor() only accepts RGroup.BYPOINT or RGroup.BYELEMENT as parameter values. " ) ; } return result ; } 
private void append ( RGeomElem elem ) { RGeomElem [ ] newelements ; if ( elements = = null ) { newelements = new RGeomElem [ 1 ] ; newelements [ 0 ] = elem ; } else { newelements = new RGeomElem [ this . elements . length + 1 ] ; System . arraycopy ( this . elements , 0 , newelements , 0 , this . elements . length ) ; newelements [ this . elements . length ] = elem ; } this . elements = newelements ; } 
private void extract ( int i ) throws RuntimeException { RGeomElem [ ] newelements ; if ( elements = = null ) { throw new RuntimeException ( " The group is empty. No elements to remove. " ) ; } else { if ( i < 0 ) { throw new RuntimeException ( " Negative values for indexes are not valid. " ) ; } if ( i > elements . length - 1 ) { throw new RuntimeException ( " Index out of the bounds of the group. You are trying to erase an element with an index higher than the number of elements in the group. " ) ; } if ( elements . length = = 1 ) { newelements = null ; } else if ( i = = 0 ) { newelements = new RGeomElem [ this . elements . length - 1 ] ; System . arraycopy ( this . elements , 1 , newelements , 0 , this . elements . length - 1 ) ; } else if ( i = = elements . length - 1 ) { newelements = new RGeomElem [ this . elements . length - 1 ] ; System . arraycopy ( this . elements , 0 , newelements , 0 , this . elements . length - 1 ) ; } else { newelements = new RGeomElem [ this . elements . length - 1 ] ; System . arraycopy ( this . elements , 0 , newelements , 0 , i ) ; System . arraycopy ( this . elements , i + 1 , newelements , i , this . elements . length - i - 1 ) ; } } this . elements = newelements ; } 
protected void add ( float x , float y ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ 0 ] . append ( new RPoint ( x , y ) ) ; } 
protected void add ( RPoint p ) { if ( contours = = null ) { this . append ( new RContour ( ) ) ; } this . contours [ 0 ] . append ( p ) ; } 
protected void add ( RContour c ) { this . append ( c ) ; } 
protected boolean isEmpty ( ) { return ( this . contours = = null ) ; } 
public boolean isHole ( ) { if ( this . contours = = null | | this . contours . length > 1 ) { throw new IllegalStateException ( " Cannot call on a poly made up of more than one poly. " ) ; } return this . contours [ 0 ] . isHole ; } 
protected boolean isContributing ( int polyIndex ) { return this . contours [ polyIndex ] . isContributing ; } 
private void append ( RContour nextcontour ) { RContour [ ] newcontours ; if ( contours = = null ) { newcontours = new RContour [ 1 ] ; newcontours [ 0 ] = nextcontour ; currentContour = 0 ; } else { newcontours = new RContour [ this . contours . length + 1 ] ; System . arraycopy ( this . contours , 0 , newcontours , 0 , this . contours . length ) ; newcontours [ this . contours . length ] = nextcontour ; currentContour + + ; } this . contours = newcontours ; } 
public static void init ( PApplet _parent ) { parent = _parent ; initialized = true ; } 
protected void calculateCurveLengths ( ) { lenCurves = new float [ countElements ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { lenCurves [ i ] = elements [ i ] . getCurveLength ( ) ; 
private RCommand [ ] splitCubicBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 4 ] [ 4 ] ; for ( int i = 0 ; i < = 3 ; i + + ) { for ( int j = 0 ; j < = 3 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 3; i++){ triangleMatrix[0][i].x = controlPoints[i].x; triangleMatrix[0][i].y = controlPoints[i].y; } Triangle computation for(int i = 1; i <= 3; i++){ for(int j = 0; j <= 3 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier4(triangleMatrix[0][0], triangleMatrix[1][0], triangleMatrix[2][0], triangleMatrix[3][0]); result[1] = createBezier4(triangleMatrix[3][0], triangleMatrix[2][1], triangleMatrix[1][2], triangleMatrix[0][3]); return result; } 
private RCommand [ ] splitQuadBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 3 ] [ 3 ] ; for ( int i = 0 ; i < = 2 ; i + + ) { for ( int j = 0 ; j < = 2 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 2; i++){ triangleMatrix[0][i] = controlPoints[i]; } Triangle computation for(int i = 1; i <= 2; i++){ for(int j = 0; j <= 2 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier3(triangleMatrix[0][0], triangleMatrix[1][0], triangleMatrix[2][0]); result[1] = createBezier3(triangleMatrix[2][0], triangleMatrix[1][1], triangleMatrix[0][2]); return result; } 
private RCommand [ ] splitLine ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 2 ] [ 2 ] ; for ( int i = 0 ; i < = 1 ; i + + ) { for ( int j = 0 ; j < = 1 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 1; i++){ triangleMatrix[0][i] = controlPoints[i]; } Triangle computation for(int i = 1; i <= 1; i++){ for(int j = 0; j <= 1 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createLine(triangleMatrix[0][0], triangleMatrix[1][0]); result[1] = createLine(triangleMatrix[1][0], triangleMatrix[0][1]); return result; } 
public void transform ( RMatrix m ) { RPoint [ ] ps = getHandles ( ) ; if ( ps ! = null ) { for ( int i = 0 ; i < ps . length ; i + + ) { 
public RGroup adaptTo ( RSubshape sshp , float wght , float lngthOffset ) throws RuntimeException { RGroup result = new RGroup ( this ) ; RContour c = result . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; int numElements = result . countElements ( ) ; switch ( adaptorType ) { case BYPOINT : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RPoint [ ] ps = elem . getHandles ( ) ; if ( ps ! = null ) { for ( int k = 0 ; k < ps . length ; k + + ) { float px = ps [ k ] . x ; float py = ps [ k ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; float amp = ( ymax - py ) ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) - ( float ) Math . PI / 2F ; ps [ k ] . x = p . x + wght * amp * ( float ) Math . cos ( angle ) ; ps [ k ] . y = p . y + wght * amp * ( float ) Math . sin ( angle ) ; } } } break ; case BYELEMENTPOSITION : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; case BYELEMENTINDEX : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( float ) i / ( float ) numElements + lngthOffset ) % 1F ; RPoint tg = sshp . getCurveTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; default : throw new RuntimeException ( " Unknown adaptor type : " + adaptorType + " . The method setAdaptor() only accepts RGroup.BYPOINT or RGroup.BYELEMENT as parameter values. " ) ; } return result ; } 
public RShape toShape ( ) { int numContours = countContours ( ) ; RShape result = new RShape ( ) ; for ( int i = 0 ; i < numContours ; i + + ) { RPoint [ ] newpoints = this . contours [ i ] . getHandles ( ) ; if ( newpoints ! = null ) { result . addMoveTo ( newpoints [ 0 ] ) ; for ( int j = 1 ; j < newpoints . length ; j + + ) { result . addLineTo ( newpoints [ j ] ) ; } if ( contours [ i ] . closed ) { result . addClose ( ) ; } result . subshapes [ i ] . setStyle ( contours [ i ] ) ; } } result . setStyle ( this ) ; return result ; } 
public void draw ( PGraphics g ) { RPoint [ ] points = getPoints ( ) ; if ( points = = null ) { return ; } g . beginShape ( ) ; for ( int i = 0 ; i < points . length ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( ) ; } 
public void draw ( PApplet a ) { RPoint [ ] points = getPoints ( ) ; if ( points = = null ) { return ; } a . beginShape ( ) ; for ( int i = 0 ; i < points . length ; i + + ) { a . vertex ( points [ i ] . x , points [ i ] . y ) ; } a . endShape ( ) ; } 
public RPolygon toPolygon ( ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getPoints ( ) ; RContour c = new RContour ( newpoints ) ; c . closed = subshapes [ i ] . closed ; c . setStyle ( subshapes [ i ] ) ; result . addContour ( c ) ; } result . setStyle ( this ) ; return result ; } 
public void draw ( PGraphics g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getPoints(); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? RGeomerative.parent().CLOSE : RGeomerative.parent().OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void draw ( PApplet g ) { int numCommands = countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getPoints(); RCommand.setSegmentator(lastSegmentator); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? RGeomerative.parent().CLOSE : RGeomerative.parent().OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public RGroup adaptTo ( RSubshape sshp , float wght , float lngthOffset ) throws RuntimeException { RGroup result = new RGroup ( this ) ; RContour c = result . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; int numElements = result . countElements ( ) ; switch ( adaptorType ) { case BYPOINT : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RPoint [ ] ps = elem . getHandles ( ) ; if ( ps ! = null ) { for ( int k = 0 ; k < ps . length ; k + + ) { float px = ps [ k ] . x ; float py = ps [ k ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; float amp = ( ymax - py ) ; RPoint tg = sshp . getTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) - ( float ) Math . PI / 2F ; ps [ k ] . x = p . x + wght * amp * ( float ) Math . cos ( angle ) ; ps [ k ] . y = p . y + wght * amp * ( float ) Math . sin ( angle ) ; } } } break ; case BYELEMENTPOSITION : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; RPoint tg = sshp . getTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; case BYELEMENTINDEX : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( float ) i / ( float ) numElements + lngthOffset ) % 1F ; RPoint tg = sshp . getTangent ( ) ; RPoint p = sshp . getCurvePoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; default : throw new RuntimeException ( " Unknown adaptor type : " + adaptorType + " . The method setAdaptor() only accepts RGroup.BYPOINT or RGroup.BYELEMENT as parameter values. " ) ; } return result ; } 
public RGroup adaptTo ( RSubshape sshp , float wght , float lngthOffset ) throws RuntimeException { RGroup result = new RGroup ( this ) ; RContour c = result . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; int numElements = result . countElements ( ) ; switch ( adaptorType ) { case BYPOINT : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RPoint [ ] ps = elem . getHandles ( ) ; if ( ps ! = null ) { for ( int k = 0 ; k < ps . length ; k + + ) { float px = ps [ k ] . x ; float py = ps [ k ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; float amp = ( ymax - py ) ; RPoint tg = sshp . getTangent ( ) ; RPoint p = sshp . getPoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) - ( float ) Math . PI / 2F ; ps [ k ] . x = p . x + wght * amp * ( float ) Math . cos ( angle ) ; ps [ k ] . y = p . y + wght * amp * ( float ) Math . sin ( angle ) ; } } } break ; case BYELEMENTPOSITION : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( px - xmin ) / ( xmax - xmin ) + lngthOffset ) % 1F ; RPoint tg = sshp . getTangent ( ) ; RPoint p = sshp . getPoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; case BYELEMENTINDEX : for ( int i = 0 ; i < numElements ; i + + ) { RGeomElem elem = result . elements [ i ] ; RContour elemc = elem . getBounds ( ) ; float px = ( elemc . points [ 2 ] . x + elemc . points [ 0 ] . x ) / 2 ; float py = elemc . points [ 2 ] . y ; float = ( ( float ) i / ( float ) numElements + lngthOffset ) % 1F ; RPoint tg = sshp . getTangent ( ) ; RPoint p = sshp . getPoint ( ) ; float angle = ( float ) Math . atan2 ( tg . y , tg . x ) ; RPoint pletter = new RPoint ( px , 0 ) ; p . sub ( pletter ) ; RMatrix mtx = new RMatrix ( ) ; mtx . translate ( p ) ; mtx . rotate ( angle , pletter ) ; mtx . scale ( wght , pletter ) ; elem . transform ( mtx ) ; } break ; default : throw new RuntimeException ( " Unknown adaptor type : " + adaptorType + " . The method setAdaptor() only accepts RGroup.BYPOINT or RGroup.BYELEMENT as parameter values. " ) ; } return result ; } 
private void quadBezierAdaptative ( ) { addCurvePoint ( new RPoint ( startPoint ) ) ; quadBezierAdaptativeRecursive ( startPoint . x , startPoint . y , controlPoints [ 0 ] . x , controlPoints [ 0 ] . y , endPoint . x , endPoint . y , 0 ) ; addCurvePoint ( new RPoint ( endPoint ) ) ; } 
private void cubicBezierUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx1 = controlPoints[0].x - startPoint.x; float dy1 = controlPoints[0].y - startPoint.y; float dx2 = controlPoints[1].x - controlPoints[0].x; float dy2 = controlPoints[1].y - controlPoints[0].y; float dx3 = endPoint.x - controlPoints[1].x; float dy3 = endPoint.y - controlPoints[1].y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1) + (float)Math.sqrt(dx2 * dx2 + dy2 * dy2) + (float)Math.sqrt(dx3 * dx3 + dy3 * dy3); steps = (int)(len * 0.25); if(steps < 4) { steps = 4; } } float dt = 1F/steps; float fx, fy, fdx, fdy, fddx, fddy, fdddx, fdddy, fdd_per_2x, fdd_per_2y, fddd_per_2x, fddd_per_2y, fddd_per_6x, fddd_per_6y; float temp = dt * dt; fx = startPoint.x; fdx = 3F * (controlPoints[0].x - startPoint.x) * dt; fdd_per_2x = 3F * (startPoint.x - 2F * controlPoints[0].x + controlPoints[1].x) * temp; fddd_per_2x = 3F * (3F * (controlPoints[0].x - controlPoints[1].x) + endPoint.x - startPoint.x) * temp * dt; fdddx = fddd_per_2x + fddd_per_2x; fddx = fdd_per_2x + fdd_per_2x; fddd_per_6x = fddd_per_2x * (1.0F / 3F); fy = startPoint.y; fdy = 3F * (controlPoints[0].y - startPoint.y) * dt; fdd_per_2y = 3F * (startPoint.y - 2F * controlPoints[0].y + controlPoints[1].y) * temp; fddd_per_2y = 3F * (3F * (controlPoints[0].y - controlPoints[1].y) + endPoint.y - startPoint.y) * temp * dt; fdddy = fddd_per_2y + fddd_per_2y; fddy = fdd_per_2y + fdd_per_2y; fddd_per_6y = fddd_per_2y * (1.0F / 3F); for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx + fdd_per_2x + fddd_per_6x; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fdy + fdd_per_2y + fddd_per_6y; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } addCurvePoint(new RPoint(endPoint)); } 
private void cubicBezierUniformLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y , fix , fiy ; float temp = dt * dt ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop + + ) { fix = fdx + fdd_per_2x + fddd_per_6x ; fiy = fdy + fdd_per_2y + fddd_per_6y ; untilPoint - = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fiy; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
private void append ( RPoint nextcontrolpoint ) { RPoint [ ] newcontrolPoints ; if ( controlPoints = = null ) { newcontrolPoints = new RPoint [ 1 ] ; newcontrolPoints [ 0 ] = nextcontrolpoint ; } else { newcontrolPoints = new RPoint [ controlPoints . length + 1 ] ; System . arraycopy ( controlPoints , 0 , newcontrolPoints , 0 , controlPoints . length ) ; newcontrolPoints [ controlPoints . length ] = nextcontrolpoint ; } this . controlPoints = newcontrolPoints ; } 
private float [ ] indAndAdvAt ( float ) { int indOfElement = 0 ; float [ ] lengthsCurves = getCurveLengths ( ) ; float lengthCurve = getCurveLength ( ) ; while ( > accumulatedAdvancement ) { indOfElement + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCurves [ indOfElement ] / lengthCurve ) ; } float advOfElement = ( - prevAccumulatedAdvancement ) / ( lengthsCurves [ indOfElement ] / lengthCurve ) ; float [ ] indAndAdv = new float [ 2 ] ; indAndAdv [ 0 ] = indOfElement ; indAndAdv [ 1 ] = advOfElement ; return indAndAdv ; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; RSubshape [ ] splittedShapes = subshapes [ indOfElement ] . split ( advOfElement ) ; result [ 0 ] = new RShape ( ) ; for ( int i = 0 ; i < indOfElement ; i + + ) { result [ 0 ] . addSubshape ( new RSubshape ( subshapes [ i ] ) ) ; } result [ 0 ] . addSubshape ( new RSubshape ( splittedShapes [ 0 ] ) ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . addSubshape ( new RSubshape ( splittedShapes [ 1 ] ) ) ; for ( int i = indOfElement + 1 ; i < countSubshapes ( ) ; i + + ) { result [ 1 ] . addSubshape ( new RSubshape ( subshapes [ i ] ) ) ; } result [ 1 ] . setStyle ( this ) ; return result ; } 
public RSubshape [ ] split ( float ) { RSubshape [ ] result = new RSubshape [ 2 ] ; int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RSubshape ( ) ; result [ 1 ] = new RSubshape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RSubshape ( this ) ; result [ 1 ] = new RSubshape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indOfElement].split(advOfElement); result[0] = new RSubshape(); for(int i = 0; i<indOfElement; i++){ result[0].addCommand(new RCommand(commands[i])); } result[0].addCommand(new RCommand(splittedCommands[0])); result[0].setStyle(this); result[1] = new RSubshape(); for(int i = indOfElement + 1; i < countCommands(); i++){ result[1].addCommand(new RCommand(commands[i])); } result[1].addCommand(new RCommand(splittedCommands[1])); result[1].setStyle(this); return result; } 
private float [ ] indAndAdvAt ( float ) { int indOfElement = 0 ; float [ ] lengthsCurves = getCurveLengths ( ) ; float lengthCurve = getCurveLength ( ) ; while ( > accumulatedAdvancement ) { indOfElement + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCurves [ indOfElement ] / lengthCurve ) ; } float advOfElement = ( - prevAccumulatedAdvancement ) / ( lengthsCurves [ indOfElement ] / lengthCurve ) ; float [ ] indAndAdv = new float [ 2 ] ; indAndAdv [ 0 ] = indOfElement ; indAndAdv [ 1 ] = advOfElement ; return indAndAdv ; } 
private void append ( RCommand nextcommand ) { RCommand [ ] newcommands ; if ( commands = = null ) { newcommands = new RCommand [ 1 ] ; newcommands [ 0 ] = nextcommand ; } else { newcommands = new RCommand [ this . commands . length + 1 ] ; System . arraycopy ( this . commands , 0 , newcommands , 0 , this . commands . length ) ; newcommands [ this . commands . length ] = nextcommand ; } this . commands = newcommands ; } 
private int quad ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addQuadTo ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ) ; return i + 3 ; } 
private int smoothQuad ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addQuadTo ( refp . x , refp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ) ; return i + 1 ; } 
private int cubic ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i + 4 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 4 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ) ; return i + 5 ; } 
private int smoothCubic ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( refp . x , refp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y , RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; curp . setLocation ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 2 ] ) + relp . x , RGeomerative . parent ( ) . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( RGeomerative . parent ( ) . parseFloat ( tags [ i ] ) + relp . x ) , 2.0f * curp . y - ( RGeomerative . parent ( ) . parseFloat ( tags [ i + 1 ] ) + relp . y ) ) ; return i + 3 ; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RContour c = this . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; int numElements = this . countElements ( ) ; switch ( RGeomerative . adaptorType ) { case RGeomerative . BYPOINT : 
public void adapt ( RShape shp ) throws RuntimeException { adapt ( shp , RGeomerative . adaptorScale , RGeomerative . adaptorLengthOffset ) ; } 
public RGroup adaptAll ( RShape shp ) throws RuntimeException { RGroup result = new RGroup ( ) ; int numSubshapes = shp . countSubshapes ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RGroup tempresult = new RGroup ( this ) ; tempresult . adapt ( shp . subshapes [ i ] . toShape ( ) ) ; int numElements = tempresult . countElements ( ) ; for ( int j = 0 ; j < numElements ; j + + ) { result . addElement ( tempresult . elements [ j ] ) ; } } return result ; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RContour c = this . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymin = c . points [ 0 ] . y ; float ymax = c . points [ 2 ] . y ; switch ( RGeomerative . adaptorType ) { case RGeomerative . BYPOINT : 
public void insertSplit ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; subshapes [ indOfElement ] . insertSplit ( advOfElement ) ; return ; } 
public void insertSplitAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return null ; } for ( int i = 0 ; i < numSubshapes ; i + + ) { subshapes [ indOfElement ] . insertSplit ( advOfElement ) ; } return ; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; RSubshape [ ] splittedShapes = subshapes [ indOfElement ] . split ( advOfElement ) ; result [ 0 ] = new RShape ( ) ; for ( int i = 0 ; i < indOfElement ; i + + ) { result [ 0 ] . addSubshape ( new RSubshape ( subshapes [ i ] ) ) ; } result [ 0 ] . addSubshape ( new RSubshape ( splittedShapes [ 0 ] ) ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . addSubshape ( new RSubshape ( splittedShapes [ 1 ] ) ) ; for ( int i = indOfElement + 1 ; i < countSubshapes ( ) ; i + + ) { result [ 1 ] . addSubshape ( new RSubshape ( subshapes [ i ] ) ) ; } result [ 1 ] . setStyle ( this ) ; return result ; } 
public void insertSplit ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indOfElement].split(advOfElement); } 
private RCommand [ ] splitCubicBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 4 ] [ 4 ] ; for ( int i = 0 ; i < = 3 ; i + + ) { for ( int j = 0 ; j < = 3 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 3; i++){ triangleMatrix[0][i].x = controlPoints[i].x; triangleMatrix[0][i].y = controlPoints[i].y; } Triangle computation for(int i = 1; i <= 3; i++){ for(int j = 0; j <= 3 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier4(startPoint, triangleMatrix[1][0], triangleMatrix[2][0], triangleMatrix[3][0]); result[1] = createBezier4(triangleMatrix[3][0], triangleMatrix[2][1], triangleMatrix[1][2], endPoint); return result; } 
private RCommand [ ] splitQuadBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 3 ] [ 3 ] ; for ( int i = 0 ; i < = 2 ; i + + ) { for ( int j = 0 ; j < = 2 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 2; i++){ triangleMatrix[0][i] = controlPoints[i]; } Triangle computation for(int i = 1; i <= 2; i++){ for(int j = 0; j <= 2 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier3(startPoint, triangleMatrix[1][0], triangleMatrix[2][0]); result[1] = createBezier3(triangleMatrix[2][0], triangleMatrix[1][1], endPoint); return result; } 
private RCommand [ ] splitLine ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 2 ] [ 2 ] ; for ( int i = 0 ; i < = 1 ; i + + ) { for ( int j = 0 ; j < = 1 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] controlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 1; i++){ triangleMatrix[0][i] = controlPoints[i]; } Triangle computation for(int i = 1; i <= 1; i++){ for(int j = 0; j <= 1 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createLine(startPoint, triangleMatrix[1][0]); result[1] = createLine(triangleMatrix[1][0], endPoint); return result; } 
public void insertSplitAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return ; } for ( int i = 0 ; i < numSubshapes ; i + + ) { subshapes [ i ] . insertSplitAll ( ) ; } return ; } 
public void insertSplit ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indOfElement].split(advOfElement); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( indOfElement ); Insert the splittedCommands insert( splittedCommands[1], indOfElement ); insert( splittedCommands[0], indOfElement ); return; } 
public void insertSplitAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numCommands = countCommands ( ) ; for ( int i = 0 ; i < numCommands * 2 ; i + = 2 ) { Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[i].split(t); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( i ); Insert the splittedCommands insert( splittedCommands[1], i ); insert( splittedCommands[0], i ); } return; } 
private void insert ( RCommand newcommand , int i ) throws RuntimeException { if ( i < 0 ) { throw new RuntimeException ( " Negative values for indexes are not valid. " ) ; } RCommand [ ] newcommands ; if ( commands = = null ) { newcommands = new RCommand [ 1 ] ; newcommands [ 0 ] = newcommand ; } else { if ( i > commands . length ) { throw new RuntimeException ( " Index out of the bounds. You are trying to insert an element with an index higher than the number of commands in the group. " ) ; } newcommands = new RCommand [ this . commands . length + 1 ] ; System . arraycopy ( this . commands , 0 , newcommands , 0 , i ) ; newcommands [ i ] = newcommand ; System . arraycopy ( this . commands , i , newcommands , i + 1 , this . commands . length - i ) ; } this . commands = newcommands ; } 
private void extract ( int i ) throws RuntimeException { RCommand [ ] newcommands ; if ( commands = = null ) { throw new RuntimeException ( " The group is empty. No commands to remove. " ) ; } else { if ( i < 0 ) { throw new RuntimeException ( " Negative values for indexes are not valid. " ) ; } if ( i > commands . length - 1 ) { throw new RuntimeException ( " Index out of the bounds of the group. You are trying to erase an element with an index higher than the number of commands in the group. " ) ; } if ( commands . length = = 1 ) { newcommands = null ; } else if ( i = = 0 ) { newcommands = new RCommand [ this . commands . length - 1 ] ; System . arraycopy ( this . commands , 1 , newcommands , 0 , this . commands . length - 1 ) ; } else if ( i = = commands . length - 1 ) { newcommands = new RCommand [ this . commands . length - 1 ] ; System . arraycopy ( this . commands , 0 , newcommands , 0 , this . commands . length - 1 ) ; } else { newcommands = new RCommand [ this . commands . length - 1 ] ; System . arraycopy ( this . commands , 0 , newcommands , 0 , i ) ; System . arraycopy ( this . commands , i + 1 , newcommands , i , this . commands . length - i - 1 ) ; } } this . commands = newcommands ; } 
public void insertSplit ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; subshapes [ indOfElement ] . insertSplit ( advOfElement ) ; Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertSplitAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return ; } for ( int i = 0 ; i < numSubshapes ; i + + ) { subshapes [ i ] . insertSplitAll ( ) ; } Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertSplit ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indOfElement].split(advOfElement); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( indOfElement ); Insert the splittedCommands insert( splittedCommands[1], indOfElement ); insert( splittedCommands[0], indOfElement ); Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertSplitAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numCommands = countCommands ( ) ; for ( int i = 0 ; i < numCommands * 2 ; i + = 2 ) { Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[i].split(t); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( i ); Insert the splittedCommands insert( splittedCommands[1], i ); insert( splittedCommands[0], i ); } Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertHandle ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; subshapes [ indOfElement ] . insertHandle ( advOfElement ) ; Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertHandleAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return ; } for ( int i = 0 ; i < numSubshapes ; i + + ) { subshapes [ i ] . insertHandleAll ( ) ; } Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertHandle ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indOfElement].split(advOfElement); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( indOfElement ); Insert the splittedCommands insert( splittedCommands[1], indOfElement ); insert( splittedCommands[0], indOfElement ); Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertHandleAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numCommands = countCommands ( ) ; for ( int i = 0 ; i < numCommands * 2 ; i + = 2 ) { Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[i].split(t); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( i ); Insert the splittedCommands insert( splittedCommands[1], i ); insert( splittedCommands[0], i ); } Clear the cache lenCurves = null; lenCurve = 0F; return; } 
public void insertHandle ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; subshapes [ indOfElement ] . insertHandle ( advOfElement ) ; Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public void insertHandleAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return ; } for ( int i = 0 ; i < numSubshapes ; i + + ) { subshapes [ i ] . insertHandleAll ( ) ; } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public void insertHandle ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indOfElement].split(advOfElement); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( indOfElement ); Insert the splittedCommands insert( splittedCommands[1], indOfElement ); insert( splittedCommands[0], indOfElement ); Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public void insertHandleAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numCommands = countCommands ( ) ; for ( int i = 0 ; i < numCommands * 2 ; i + = 2 ) { Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[i].split(t); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( i ); Insert the splittedCommands insert( splittedCommands[1], i ); insert( splittedCommands[0], i ); } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public static RMesh polygonToMesh ( RPolygon s ) { RPolygon empty = new RPolygon ( ) ; RPolygon s_clean = s . removeOpenContours ( ) ; PolygonNode very_clean = clip ( OperationType . GPC_UNION , s_clean , empty ) ; if ( very_clean = = null ) { return new RMesh ( ) ; 
private static RMesh polygonNodeToMesh ( PolygonNode tlist ) { PolygonNode tn , tnn ; VertexNode rt , lt , ltn , rtn ; for ( lt = tn . v_left ; lt ! = null ; lt = ltn ) { ltn = lt . next ; } for ( rt = tn . v_right ; rt ! = null ; rt = rtn ) { rtn = rt . next ; } } } } return result ; } 
private static int PREV_INDEX ( int i , int ) { return ( ( i - 1 + ) % ) ; } 
private static int NEXT_INDEX ( int i , int ) { return ( ( i + 1 ) % ) ; } 
private static boolean OPTIMAL ( RPoint [ ] p , int i ) { return p [ PREV_INDEX ( i , p . length ) ] . y ! = p [ i ] . y | | p [ NEXT_INDEX ( i , p . length ) ] . y ! = p [ i ] . y ; 
private static float P_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { d = e ; do { td = d . prev ; } while ( d . outp_above = = null ) ; return d . bot_x + d . dx * ( j - d . bot_y ) ; } 
private static float N_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { d = e ; do { td = d . next ; } while ( d . outp_above = = null ) ; return d . bot_x + d . dx * ( j - d . bot_y ) ; } 
private static void minimax_test ( RPolygon subj , RPolygon clip , OperationType op ) { RRectangle [ ] s_bbox = create_contour_bboxes ( subj ) ; RRectangle [ ] c_bbox = create_contour_bboxes ( clip ) ; int subj_num_poly = subj . getNumInnerPoly ( ) ; int clip_num_poly = clip . getNumInnerPoly ( ) ; boolean [ ] [ ] o_table = new boolean [ subj_num_poly ] [ clip_num_poly ] ; for ( int c = 0 ; c < clip_num_poly ; c + + ) { boolean overlap = false ; for ( int s = 0 ; ! overlap & & ( s < subj_num_poly ) ; s + + ) { overlap = o_table [ s ] [ c ] ; } if ( ! overlap ) { clip . setContributing ( c , false ) ; Flag non contributing status } } if (op == OperationType.GPC_INT) { 
private static PolygonNode new_tristrip ( PolygonNode po_node , EdgeNode edge , float x , float y ) { if ( po_node = = null ) { po_node . next = new_tristrip ( po_node . next , edge , x , y ) ; } return po_node ; } 
public void add_right ( float x , float y ) { VertexNode nv = new VertexNode ( x , y ) ; proxy . v_right = nv ; } 
public void add_left ( float x , float y ) { VertexNode nv = new VertexNode ( x , y ) ; proxy . v_left = nv ; } 
public int count_contours ( ) { int nc = 0 ; for ( PolygonNode polygon = top_node ; ( polygon ! = null ) ; polygon = polygon . next ) { if ( polygon . active ! = 0 ) { VertexNode nextv = null ; for (VertexNode v= polygon.proxy.v_left; (v != null); v = nextv) { nextv= v.next; v = null ; } polygon.active= 0; } } } return nc; } 
public void addNode ( float x , float y ) { EdgeNode node = new EdgeNode ( ) ; node . vertex_x = x ; node . vertex_y = y ; m_List [ len ] = node ; len + + ; } 
public boolean FWD_MIN ( int i ) { EdgeNode prev = m_List [ PREV_INDEX ( i , len ) ] ; EdgeNode next = m_List [ NEXT_INDEX ( i , len ) ] ; EdgeNode ith = m_List [ i ] ; return ( ( prev . vertex_y > = ith . vertex_y ) & & ( next . vertex_y > ith . vertex_y ) ) ; 
public boolean NOT_FMAX ( int i ) { EdgeNode next = m_List [ NEXT_INDEX ( i , len ) ] ; EdgeNode ith = m_List [ i ] ; return ( next . vertex_y > ith . vertex_y ) ; } 
public boolean REV_MIN ( int i ) { EdgeNode prev = m_List [ PREV_INDEX ( i , len ) ] ; EdgeNode next = m_List [ NEXT_INDEX ( i , len ) ] ; EdgeNode ith = m_List [ i ] ; return ( ( prev . vertex_y > ith . vertex_y ) & & ( next . vertex_y > = ith . vertex_y ) ) ; 
public boolean NOT_RMAX ( int i ) { EdgeNode prev = m_List [ PREV_INDEX ( i , len ) ] ; EdgeNode ith = m_List [ i ] ; return ( prev . vertex_y > ith . vertex_y ) ; } 
public float [ ] build_sbt ( ) { float [ ] sbt = new float [ sbt_entries ] ; int entries = 0 ; entries = inner_build_sbt ( entries , sbt , sb_tree ) ; if ( entries ! = sbt_entries ) { throw new IllegalStateException ( " Something went wrong buildign sbt from tree. " ) ; } return sbt ; } 
public void addPoints ( RPoint [ ] morePoints ) { if ( points = = null ) { this . points = morePoints ; 
public void addPoints ( List morePoints ) { int start = 0 ; if ( points = = null ) { this . points = new RPoint [ morePoints . size ( ) ] ; } else { RPoint [ ] newPoints = new RPoint [ this . points . length + morePoints . size ( ) ] ; System . arraycopy ( this . points , 0 , newPoints , 0 , this . points . length ) ; this . points = newPoints ; start = morePoints . size ( ) ; } it would be nice to be able to access the ArrayList's internal array! for(int i = start, j = 0; i < points.length; i++) { points[i] = (RPoint)morePoints.get(j); 
public static void main ( String [ ] args ) { TestSuite suite = new TestSuite ( ClipTest . class ) ; TestResult result = new TestResult ( ) ; suite . run ( result ) ; if ( result . failureCount ( ) = = 0 & & result . errorCount ( ) = = 0 ) { System . out . println ( " Tests Passed! " ) ; } for ( Enumeration failures = result . failures ( ) ; failures . hasMoreElements ( ) ; ) { TestFailure failure = ( TestFailure ) failures . nextElement ( ) ; System . out . println ( failure ) ; } for ( Enumeration errors = result . errors ( ) ; errors . hasMoreElements ( ) ; ) { TestFailure error = ( TestFailure ) errors . nextElement ( ) ; 
public void testCorrectness ( ) { System . out . println ( " running test " ) ; RPolygon a = makeShape ( 50 ) ; RPolygon b = makeShape ( 60 ) ; Fastness f = new Fastness ( ) ; int = 10 ; RPolygon slow_int = null , slow_union = null , slow_xor = null , slow_diff = null ; RPolygon fast_int = null , fast_union = null , fast_xor = null , fast_diff = null ; f . record ( " slow intersection " ) ; for ( int i = 0 ; i < ; i + + ) { slow_int = RClip . intersection ( a , b ) ; } f . record ( " slow union " ) ; for ( int i = 0 ; i < ; i + + ) { slow_union = RClip . union ( a , b ) ; } f . record ( " slow xor " ) ; for ( int i = 0 ; i < ; i + + ) { slow_xor = RClip . xor ( a , b ) ; } f . record ( " slow diff " ) ; for ( int i = 0 ; i < ; i + + ) { slow_diff = RClip . diff ( a , b ) ; } f . record ( " fast int " ) ; for ( int i = 0 ; i < ; i + + ) { fast_int = FastRClip . intersection ( a , b ) ; } f . record ( " fast union " ) ; for ( int i = 0 ; i < ; i + + ) { fast_union = FastRClip . union ( a , b ) ; } f . record ( " fast xor " ) ; for ( int i = 0 ; i < ; i + + ) { fast_xor = FastRClip . xor ( a , b ) ; } f . record ( " fast diff " ) ; for ( int i = 0 ; i < ; i + + ) { fast_diff = FastRClip . diff ( a , b ) ; } f . stop ( ) ; f . print ( ) ; checkPoints ( slow_int , fast_int ) ; checkPoints ( slow_union , fast_union ) ; checkPoints ( slow_xor , fast_xor ) ; checkPoints ( slow_diff , fast_diff ) ; } 
private void checkPoints ( RPolygon slow , RPolygon fast ) { RPoint [ ] slowp = slow . getPoints ( ) ; RPoint [ ] fastp = fast . getPoints ( ) ; assertEquals ( slowp . length , fastp . length ) ; int minlen = Math . min ( slowp . length , fastp . length ) ; robustness is pessimism for(int i = 0; i < minlen; i++) { assertClose(slowp[i].x, fastp[i].x); 
private void assertClose ( float v1 , float v2 ) { assertTrue ( Math . abs ( v1 - v2 ) < 0.0000000000001 ) ; scientifix } 
RPolygon makeShape ( int numPoints ) { Random r = new Random ( ) ; r . setSeed ( numPoints ) ; RPoint [ ] points = new RPoint [ numPoints ] ; for ( int i = 0 ; i < numPoints ; i + + ) { points [ i ] = new RPoint ( r . nextFloat ( ) * 100 , r . nextFloat ( ) * 100 ) ; } return new RPolygon ( points ) . update ( ) ; } 
public void record ( String name ) { long now = System . currentTimeMillis ( ) ; if ( lastName ! = null ) { recordings . add ( new Recording ( lastName , now - lastRecordStart ) ) ; } lastName = name ; lastRecordStart = now ; } 
public void stop ( ) { record ( " " ) ; lastName = null ; } 
public void clear ( ) { recordings . clear ( ) ; lastName = null ; } 
public void print ( ) { stop ( ) ; for ( Recording r : recordings ) { System . out . println ( r ) ; 
public String toString ( ) { return name + " " + length ; } 
static public RPolygon createCircle ( float x , float y , float radius , int detail ) { RPoint [ ] points = new RPoint [ detail ] ; double radiansPerStep = 2 * Math . PI / detail ; for ( int i = 0 ; i < detail ; i + + ) { points [ i ] = new RPoint ( radius * Math . cos ( i * radiansPerStep ) + x , radius * Math . sin ( i * radiansPerStep ) + y ) ; } return new RPolygon ( points ) ; } 
static public RPolygon createStar ( float x , float y , float radiusBig , float radiusSmall , int spikes ) { int numPoints = spikes * 2 ; RPoint [ ] points = new RPoint [ numPoints ] ; double radiansPerStep = Math . PI / spikes ; for ( int i = 0 ; i < numPoints ; i + = 2 ) { points [ i ] = new RPoint ( radiusBig * Math . cos ( i * radiansPerStep ) + x , radiusBig * Math . sin ( i * radiansPerStep ) + y ) ; points [ i + 1 ] = new RPoint ( radiusSmall * Math . cos ( i * radiansPerStep ) + x , radiusSmall * Math . sin ( i * radiansPerStep ) + y ) ; } return new RPolygon ( points ) ; } 
static public RPolygon createRing ( float x , float y , float radiusBig , float radiusSmall , int detail ) { RPoint [ ] inner = new RPoint [ detail ] ; RPoint [ ] outer = new RPoint [ detail ] ; double radiansPerStep = 2 * Math . PI / detail ; for ( int i = 0 ; i < detail ; i + + ) { inner [ i ] = new RPoint ( radiusSmall * Math . cos ( i * radiansPerStep ) + x , radiusSmall * Math . sin ( i * radiansPerStep ) + y ) ; outer [ i ] = new RPoint ( radiusBig * Math . cos ( i * radiansPerStep ) + x , radiusBig * Math . sin ( i * radiansPerStep ) + y ) ; } RPolygon ring = new RPolygon ( ) ; ring . addContour ( outer ) ; ring . addContour ( inner ) ; return ring ; } 
public void addContour ( RPoint [ ] points ) { this . append ( new RContour ( points ) ) ; } 
private static boolean OPTIMAL ( RPolygon p , int i ) { return ( p . getY ( PREV_INDEX ( i , p . getNumPoints ( ) ) ) ! = p . getY ( i ) ) | | ( p . getY ( NEXT_INDEX ( i , p . getNumPoints ( ) ) ) ! = p . getY ( i ) ) ; 
private static void VERTEX ( EdgeNode e , int p , int s , float x , float y ) { if ( p = = ABOVE ) { if ( s = = RIGHT ) { 
private static float P_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { if ( p = = ABOVE ) { 
private static float N_EDGE ( EdgeNode d , EdgeNode e , int p , float i , float j ) { if ( p = = ABOVE ) { 
private static void minimax_test ( RPolygon subj , RPolygon clip , OperationType op ) { RRectangle [ ] s_bbox = create_contour_bboxes ( subj ) ; RRectangle [ ] c_bbox = create_contour_bboxes ( clip ) ; int subj_num_poly = subj . getNumInnerPoly ( ) ; int clip_num_poly = clip . getNumInnerPoly ( ) ; boolean [ ] [ ] o_table = new boolean [ subj_num_poly ] [ clip_num_poly ] ; for ( int c = 0 ; c < clip_num_poly ; c + + ) { boolean overlap = false ; for ( int s = 0 ; ! overlap & & ( s < subj_num_poly ) ; s + + ) { overlap = o_table [ s ] [ c ] ; } if ( ! overlap ) { clip . setContributing ( c , false ) ; Flag non contributing status } } if (op == OperationType.GPC_INT) { 
private static void add_to_sbtree ( ScanBeamTreeEntries sbte , float y ) { if ( sbte . sb_tree = = null ) { sbte . sb_tree = new ScanBeamTree ( y ) ; sbte . sbt_entries + + ; return ; } ScanBeamTree tree_node = sbte . sb_tree ; boolean done = false ; while ( ! done ) { 
private static StNode add_st_edge ( StNode st , ItNodeTable it , EdgeNode edge , float dy ) { if ( st = = null ) { st . prev = add_st_edge ( st . prev , it , edge , dy ) ; } } return st ; } 
private static ItNode add_intersection ( ItNode it_node , EdgeNode edge0 , EdgeNode edge1 , float x , float y ) { if ( it_node = = null ) { it_node . next = add_intersection ( it_node . next , edge0 , edge1 , x , y ) ; } } return it_node ; } 
public PolygonNode add_local_min ( float x , float y ) { PolygonNode existing_min = top_node ; top_node = new PolygonNode ( existing_min , x , y ) ; return top_node ; } 
public void merge_left ( PolygonNode p , PolygonNode q ) { q . proxy . hole = true ; if ( p . proxy ! = q . proxy ) { 
public void merge_right ( PolygonNode p , PolygonNode q ) { q . proxy . hole = false ; if ( p . proxy ! = q . proxy ) { 
public int count_contours ( ) { int nc = 0 ; for ( PolygonNode polygon = top_node ; ( polygon ! = null ) ; polygon = polygon . next ) { if ( polygon . active ! = 0 ) { VertexNode nextv = null; for (VertexNode v= polygon.proxy.v_left; (v != null); v = nextv) { nextv= v.next; v = null; } polygon.active= 0; } } } return nc; } 
public void print ( ) { System . out . println ( " ---- out_poly ---- " ) ; int c = 0 ; PolygonNode npoly_node = null ; for ( PolygonNode poly_node = top_node ; ( poly_node ! = null ) ; poly_node = npoly_node ) { 
public void print ( ) { System . out . println ( " " ) ; System . out . println ( " aet " ) ; for ( EdgeNode edge = top_node ; ( edge ! = null ) ; edge = edge . next ) { 
public void addNode ( float x , float y ) { EdgeNode node = new EdgeNode ( ) ; node . vertex_x = x ; node . vertex_y = y ; edges . add ( node ) ; } 
public boolean FWD_MIN ( int i ) { EdgeNode prev = ( EdgeNode ) edges . get ( PREV_INDEX ( i , edges . size ( ) ) ) ; EdgeNode next = ( EdgeNode ) edges . get ( NEXT_INDEX ( i , edges . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) edges . get ( i ) ; return ( ( prev . vertex_y > = ith . vertex_y ) & & ( next . vertex_y > ith . vertex_y ) ) ; 
public boolean NOT_FMAX ( int i ) { EdgeNode next = ( EdgeNode ) edges . get ( NEXT_INDEX ( i , edges . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) edges . get ( i ) ; return ( next . vertex_y > ith . vertex_y ) ; } 
public boolean REV_MIN ( int i ) { EdgeNode prev = ( EdgeNode ) edges . get ( PREV_INDEX ( i , edges . size ( ) ) ) ; EdgeNode next = ( EdgeNode ) edges . get ( NEXT_INDEX ( i , edges . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) edges . get ( i ) ; return ( ( prev . vertex_y > ith . vertex_y ) & & ( next . vertex_y > = ith . vertex_y ) ) ; 
public boolean NOT_RMAX ( int i ) { EdgeNode prev = ( EdgeNode ) edges . get ( PREV_INDEX ( i , edges . size ( ) ) ) ; EdgeNode ith = ( EdgeNode ) edges . get ( i ) ; return ( prev . vertex_y > ith . vertex_y ) ; } 
public void print ( ) { int = 0 ; LmtNode lmt = top_node ; while ( lmt ! = null ) { 
public float [ ] build_sbt ( ) { float [ ] sbt = new float [ sbt_entries ] ; int entries = 0 ; entries = inner_build_sbt ( entries , sbt , sb_tree ) ; if ( entries ! = sbt_entries ) { throw new IllegalStateException ( " Something went wrong buildign sbt from tree. " ) ; } return sbt ; } 
private int inner_build_sbt ( int entries , float [ ] sbt , ScanBeamTree sbt_node ) { if ( sbt_node . less ! = null ) { entries = inner_build_sbt ( entries , sbt , sbt_node . less ) ; } sbt [ entries ] = sbt_node . y ; entries + + ; if ( sbt_node . more ! = null ) { entries = inner_build_sbt ( entries , sbt , sbt_node . more ) ; } return entries ; } 
public void build_intersection_table ( AetTree aet , float dy ) { StNode st = null ; for ( EdgeNode edge = aet . top_node ; ( edge ! = null ) ; edge = edge . next ) { 
private static void print_sbt ( float [ ] sbt ) { System . out . println ( " " ) ; System . out . println ( " sbt.length= " + sbt . length ) ; for ( int i = 0 ; i < sbt . length ; i + + ) { 
public void testCorrectness ( ) { System . out . println ( " running test " ) ; RPolygon a = makeShape ( 50 ) ; RPolygon b = makeShape ( 60 ) ; Fastness f = new Fastness ( ) ; int = 10 ; RPolygon slow_int = null , slow_union = null , slow_xor = null , slow_diff = null ; RPolygon fast_int = null , fast_union = null , fast_xor = null , fast_diff = null ; RGeomerative . useFastClip = false ; f . record ( " slow intersection " ) ; for ( int i = 0 ; i < ; i + + ) { slow_int = RClip . intersection ( a , b ) ; } f . record ( " slow union " ) ; for ( int i = 0 ; i < ; i + + ) { slow_union = RClip . union ( a , b ) ; } f . record ( " slow xor " ) ; for ( int i = 0 ; i < ; i + + ) { slow_xor = RClip . xor ( a , b ) ; } f . record ( " slow diff " ) ; for ( int i = 0 ; i < ; i + + ) { slow_diff = RClip . diff ( a , b ) ; } RGeomerative . useFastClip = true ; f . record ( " fast int " ) ; for ( int i = 0 ; i < ; i + + ) { fast_int = RClip . intersection ( a , b ) ; } f . record ( " fast union " ) ; for ( int i = 0 ; i < ; i + + ) { fast_union = RClip . union ( a , b ) ; } f . record ( " fast xor " ) ; for ( int i = 0 ; i < ; i + + ) { fast_xor = RClip . xor ( a , b ) ; } f . record ( " fast diff " ) ; for ( int i = 0 ; i < ; i + + ) { fast_diff = RClip . diff ( a , b ) ; } f . stop ( ) ; f . print ( ) ; checkPoints ( slow_int , fast_int ) ; checkPoints ( slow_union , fast_union ) ; checkPoints ( slow_xor , fast_xor ) ; checkPoints ( slow_diff , fast_diff ) ; } 
public void testOldMeshing ( ) { RGeomerative . useFastClip = true ; RMesh mesh = RClip . polygonToMesh ( poly ) ; assertNotNull ( mesh ) ; } 
public void testNewMeshing ( ) { RGeomerative . useFastClip = true ; RMesh mesh = RClip . polygonToMesh ( poly ) ; assertNotNull ( mesh ) ; } 
static void print_sbt ( float [ ] sbt ) { System . out . println ( " " ) ; System . out . println ( " sbt.length= " + sbt . length ) ; for ( int i = 0 ; i < sbt . length ; i + + ) { 
public RCommand [ ] split ( float ) { switch ( commandType ) { case LINETO : return splitLine ( ) ; case QUADBEZIERTO : return splitQuadBezier ( ) ; case CUBICBEZIERTO : return splitCubicBezier ( ) ; } return null ; } 
private RCommand [ ] splitCubicBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 4 ] [ 4 ] ; for ( int i = 0 ; i < = 3 ; i + + ) { for ( int j = 0 ; j < = 3 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 3; i++){ triangleMatrix[0][i].x = ctrlPoints[i].x; triangleMatrix[0][i].y = ctrlPoints[i].y; } Triangle computation for(int i = 1; i <= 3; i++){ for(int j = 0; j <= 3 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier4(startPoint, triangleMatrix[1][0], triangleMatrix[2][0], triangleMatrix[3][0]); result[1] = createBezier4(triangleMatrix[3][0], triangleMatrix[2][1], triangleMatrix[1][2], endPoint); return result; } 
private RCommand [ ] splitQuadBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 3 ] [ 3 ] ; for ( int i = 0 ; i < = 2 ; i + + ) { for ( int j = 0 ; j < = 2 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 2; i++){ triangleMatrix[0][i] = ctrlPoints[i]; } Triangle computation for(int i = 1; i <= 2; i++){ for(int j = 0; j <= 2 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier3(startPoint, triangleMatrix[1][0], triangleMatrix[2][0]); result[1] = createBezier3(triangleMatrix[2][0], triangleMatrix[1][1], endPoint); return result; } 
private RCommand [ ] splitLine ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 2 ] [ 2 ] ; for ( int i = 0 ; i < = 1 ; i + + ) { for ( int j = 0 ; j < = 1 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 1; i++){ triangleMatrix[0][i] = ctrlPoints[i]; } Triangle computation for(int i = 1; i <= 1; i++){ for(int j = 0; j <= 1 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createLine(startPoint, triangleMatrix[1][0]); result[1] = createLine(triangleMatrix[1][0], endPoint); return result; } 
private void lineUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx = endPoint.x - startPoint.x; float dy = endPoint.y - startPoint.y; float len = (float)Math.sqrt(dx * dx + dy * dy); steps = (int)(len * 0.25); if(steps < 4) steps = 4; } float dt = 1F/steps; float fx, fy, fdx, fdy; fx = startPoint.x; fdx = (endPoint.x - startPoint.x) * dt; fy = startPoint.y; fdy = (endPoint.y - startPoint.y) * dt; for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx; fy = fy + fdy; } addCurvePoint(new RPoint(endPoint)); } 
private float quadBezierLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y , fix , fiy ; float temp = dt * dt ; float totallen = 0F ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop < = steps ; loop + + ) { fix = fdx + fdd_per_2x ; fiy = fdy + fdd_per_2y ; totallen + = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx; fy = fy + fiy; fdy = fdy + fddy; } return totallen; } 
public void draw ( PGraphics g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( closed ? PConstants . CLOSE : PConstants . OPEN ) ; if ( beforeFill ) g . fill ( g . fillColor ) ; 
public void draw ( PApplet g ) { int numPoints = countPoints ( ) ; boolean beforeFill = g . g . fill ; g . noFill ( ) ; g . beginShape ( ) ; for ( int i = 0 ; i < numPoints ; i + + ) { g . vertex ( points [ i ] . x , points [ i ] . y ) ; } g . endShape ( closed ? PConstants . CLOSE : PConstants . OPEN ) ; if ( beforeFill ) g . fill ( g . g . fillColor ) ; 
protected void calculateCurveLengths ( ) { PApplet . println ( " Feature not yet implemented for this class. " ) ; } 
public static boolean initialized ( ) { return initialized ; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RContour c = this . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymax = c . points [ 2 ] . y ; int numElements = this . countElements ( ) ; switch ( RGeomerative . adaptorType ) { case RGeomerative . BYPOINT : 
public void draw ( PGraphics g ) { for ( int i = 0 ; i < this . countStrips ( ) ; i + + ) { g . beginShape ( PConstants . TRIANGLE_STRIP ) ; 
public void draw ( PApplet g ) { for ( int i = 0 ; i < this . countStrips ( ) ; i + + ) { g . beginShape ( PConstants . TRIANGLE_STRIP ) ; 
private int move ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addMoveTo ( PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; strp . setLocation ( curp . x , curp . y ) ; relp.setLocation(0F, 0F); return i + 1; } 
private int curve ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y , PApplet . parseFloat ( tags [ i + 2 ] ) + relp . x , PApplet . parseFloat ( tags [ i + 3 ] ) + relp . y , PApplet . parseFloat ( tags [ i + 4 ] ) + relp . x , PApplet . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; curp . setLocation ( PApplet . parseFloat ( tags [ i + 4 ] ) + relp . x , PApplet . parseFloat ( tags [ i + 5 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( PApplet . parseFloat ( tags [ i + 2 ] ) + relp . x ) , 2.0f * curp . y - ( PApplet . parseFloat ( tags [ i + 3 ] ) + relp . y ) ) ; return i + 5 ; } 
private int smooth ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addBezierTo ( refp . x , refp . y , PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y , PApplet . parseFloat ( tags [ i + 2 ] ) + relp . x , PApplet . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; curp . setLocation ( PApplet . parseFloat ( tags [ i + 2 ] ) + relp . x , PApplet . parseFloat ( tags [ i + 3 ] ) + relp . y ) ; refp . setLocation ( 2.0f * curp . x - ( PApplet . parseFloat ( tags [ i ] ) + relp . x ) , 2.0f * curp . y - ( PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y ) ) ; return i + 3 ; } 
private int line ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i + 1 ; } 
private int horizontal ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( PApplet . parseFloat ( tags [ i ] ) + relp . x , curp . y ) ; curp . setLocation ( PApplet . parseFloat ( tags [ i ] ) + relp . x , curp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i ; } 
private int vertical ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( curp . x , PApplet . parseFloat ( tags [ i ] ) + relp . y ) ; curp . setLocation ( curp . x , PApplet . parseFloat ( tags [ i ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i ; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RContour c = this . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; switch ( RGeomerative . adaptorType ) { case RGeomerative . BYPOINT : 
public void draw ( PGraphics g ) { int numVertices = countVertices ( ) ; g . beginShape ( PConstants . TRIANGLE_STRIP ) ; for ( int i = 0 ; i < numVertices ; i + + ) { g . vertex ( vertices [ i ] . x , vertices [ i ] . y ) ; } g . endShape ( ) ; } 
public void draw ( PGraphics g ) { countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getPoints(); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? PConstants.CLOSE : PConstants.OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void draw ( PApplet g ) { countCommands ( ) ; By default always draw with an adaptative segmentator int lastSegmentator = RCommand.segmentType; RCommand.setSegmentator(RCommand.ADAPTATIVE); RPoint[] points = getPoints(); RCommand.setSegmentator(lastSegmentator); if(points == null){ return; } g.beginShape(); for(int i=0;i<points.length;i++){ g.vertex(points[i].x,points[i].y); } g.endShape(closed ? PConstants.CLOSE : PConstants.OPEN); Restore the user set segmentator RCommand.setSegmentator(lastSegmentator); } 
public void testOldMeshing ( ) { RGeomerative . useFastClip = false ; RMesh mesh = RClip . polygonToMesh ( poly ) ; assertNotNull ( mesh ) ; } 
public boolean contains ( RPoint p ) { PApplet . println ( " Feature not yet implemented for this class. " ) ; return false ; } 
public boolean contains ( RPoint p ) { boolean result = false ; for ( int i = 0 ; i < countElements ( ) ; i + + ) { result | = elements [ i ] . contains ( p ) ; } return result ; } 
public RMesh toMesh ( ) { if ( contours = = null ) { return new RMesh ( ) ; } RMesh mesh = RClip . polygonToMesh ( this ) ; if ( mesh ! = null ) { mesh . setStyle ( this ) ; } return mesh ; } 
public boolean contains ( RPoint p ) { RPoint [ ] [ ] pointpaths = getPointPaths ( ) ; if ( pointpaths = = null ) { return false ; } RPoint [ ] verts = pointpaths [ 0 ] ; for ( int k = 1 ; k < pointpaths . length ; k + + ) { verts = ( RPoint [ ] ) RGeomerative . parent ( ) . append ( verts , new RPoint ( 0F , 0F ) ) ; verts = ( RPoint [ ] ) RGeomerative . parent ( ) . concat ( verts , pointpaths [ k ] ) ; } verts = ( RPoint [ ] ) RGeomerative . parent ( ) . append ( verts , new RPoint ( 0F , 0F ) ) ; if ( verts = = null ) { return false ; } float testx = p . x ; float testy = p . y ; int nvert = verts . length ; int i , j = 0 ; boolean c = false ; for ( i = 0 , j = nvert - 1 ; i < nvert ; j = i + + ) { if ( ( ( verts [ i ] . y > testy ) ! = ( verts [ j ] . y > testy ) ) & & ( testx < ( verts [ j ] . x - verts [ i ] . x ) * ( testy - verts [ i ] . y ) / ( verts [ j ] . y - verts [ i ] . y ) + verts [ i ] . x ) ) { c = ! c ; } } return c ; } 
public boolean contains ( RPoint p ) { RPoint [ ] verts = getPoints ( ) ; if ( verts = = null ) { return false ; } float testx = p . x ; float testy = p . y ; int nvert = verts . length ; int i , j = 0 ; boolean c = false ; for ( i = 0 , j = nvert - 1 ; i < nvert ; j = i + + ) { if ( ( ( verts [ i ] . y > testy ) ! = ( verts [ j ] . y > testy ) ) & & ( testx < ( verts [ j ] . x - verts [ i ] . x ) * ( testy - verts [ i ] . y ) / ( verts [ j ] . y - verts [ i ] . y ) + verts [ i ] . x ) ) c = ! c ; } return c ; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RContour bbox = getBounds(); float xmin = bbox.points[0].x; float xmax = bbox.points[2].x; float ymin = bbox.points[0].y; float ymax = bbox.points[2].y; if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in elements boolean result = false; for(int i = 0;i<countElements();i++){ result |= elements[i].contains(p); } return result; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RContour bbox = getBounds(); float xmin = bbox.points[0].x; float xmax = bbox.points[2].x; float ymin = bbox.points[0].y; float ymax = bbox.points[2].y; if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in shape RPoint[][] pointpaths = getPointPaths(); if(pointpaths == null){ return false; } RPoint[] verts = pointpaths[0]; for(int k=1;k<pointpaths.length;k++){ verts = (RPoint[])RGeomerative.parent().append(verts, new RPoint(0F, 0F)); verts = (RPoint[])RGeomerative.parent().concat(verts, pointpaths[k]); } verts = (RPoint[])RGeomerative.parent().append(verts, new RPoint(0F, 0F)); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ){ c = !c; } } return c; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RContour bbox = getBounds(); float xmin = bbox.points[0].x; float xmax = bbox.points[2].x; float ymin = bbox.points[0].y; float ymax = bbox.points[2].y; if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in subshape RPoint[] verts = getPoints(); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ) c = !c; } return c; } 
public RMesh toMesh ( ) { if ( contours = = null ) { return new RMesh ( ) ; } if ( this . cachedMesh = = null ) { System.out.println("Creating cached mesh"); this.cachedMesh = RClip.polygonToMesh( this ); } RMesh mesh = new RMesh( this.cachedMesh ); if ( mesh != null ) { mesh.setStyle( this ); } return mesh; } 
public RPolygon toPolygon ( ) { if ( this . cachedPolygon = = null ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getPoints ( ) ; RContour c = new RContour ( newpoints ) ; c . closed = subshapes [ i ] . closed ; c . setStyle ( subshapes [ i ] ) ; result . addContour ( c ) ; } this . cachedPolygon = result ; } RPolygon polygon = new RPolygon ( this . cachedPolygon ) ; polygon . setStyle ( this ) ; return polygon ; } 
public RMesh toMesh ( ) { if ( contours = = null ) { return new RMesh ( ) ; } if ( this . cachedMesh = = null ) { System.out.println( "Creating cached mesh / id:" + this.id ); this.cachedMesh = RClip.polygonToMesh( this ); } RMesh mesh = this.cachedMesh; if ( mesh == null ) { return null; } mesh.setStyle( this ) ; return mesh; } 
public void print ( ) { System . out . println ( " polygon: " ) ; for ( int i = 0 ; i < countContours ( ) ; i + + ) { 
public RPolygon toPolygon ( ) { if ( this . cachedPolygon = = null ) { int numSubshapes = countSubshapes ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numSubshapes ; i + + ) { RPoint [ ] newpoints = this . subshapes [ i ] . getPoints ( ) ; RContour c = new RContour ( newpoints ) ; c . closed = subshapes [ i ] . closed ; c . setStyle ( subshapes [ i ] ) ; result . addContour ( c ) ; } this . cachedPolygon = result ; } RPolygon polygon = this . cachedPolygon ; polygon . setStyle ( this ) ; return polygon ; } 
public void transform ( float x , float y , float w , float h , boolean keepAspectRatio ) { RMatrix mtx = new RMatrix ( ) ; RContour orig = this . getBounds ( ) ; float orig_w = orig . points [ 2 ] . x - orig . points [ 0 ] . x ; float orig_h = orig . points [ 2 ] . y - orig . points [ 0 ] . y ; mtx . translate ( - orig . points [ 0 ] . x , - orig . points [ 0 ] . y ) ; if ( keepAspectRatio ) { mtx . scale ( Math . min ( w / orig_w , h / orig_h ) ) ; } else { mtx . scale ( w / orig_w , h / orig_h ) ; } mtx . translate ( x , y ) ; this . transform ( mtx ) ; return ; } 
public void transform ( float x , float y , float w , float h ) { this . transform ( x , y , w , h , true ) ; return ; } 
public RShape toShape ( ) { return new RShape ( new RPath ( this ) ) ; } 
public RPath [ ] split ( float ) { RPath [ ] result = new RPath [ 2 ] ; int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RPath ( ) ; result [ 1 ] = new RPath ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RPath ( this ) ; result [ 1 ] = new RPath ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[indOfElement].split(advOfElement); result[0] = new RPath(); for(int i = 0; i<indOfElement; i++){ result[0].addCommand(new RCommand(commands[i])); } result[0].addCommand(new RCommand(splittedCommands[0])); result[0].setStyle(this); result[1] = new RPath(); for(int i = indOfElement + 1; i < countCommands(); i++){ result[1].addCommand(new RCommand(commands[i])); } result[1].addCommand(new RCommand(splittedCommands[1])); result[1].setStyle(this); return result; } 
public void addSubshape ( ) { this . append ( new RPath ( ) ) ; } 
public void addMoveTo ( float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RPath ( endx , endy ) ) ; 
public void addLineTo ( float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RPath ( ) ) ; } this . subshapes [ currentSubshape ] . addLineTo ( endx , endy ) ; } 
public void addQuadTo ( float cp1x , float cp1y , float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RPath ( ) ) ; } this . subshapes [ currentSubshape ] . addQuadTo ( cp1x , cp1y , endx , endy ) ; } 
public void addBezierTo ( float cp1x , float cp1y , float cp2x , float cp2y , float endx , float endy ) { if ( subshapes = = null ) { this . append ( new RPath ( ) ) ; } this . subshapes [ currentSubshape ] . addBezierTo ( cp1x , cp1y , cp2x , cp2y , endx , endy ) ; } 
public void addClose ( ) { if ( subshapes = = null ) { this . append ( new RPath ( ) ) ; } this . subshapes [ currentSubshape ] . addClose ( ) ; } 
public RShape [ ] splitAll ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; for ( int i = 0 ; i < countSubshapes ( ) ; i + + ) { RPath [ ] splittedSubshapes = subshapes [ i ] . split ( ) ; if ( splittedSubshapes ! = null ) { result [ 0 ] . addSubshape ( splittedSubshapes [ 0 ] ) ; result [ 1 ] . addSubshape ( splittedSubshapes [ 1 ] ) ; } } result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; int numSubshapes = countSubshapes ( ) ; if ( numSubshapes = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; RPath [ ] splittedShapes = subshapes [ indOfElement ] . split ( advOfElement ) ; result [ 0 ] = new RShape ( ) ; for ( int i = 0 ; i < indOfElement ; i + + ) { result [ 0 ] . addSubshape ( new RPath ( subshapes [ i ] ) ) ; } result [ 0 ] . addSubshape ( new RPath ( splittedShapes [ 0 ] ) ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . addSubshape ( new RPath ( splittedShapes [ 1 ] ) ) ; for ( int i = indOfElement + 1 ; i < countSubshapes ( ) ; i + + ) { result [ 1 ] . addSubshape ( new RPath ( subshapes [ i ] ) ) ; } result [ 1 ] . setStyle ( this ) ; return result ; } 
private void append ( RPath nextsubshape ) { RPath [ ] newsubshapes ; if ( subshapes = = null ) { newsubshapes = new RPath [ 1 ] ; newsubshapes [ 0 ] = nextsubshape ; currentSubshape = 0 ; } else { newsubshapes = new RPath [ this . subshapes . length + 1 ] ; System . arraycopy ( this . subshapes , 0 , newsubshapes , 0 , this . subshapes . length ) ; newsubshapes [ this . subshapes . length ] = nextsubshape ; currentSubshape + + ; } this . subshapes = newsubshapes ; } 
public RShape toShape ( ) throws RuntimeException { throw new RuntimeException("Transforming a Group to a Shape is not yet implemented."); RShape result = new RShape(); for(int i=0;i<countElements();i++){ RShape currentShape = elements[i].toShape(); for(int j=0;j<currentShape.countPaths();j++){ result.addPath(currentShape.paths[j]); } } result.setStyle(this); return result; } 
private float [ ] indAndAdvAt ( float ) { int indOfElement = 0 ; float [ ] lengthsCurves = getCurveLengths ( ) ; float lengthCurve = getCurveLength ( ) ; while ( > accumulatedAdvancement ) { indOfElement + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCurves [ indOfElement ] / lengthCurve ) ; } float advOfElement = ( - prevAccumulatedAdvancement ) / ( lengthsCurves [ indOfElement ] / lengthCurve ) ; float [ ] indAndAdv = new float [ 2 ] ; indAndAdv [ 0 ] = indOfElement ; indAndAdv [ 1 ] = advOfElement ; return indAndAdv ; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RContour bbox = getBounds(); float xmin = bbox.points[0].x; float xmax = bbox.points[2].x; float ymin = bbox.points[0].y; float ymax = bbox.points[2].y; if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in path RPoint[] verts = getPoints(); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ) c = !c; } return c; } 
private float [ ] indAndAdvAt ( float ) { int indOfElement = 0 ; float [ ] lengthsCurves = getCurveLengths ( ) ; float lengthCurve = getCurveLength ( ) ; while ( > accumulatedAdvancement ) { indOfElement + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCurves [ indOfElement ] / lengthCurve ) ; } float advOfElement = ( - prevAccumulatedAdvancement ) / ( lengthsCurves [ indOfElement ] / lengthCurve ) ; float [ ] indAndAdv = new float [ 2 ] ; indAndAdv [ 0 ] = indOfElement ; indAndAdv [ 1 ] = advOfElement ; return indAndAdv ; } 
public RShape toShape ( ) { int numContours = countContours ( ) ; RShape result = new RShape ( ) ; for ( int i = 0 ; i < numContours ; i + + ) { RPoint [ ] newpoints = this . contours [ i ] . getHandles ( ) ; if ( newpoints ! = null ) { result . addMoveTo ( newpoints [ 0 ] ) ; for ( int j = 1 ; j < newpoints . length ; j + + ) { result . addLineTo ( newpoints [ j ] ) ; } if ( contours [ i ] . closed ) { result . addClose ( ) ; } result . paths [ i ] . setStyle ( contours [ i ] ) ; } } result . setStyle ( this ) ; return result ; } 
static public RShape createRing ( float x , float y , float radiusBig , float radiusSmall ) { RShape ring = new RShape ( ) ; RShape outer = RShape . createCircle ( x , y , radiusBig ) ; RShape inner = RShape . createCircle ( x , y , - radiusSmall ) ; ring . addPath ( outer . paths [ 0 ] ) ; ring . addPath ( inner . paths [ 0 ] ) ; return ring ; } 
public int countPaths ( ) { if ( this . paths = = null ) { return 0 ; } return this . paths . length ; } 
public void addShape ( RShape s ) { for ( int i = 0 ; i < s . countPaths ( ) ; i + + ) { this . append ( s . paths [ i ] ) ; 
public void addMoveTo ( float endx , float endy ) { if ( paths = = null ) { this . append ( new RPath ( endx , endy ) ) ; 
public void addLineTo ( float endx , float endy ) { if ( paths = = null ) { this . append ( new RPath ( ) ) ; } this . paths [ currentPath ] . addLineTo ( endx , endy ) ; } 
public void addQuadTo ( float cp1x , float cp1y , float endx , float endy ) { if ( paths = = null ) { this . append ( new RPath ( ) ) ; } this . paths [ currentPath ] . addQuadTo ( cp1x , cp1y , endx , endy ) ; } 
public void addBezierTo ( float cp1x , float cp1y , float cp2x , float cp2y , float endx , float endy ) { if ( paths = = null ) { this . append ( new RPath ( ) ) ; } this . paths [ currentPath ] . addBezierTo ( cp1x , cp1y , cp2x , cp2y , endx , endy ) ; } 
public void addClose ( ) { if ( paths = = null ) { this . append ( new RPath ( ) ) ; } this . paths [ currentPath ] . addClose ( ) ; } 
public RPolygon toPolygon ( ) { if ( this . cachedPolygon = = null ) { int numPaths = countPaths ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newpoints = this . paths [ i ] . getPoints ( ) ; RContour c = new RContour ( newpoints ) ; c . closed = paths [ i ] . closed ; c . setStyle ( paths [ i ] ) ; result . addContour ( c ) ; } this . cachedPolygon = result ; } RPolygon polygon = this . cachedPolygon ; polygon . setStyle ( this ) ; return polygon ; } 
public RShape [ ] splitAll ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { RPath [ ] splittedPaths = paths [ i ] . split ( ) ; if ( splittedPaths ! = null ) { result [ 0 ] . addPath ( splittedPaths [ 0 ] ) ; result [ 1 ] . addPath ( splittedPaths [ 1 ] ) ; } } result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } 
public void insertHandle ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; paths [ indOfElement ] . insertHandle ( advOfElement ) ; Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public void insertHandleAll ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numPaths = countPaths ( ) ; if ( numPaths = = 0 ) { return ; } for ( int i = 0 ; i < numPaths ; i + + ) { paths [ i ] . insertHandleAll ( ) ; } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; int numPaths = countPaths ( ) ; if ( numPaths = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; RPath [ ] splittedShapes = paths [ indOfElement ] . split ( advOfElement ) ; result [ 0 ] = new RShape ( ) ; for ( int i = 0 ; i < indOfElement ; i + + ) { result [ 0 ] . addPath ( new RPath ( paths [ i ] ) ) ; } result [ 0 ] . addPath ( new RPath ( splittedShapes [ 0 ] ) ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . addPath ( new RPath ( splittedShapes [ 1 ] ) ) ; for ( int i = indOfElement + 1 ; i < countPaths ( ) ; i + + ) { result [ 1 ] . addPath ( new RPath ( paths [ i ] ) ) ; } result [ 1 ] . setStyle ( this ) ; return result ; } 
public void print ( ) { System . out . println ( " paths [count " + this . countPaths ( ) + " ]: " ) ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { 
protected void calculateCurveLengths ( ) { lenCurves = new float [ countPaths ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { lenCurves [ i ] = paths [ i ] . getCurveLength ( ) ; 
private void append ( RPath nextpath ) { RPath [ ] newpaths ; if ( paths = = null ) { newpaths = new RPath [ 1 ] ; newpaths [ 0 ] = nextpath ; currentPath = 0 ; } else { newpaths = new RPath [ this . paths . length + 1 ] ; System . arraycopy ( this . paths , 0 , newpaths , 0 , this . paths . length ) ; newpaths [ this . paths . length ] = nextpath ; currentPath + + ; } this . paths = newpaths ; } 
private void drawUsingInternalTesselator ( PGraphics g ) { int numPaths = countPaths ( ) ; if ( numPaths ! = 0 ) { if ( isIn ( g ) ) { 
private void drawUsingInternalTesselator ( PApplet p ) { int numPaths = countPaths ( ) ; if ( numPaths ! = 0 ) { if ( isIn ( p ) ) { 
private void drawUsingBreakShape ( PGraphics g ) { int numPaths = countPaths ( ) ; if ( numPaths ! = 0 ) { if ( isIn ( g ) ) { 
private void drawUsingBreakShape ( PApplet g ) { int numPaths = countPaths ( ) ; if ( numPaths ! = 0 ) { if ( isIn ( g ) ) { 
public void insertHandleInPaths ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numCommands = countCommands ( ) ; for ( int i = 0 ; i < numCommands * 2 ; i + = 2 ) { Split the affected command and reconstruct each of the shapes RCommand[] splittedCommands = commands[i].split(t); if(splittedCommands[0] == null || splittedCommands[1] == null) { return; } Extract the splitted command extract( i ); Insert the splittedCommands insert( splittedCommands[1], i ); insert( splittedCommands[0], i ); } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RContour bbox = getBounds(); float xmin = bbox.points[0].x; float xmax = bbox.points[2].x; float ymin = bbox.points[0].y; float ymax = bbox.points[2].y; if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in shape RPoint[][] pointpaths = getPointsInPaths(); if(pointpaths == null){ return false; } RPoint[] verts = pointpaths[0]; for(int k=1;k<pointpaths.length;k++){ verts = (RPoint[])RGeomerative.parent().append(verts, new RPoint(0F, 0F)); verts = (RPoint[])RGeomerative.parent().concat(verts, pointpaths[k]); } verts = (RPoint[])RGeomerative.parent().append(verts, new RPoint(0F, 0F)); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ){ c = !c; } } return c; } 
public RShape [ ] splitPaths ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { RPath [ ] splittedPaths = paths [ i ] . split ( ) ; if ( splittedPaths ! = null ) { result [ 0 ] . addPath ( splittedPaths [ 0 ] ) ; result [ 1 ] . addPath ( splittedPaths [ 1 ] ) ; } } result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } 
public void insertHandleInPaths ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numPaths = countPaths ( ) ; if ( numPaths = = 0 ) { return ; } for ( int i = 0 ; i < numPaths ; i + + ) { paths [ i ] . insertHandleInPaths ( ) ; } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public static void loadFont ( String font , int size ) { fntLoader = new RFont ( font , size ) ; } 
public static RGroup loadText ( String font , String text , int size ) { RFont tempFntLoader = new RFont ( font , size ) ; return tempFntLoader . toGroup ( text ) ; } 
public static RGroup loadText ( String text ) { if ( fntLoader = = null ) { throw new FontNotLoadedException ( ) ; } return fntLoader . toGroup ( text ) ; } 
public static RGroup loadSVG ( String filename ) { RSVG svgLoader = new RSVG ( ) ; return svgLoader . toGroup ( filename ) ; } 
public static void beginShape ( ) { shape = new RShape ( ) ; } 
public static void vertex ( float x , float y ) { if ( path = = null ) { if ( shape . countPaths ( ) = = 0 ) { 
public static void bezierVertex ( float cx1 , float cy1 , float cx2 , float cy2 , float x , float y ) { if ( path = = null ) { if ( shape . countPaths ( ) = = 0 ) { 
public static void endShape ( PGraphics g ) { if ( group = = null ) { We are not inside a beginGroup shape.draw(g); }else{ We are inside a beginGroup group.addElement(shape); shape = null; } shape = null; } 
public static void endShape ( ) { shape . draw ( ) ; shape = null ; } 
public static void breakShape ( ) { shape . addPath ( ) ; shapeBegin = true ; } 
public static void breakShape ( int endMode ) { if ( endMode = = CLOSE ) { shape . addClose ( ) ; } breakShape ( ) ; } 
protected void saveContext ( ) { saveContext ( RG . parent ( ) ) ; } 
protected void restoreContext ( ) { restoreContext ( RG . parent ( ) ) ; } 
public void draw ( PGraphics g ) { if ( ! RG . ignoreStyles ) { saveContext ( g ) ; setContext ( g ) ; } for ( int i = 0 ; i < countElements ( ) ; i + + ) { elements [ i ] . draw ( g ) ; } if ( ! RG . ignoreStyles ) { restoreContext ( g ) ; 
public void draw ( PApplet a ) { if ( ! RG . ignoreStyles ) { saveContext ( a ) ; setContext ( a ) ; } for ( int i = 0 ; i < countElements ( ) ; i + + ) { elements [ i ] . draw ( a ) ; } if ( ! RG . ignoreStyles ) { restoreContext ( a ) ; 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RContour c = this . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymax = c . points [ 2 ] . y ; int numElements = this . countElements ( ) ; switch ( RG . adaptorType ) { case RG . BYPOINT : 
public void adapt ( RShape shp ) throws RuntimeException { adapt ( shp , RG . adaptorScale , RG . adaptorLengthOffset ) ; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RContour bbox = getBounds(); float xmin = bbox.points[0].x; float xmax = bbox.points[2].x; float ymin = bbox.points[0].y; float ymax = bbox.points[2].y; if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in shape RPoint[][] pointpaths = getPointsInPaths(); if(pointpaths == null){ return false; } RPoint[] verts = pointpaths[0]; for(int k=1;k<pointpaths.length;k++){ verts = (RPoint[])RG.parent().append(verts, new RPoint(0F, 0F)); verts = (RPoint[])RG.parent().concat(verts, pointpaths[k]); } verts = (RPoint[])RG.parent().append(verts, new RPoint(0F, 0F)); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ){ c = !c; } } return c; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RContour c = this . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; switch ( RG . adaptorType ) { case RG . BYPOINT : 
public static RGroup loadText ( String text , String font , int size , int align ) { RFont tempFntLoader = new RFont ( font , size , align ) ; return tempFntLoader . toGroup ( text ) ; } 
public RMesh toMesh ( ) { if ( contours = = null ) { return new RMesh ( ) ; } RMesh mesh = RClip . polygonToMesh ( this ) ; if ( mesh = = null ) { return null ; } mesh . setStyle ( this ) ; return mesh ; } 
public RPolygon toPolygon ( ) { int numPaths = countPaths ( ) ; RPolygon result = new RPolygon ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newpoints = this . paths [ i ] . getPoints ( ) ; RContour c = new RContour ( newpoints ) ; c . closed = paths [ i ] . closed ; c . setStyle ( paths [ i ] ) ; result . addContour ( c ) ; } result . setStyle ( this ) ; return result ; } 
public void polygonize ( ) { RGroup grp = toPolygonGroup ( ) . toShapeGroup ( ) ; this . elements = grp . elements ; } 
public void setup ( ) { size ( 800 , 600 ) ; smooth ( ) ; g . smooth = true ; VERY IMPORTANT: Allways initialize the library before using it RG.init(this); grp = RG.loadSVG("pirata.svg"); grp.centerIn(g);} 
public void draw ( ) { background ( 255 ) ; We decided the separation between the polygon points dependent of the mouseX float pointSeparation = map(constrain(mouseX, 200, width-200), 200, width-200, 5, 300); We create the polygonized version RCommand.setSegmentator(RG.UNIFORMLENGTH); RCommand.setSegmentLength(pointSeparation); polyGrp = grp.toPolygonGroup(); We move ourselves to the mouse position translate(mouseX, mouseY); We draw the polygonized group with the SVG styles polyGrp.draw();} 
static public void main ( String args [ ] ) { PApplet . main ( new String [ ] { " Tutorial_10_HelloBot_svgToPolygonGroup " } ) ; } 
public static RGroup ellipse ( float x , float y , float rx , float ry ) { RGroup ret = new RGroup ( ) ; ret . addElement ( RShape . createEllipse ( x , y , rx , ry ) ) ; return ret ; } 
public static RGroup ellipse ( float x , float y , float r ) { return ellipse ( x , y , r , r ) ; } 
public static RGroup centerIn ( RGroup grp , PGraphics g , float margin ) { RGroup ret = new RGroup ( grp ) ; ret . centerIn ( g , margin ) ; return ret ; } 
public static RGroup centerIn ( RGroup grp , PGraphics g ) { return centerIn ( grp , g , 0 ) ; } 
public static RGroup [ ] split ( RGroup grp , float ) { return grp . split ( ) ; } 
public static RGroup adapt ( RGroup grp , RGroup path ) { RGroup ret = new RGroup ( grp ) ; ret . adapt ( path ) ; return ret ; } 
public static RGroup polygonize ( RGroup grp ) { RGroup ret = new RGroup ( grp ) ; ret . polygonize ( ) ; return ret ; } 
public void centerIn ( PGraphics g , float margin ) { transform ( getCenteringTransf ( g , margin , 1 , 1 ) ) ; } 
public void adapt ( RGroup grp , float wght , float lngthOffset ) throws RuntimeException { RContour c = this . getBounds ( ) ; float xmin = c . points [ 0 ] . x ; float xmax = c . points [ 2 ] . x ; float ymax = c . points [ 2 ] . y ; int numElements = this . countElements ( ) ; switch ( RG . adaptorType ) { case RG . BYPOINT : 
public void adapt ( RGroup grp ) throws RuntimeException { adapt ( grp , RG . adaptorScale , RG . adaptorLengthOffset ) ; } 
public void adapt ( RShape shp ) { RGroup grp = new RGroup ( ) ; grp . addElement ( shp ) ; adapt ( grp ) ; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) { RGroup grp = new RGroup ( ) ; grp . addElement ( shp ) ; adapt ( grp , wght , lngthOffset ) ; } 
public static RFont loadFont ( String fontFile ) { return new RFont ( fontFile ) ; } 
public static void text ( String text ) { RGroup grp = getText ( text ) ; grp . draw ( ) ; } 
public static void textFont ( RFont font , int size ) { font . setSize ( size ) ; fntLoader = font ; } 
public static RGroup loadShape ( String filename ) { RSVG svgLoader = new RSVG ( ) ; return svgLoader . toGroup ( filename ) ; } 
public RGroup toGroup ( String text ) throws RuntimeException { RGroup result = new RGroup ( ) ; Decide upon a cmap table to use for our character to glyph look-up CmapFormat cmapFmt = getCmapFormat(); if (cmapFmt == null) { throw new RuntimeException("Cannot find a suitable cmap table"); } If this font includes arabic script, we want to specify substitutions for initial, medial, terminal & isolated cases. int x = 0; for (short i = 0; i < text.length(); i++) { int glyphIndex = cmapFmt.mapCharCode(text.charAt(i)); Glyph glyph = f.getGlyph(glyphIndex); int default_advance_x = f.getHmtxTable().getAdvanceWidth(glyphIndex); if (glyph != null) { glyph.scale(scaleFactor); Add the Glyph to the Shape with an horizontal offset of x result.addElement(getGlyphAsShape(f,glyph, glyphIndex,x)); x += glyph.getAdvanceWidth(); }else{ x += (int)((float)default_advance_x*scaleFactor); } } if(align!=LEFT && align!=CENTER && align!=RIGHT){ throw new RuntimeException("Alignement unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT"); } RRectangle r; RMatrix mattrans; switch(this.align){ case RFont.CENTER: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX())/2,0); result.transform(mattrans); break; case RFont.RIGHT: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX()),0); result.transform(mattrans); break; case RFont.LEFT: break; } return result; } 
public void transform ( float x , float y , float w , float h , boolean keepAspectRatio ) { RMatrix mtx = new RMatrix ( ) ; RRectangle orig = this . getBounds ( ) ; float orig_w = orig . getMaxX ( ) - orig . getMinX ( ) ; float orig_h = orig . getMaxY ( ) - orig . getMinY ( ) ; mtx . translate ( - orig . getMinX ( ) , - orig . getMinY ( ) ) ; if ( keepAspectRatio ) { mtx . scale ( Math . min ( w / orig_w , h / orig_h ) ) ; } else { mtx . scale ( w / orig_w , h / orig_h ) ; } mtx . translate ( x , y ) ; this . transform ( mtx ) ; return ; } 
public boolean isIn ( PGraphics g ) { RRectangle c = getBounds ( ) ; float x0 = g . screenX ( c . topLeft . x , c . topLeft . y ) ; float y0 = g . screenY ( c . topLeft . x , c . topLeft . y ) ; float x1 = g . screenX ( c . bottomRight . x , c . topLeft . y ) ; float y1 = g . screenY ( c . bottomRight . x , c . topLeft . y ) ; float x2 = g . screenX ( c . bottomRight . x , c . bottomRight . y ) ; float y2 = g . screenY ( c . bottomRight . x , c . bottomRight . y ) ; float x3 = g . screenX ( c . topLeft . x , c . bottomRight . y ) ; float y3 = g . screenY ( c . topLeft . x , c . bottomRight . y ) ; float xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; float ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; float xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; float ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; return ! ( ( xmax < 0 | | xmin > g . width ) & & ( ymax < 0 | | ymin > g . height ) ) ; } 
public boolean isIn ( PApplet g ) { RRectangle c = getBounds ( ) ; float x0 = g . screenX ( c . topLeft . x , c . topLeft . y ) ; float y0 = g . screenY ( c . topLeft . x , c . topLeft . y ) ; float x1 = g . screenX ( c . bottomRight . x , c . topLeft . y ) ; float y1 = g . screenY ( c . bottomRight . x , c . topLeft . y ) ; float x2 = g . screenX ( c . bottomRight . x , c . bottomRight . y ) ; float y2 = g . screenY ( c . bottomRight . x , c . bottomRight . y ) ; float x3 = g . screenX ( c . topLeft . x , c . bottomRight . y ) ; float y3 = g . screenY ( c . topLeft . x , c . bottomRight . y ) ; float xmax = Math . max ( Math . max ( x0 , x1 ) , Math . max ( x2 , x3 ) ) ; float ymax = Math . max ( Math . max ( y0 , y1 ) , Math . max ( y2 , y3 ) ) ; float xmin = Math . min ( Math . min ( x0 , x1 ) , Math . min ( x2 , x3 ) ) ; float ymin = Math . min ( Math . min ( y0 , y1 ) , Math . min ( y2 , y3 ) ) ; return ! ( ( xmax < 0 | | xmin > g . width ) & & ( ymax < 0 | | ymin > g . height ) ) ; } 
public RMatrix getCenteringTransf ( PGraphics g , float margin , float sclDamping , float trnsDamping ) throws RuntimeException { RMatrix transf ; float mrgn = margin * 2 ; RRectangle c = getBounds ( ) ; float scl = ( float ) Math . min ( ( g . width - mrgn ) / ( float ) Math . abs ( c . getMinX ( ) - c . getMaxX ( ) ) , ( g . height - mrgn ) / ( float ) Math . abs ( c . getMinY ( ) - c . getMaxY ( ) ) ) ; RPoint trns = getCenter ( ) ; transf = new RMatrix ( ) ; if ( sclDamping ! = 0 ) { transf . scale ( 1 + ( scl - 1 ) * sclDamping ) ; } if ( trnsDamping ! = 0 ) { transf . translate ( - trns . x * trnsDamping , - trns . y * trnsDamping ) ; } return transf ; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RRectangle bbox = getBounds(); float xmin = bbox.getMinX(); float xmax = bbox.getMaxX(); float ymin = bbox.getMinY(); float ymax = bbox.getMaxY(); if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in elements boolean result = false; for(int i = 0;i<countElements();i++){ result |= elements[i].contains(p); } return result; } 
public void adapt ( RGroup grp , float wght , float lngthOffset ) throws RuntimeException { RRectangle c = this . getBounds ( ) ; float xmin = c . getMinX ( ) ; float xmax = c . getMaxX ( ) ; float ymax = c . getMaxY ( ) ; int numElements = this . countElements ( ) ; switch ( RG . adaptorType ) { case RG . BYPOINT : 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RRectangle bbox = getBounds(); float xmin = bbox.getMinX(); float xmax = bbox.getMaxX(); float ymin = bbox.getMinY(); float ymax = bbox.getMaxY(); if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in path RPoint[] verts = getPoints(); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ) c = !c; } return c; } 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RRectangle bbox = getBounds(); float xmin = bbox.getMinX(); float xmax = bbox.getMaxX(); float ymin = bbox.getMinY(); float ymax = bbox.getMaxY(); if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in shape RPoint[][] pointpaths = getPointsInPaths(); if(pointpaths == null){ return false; } RPoint[] verts = pointpaths[0]; for(int k=1;k<pointpaths.length;k++){ verts = (RPoint[])RG.parent().append(verts, new RPoint(0F, 0F)); verts = (RPoint[])RG.parent().concat(verts, pointpaths[k]); } verts = (RPoint[])RG.parent().append(verts, new RPoint(0F, 0F)); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ){ c = !c; } } return c; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RRectangle c = this . getBounds ( ) ; float xmin = c . getMinX ( ) ; float xmax = c . getMaxX ( ) ; switch ( RG . adaptorType ) { case RG . BYPOINT : 
protected void saveContext ( PGraphics g ) { style . saveContext ( g ) ; } 
protected void saveContext ( PApplet p ) { style . saveContext ( p ) ; } 
protected void saveContext ( ) { style . saveContext ( ) ; } 
protected void restoreContext ( PGraphics g ) { style . restoreContext ( g ) ; } 
protected void restoreContext ( PApplet p ) { style . restoreContext ( p ) ; } 
protected void restoreContext ( ) { style . restoreContext ( ) ; } 
private float [ ] indAndAdvAt ( float ) { int indOfElement = 0 ; float [ ] lengthsCurves = getCurveLengths ( ) ; float lengthCurve = getCurveLength ( ) ; while ( > accumulatedAdvancement ) { indOfElement + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCurves [ indOfElement ] / lengthCurve ) ; } float advOfElement = ( - prevAccumulatedAdvancement ) / ( lengthsCurves [ indOfElement ] / lengthCurve ) ; float [ ] indAndAdv = new float [ 2 ] ; indAndAdv [ 0 ] = indOfElement ; indAndAdv [ 1 ] = advOfElement ; return indAndAdv ; } 
static public RShape createStar ( float x , float y , float radiusBig , float radiusSmall , int spikes ) { RShape star = new RShape ( ) ; star . addMoveTo ( x - radiusBig , y ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI / spikes ) ) ) ; for ( int i = 2 ; i < 2 * spikes ; i + = 2 ) { star . addLineTo ( x - ( float ) ( radiusBig * Math . cos ( Math . PI * i / spikes ) ) , y - ( float ) ( radiusBig * Math . sin ( Math . PI * i / spikes ) ) ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI * ( i + 1 ) / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI * ( i + 1 ) / spikes ) ) ) ; } star . addClose ( ) ; return star ; } 
public int countChildren ( ) { if ( this . children = = null ) { return 0 ; } return this . children . length ; } 
public void insertHandle ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; if ( indOfElement < countPaths ( ) ) { paths [ indOfElement ] . insertHandle ( advOfElement ) ; } else { children [ indOfElement - countPaths ( ) ] . insertHandle ( advOfElement ) ; } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; int numPaths = countPaths ( ) ; if ( numPaths = = 0 ) { return null ; } if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; if ( indOfElement < countPaths ( ) ) { RPath [ ] splittedShapes = paths [ indOfElement ] . split ( advOfElement ) ; 
public void print ( ) { System . out . println ( " paths [count " + this . countPaths ( ) + " ]: " ) ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { System . out . println ( " --- path " + i + " --- " ) ; paths [ i ] . print ( ) ; System . out . println ( " --------------- " ) ; } System . out . println ( " children [count " + this . countChildren ( ) + " ]: " ) ; for ( int i = 0 ; i < countChildren ( ) ; i + + ) { 
public void draw ( PGraphics g ) { this . drawPaths ( g ) ; for ( int i = 0 ; i < countChildren ( ) ; i + + ) { this . children [ i ] . draw ( g ) ; 
public void draw ( PApplet g ) { this . drawPaths ( g ) ; for ( int i = 0 ; i < countChildren ( ) ; i + + ) { this . children [ i ] . draw ( g ) ; 
private void drawPaths ( PGraphics g ) { try { Class declaringClass = g . getClass ( ) . getMethod ( " breakShape " , null ) . getDeclaringClass ( ) ; 
private void drawPaths ( PApplet g ) { try { Class declaringClass = g . g . getClass ( ) . getMethod ( " breakShape " , null ) . getDeclaringClass ( ) ; 
protected void calculateCurveLengths ( ) { lenCurves = new float [ countPaths ( ) + countChildren ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { lenCurves [ i ] = paths [ i ] . getCurveLength ( ) ; lenCurve + = lenCurves [ i ] ; } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { lenCurves [ i + countPaths ( ) ] = children [ i ] . getCurveLength ( ) ; 
private void appendChild ( RShape nextshape ) { RShape [ ] newshapes ; if ( children = = null ) { newshapes = new RShape [ 1 ] ; newshapes [ 0 ] = nextshape ; currentChild = 0 ; } else { newshapes = new RShape [ this . children . length + 1 ] ; System . arraycopy ( this . children , 0 , newshapes , 0 , this . children . length ) ; newshapes [ this . children . length ] = nextshape ; currentChild + + ; } this . children = newshapes ; } 
public void addChild ( ) { this . appendChild ( new RShape ( ) ) ; } 
public void addPath ( RShape s ) { this . appendChild ( s ) ; } 
public RShape toShape ( String text ) throws RuntimeException { RShape result = new RShape ( ) ; Decide upon a cmap table to use for our character to glyph look-up CmapFormat cmapFmt = getCmapFormat(); if (cmapFmt == null) { throw new RuntimeException("Cannot find a suitable cmap table"); } If this font includes arabic script, we want to specify substitutions for initial, medial, terminal & isolated cases. int x = 0; for (short i = 0; i < text.length(); i++) { int glyphIndex = cmapFmt.mapCharCode(text.charAt(i)); Glyph glyph = f.getGlyph(glyphIndex); int default_advance_x = f.getHmtxTable().getAdvanceWidth(glyphIndex); if (glyph != null) { glyph.scale(scaleFactor); Add the Glyph to the Shape with an horizontal offset of x result.addChild(getGlyphAsShape(f,glyph, glyphIndex,x)); x += glyph.getAdvanceWidth(); }else{ x += (int)((float)default_advance_x*scaleFactor); } } if(align!=LEFT && align!=CENTER && align!=RIGHT){ throw new RuntimeException("Alignement unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT"); } RRectangle r; RMatrix mattrans; switch(this.align){ case RFont.CENTER: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX())/2,0); result.transform(mattrans); break; case RFont.RIGHT: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX()),0); result.transform(mattrans); break; case RFont.LEFT: break; } return result; } 
public static void text ( String text ) { RShape grp = getText ( text ) ; grp . draw ( ) ; } 
public static RShape loadShape ( String filename ) { RSVG svgLoader = new RSVG ( ) ; return svgLoader . toShape ( filename ) ; } 
public static void endShape ( PGraphics g ) { if ( group = = null ) { We are not inside a beginGroup shape.draw(g); }else{ We are inside a beginGroup group.addChild(shape); shape = null; } shape = null; } 
public static RShape centerIn ( RShape grp , PGraphics g , float margin ) { RShape ret = new RShape ( grp ) ; ret . centerIn ( g , margin ) ; return ret ; } 
public static RShape centerIn ( RShape grp , PGraphics g ) { return centerIn ( grp , g , 0 ) ; } 
public static RShape [ ] split ( RShape grp , float ) { return grp . split ( ) ; } 
public static RShape adapt ( RShape grp , RShape path ) { RShape ret = new RShape ( grp ) ; ret . adapt ( path ) ; return ret ; } 
public static RShape polygonize ( RShape grp ) { RShape ret = new RShape ( grp ) ; ret . polygonize ( ) ; return ret ; } 
public void polygonize ( ) { RPoint [ ] points = getPoints ( ) ; if ( points = = null ) { this . commands = null ; 
public void addChild ( RShape s ) { this . appendChild ( s ) ; } 
public void polygonize ( ) { int numPaths = countPaths ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { this . paths [ i ] . polygonize ( ) ; } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { this . children [ i ] . polygonize ( ) ; 
public void draw ( PGraphics g ) { if ( ! RG . ignoreStyles ) { saveContext ( g ) ; setContext ( g ) ; } this . drawPaths ( g ) ; for ( int i = 0 ; i < countChildren ( ) ; i + + ) { this . children [ i ] . draw ( g ) ; } if ( ! RG . ignoreStyles ) { restoreContext ( g ) ; 
public void draw ( PApplet g ) { if ( ! RG . ignoreStyles ) { saveContext ( g ) ; setContext ( g ) ; } this . drawPaths ( g ) ; for ( int i = 0 ; i < countChildren ( ) ; i + + ) { this . children [ i ] . draw ( g ) ; } if ( ! RG . ignoreStyles ) { restoreContext ( g ) ; 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; if ( indOfElement < countPaths ( ) ) { RPath [ ] splittedShapes = paths [ indOfElement ] . split ( advOfElement ) ; 
public void transform ( RMatrix m ) { RPoint [ ] ps = getHandles ( ) ; if ( ps = = null ) return ; for ( int i = 0 ; i < ps . length ; i + + ) { ps [ i ] . transform ( m ) ; 
public static RShape diff ( RShape a , RShape b ) { return a . diff ( b ) ; } 
public RShape [ ] splitPaths ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { RPath [ ] splittedPaths = paths [ i ] . split ( ) ; if ( splittedPaths ! = null ) { result [ 0 ] . addPath ( splittedPaths [ 0 ] ) ; result [ 1 ] . addPath ( splittedPaths [ 1 ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape [ ] splittedPaths = children [ i ] . splitPaths ( ) ; if ( splittedPaths ! = null ) { result [ 0 ] . addChild ( splittedPaths [ 0 ] ) ; result [ 1 ] . addChild ( splittedPaths [ 1 ] ) ; } } result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RRectangle c = this . getBounds ( ) ; float xmin = c . getMinX ( ) ; float xmax = c . getMaxX ( ) ; int numChildren = countChildren ( ) ; switch ( RG . adaptorType ) { case RG . BYPOINT : 
public static RShape union ( RShape a , RShape b ) { return a . union ( b ) ; } 
public static RShape intersection ( RShape a , RShape b ) { return a . intersection ( b ) ; } 
public static RShape xor ( RShape a , RShape b ) { return a . xor ( b ) ; } 
public RShape intersection ( RShape p ) { RPolygon result = RClip . intersection ( p . toPolygon ( ) , this . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; } 
public RShape union ( RShape p ) { RPolygon result = RClip . union ( p . toPolygon ( ) , this . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; } 
public RShape xor ( RShape p ) { RPolygon result = RClip . xor ( p . toPolygon ( ) , this . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; 
public RShape diff ( RShape p ) { RPolygon result = RClip . diff ( p . toPolygon ( ) , this . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; } 
public boolean contains ( float x , float y ) { return contains ( new RPoint ( x , y ) ) ; } 
public static void shape ( RShape shp , float x , float y , float w , float h ) { RShape tshp = new RShape ( shp ) ; tshp . transform ( x , y , w , h ) ; tshp . draw ( ) ; } 
public static void shape ( RShape shp , float x , float y ) { RShape tshp = new RShape ( shp ) ; tshp . transform ( x , y , tshp . getWidth ( ) , tshp . getHeight ( ) ) ; tshp . draw ( ) ; } 
public static RShape [ ] split ( RShape shp , float ) { return shp . split ( ) ; } 
public static void ignoreStyles ( boolean value ) { ignoreStyles = value ; } 
public static RShape polygonize ( RShape shp ) { RShape ret = new RShape ( shp ) ; ret . polygonize ( ) ; return ret ; } 
public boolean contains ( RGeomElem shp , boolean approx ) { RPoint tl = shp . getTopLeft ( ) ; RPoint tr = shp . getTopRight ( ) ; RPoint bl = shp . getBottomRight ( ) ; RPoint br = shp . getBottomLeft ( ) ; if ( this . contains ( tl ) & & this . contains ( tr ) & & this . contains ( bl ) & & this . contains ( br ) ) { return true ; } return false ; } 
public boolean intersects ( RGeomElem shp ) { RPoint tl = shp . getTopLeft ( ) ; RPoint tr = shp . getTopRight ( ) ; RPoint bl = shp . getBottomRight ( ) ; RPoint br = shp . getBottomLeft ( ) ; if ( this . contains ( tl ) | | this . contains ( tr ) | | this . contains ( bl ) | | this . contains ( br ) ) { return true ; } return false ; } 
public boolean contains ( RGeomElem shp ) { return contains ( shp . getPoints ( ) ) ; } 
public boolean containsBounds ( RGeomElem shp ) { RPoint tl = shp . getTopLeft ( ) ; RPoint tr = shp . getTopRight ( ) ; RPoint bl = shp . getBottomRight ( ) ; RPoint br = shp . getBottomLeft ( ) ; if ( this . contains ( tl ) & & this . contains ( tr ) & & this . contains ( bl ) & & this . contains ( br ) ) { return true ; } return false ; } 
public boolean containsHandles ( RGeomElem shp ) { return contains ( shp . getHandles ( ) ) ; } 
public boolean contains ( RPoint [ ] ps ) { boolean contains = false ; if ( ps ! = null ) { for ( int i = 0 ; i < ps . length ; i + + ) { contains & = this . contains ( ps [ i ] ) ; } } return contains ; } 
public boolean intersects ( RGeomElem shp ) { return intersects ( shp . getPoints ( ) ) ; } 
public boolean intersectsBounds ( RGeomElem shp ) { RPoint tl = shp . getTopLeft ( ) ; RPoint tr = shp . getTopRight ( ) ; RPoint bl = shp . getBottomRight ( ) ; RPoint br = shp . getBottomLeft ( ) ; if ( this . contains ( tl ) | | this . contains ( tr ) | | this . contains ( bl ) | | this . contains ( br ) ) { return true ; } return false ; } 
public boolean intersectsHandles ( RGeomElem shp ) { return intersects ( shp . getHandles ( ) ) ; } 
public boolean intersects ( RPoint [ ] ps ) { boolean intersects = false ; if ( ps ! = null ) { for ( int i = 0 ; i < ps . length ; i + + ) { intersects | = this . contains ( ps [ i ] ) ; } } return intersects ; } 
public void scale ( float sx , float sy , RPoint p ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( sx , sy , p ) ; transform ( transf ) ; } 
public void scale ( float sx , float sy , float x , float y ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( sx , sy , x , y ) ; transform ( transf ) ; } 
public void scale ( float s , RPoint p ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( s , p ) ; transform ( transf ) ; } 
public void scale ( float s , float x , float y ) { RMatrix transf = new RMatrix ( ) ; transf . scale ( s , x , y ) ; transform ( transf ) ; } 
public static RShape createShape ( RPoint [ ] [ ] points ) { return new RShape ( points ) ; } 
public static void shape ( RShape shp , float x , float y , float w , float h ) { RShape tshp = new RShape ( shp ) ; RMatrix transf = new RMatrix ( ) ; transf . translate ( x , y ) ; transf . scale ( w / tshp . getOrigWidth ( ) , h / tshp . getOrigHeight ( ) ) ; tshp . transform ( transf ) ; tshp . draw ( ) ; } 
public static void shape ( RShape shp , float x , float y ) { RShape tshp = new RShape ( shp ) ; RMatrix transf = new RMatrix ( ) ; transf . translate ( x , y ) ; tshp . transform ( transf ) ; tshp . draw ( ) ; } 
public static void breakShape ( int endMode ) { if ( endMode = = CLOSE ) { shape . addClose ( ) ; } shape . updateOrigParams ( ) ; breakShape ( ) ; } 
protected void updateOrigParams ( ) { this . width = this . getWidth ( ) ; this . height = this . getHeight ( ) ; } 
public RShape elemToPolyline ( XMLElement elem ) { RShape shp = getPolyline ( elem . getStringAttribute ( " points " ) . trim ( ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToPolygon ( XMLElement elem ) { RShape poly = elemToPolyline ( elem ) ; poly . addClose ( ) ; poly . updateOrigParams ( ) ; return poly ; } 
public RShape elemToRect ( XMLElement elem ) { RShape shp = getRect ( elem . getFloatAttribute ( " x " ) , elem . getFloatAttribute ( " y " ) , elem . getFloatAttribute ( " width " ) , elem . getFloatAttribute ( " height " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToLine ( XMLElement elem ) { RShape shp = getLine ( elem . getFloatAttribute ( " x1 " ) , elem . getFloatAttribute ( " y1 " ) , elem . getFloatAttribute ( " x2 " ) , elem . getFloatAttribute ( " y2 " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToEllipse ( XMLElement elem ) { RShape shp = getEllipse ( elem . getFloatAttribute ( " cx " ) , elem . getFloatAttribute ( " cy " ) , elem . getFloatAttribute ( " rx " ) , elem . getFloatAttribute ( " ry " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToCircle ( XMLElement elem ) { float r = elem . getFloatAttribute ( " r " ) ; RShape shp = getEllipse ( elem . getFloatAttribute ( " cx " ) , elem . getFloatAttribute ( " cy " ) , r , r ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToShape ( XMLElement elem ) { RShape shp = getShape ( elem . getStringAttribute ( " d " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
RPolygon toPolygon ( RShape shp ) { int numPnts = shp . countPaths ( ) ; RPolygon poly = new RPolygon ( ) ; if ( shp . children ! = null ) { for ( int i = 0 ; i < shp . children . length ; i + + ) { RPolygon childPoly = toPolygon ( shp . children [ i ] ) ; for ( int ii = 0 ; ii < childPoly . contours . length ; ii + + ) { poly . addContour ( childPoly . contours [ ii ] ) ; } } } for ( int i = 0 ; i < numPnts ; i + + ) { RPoint [ ] pnts = shp . paths [ i ] . getPoints ( ) ; RContour c = new RContour ( pnts ) ; c.closed = shp.paths[i].closed; c.setStyle( shp.paths[i] ); poly.addContour(c); } return poly; } 
public RPolygon toPolygon ( ) { int numPnts = this . countPaths ( ) ; RPolygon poly = new RPolygon ( ) ; if ( this . children ! = null ) { for ( int i = 0 ; i < this . children . length ; i + + ) { RPolygon childPoly = this . children [ i ] . toPolygon ( ) ; for ( int ii = 0 ; ii < childPoly . contours . length ; ii + + ) { poly . addContour ( childPoly . contours [ ii ] ) ; } } } for ( int i = 0 ; i < numPnts ; i + + ) { RPoint [ ] pnts = this . paths [ i ] . getPoints ( ) ; RContour c = new RContour ( pnts ) ; c . closed = this . paths [ i ] . closed ; c . setStyle ( this . paths [ i ] ) ; poly . addContour ( c ) ; } return poly ; } 
public RShape intersection ( RShape p ) { RPolygon result = RClip . intersection ( this . toPolygon ( ) , p . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; } 
public RShape union ( RShape p ) { RPolygon result = RClip . union ( this . toPolygon ( ) , p . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; } 
public RShape xor ( RShape p ) { RPolygon result = RClip . xor ( this . toPolygon ( ) , p . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; 
public RShape diff ( RShape p ) { RPolygon result = RClip . diff ( this . toPolygon ( ) , p . toPolygon ( ) ) ; if ( result = = null ) return null ; return result . toShape ( ) ; } 
static public RShape createRing ( float x , float y , float widthBig , float widthSmall ) { RShape ring = new RShape ( ) ; RShape outer = RShape . createCircle ( x , y , widthBig ) ; RShape inner = RShape . createCircle ( x , y , - widthSmall ) ; ring . addPath ( outer . paths [ 0 ] ) ; ring . addPath ( inner . paths [ 0 ] ) ; return ring ; } 
static public RShape createStar ( float x , float y , float widthBig , float widthSmall , int spikes ) { float radiusBig = widthBig / 2F ; float radiusSmall = widthSmall / 2F ; RShape star = new RShape ( ) ; star . addMoveTo ( x - radiusBig , y ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI / spikes ) ) ) ; for ( int i = 2 ; i < 2 * spikes ; i + = 2 ) { star . addLineTo ( x - ( float ) ( radiusBig * Math . cos ( Math . PI * i / spikes ) ) , y - ( float ) ( radiusBig * Math . sin ( Math . PI * i / spikes ) ) ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI * ( i + 1 ) / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI * ( i + 1 ) / spikes ) ) ) ; } star . addClose ( ) ; return star ; } 
static public RShape createEllipse ( float x , float y , float w , float h ) { float rx = w / 2F ; float ry = h / 2F ; RPoint center = new RPoint ( x , y ) ; RShape circle = new RShape ( ) ; float kx = ( ( ( 8F / ( float ) Math . sqrt ( 2F ) ) - 4F ) / 3F ) * rx ; float ky = ( ( ( 8F / ( float ) Math . sqrt ( 2F ) ) - 4F ) / 3F ) * ry ; circle . addMoveTo ( center . x , center . y - ry ) ; circle . addBezierTo ( center . x + kx , center . y - ry , center . x + rx , center . y - ky , center . x + rx , center . y ) ; circle . addBezierTo ( center . x + rx , center . y + ky , center . x + kx , center . y + ry , center . x , center . y + ry ) ; circle . addBezierTo ( center . x - kx , center . y + ry , center . x - rx , center . y + ky , center . x - rx , center . y ) ; circle . addBezierTo ( center . x - rx , center . y - ky , center . x - kx , center . y - ry , center . x , center . y - ry ) ; circle . addClose ( ) ; return circle ; } 
static public RShape createCircle ( float x , float y , float d ) { return createEllipse ( x , y , d , d ) ; } 
public static RShape adapt ( RShape shp , RShape path ) { RShape ret = new RShape ( grp ) ; ret . adapt ( path ) ; return ret ; } 
public void scale ( float sx , float sy , float x , float y ) { translate ( x , y ) ; scale ( sx , sy ) ; translate ( - x , - y ) ; } 
public void scale ( float s , float x , float y ) { scale ( s , s , x , y ) ; } 
public void scale ( float sx , float sy , RPoint p ) { scale ( sx , sy , p . x , p . y ) ; } 
public void scale ( float s , RPoint p ) { scale ( s , s , p . x , p . y ) ; } 
public static RShape adapt ( RShape shp , RShape path ) { RShape ret = new RShape ( shp ) ; ret . adapt ( path ) ; return ret ; } 
public static RFont loadFont ( String fontFile ) { RFont newFntLoader = new RFont ( fontFile ) ; if ( fntLoader = = null ) fntLoader = newFntLoader ; return newFntLoader ; 
public static void vertex ( float x , float y ) { if ( shape . countPaths ( ) = = 0 ) { shape . addMoveTo ( x , y ) ; 
public static void bezierVertex ( float cx1 , float cy1 , float cx2 , float cy2 , float x , float y ) { if ( shape . countPaths ( ) = = 0 ) { throw new NoPathInitializedException ( ) ; 
public static void endShape ( PGraphics g ) { shape . draw ( g ) ; shape = null ; } 
public void addClose ( ) { if ( commands = = null ) { return ; } if ( ( commands [ commands . length - 1 ] . endPoint . x = = commands [ 0 ] . startPoint . x ) & & ( commands [ commands . length - 1 ] . endPoint . y = = commands [ 0 ] . startPoint . y ) ) { commands [ commands . length - 1 ] . endPoint = new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ; lastPoint = commands [ commands . length - 1 ] . endPoint ; } else { addLineTo ( new RPoint ( commands [ 0 ] . startPoint . x , commands [ 0 ] . startPoint . y ) ) ; } closed = true ; } 
public void skewX ( float angle ) { RMatrix transf = new RMatrix ( ) ; transf . skewY ( angle ) ; transform ( transf ) ; } 
public void skewY ( float angle ) { RMatrix transf = new RMatrix ( ) ; transf . skewY ( angle ) ; transform ( transf ) ; } 
public void shear ( float shx , float shy ) { RMatrix transf = new RMatrix ( ) ; transf . shear ( shx , shy ) ; transform ( transf ) ; } 
public static RPoint [ ] lineLine ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float epsilon = 1e-9f ; test for parallel case float denom = (d.y - c.y)*(b.x - a.x) - (d.x - c.x)*(b.y - a.y); if(Math.abs(denom) < epsilon) return null; calculate segment parameter and ensure its within bounds float t1 = ((d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x))/denom; float t2 = ((b.x - a.x)*(a.y - c.y) - (b.y - a.y)*(a.x - c.x))/denom; if ( t1 < 0.0f || t1 > 1.0f || t2 < 0.0f || t2 > 1.0f ) return null; store actual intersection RPoint[] result = new RPoint[1]; RPoint temp = new RPoint(b); temp.sub(a); temp.scale(t1); result[0] = new RPoint(a); result[0].add(temp); return result; } 
public static RPoint [ ] lineQuad ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] lineCubic ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] lineCubic ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadQuad ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] quadQuad ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadCubic ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] quadCubic ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] cubicCubic ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] cubicCubic ( RCommand c1 , RCommand c2 ) { return null ; } } 
public RPoint [ ] intersection ( RCommand other ) { int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numCommands ; i + + ) { RPoint [ ] newPoints = commands [ i ] . intersection ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
public RPoint [ ] intersection ( RCommand other ) { RShape shp = new RShape ( this ) ; shp . polygonize ( ) ; return shp . polygonIntersection ( other ) ; } 
public RPoint [ ] polygonIntersection ( RCommand other ) { int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = paths [ i ] . intersection ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RPoint [ ] newPoints = children [ i ] . intersection ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
public RPoint [ ] intersection ( float x1 , float y1 , float x2 , float y2 ) { return this . intersection ( new RCommand ( new RPoint ( x1 , y1 ) , new RPoint ( x2 , y2 ) ) ) ; } 
public static RPoint [ ] lineLineIntersection ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float epsilon = 1e-9f ; test for parallel case float denom = (d.y - c.y)*(b.x - a.x) - (d.x - c.x)*(b.y - a.y); if(Math.abs(denom) < epsilon) return null; calculate segment parameter and ensure its within bounds float t1 = ((d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x))/denom; float t2 = ((b.x - a.x)*(a.y - c.y) - (b.y - a.y)*(a.x - c.x))/denom; if ( t1 < 0.0f || t1 > 1.0f || t2 < 0.0f || t2 > 1.0f ) return null; store actual intersection RPoint[] result = new RPoint[1]; RPoint temp = new RPoint(b); temp.sub(a); temp.scale(t1); result[0] = new RPoint(a); result[0].add(temp); return result; } 
public static RPoint [ ] lineQuadIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] lineCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] lineCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadQuadIntersection ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] quadQuadIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] quadCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] cubicCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] cubicCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } } 
public RPoint [ ] intersectionPoints ( RCommand other ) { int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numCommands ; i + + ) { RPoint [ ] newPoints = commands [ i ] . intersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
public RPoint [ ] intersectionPoints ( RPath other ) { int numCommands = countCommands ( ) ; int numOtherCommands = other . countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int j = 0 ; j < numOtherCommands ; j + + ) { for ( int i = 0 ; i < numCommands ; i + + ) { RPoint [ ] newPoints = commands [ i ] . intersectionPoints ( other . commands [ j ] ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } } return result ; } 
static public RShape createLine ( float x1 , float y1 , float x2 , float y2 ) { RShape line = new RShape ( ) ; RPath path = new RPath ( ) ; RCommand lineCommand = new RCommand ( x1 , y1 , x2 , y2 ) ; path . addCommand ( lineCommand ) ; line . addPath ( path ) ; return line ; } 
public RPoint [ ] intersectionPoints ( RShape other ) { TODO: when we will be able to intersect between all geometric elements the polygonization will not be necessary RShape shp = new RShape(this); shp.polygonize(); RShape otherPol = new RShape(other); otherPol.polygonize(); return shp.polygonIntersectionPoints(otherPol); } 
public RPoint [ ] intersectionPoints ( RCommand other ) { TODO: when we will be able to intersect between all geometric elements the polygonization will not be necessary RShape shp = new RShape(this); shp.polygonize(); return shp.polygonIntersectionPoints(other); } 
public RPoint [ ] polygonIntersectionPoints ( RCommand other ) { int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = paths [ i ] . intersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RPoint [ ] newPoints = children [ i ] . intersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
public RPoint [ ] intersectionPoints ( float x1 , float y1 , float x2 , float y2 ) { return this . intersectionPoints ( new RCommand ( new RPoint ( x1 , y1 ) , new RPoint ( x2 , y2 ) ) ) ; } 
public RPoint [ ] polygonIntersectionPoints ( RPath other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = paths [ i ] . intersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < numChildren ; i + + ) { RPoint [ ] newPoints = children [ i ] . polygonIntersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
public RPoint [ ] polygonIntersectionPoints ( RShape other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = other . polygonIntersectionPoints ( paths [ i ] ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < numChildren ; i + + ) { RPoint [ ] newPoints = other . polygonIntersectionPoints ( children [ i ] ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
RPoint [ ] polygonIntersectionPoints ( RCommand other ) { int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = paths [ i ] . intersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RPoint [ ] newPoints = children [ i ] . polygonIntersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
RPoint [ ] polygonIntersectionPoints ( RPath other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = paths [ i ] . intersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < numChildren ; i + + ) { RPoint [ ] newPoints = children [ i ] . polygonIntersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
RPoint [ ] polygonIntersectionPoints ( RShape other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = other . polygonIntersectionPoints ( paths [ i ] ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < numChildren ; i + + ) { RPoint [ ] newPoints = other . polygonIntersectionPoints ( children [ i ] ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
public static RPoint [ ] cubicCubicIntersection ( RCommand c1 , RCommand c2 ) { return null ; } 
public static float closestAdvFrom ( RCommand c , RPoint p ) { RPoint a = new RPoint ( c . startPoint ) ; RPoint b = new RPoint ( c . endPoint ) ; RPoint ap = new RPoint ( p ) ; ap . sub ( a ) ; RPoint ab = new RPoint ( b ) ; ab . sub ( a ) ; float denom = ab . norm ( ) ; float epsilon = 1e-9f ; if ( denom < epsilon ) return 0.5f ; float = ( ab . x * ap . x + ab . y * ap . y ) / denom ; = > 0.0f ? : 0.0f ; = < 1.0f ? : 1.0f ; return ; 
public static RPoint [ ] lineLineDistance ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float t1 = closestAdvFrom ( c1 , c ) ; float t2 = closestAdvFrom ( c1 , d ) ; RPoint p1 = c1 . getPoint ( t1 ) ; p1 . sub ( c ) ; RPoint p2 = c1 . getPoint ( t2 ) ; p2 . sub ( d ) ; float dist1 = p1 . norm ( ) ; float dist2 = p2 . norm ( ) ; RPoint [ ] result = new RPoint [ 2 ] ; if ( dist1 < dist2 ) { result [ 0 ] = p1 ; result [ 1 ] = c ; } else { result [ 0 ] = p2 ; result [ 1 ] = d ; } return result ; } 
public static RPoint [ ] lineQuadDistance ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] lineCubicDistance ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] lineCubicDistance ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadQuadDistance ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] quadQuadDistance ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] quadCubicDistance ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] quadCubicDistance ( RCommand c1 , RCommand c2 ) { return null ; } public static RPoint [ ] cubicCubicDistance ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RPoint [ ] cubicCubicDistance ( RCommand c1 , RCommand c2 ) { return null ; } } 
public float dist ( RPoint p ) { float dx = ( p . x - this . x ) ; float dy = ( p . y - this . y ) ; return ( float ) Math . sqrt ( dx * dx + dy * dy ) ; } 
public void update ( RClosest other ) { if ( other . intersects = = null ) { 
public static RClosest lineLineClosest ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float t1 = closestAdvFrom ( c1 , c ) ; float t2 = closestAdvFrom ( c1 , d ) ; RPoint p1 = c1 . getPoint ( t1 ) ; p1 . sub ( c ) ; RPoint p2 = c1 . getPoint ( t2 ) ; p2 . sub ( d ) ; float dist1 = p1 . norm ( ) ; float dist2 = p2 . norm ( ) ; RClosest result = new RClosest ( ) ; result . closest = new RPoint [ 2 ] ; result . advancements = new float [ 2 ] ; if ( dist1 < dist2 ) { result . closest [ 0 ] = p1 ; result . closest [ 1 ] = c ; result . distance = dist1 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } else { result . closest [ 0 ] = p2 ; result . closest [ 1 ] = d ; result . distance = dist2 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } return result ; } 
public static RClosest lineQuadClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest lineCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RClosest lineCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest quadQuadClosest ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RClosest quadQuadClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest quadCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RClosest quadCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } public static RClosest cubicCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } 
public static RClosest cubicCubicClosest ( RCommand c1 , RCommand c2 ) { return null ; } } 
public RClosest closestPoints ( RCommand other ) { int numCommands = countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } TODO: get here the max value of an integer float minDist = 100000; RClosest result = new RClosest(); for(int i=0;i<numCommands;i++){ RClosest currResult = commands[i].closestPoints(other); result.update(currResult); } return result; } 
public RClosest closestPoints ( RPath other ) { int numCommands = countCommands ( ) ; int numOtherCommands = other . countCommands ( ) ; if ( numCommands = = 0 ) { return null ; } TODO: get here the max value of an integer float minDist = 100000; RClosest result = new RClosest(); for(int j=0;j<numOtherCommands;j++){ for(int i=0;i<numCommands;i++){ RClosest currResult = commands[i].closestPoints(other.commands[j]); result.update(currResult); } } return result; } 
RClosest polygonClosestPoints ( RCommand other ) { int numPaths = countPaths ( ) ; RClosest result = new RClosest ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RClosest currResult = paths [ i ] . closestPoints ( other ) ; result . update ( currResult ) ; } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RClosest currResult = children [ i ] . polygonClosestPoints ( other ) ; result . update ( currResult ) ; } return result ; } 
RClosest polygonClosestPoints ( RPath other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RClosest result = new RClosest ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RClosest currClosest = paths [ i ] . closestPoints ( other ) ; result . update ( currClosest ) ; } for ( int i = 0 ; i < numChildren ; i + + ) { RClosest currClosest = children [ i ] . polygonClosestPoints ( other ) ; result . update ( currClosest ) ; } return result ; } 
RClosest polygonClosestPoints ( RShape other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RClosest result = new RClosest ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RClosest currClosest = other . polygonClosestPoints ( paths [ i ] ) ; result . update ( currClosest ) ; } for ( int i = 0 ; i < numChildren ; i + + ) { RClosest currClosest = other . polygonClosestPoints ( children [ i ] ) ; result . update ( currClosest ) ; } return result ; } 
protected void saveSegmentatorContext ( ) { oldSegmentType = RCommand . segmentType ; oldSegmentSteps = RCommand . segmentSteps ; oldSegmentLines = RCommand . segmentLines ; } 
protected void restoreSegmentatorContext ( ) { RCommand . segmentType = oldSegmentType ; RCommand . segmentSteps = oldSegmentSteps ; RCommand . segmentLines = oldSegmentLines ; } 
public RCommand [ ] split ( float ) { switch ( commandType ) { case LINETO : return splitLine ( ) ; case QUADBEZIERTO : return splitQuadBezier ( ) ; case CUBICBEZIERTO : return splitCubicBezier ( ) ; } return null ; } 
private RCommand [ ] splitCubicBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 4 ] [ 4 ] ; for ( int i = 0 ; i < = 3 ; i + + ) { for ( int j = 0 ; j < = 3 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 3; i++){ triangleMatrix[0][i].x = ctrlPoints[i].x; triangleMatrix[0][i].y = ctrlPoints[i].y; } Triangle computation for(int i = 1; i <= 3; i++){ for(int j = 0; j <= 3 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier4(startPoint, triangleMatrix[1][0], triangleMatrix[2][0], triangleMatrix[3][0]); result[1] = createBezier4(triangleMatrix[3][0], triangleMatrix[2][1], triangleMatrix[1][2], endPoint); return result; } 
private RCommand [ ] splitQuadBezier ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 3 ] [ 3 ] ; for ( int i = 0 ; i < = 2 ; i + + ) { for ( int j = 0 ; j < = 2 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 2; i++){ triangleMatrix[0][i] = ctrlPoints[i]; } Triangle computation for(int i = 1; i <= 2; i++){ for(int j = 0; j <= 2 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createBezier3(startPoint, triangleMatrix[1][0], triangleMatrix[2][0]); result[1] = createBezier3(triangleMatrix[2][0], triangleMatrix[1][1], endPoint); return result; } 
private RCommand [ ] splitLine ( float ) { RPoint [ ] [ ] triangleMatrix = new RPoint [ 2 ] [ 2 ] ; for ( int i = 0 ; i < = 1 ; i + + ) { for ( int j = 0 ; j < = 1 ; j + + ) { triangleMatrix [ i ] [ j ] = new RPoint ( ) ; } } RPoint [ ] ctrlPoints = this . getHandles ( ) ; Copy control points to triangle matrix for(int i = 0; i <= 1; i++){ triangleMatrix[0][i] = ctrlPoints[i]; } Triangle computation for(int i = 1; i <= 1; i++){ for(int j = 0; j <= 1 - i; j++){ triangleMatrix[i][j].x = (1-t) * triangleMatrix[i-1][j].x + t * triangleMatrix[i-1][j+1].x; triangleMatrix[i][j].y = (1-t) * triangleMatrix[i-1][j].y + t * triangleMatrix[i-1][j+1].y; } } RCommand[] result = new RCommand[2]; result[0] = createLine(startPoint, triangleMatrix[1][0]); result[1] = createLine(triangleMatrix[1][0], endPoint); return result; } 
private void quadBezierAdaptativeRecursive ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , int level ) { if ( level > segmentRecursionLimit ) { return ; } Calculate all the mid-points of the line segments ---------------------- float x12 = (x1 + x2) / 2; float y12 = (y1 + y2) / 2; float x23 = (x2 + x3) / 2; float y23 = (y2 + y3) / 2; float x123 = (x12 + x23) / 2; float y123 = (y12 + y23) / 2; float dx = x3-x1; float dy = y3-y1; float d = Math.abs(((x2 - x3) * dy - (y2 - y3) * dx)); if(d > segmentCollinearityEpsilon) { Regular care ----------------- if(d * d <= segmentDistTolSqr * (dx*dx + dy*dy)) { If the curvature doesn't exceed the distance_tolerance value we tend to finish subdivisions. ---------------------- if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x123, y123)); return; } Angle & Cusp Condition ---------------------- float da = Math.abs((float)Math.atan2(y3 - y2, x3 - x2) - (float)Math.atan2(y2 - y1, x2 - x1)); if(da >= Math.PI) da = 2*(float)Math.PI - da; if(da < segmentAngleTol) { Finally we can stop the recursion ---------------------- addCurvePoint(new RPoint(x123, y123)); return; } } } else { if(Math.abs(x1 + x3 - x2 - x2) + Math.abs(y1 + y3 - y2 - y2) <= segmentDistTolMnhttn) { addCurvePoint(new RPoint(x123, y123)); return; } } Continue subdivision ---------------------- quadBezierAdaptativeRecursive(x1, y1, x12, y12, x123, y123, level + 1); quadBezierAdaptativeRecursive(x123, y123, x23, y23, x3, y3, level + 1); } 
private void cubicBezierAdaptativeRecursive ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , int level ) { if ( level > segmentRecursionLimit ) { return ; } Calculate all the mid-points of the line segments ---------------------- float x12 = (x1 + x2) / 2; float y12 = (y1 + y2) / 2; float x23 = (x2 + x3) / 2; float y23 = (y2 + y3) / 2; float x34 = (x3 + x4) / 2; float y34 = (y3 + y4) / 2; float x123 = (x12 + x23) / 2; float y123 = (y12 + y23) / 2; float x234 = (x23 + x34) / 2; float y234 = (y23 + y34) / 2; float x1234 = (x123 + x234) / 2; float y1234 = (y123 + y234) / 2; Try to approximate the full cubic curve by a single straight line ------------------ float dx = x4-x1; float dy = y4-y1; float d2 = Math.abs(((x2 - x4) * dy - (y2 - y4) * dx)); float d3 = Math.abs(((x3 - x4) * dy - (y3 - y4) * dx)); float da1, da2; int d2b = (d2 > segmentCollinearityEpsilon)?1:0; int d3b = (d3 > segmentCollinearityEpsilon)?1:0; switch((d2b << 1) + d3b){ case 0: All collinear OR p1==p4 ---------------------- if(Math.abs(x1 + x3 - x2 - x2) + Math.abs(y1 + y3 - y2 - y2) + Math.abs(x2 + x4 - x3 - x3) + Math.abs(y2 + y4 - y3 - y3) <= segmentDistTolMnhttn) { addCurvePoint(new RPoint(x1234, y1234)); return; } break; case 1: p1,p2,p4 are collinear, p3 is considerable ---------------------- if(d3 * d3 <= segmentDistTolSqr * (dx*dx + dy*dy)) { if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x23, y23)); return; } Angle Condition ---------------------- da1 = Math.abs((float)Math.atan2(y4 - y3, x4 - x3) - (float)Math.atan2(y3 - y2, x3 - x2)); if(da1 >= (float)Math.PI) da1 = 2*(float)Math.PI - da1; if(da1 < segmentAngleTol) { addCurvePoint(new RPoint(x2, y2)); addCurvePoint(new RPoint(x3, y3)); return; } if(segmentCuspLimit != 0.0) { if(da1 > segmentCuspLimit) { addCurvePoint(new RPoint(x3, y3)); return; } } } break; case 2: p1,p3,p4 are collinear, p2 is considerable ---------------------- if(d2 * d2 <= segmentDistTolSqr * (dx*dx + dy*dy)) { if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x23, y23)); return; } Angle Condition ---------------------- da1 = Math.abs((float)Math.atan2(y3 - y2, x3 - x2) - (float)Math.atan2(y2 - y1, x2 - x1)); if(da1 >= (float)Math.PI) da1 = 2*(float)Math.PI - da1; if(da1 < segmentAngleTol) { addCurvePoint(new RPoint(x2, y2)); addCurvePoint(new RPoint(x3, y3)); return; } if(segmentCuspLimit != 0.0) { if(da1 > segmentCuspLimit) { addCurvePoint(new RPoint(x2, y2)); return; } } } break; case 3: Regular care ----------------- if((d2 + d3)*(d2 + d3) <= segmentDistTolSqr * (dx*dx + dy*dy)) { If the curvature doesn't exceed the distance_tolerance value we tend to finish subdivisions. ---------------------- if(segmentAngleTol < segmentAngleTolEpsilon) { addCurvePoint(new RPoint(x23, y23)); return; } Angle & Cusp Condition ---------------------- float a23 = (float)Math.atan2(y3 - y2, x3 - x2); da1 = Math.abs(a23 - (float)Math.atan2(y2 - y1, x2 - x1)); da2 = Math.abs((float)Math.atan2(y4 - y3, x4 - x3) - a23); if(da1 >= (float)Math.PI) da1 = 2*(float)Math.PI - da1; if(da2 >= (float)Math.PI) da2 = 2*(float)Math.PI - da2; if(da1 + da2 < segmentAngleTol) { Finally we can stop the recursion ---------------------- addCurvePoint(new RPoint(x23, y23)); return; } if(segmentCuspLimit != 0.0) { if(da1 > segmentCuspLimit) { addCurvePoint(new RPoint(x2, y2)); return; } if(da2 > segmentCuspLimit) { addCurvePoint(new RPoint(x3, y3)); return; } } } break; } Continue subdivision ---------------------- cubicBezierAdaptativeRecursive(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1); cubicBezierAdaptativeRecursive(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1); } 
private void lineUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx = endPoint.x - startPoint.x; float dy = endPoint.y - startPoint.y; float len = (float)Math.sqrt(dx * dx + dy * dy); steps = (int)(len * 0.25); if(steps < 4) steps = 4; } float dt = 1F/steps; float fx, fy, fdx, fdy; fx = startPoint.x; fdx = (endPoint.x - startPoint.x) * dt; fy = startPoint.y; fdy = (endPoint.y - startPoint.y) * dt; for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx; fy = fy + fdy; } addCurvePoint(new RPoint(endPoint)); } 
private void cubicBezierUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx1 = controlPoints[0].x - startPoint.x; float dy1 = controlPoints[0].y - startPoint.y; float dx2 = controlPoints[1].x - controlPoints[0].x; float dy2 = controlPoints[1].y - controlPoints[0].y; float dx3 = endPoint.x - controlPoints[1].x; float dy3 = endPoint.y - controlPoints[1].y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1) + (float)Math.sqrt(dx2 * dx2 + dy2 * dy2) + (float)Math.sqrt(dx3 * dx3 + dy3 * dy3); steps = (int)(len * 0.25); if(steps < 4) { steps = 4; } } float dt = 1F/steps; float fx, fy, fdx, fdy, fddx, fddy, fdddx, fdddy, fdd_per_2x, fdd_per_2y, fddd_per_2x, fddd_per_2y, fddd_per_6x, fddd_per_6y; float temp = dt * dt; fx = startPoint.x; fdx = 3F * (controlPoints[0].x - startPoint.x) * dt; fdd_per_2x = 3F * (startPoint.x - 2F * controlPoints[0].x + controlPoints[1].x) * temp; fddd_per_2x = 3F * (3F * (controlPoints[0].x - controlPoints[1].x) + endPoint.x - startPoint.x) * temp * dt; fdddx = fddd_per_2x + fddd_per_2x; fddx = fdd_per_2x + fdd_per_2x; fddd_per_6x = fddd_per_2x * (1.0F / 3F); fy = startPoint.y; fdy = 3F * (controlPoints[0].y - startPoint.y) * dt; fdd_per_2y = 3F * (startPoint.y - 2F * controlPoints[0].y + controlPoints[1].y) * temp; fddd_per_2y = 3F * (3F * (controlPoints[0].y - controlPoints[1].y) + endPoint.y - startPoint.y) * temp * dt; fdddy = fddd_per_2y + fddd_per_2y; fddy = fdd_per_2y + fdd_per_2y; fddd_per_6y = fddd_per_2y * (1.0F / 3F); for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx + fdd_per_2x + fddd_per_6x; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fdy + fdd_per_2y + fddd_per_6y; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } addCurvePoint(new RPoint(endPoint)); } 
private void quadBezierUniformStep ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve int steps = segmentSteps; if(segmentSteps==0.0F){ float dx1 = controlPoints[0].x - startPoint.x; float dy1 = controlPoints[0].y - startPoint.y; float dx2 = endPoint.x - controlPoints[0].x; float dy2 = endPoint.y - controlPoints[0].y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1) + (float)Math.sqrt(dx2 * dx2 + dy2 * dy2); steps = (int)(len * 0.25); if(steps < 4) steps = 4; } float dt = 1F/steps; float fx, fy, fdx, fdy, fddx, fddy, fdd_per_2x, fdd_per_2y; float temp = dt * dt; fx = startPoint.x; fdx = 2F * (controlPoints[0].x - startPoint.x) * dt; fdd_per_2x = (startPoint.x - 2F * controlPoints[0].x + endPoint.x) * temp; fddx = fdd_per_2x + fdd_per_2x; fy = startPoint.y; fdy = 2F * (controlPoints[0].y - startPoint.y) * dt; fdd_per_2y = (startPoint.y - 2F * controlPoints[0].y + endPoint.y) * temp; fddy = fdd_per_2y + fdd_per_2y; for (int loop=0; loop < steps; loop++) { addCurvePoint(new RPoint(fx,fy)); fx = fx + fdx + fdd_per_2x; fdx = fdx + fddx; fy = fy + fdy + fdd_per_2y; fdy = fdy + fddy; } addCurvePoint(new RPoint(endPoint)); } 
private void lineUniformLength ( ) { If the number of steps is equal to 0 then choose a number of steps adapted to the curve float dx1 = endPoint.x - startPoint.x; float dy1 = endPoint.y - startPoint.y; float len = (float)Math.sqrt(dx1 * dx1 + dy1 * dy1); float steps = (int)(len * 2); if(steps < 4) steps = 4; This holds the amount of steps used to calculate segment lengths float dt = 1F/steps; This holds how much length has to bee advanced until adding a point float untilPoint = RCommand.segmentAccOffset; float fx, fy, fdx, fdy; fx = startPoint.x; fdx = (endPoint.x - startPoint.x) * dt; fy = startPoint.y; fdy = (endPoint.y - startPoint.y) * dt; for (int loop=0; loop <= steps; loop++) { untilPoint -= (float)Math.sqrt(fdx*fdx + fdy*fdy); Eventually try other distance measures fx = fx + fdx; fy = fy + fdy; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
private void quadBezierUniformLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y , fix , fiy ; float temp = dt * dt ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop < = steps ; loop + + ) { fix = fdx + fdd_per_2x ; fiy = fdy + fdd_per_2y ; untilPoint - = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx; fy = fy + fiy; fdy = fdy + fddy; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
private void cubicBezierUniformLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float untilPoint = RCommand . segmentAccOffset ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y , fix , fiy ; float temp = dt * dt ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop + + ) { fix = fdx + fdd_per_2x + fddd_per_6x ; fiy = fdy + fdd_per_2y + fddd_per_6y ; untilPoint - = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fiy; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } addCurvePoint(new RPoint(endPoint)); RCommand.segmentAccOffset = untilPoint; } 
private float quadBezierLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = endPoint . x - controlPoints [ 0 ] . x ; float dy2 = endPoint . y - controlPoints [ 0 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdd_per_2x , fdd_per_2y , fix , fiy ; float temp = dt * dt ; float totallen = 0F ; fx = startPoint . x ; fdx = 2F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = ( startPoint . x - 2F * controlPoints [ 0 ] . x + endPoint . x ) * temp ; fddx = fdd_per_2x + fdd_per_2x ; fy = startPoint . y ; fdy = 2F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = ( startPoint . y - 2F * controlPoints [ 0 ] . y + endPoint . y ) * temp ; fddy = fdd_per_2y + fdd_per_2y ; for ( int loop = 0 ; loop < = steps ; loop + + ) { fix = fdx + fdd_per_2x ; fiy = fdy + fdd_per_2y ; totallen + = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx; fy = fy + fiy; fdy = fdy + fddy; } return totallen; } 
private float cubicBezierLength ( ) { float dx1 = controlPoints [ 0 ] . x - startPoint . x ; float dy1 = controlPoints [ 0 ] . y - startPoint . y ; float dx2 = controlPoints [ 1 ] . x - controlPoints [ 0 ] . x ; float dy2 = controlPoints [ 1 ] . y - controlPoints [ 0 ] . y ; float dx3 = endPoint . x - controlPoints [ 1 ] . x ; float dy3 = endPoint . y - controlPoints [ 1 ] . y ; float len = ( float ) Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) + ( float ) Math . sqrt ( dx2 * dx2 + dy2 * dy2 ) + ( float ) Math . sqrt ( dx3 * dx3 + dy3 * dy3 ) ; float steps = ( int ) ( len * 2 ) ; if ( steps < 4 ) steps = 4 ; float dt = 1F / steps ; float fx , fy , fdx , fdy , fddx , fddy , fdddx , fdddy , fdd_per_2x , fdd_per_2y , fddd_per_2x , fddd_per_2y , fddd_per_6x , fddd_per_6y , fix , fiy ; float temp = dt * dt ; float totallen = 0F ; fx = startPoint . x ; fdx = 3F * ( controlPoints [ 0 ] . x - startPoint . x ) * dt ; fdd_per_2x = 3F * ( startPoint . x - 2F * controlPoints [ 0 ] . x + controlPoints [ 1 ] . x ) * temp ; fddd_per_2x = 3F * ( 3F * ( controlPoints [ 0 ] . x - controlPoints [ 1 ] . x ) + endPoint . x - startPoint . x ) * temp * dt ; fdddx = fddd_per_2x + fddd_per_2x ; fddx = fdd_per_2x + fdd_per_2x ; fddd_per_6x = fddd_per_2x * ( 1.0F / 3F ) ; fy = startPoint . y ; fdy = 3F * ( controlPoints [ 0 ] . y - startPoint . y ) * dt ; fdd_per_2y = 3F * ( startPoint . y - 2F * controlPoints [ 0 ] . y + controlPoints [ 1 ] . y ) * temp ; fddd_per_2y = 3F * ( 3F * ( controlPoints [ 0 ] . y - controlPoints [ 1 ] . y ) + endPoint . y - startPoint . y ) * temp * dt ; fdddy = fddd_per_2y + fddd_per_2y ; fddy = fdd_per_2y + fdd_per_2y ; fddd_per_6y = fddd_per_2y * ( 1.0F / 3F ) ; for ( int loop = 0 ; loop < steps ; loop + + ) { fix = fdx + fdd_per_2x + fddd_per_6x ; fiy = fdy + fdd_per_2y + fddd_per_6y ; totallen + = ( float ) Math . sqrt ( fix * fix + fiy * fiy ) ; Eventually try other distance measures fx = fx + fix; fdx = fdx + fddx + fddd_per_2x; fddx = fddx + fdddx; fdd_per_2x = fdd_per_2x + fddd_per_2x; fy = fy + fiy; fdy = fdy + fddy + fddd_per_2y; fddy = fddy + fdddy; fdd_per_2y = fdd_per_2y + fddd_per_2y; } return totallen; } 
public static RPoint [ ] lineLineIntersection ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float epsilon = 1e-9f ; test for parallel case float denom = (d.y - c.y)*(b.x - a.x) - (d.x - c.x)*(b.y - a.y); if(Math.abs(denom) < epsilon) return null; calculate segment parameter and ensure its within bounds float t1 = ((d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x))/denom; float t2 = ((b.x - a.x)*(a.y - c.y) - (b.y - a.y)*(a.x - c.x))/denom; if ( t1 < 0.0f || t1 > 1.0f || t2 < 0.0f || t2 > 1.0f ) return null; store actual intersection RPoint[] result = new RPoint[1]; RPoint temp = new RPoint(b); temp.sub(a); temp.scale(t1); result[0] = new RPoint(a); result[0].add(temp); return result; } 
public static float closestAdvFrom ( RCommand c , RPoint p ) { RPoint a = new RPoint ( c . startPoint ) ; RPoint b = new RPoint ( c . endPoint ) ; RPoint ap = new RPoint ( p ) ; ap . sub ( a ) ; RPoint ab = new RPoint ( b ) ; ab . sub ( a ) ; float denom = ab . norm ( ) ; float epsilon = 1e-9f ; if ( denom < epsilon ) return 0.5f ; float = ( ab . x * ap . x + ab . y * ap . y ) / denom ; = > 0.0f ? : 0.0f ; = < 1.0f ? : 1.0f ; return ; 
public static RClosest lineLineClosest ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float t1 = closestAdvFrom ( c1 , c ) ; float t2 = closestAdvFrom ( c1 , d ) ; RPoint p1 = c1 . getPoint ( t1 ) ; p1 . sub ( c ) ; RPoint p2 = c1 . getPoint ( t2 ) ; p2 . sub ( d ) ; float dist1 = p1 . norm ( ) ; float dist2 = p2 . norm ( ) ; RClosest result = new RClosest ( ) ; result . closest = new RPoint [ 2 ] ; result . advancements = new float [ 2 ] ; if ( dist1 < dist2 ) { result . closest [ 0 ] = p1 ; result . closest [ 1 ] = c ; result . distance = dist1 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } else { result . closest [ 0 ] = p2 ; result . closest [ 1 ] = d ; result . distance = dist2 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } return result ; } 
public static RClosest lineLineClosest ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float t1 = closestAdvFrom ( c1 , c ) ; float t2 = closestAdvFrom ( c1 , d ) ; RPoint p1 = c1 . getPoint ( t1 ) ; RPoint p2 = c1 . getPoint ( t2 ) ; float dist1 = p1 . dist ( c ) ; float dist2 = p2 . dist ( d ) ; RClosest result = new RClosest ( ) ; result . closest = new RPoint [ 2 ] ; result . advancements = new float [ 2 ] ; if ( dist1 < dist2 ) { result . closest [ 0 ] = p1 ; result . closest [ 1 ] = c ; result . distance = dist1 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } else { result . closest [ 0 ] = p2 ; result . closest [ 1 ] = d ; result . distance = dist2 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } return result ; } 
public static float closestAdvFrom ( RCommand c , RPoint p ) { RPoint a = new RPoint ( c . startPoint ) ; RPoint b = new RPoint ( c . endPoint ) ; RPoint ap = new RPoint ( p ) ; ap . sub ( a ) ; RPoint ab = new RPoint ( b ) ; ab . sub ( a ) ; float denom = ab . sqrnorm ( ) ; float epsilon = 1e-19f ; if ( denom < epsilon ) return 0.5f ; float = ( ab . x * ap . x + ab . y * ap . y ) / denom ; = > 0.0f ? : 0.0f ; = < 1.0f ? : 1.0f ; return ; 
public static RClosest lineLineClosest ( RCommand c1 , RCommand c2 ) { RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float t1 = closestAdvFrom ( c1 , c ) ; float t2 = closestAdvFrom ( c1 , d ) ; RPoint p1 = c1 . getPoint ( t1 ) ; RPoint p2 = c1 . getPoint ( t2 ) ; float dist1 = p1 . dist ( c ) ; float dist2 = p2 . dist ( d ) ; RClosest result = new RClosest ( ) ; result . closest = new RPoint [ 2 ] ; result . advancements = new float [ 2 ] ; if ( dist1 < dist2 ) { result . closest [ 0 ] = p1 ; result . closest [ 1 ] = c ; result . distance = dist1 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } else { result . closest [ 0 ] = p2 ; result . closest [ 1 ] = d ; result . distance = dist2 ; result . advancements [ 0 ] = t1 ; result . advancements [ 1 ] = t2 ; } return result ; } 
public void transform ( RMatrix m ) { float tempx = m . m00 * x + m . m01 * y + m . m02 ; float tempy = m . m10 * x + m . m11 * y + m . m12 ; x = tempx ; y = tempy ; } 
public void rotate ( float angle , float vx , float vy ) { float c = ( float ) Math . cos ( angle ) ; float s = ( float ) Math . sin ( angle ) ; x - = vx ; y - = vy ; float tempx = x ; float tempy = y ; x = tempx * c - tempy * s ; y = tempx * s + tempy * c ; x + = vx ; y + = vy ; } 
public void rotate ( float angle ) { float c = ( float ) Math . cos ( angle ) ; float s = ( float ) Math . sin ( angle ) ; float tempx = x ; float tempy = y ; x = tempx * c - tempy * s ; y = tempx * s + tempy * c ; } 
public void rotate ( float angle , RPoint v ) { float c = ( float ) Math . cos ( angle ) ; float s = ( float ) Math . sin ( angle ) ; x - = v . x ; y - = v . y ; float tempx = x ; float tempy = y ; x = tempx * c - tempy * s ; y = tempx * s + tempy * c ; x + = v . x ; y + = v . y ; } 
public float sqrnorm ( ) { return ( float ) mult ( this ) ; } 
public int countContours ( ) { if ( this . contours = = null ) { return 0 ; } return this . contours . length ; } 
public void addClose ( ) { if ( contours = = null ) { return ; } contours [ contours . length - 1 ] . addClose ( ) ; } 
public RMesh toMesh ( ) { if ( contours = = null ) { return new RMesh ( ) ; } RMesh mesh = RClip . polygonToMesh ( this ) ; if ( mesh = = null ) { return null ; } mesh . setStyle ( this ) ; return mesh ; } 
public RShape toShape ( ) { int numContours = countContours ( ) ; RShape result = new RShape ( ) ; for ( int i = 0 ; i < numContours ; i + + ) { RPoint [ ] newpoints = this . contours [ i ] . getHandles ( ) ; if ( newpoints ! = null ) { result . addMoveTo ( newpoints [ 0 ] ) ; for ( int j = 1 ; j < newpoints . length ; j + + ) { result . addLineTo ( newpoints [ j ] ) ; } if ( contours [ i ] . closed ) { result . addClose ( ) ; } result . paths [ i ] . setStyle ( contours [ i ] ) ; } } result . setStyle ( this ) ; return result ; } 
public RPolygon intersection ( RPolygon p ) { RPolygon res = RClip . intersection ( p , this ) ; res . setStyle ( this . getStyle ( ) ) ; return res ; } 
public RPolygon union ( RPolygon p ) { RPolygon res = RClip . union ( p , this ) ; res . setStyle ( this . getStyle ( ) ) ; return res ; } 
public RPolygon xor ( RPolygon p ) { RPolygon res = RClip . xor ( p , this ) ; res . setStyle ( this . getStyle ( ) ) ; return res ; } 
public RPolygon diff ( RPolygon p ) { RPolygon res = RClip . diff ( this , p ) ; res . setStyle ( this . getStyle ( ) ) ; return res ; } 
public RShape intersection ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . intersection ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . intersection ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public RShape union ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . union ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . union ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public RShape xor ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . xor ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . xor ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public RShape diff ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . diff ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . diff ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public void draw ( String filename , PGraphics g ) { this . toGroup ( filename ) . draw ( g ) ; } 
public void saveGroup ( String filename , RGroup group ) { String svg = " <svg> " + groupToString ( group ) + " </svg> " ; String[] splittedSvg = PApplet.split(svg, ""); 
public String polygonToString ( RPolygon poly ) { String result = " " ; result + = shapeToString ( poly . toShape ( ) ) ; return result ; } 
public String styleToString ( RStyle style ) { String result = " style= \" " ; if ( style . fillDef ) { if ( ! style . fill ) { result + = " fill:none; " ; } else { result + = " fill:# " + PApplet . hex ( style . fillColor , 6 ) + " ; " ; } } if ( style . strokeDef ) { if ( ! style . stroke ) { result + = " stroke:none; " ; } else { result + = " stroke:# " + PApplet . hex ( style . strokeColor , 6 ) + " ; " ; } } result + = " \" " ; return result ; } 
public RShape elemToPolygon ( XMLElement elem ) { RShape poly = elemToPolyline ( elem ) ; poly . addClose ( ) ; poly . updateOrigParams ( ) ; return poly ; } 
public RShape elemToRect ( XMLElement elem ) { RShape shp = getRect ( elem . getFloatAttribute ( " x " ) , elem . getFloatAttribute ( " y " ) , elem . getFloatAttribute ( " width " ) , elem . getFloatAttribute ( " height " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToCircle ( XMLElement elem ) { float r = elem . getFloatAttribute ( " r " ) ; RShape shp = getEllipse ( elem . getFloatAttribute ( " cx " ) , elem . getFloatAttribute ( " cy " ) , r , r ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToShape ( XMLElement elem ) { RShape shp = getShape ( elem . getStringAttribute ( " d " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
private int line ( RShape shp , RPoint curp , RPoint relp , RPoint refp , RPoint strp , String [ ] tags , int i ) { shp . addLineTo ( PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; curp . setLocation ( PApplet . parseFloat ( tags [ i ] ) + relp . x , PApplet . parseFloat ( tags [ i + 1 ] ) + relp . y ) ; refp . setLocation ( curp . x , curp . y ) ; return i + 1 ; } 
public static RFont loadFont ( String fontFile ) { RFont newFntLoader = new RFont ( fontFile ) ; if ( fntLoader = = null ) fntLoader = newFntLoader ; return newFntLoader ; 
public static void shape ( RShape shp , float x , float y ) { RShape tshp = new RShape ( shp ) ; RMatrix transf = new RMatrix ( ) ; transf . translate ( x , y ) ; tshp . transform ( transf ) ; tshp . draw ( ) ; } 
public static RShape loadShape ( String filename ) { RSVG svgLoader = new RSVG ( ) ; return svgLoader . toShape ( filename ) ; } 
public static void saveShape ( String filename , RShape shape ) { RSVG svgSaver = new RSVG ( ) ; String str = svgSaver . fromShape ( shape ) ; String [ ] strs = PApplet . split ( str , " " ) ; RG . parent ( ) . saveStrings ( filename , strs ) ; } 
public static void breakShape ( int endMode ) { if ( endMode = = CLOSE ) { shape . addClose ( ) ; } shape . updateOrigParams ( ) ; breakShape ( ) ; } 
public String fromShape ( RShape shape ) { String header = " <?xml version= \" 1.0 \" standalone= \" no \" ?> n<!DOCTYPE svg PUBLIC \" -W3CDTD SVG 1.1EN \" \" http:www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd \" > n<svg width= \" 100% \" height= \" 100% \" version= \" 1.1 \" xmlns= \" http:www.w3.org/2000/svg \" > " ; return header + shapeToString ( shape ) + " </svg> " ; } 
public String fromGroup ( RGroup group ) { String header = " <?xml version= \" 1.0 \" standalone= \" no \" ?> n<!DOCTYPE svg PUBLIC \" -W3CDTD SVG 1.1EN \" \" http:www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd \" > n<svg width= \" 100% \" height= \" 100% \" version= \" 1.1 \" xmlns= \" http:www.w3.org/2000/svg \" > " ; return header + groupToString ( group ) + " </svg> " ; } 
public String styleToString ( RStyle style ) { String result = " style= \" " ; if ( style . fillDef ) { if ( ! style . fill ) { result + = " fill:none; " ; } else { result + = " fill:# " + PApplet . hex ( style . fillColor , 6 ) + " ; " ; } } if ( style . fillAlphaDef ) { result + = " fill-opacity: " + style . fillAlpha / 255.0f + " ; " ; } if ( style . strokeDef ) { if ( ! style . stroke ) { result + = " stroke:none; " ; } else { result + = " stroke:# " + PApplet . hex ( style . strokeColor , 6 ) + " ; " ; } } if ( style . strokeAlphaDef ) { result + = " stroke-opacity: " + style . strokeAlpha / 255.0f + " ; " ; } if ( style . strokeWeightDef ) { result + = " stroke-width: " + style . strokeWeight + " ; " ; } if ( style . strokeCapDef ) { result + = " stroke-linecap: " ; switch ( style . strokeCap ) { case RG . PROJECT : result + = " butt " ; break ; case RG . ROUND : result + = " round " ; break ; case RG . SQUARE : result + = " square " ; break ; default : break ; } result + = " ; " ; } if ( style . strokeJoinDef ) { result + = " stroke-linejoin: " ; switch ( style . strokeJoin ) { case RG . MITER : result + = " miter " ; break ; case RG . ROUND : result + = " round " ; break ; case RG . BEVEL : result + = " bevel " ; break ; default : break ; } result + = " ; " ; } result + = " \" " ; return result ; } 
public void saveShape ( String filename , RShape shp ) { String str = fromShape ( shp ) ; String [ ] strs = PApplet . split ( str , " " ) ; RG . parent ( ) . saveStrings ( filename , strs ) ; } 
public void saveGroup ( String filename , RGroup grp ) { String str = fromGroup ( grp ) ; String [ ] strs = PApplet . split ( str , " " ) ; RG . parent ( ) . saveStrings ( filename , strs ) ; } 
public static RPoint [ ] lineLineIntersection ( RCommand c1 , RCommand c2 ) { RPoint a = new RPoint ( c1 . startPoint ) ; RPoint b = new RPoint ( c1 . endPoint ) ; RPoint c = new RPoint ( c2 . startPoint ) ; RPoint d = new RPoint ( c2 . endPoint ) ; float epsilon = 1e-9f ; test for parallel case float denom = (d.y - c.y)*(b.x - a.x) - (d.x - c.x)*(b.y - a.y); if(Math.abs(denom) < epsilon) return null; calculate segment parameter and ensure its within bounds float t1 = ((d.x - c.x)*(a.y - c.y) - (d.y - c.y)*(a.x - c.x))/denom; float t2 = ((b.x - a.x)*(a.y - c.y) - (b.y - a.y)*(a.x - c.x))/denom; if ( t1 < 0.0f || t1 > 1.0f || t2 < 0.0f || t2 > 1.0f ) return null; store actual intersection RPoint[] result = new RPoint[1]; RPoint temp = new RPoint(b); temp.sub(a); temp.scale(t1); result[0] = new RPoint(a); result[0].add(temp); return result; } 
public static RClosest lineLineClosest ( RCommand c1 , RCommand c2 ) { RPoint c1b = new RPoint ( c1 . startPoint ) ; RPoint c1e = new RPoint ( c1 . endPoint ) ; float c2t1 = closestAdvFrom ( c2 , c1b ) ; float c2t2 = closestAdvFrom ( c2 , c1e ) ; RPoint c2p1 = c2 . getPoint ( c2t1 ) ; RPoint c2p2 = c2 . getPoint ( c2t2 ) ; float dist1c2 = c2p1 . dist ( c1b ) ; float dist2c2 = c2p2 . dist ( c1e ) ; RPoint c2b = new RPoint ( c2 . startPoint ) ; RPoint c2e = new RPoint ( c2 . endPoint ) ; float c1t1 = closestAdvFrom ( c1 , c2b ) ; float c1t2 = closestAdvFrom ( c1 , c2e ) ; RPoint c1p1 = c1 . getPoint ( c1t1 ) ; RPoint c1p2 = c1 . getPoint ( c1t2 ) ; float dist1c1 = c1p1 . dist ( c2b ) ; float dist2c1 = c1p2 . dist ( c2e ) ; RClosest result = new RClosest ( ) ; result . distance = Math . min ( Math . min ( dist1c2 , dist2c2 ) , Math . min ( dist1c1 , dist2c1 ) ) ; result . closest = new RPoint [ 2 ] ; result . advancements = new float [ 2 ] ; if ( result . distance = = dist1c2 ) { result . closest [ 0 ] = c1b ; result . closest [ 1 ] = c2p1 ; result . advancements [ 0 ] = 0 ; result . advancements [ 1 ] = c2t1 ; } else if ( result . distance = = dist2c2 ) { result . closest [ 0 ] = c1e ; result . closest [ 1 ] = c2p2 ; result . advancements [ 0 ] = 1 ; result . advancements [ 1 ] = c2t2 ; } else if ( result . distance = = dist1c1 ) { result . closest [ 0 ] = c2b ; result . closest [ 1 ] = c1p1 ; result . advancements [ 0 ] = 0 ; result . advancements [ 1 ] = c1t1 ; } else return result ; } 
public float unitsToPixels ( String units , float originalPxSize ) { TODO: check if it is possible to know the dpi of a given PGraphics or device return unitsToPixels(units, originalPxSize, Toolkit.getDefaultToolkit().getScreenResolution()); } 
public float unitsToPixels ( String units , float originalPxSize , float dpi ) { int chars = 0 ; float multiplier = 1.0f ; if ( units . endsWith ( " em " ) ) { chars = 2 ; multiplier = 1.0f ; } else if ( units . endsWith ( " ex " ) ) { chars = 2 ; multiplier = 1.0f ; } else if ( units . endsWith ( " px " ) ) { chars = 2 ; multiplier = 1.0f ; } else if ( units . endsWith ( " pt " ) ) { chars = 2 ; multiplier = 1.25f ; } else if ( units . endsWith ( " pc " ) ) { chars = 2 ; multiplier = 15 f ; } else if ( units . endsWith ( " cm " ) ) { chars = 2 ; multiplier = 35.43307f / 90.0f * dpi ; } else if ( units . endsWith ( " mm " ) ) { chars = 2 ; multiplier = 3.543307f / 90.0f * dpi ; } else if ( units . endsWith ( " in " ) ) { chars = 2 ; multiplier = dpi ; } else if ( units . endsWith ( " % " ) ) { chars = 1 ; multiplier = originalPxSize / 100.0f ; } else { chars = 0 ; multiplier = 1.0f ; } return Float . valueOf ( units . substring ( 0 , units . length ( ) - chars ) ) . floatValue ( ) * multiplier ; } 
protected void updateOrigParams ( ) { this . origWidth = this . getWidth ( ) ; this . origHeight = this . getHeight ( ) ; } 
private float [ ] indAndAdvAt ( float ) { int indOfElement = 0 ; float [ ] lengthsCurves = getCurveLengths ( ) ; float lengthCurve = getCurveLength ( ) ; while ( > accumulatedAdvancement ) { indOfElement + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCurves [ indOfElement ] / lengthCurve ) ; } float advOfElement = ( - prevAccumulatedAdvancement ) / ( lengthsCurves [ indOfElement ] / lengthCurve ) ; float [ ] indAndAdv = new float [ 2 ] ; indAndAdv [ 0 ] = indOfElement ; indAndAdv [ 1 ] = RG . parent ( ) . constrain ( advOfElement , 0.0f , 1.0f ) ; return indAndAdv ; } 
public RShape elemToPolyline ( XML elem ) { RShape shp = getPolyline ( elem . getString ( " points " ) . trim ( ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToPolygon ( XML elem ) { RShape poly = elemToPolyline ( elem ) ; poly . addClose ( ) ; poly . updateOrigParams ( ) ; return poly ; } 
public RShape elemToRect ( XML elem ) { RShape shp = getRect ( elem . getFloat ( " x " ) , elem . getFloat ( " y " ) , elem . getFloat ( " width " ) , elem . getFloat ( " height " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToLine ( XML elem ) { RShape shp = getLine ( elem . getFloat ( " x1 " ) , elem . getFloat ( " y1 " ) , elem . getFloat ( " x2 " ) , elem . getFloat ( " y2 " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToEllipse ( XML elem ) { RShape shp = getEllipse ( elem . getFloat ( " cx " ) , elem . getFloat ( " cy " ) , elem . getFloat ( " rx " ) , elem . getFloat ( " ry " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToCircle ( XML elem ) { float r = elem . getFloat ( " r " ) ; RShape shp = getEllipse ( elem . getFloat ( " cx " ) , elem . getFloat ( " cy " ) , r , r ) ; shp . updateOrigParams ( ) ; return shp ; } 
public RShape elemToShape ( XML elem ) { RShape shp = getShape ( elem . getString ( " d " ) ) ; shp . updateOrigParams ( ) ; return shp ; } 
private void drawPaths ( PGraphics g ) { try { Class declaringClass = g . getClass ( ) . getMethod ( " breakShape " , new Class [ 0 ] ) . getDeclaringClass ( ) ; 
private void drawPaths ( PApplet g ) { try { Class declaringClass = g . g . getClass ( ) . getMethod ( " breakShape " , new Class [ 0 ] ) . getDeclaringClass ( ) ; 
private void addCurvePoint ( RPoint nextcurvepoint ) { if ( curvePoints = = null ) curvePoints = new Vector < RPoint > ( ) ; curvePoints . add ( nextcurvepoint ) ; / * 
public float unitsToPixels ( String units , float originalPxSize ) { TODO: check if it is possible to know the dpi of a given PGraphics or device return unitsToPixels(units, originalPxSize, 72.0f); } 
private void drawPaths ( PGraphics g ) { drawUsingBreakShape ( g ) ; } 
private void drawPaths ( PApplet g ) { drawUsingBreakShape ( g ) ; } 
public void testCorrectness ( ) { System . out . println ( " running test " ) ; RPolygon a = makeShape ( 50 ) ; RPolygon b = makeShape ( 60 ) ; Fastness f = new Fastness ( ) ; int = 10 ; RPolygon slow_int = null , slow_union = null , slow_xor = null , slow_diff = null ; RPolygon fast_int = null , fast_union = null , fast_xor = null , fast_diff = null ; RG . useFastClip = false ; f . record ( " slow intersection " ) ; for ( int i = 0 ; i < ; i + + ) { slow_int = RClip . intersection ( a , b ) ; } f . record ( " slow union " ) ; for ( int i = 0 ; i < ; i + + ) { slow_union = RClip . union ( a , b ) ; } f . record ( " slow xor " ) ; for ( int i = 0 ; i < ; i + + ) { slow_xor = RClip . xor ( a , b ) ; } f . record ( " slow diff " ) ; for ( int i = 0 ; i < ; i + + ) { slow_diff = RClip . diff ( a , b ) ; } RG . useFastClip = true ; f . record ( " fast int " ) ; for ( int i = 0 ; i < ; i + + ) { fast_int = RClip . intersection ( a , b ) ; } f . record ( " fast union " ) ; for ( int i = 0 ; i < ; i + + ) { fast_union = RClip . union ( a , b ) ; } f . record ( " fast xor " ) ; for ( int i = 0 ; i < ; i + + ) { fast_xor = RClip . xor ( a , b ) ; } f . record ( " fast diff " ) ; for ( int i = 0 ; i < ; i + + ) { fast_diff = RClip . diff ( a , b ) ; } f . stop ( ) ; f . print ( ) ; checkPoints ( slow_int , fast_int ) ; checkPoints ( slow_union , fast_union ) ; checkPoints ( slow_xor , fast_xor ) ; checkPoints ( slow_diff , fast_diff ) ; } 
public void testOldMeshing ( ) { RG . useFastClip = false ; RMesh mesh = RClip . polygonToMesh ( poly ) ; assertNotNull ( mesh ) ; } 
public void testNewMeshing ( ) { RG . useFastClip = true ; RMesh mesh = RClip . polygonToMesh ( poly ) ; assertNotNull ( mesh ) ; } 
public void setAlign ( int align ) throws RuntimeException { if ( align ! = LEFT & & align ! = CENTER & & align ! = RIGHT ) { throw new RuntimeException ( " Alignment unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT " ) ; } this . align = align ; } 
public RGroup toGroup ( String text ) throws RuntimeException { RGroup result = new RGroup ( ) ; Decide upon a cmap table to use for our character to glyph look-up CmapFormat cmapFmt = getCmapFormat(); if (cmapFmt == null) { throw new RuntimeException("Cannot find a suitable cmap table"); } If this font includes arabic script, we want to specify substitutions for initial, medial, terminal & isolated cases. int x = 0; for (short i = 0; i < text.length(); i++) { int glyphIndex = cmapFmt.mapCharCode(text.charAt(i)); Glyph glyph = f.getGlyph(glyphIndex); int default_advance_x = f.getHmtxTable().getAdvanceWidth(glyphIndex); if (glyph != null) { glyph.scale(scaleFactor); Add the Glyph to the Shape with an horizontal offset of x result.addElement(getGlyphAsShape(f,glyph, glyphIndex,x)); x += glyph.getAdvanceWidth(); }else{ x += (int)((float)default_advance_x*scaleFactor); } } if(align!=LEFT && align!=CENTER && align!=RIGHT){ throw new RuntimeException("Alignment unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT"); } RRectangle r; RMatrix mattrans; switch(this.align){ case RFont.CENTER: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX())/2,0); result.transform(mattrans); break; case RFont.RIGHT: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX()),0); result.transform(mattrans); break; case RFont.LEFT: break; } return result; } 
public RShape toShape ( String text ) throws RuntimeException { RShape result = new RShape ( ) ; Decide upon a cmap table to use for our character to glyph look-up CmapFormat cmapFmt = getCmapFormat(); if (cmapFmt == null) { throw new RuntimeException("Cannot find a suitable cmap table"); } If this font includes arabic script, we want to specify substitutions for initial, medial, terminal & isolated cases. int x = 0; for (short i = 0; i < text.length(); i++) { int glyphIndex = cmapFmt.mapCharCode(text.charAt(i)); Glyph glyph = f.getGlyph(glyphIndex); int default_advance_x = f.getHmtxTable().getAdvanceWidth(glyphIndex); if (glyph != null) { glyph.scale(scaleFactor); Add the Glyph to the Shape with an horizontal offset of x result.addChild(getGlyphAsShape(f,glyph, glyphIndex,x)); x += glyph.getAdvanceWidth(); }else{ x += (int)((float)default_advance_x*scaleFactor); } } if(align!=LEFT && align!=CENTER && align!=RIGHT){ throw new RuntimeException("Alignment unknown. The only accepted values are: RFont.LEFT, RFont.CENTER and RFont.RIGHT"); } RRectangle r; RMatrix mattrans; switch(this.align){ case RFont.CENTER: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX())/2,0); result.transform(mattrans); break; case RFont.RIGHT: r = result.getBounds(); mattrans = new RMatrix(); mattrans.translate((r.getMinX()-r.getMaxX()),0); result.transform(mattrans); break; case RFont.LEFT: break; } return result; } 
static public RShape createLine ( float x1 , float y1 , float x2 , float y2 ) { RShape line = new RShape ( ) ; RPath path = new RPath ( ) ; RCommand lineCommand = new RCommand ( x1 , y1 , x2 , y2 ) ; path . addCommand ( lineCommand ) ; line . addPath ( path ) ; return line ; } 
static public RShape createRing ( float x , float y , float widthBig , float widthSmall ) { RShape ring = new RShape ( ) ; RShape outer = RShape . createCircle ( x , y , widthBig ) ; RShape inner = RShape . createCircle ( x , y , - widthSmall ) ; ring . addPath ( outer . paths [ 0 ] ) ; ring . addPath ( inner . paths [ 0 ] ) ; return ring ; } 
static public RShape createStar ( float x , float y , float widthBig , float widthSmall , int spikes ) { float radiusBig = widthBig / 2F ; float radiusSmall = widthSmall / 2F ; RShape star = new RShape ( ) ; star . addMoveTo ( x - radiusBig , y ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI / spikes ) ) ) ; for ( int i = 2 ; i < 2 * spikes ; i + = 2 ) { star . addLineTo ( x - ( float ) ( radiusBig * Math . cos ( Math . PI * i / spikes ) ) , y - ( float ) ( radiusBig * Math . sin ( Math . PI * i / spikes ) ) ) ; star . addLineTo ( x - ( float ) ( radiusSmall * Math . cos ( Math . PI * ( i + 1 ) / spikes ) ) , y - ( float ) ( radiusSmall * Math . sin ( Math . PI * ( i + 1 ) / spikes ) ) ) ; } star . addClose ( ) ; return star ; } 
public int countPaths ( ) { if ( this . paths = = null ) { return 0 ; } return this . paths . length ; } 
public int countChildren ( ) { if ( this . children = = null ) { return 0 ; } return this . children . length ; } 
public RPolygon toPolygon ( ) { int numPnts = this . countPaths ( ) ; RPolygon poly = new RPolygon ( ) ; if ( this . children ! = null ) { for ( int i = 0 ; i < this . children . length ; i + + ) { RPolygon childPoly = this . children [ i ] . toPolygon ( ) ; for ( int ii = 0 ; ii < childPoly . contours . length ; ii + + ) { poly . addContour ( childPoly . contours [ ii ] ) ; } } } for ( int i = 0 ; i < numPnts ; i + + ) { RPoint [ ] pnts = this . paths [ i ] . getPoints ( ) ; RContour c = new RContour ( pnts ) ; c . closed = this . paths [ i ] . closed ; c . setStyle ( this . paths [ i ] ) ; poly . addContour ( c ) ; } return poly ; } 
public void polygonize ( ) { int numPaths = countPaths ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { this . paths [ i ] . polygonize ( ) ; } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { this . children [ i ] . polygonize ( ) ; 
public RShape intersection ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . intersection ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . intersection ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public RShape union ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . union ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . union ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public RShape xor ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . xor ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . xor ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public RShape diff ( RShape p ) { int numPaths = countPaths ( ) ; RPolygon ppoly = p . toPolygon ( ) ; RShape result = new RShape ( ) ; RShape temp = new RShape ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { temp . addPath ( this . paths [ i ] ) ; } RPolygon resPolPaths = RClip . diff ( temp . toPolygon ( ) , ppoly ) ; if ( resPolPaths ! = null ) { RShape resPaths = resPolPaths . toShape ( ) ; for ( int i = 0 ; i < resPaths . countPaths ( ) ; i + + ) { result . addPath ( resPaths . paths [ i ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape resChildren = this . children [ i ] . diff ( p ) ; if ( resChildren ! = null ) { result . addChild ( resChildren ) ; } } if ( result ! = null ) { result . setStyle ( this ) ; } return result ; 
public boolean contains ( RPoint p ) { float testx = p . x ; float testy = p . y ; Test for containment in bounding box RRectangle bbox = getBounds(); float xmin = bbox.getMinX(); float xmax = bbox.getMaxX(); float ymin = bbox.getMinY(); float ymax = bbox.getMaxY(); if( (testx < xmin) || (testx > xmax) || (testy < ymin) || (testy > ymax)){ return false; } Test for containment in shape RPoint[][] pointpaths = getPointsInPaths(); if(pointpaths == null){ return false; } RPoint[] verts = pointpaths[0]; for(int k=1;k<pointpaths.length;k++){ verts = (RPoint[])RG.parent().append(verts, new RPoint(0F, 0F)); verts = (RPoint[])RG.parent().concat(verts, pointpaths[k]); } verts = (RPoint[])RG.parent().append(verts, new RPoint(0F, 0F)); if(verts == null){ return false; } int nvert = verts.length; int i, j = 0; boolean c = false; for (i = 0, j = nvert-1; i < nvert; j = i++) { if ( ((verts[i].y > testy) != (verts[j].y>testy)) && (testx < (verts[j].x-verts[i].x) * (testy-verts[i].y) / (verts[j].y-verts[i].y) + verts[i].x) ){ c = !c; } } return c; } 
public RShape [ ] splitPaths ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { RPath [ ] splittedPaths = paths [ i ] . split ( ) ; if ( splittedPaths ! = null ) { result [ 0 ] . addPath ( splittedPaths [ 0 ] ) ; result [ 1 ] . addPath ( splittedPaths [ 1 ] ) ; } } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RShape [ ] splittedPaths = children [ i ] . splitPaths ( ) ; if ( splittedPaths ! = null ) { result [ 0 ] . addChild ( splittedPaths [ 0 ] ) ; result [ 1 ] . addChild ( splittedPaths [ 1 ] ) ; } } result [ 0 ] . setStyle ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } 
public void insertHandle ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; if ( indOfElement < countPaths ( ) ) { paths [ indOfElement ] . insertHandle ( advOfElement ) ; } else { children [ indOfElement - countPaths ( ) ] . insertHandle ( advOfElement ) ; } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public void insertHandleInPaths ( float ) { if ( ( = = 0F ) | | ( = = 1F ) ) { return ; } int numPaths = countPaths ( ) ; if ( numPaths = = 0 ) { return ; } for ( int i = 0 ; i < numPaths ; i + + ) { paths [ i ] . insertHandleInPaths ( ) ; } Clear the cache lenCurves = null; lenCurve = -1F; return; } 
public RShape [ ] split ( float ) { RShape [ ] result = new RShape [ 2 ] ; result [ 0 ] = new RShape ( ) ; result [ 1 ] = new RShape ( ) ; if ( = = 0.0F ) { result [ 0 ] = new RShape ( ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( this ) ; result [ 1 ] . setStyle ( this ) ; return result ; } if ( = = 1.0F ) { result [ 0 ] = new RShape ( this ) ; result [ 0 ] . setStyle ( this ) ; result [ 1 ] = new RShape ( ) ; result [ 1 ] . setStyle ( this ) ; return result ; } float [ ] indAndAdv = indAndAdvAt ( ) ; int indOfElement = ( int ) ( indAndAdv [ 0 ] ) ; float advOfElement = indAndAdv [ 1 ] ; if ( indOfElement < countPaths ( ) ) { RPath [ ] splittedShapes = paths [ indOfElement ] . split ( advOfElement ) ; 
RPoint [ ] polygonIntersectionPoints ( RPath other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = paths [ i ] . intersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < numChildren ; i + + ) { RPoint [ ] newPoints = children [ i ] . polygonIntersectionPoints ( other ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
RPoint [ ] polygonIntersectionPoints ( RShape other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RPoint [ ] result = null ; RPoint [ ] newresult = null ; for ( int i = 0 ; i < numPaths ; i + + ) { RPoint [ ] newPoints = other . polygonIntersectionPoints ( paths [ i ] ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } for ( int i = 0 ; i < numChildren ; i + + ) { RPoint [ ] newPoints = other . polygonIntersectionPoints ( children [ i ] ) ; if ( newPoints ! = null ) { if ( result = = null ) { result = new RPoint [ newPoints . length ] ; System . arraycopy ( newPoints , 0 , result , 0 , newPoints . length ) ; } else { newresult = new RPoint [ result . length + newPoints . length ] ; System . arraycopy ( result , 0 , newresult , 0 , result . length ) ; System . arraycopy ( newPoints , 0 , newresult , result . length , newPoints . length ) ; result = newresult ; } } } return result ; } 
RClosest polygonClosestPoints ( RCommand other ) { int numPaths = countPaths ( ) ; RClosest result = new RClosest ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RClosest currResult = paths [ i ] . closestPoints ( other ) ; result . update ( currResult ) ; } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { RClosest currResult = children [ i ] . polygonClosestPoints ( other ) ; result . update ( currResult ) ; } return result ; } 
RClosest polygonClosestPoints ( RPath other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RClosest result = new RClosest ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RClosest currClosest = paths [ i ] . closestPoints ( other ) ; result . update ( currClosest ) ; } for ( int i = 0 ; i < numChildren ; i + + ) { RClosest currClosest = children [ i ] . polygonClosestPoints ( other ) ; result . update ( currClosest ) ; } return result ; } 
RClosest polygonClosestPoints ( RShape other ) { int numChildren = countChildren ( ) ; int numPaths = countPaths ( ) ; RClosest result = new RClosest ( ) ; for ( int i = 0 ; i < numPaths ; i + + ) { RClosest currClosest = other . polygonClosestPoints ( paths [ i ] ) ; result . update ( currClosest ) ; } for ( int i = 0 ; i < numChildren ; i + + ) { RClosest currClosest = other . polygonClosestPoints ( children [ i ] ) ; result . update ( currClosest ) ; } return result ; } 
public void adapt ( RShape shp , float wght , float lngthOffset ) throws RuntimeException { RRectangle c = this . getBounds ( ) ; float xmin = c . getMinX ( ) ; float xmax = c . getMaxX ( ) ; int numChildren = countChildren ( ) ; switch ( RG . adaptorType ) { case RG . BYPOINT : 
private void drawPaths ( PGraphics g ) { drawUsingBreakShape ( g ) ; } 
private void drawPaths ( PApplet g ) { drawUsingBreakShape ( g ) ; } 
protected void calculateCurveLengths ( ) { lenCurves = new float [ countPaths ( ) + countChildren ( ) ] ; lenCurve = 0F ; for ( int i = 0 ; i < countPaths ( ) ; i + + ) { lenCurves [ i ] = paths [ i ] . getCurveLength ( ) ; lenCurve + = lenCurves [ i ] ; } for ( int i = 0 ; i < countChildren ( ) ; i + + ) { lenCurves [ i + countPaths ( ) ] = children [ i ] . getCurveLength ( ) ; 
private float [ ] indAndAdvAt ( float ) { int indOfElement = 0 ; float [ ] lengthsCurves = getCurveLengths ( ) ; float lengthCurve = getCurveLength ( ) ; while ( > accumulatedAdvancement ) { indOfElement + + ; prevAccumulatedAdvancement = accumulatedAdvancement ; accumulatedAdvancement + = ( lengthsCurves [ indOfElement ] / lengthCurve ) ; } float advOfElement = ( - prevAccumulatedAdvancement ) / ( lengthsCurves [ indOfElement ] / lengthCurve ) ; float [ ] indAndAdv = new float [ 2 ] ; indAndAdv [ 0 ] = indOfElement ; indAndAdv [ 1 ] = RG . parent ( ) . constrain ( advOfElement , 0.0f , 1.0f ) ; return indAndAdv ; } 
private void drawUsingInternalTesselator ( PGraphics g ) { int numPaths = countPaths ( ) ; if ( numPaths ! = 0 ) { if ( isIn ( g ) ) { 
private void drawUsingInternalTesselator ( PApplet p ) { int numPaths = countPaths ( ) ; if ( numPaths ! = 0 ) { if ( isIn ( p ) ) { 
public boolean contains ( RPoint [ ] pts ) { if ( pts . length = = 0 ) { return false ; } boolean inside = true ; for ( RPoint pt : pts ) { if ( ! contains ( pt ) ) { inside = false ; break ; } } return inside ; } 
