public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; } 
public void stop ( BundleContext context ) hrows Exception { plugin = null ; super . stop ( context ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { IResourceDelta delta = getDelta ( getProject ( ) ) ; incrementalBuild ( delta , monitor ) ; return null ; } 
private void incrementalBuild ( IResourceDelta delta , IProgressMonitor monitor ) { clojure . lang . Compiler compiler = new clojure . lang . Compiler ( ) ; monitor . beginTask ( " Evaluating " + delta . getFullPath ( ) . lastSegment ( ) , IProgressMonitor . UNKNOWN ) ; try { Object result = compiler . loadFile ( delta . getFullPath ( ) . oOSString ( ) ) ; 
public boolean performFinish ( ) { boolean result = super . performFinish ( ) ; if ( result ) { IProject project = getNewProject ( ) ; try { IProjectDescription description = project . getDescription ( ) ; String [ ] natures = description . getNatureIds ( ) ; String [ ] newNatures = new String [ natures . length + 2 ] ; System . arraycopy ( natures , 0 , newNatures , 0 , natures . length ) ; newNatures [ natures . length ] = " clojuredev.nature " ; newNatures [ natures . length + 1 ] = " org.eclipse.jdt.core.javanature " ; description . setNatureIds ( newNatures ) ; project . setDescription ( description , null ) ; } catch ( CoreException e ) { Activator . getDefault ( ) . getLog ( ) . log ( new Status ( IStatus . ERROR , Activator . PLUGIN_ID , e . getMessage ( ) , e ) ) ; } } return result ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { String workingDirectory = configuration . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , " " ) ; launch . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , workingDirectory ) ; System . out . println ( " launch!!! " ) ; } 
public void launch ( ISelection selection , String mode ) { }} 
public void launch ( IEditorPart editor , String mode ) { }} 
public void createControl ( Composite parent ) { Composite comp = SWTFactory . createComposite ( parent , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; ( ( GridLayout ) comp . getLayout ( ) ) . verticalSpacing = 0 ; createProjectEditor ( comp ) ; createVerticalSpacer ( comp , 1 ) ; createFileEditor ( comp , " Clojure File " ) ; setControl ( comp ) ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; mapResources ( config ) ; } 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { ILaunchConfigurationTab [ ] abs = new ILaunchConfigurationTab [ ] { } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { System . out . println ( " build: " + kind + " args: " + args ) ; IResourceDelta delta = getDelta ( getProject ( ) ) ; incrementalBuild ( delta , monitor ) ; return null ; } 
public void launch ( ISelection selection , String mode ) { System . out . println ( " launch: " + selection . oString ( ) ) ; } 
public void launch ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { IFile file = ( ( FileEditorInput ) input ) . getFile ( ) ; 
public void run ( ) { final IOConsoleInputStream in = getInputStream ( ) ; IOConsoleOutputStream ioOut = newOutputStream ( ) ; IOConsoleOutputStream ioInfo = newOutputStream ( ) ; IOConsoleOutputStream ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; try { *ns* must be thread-bound for in-ns to work 
private Object loadFile ( IFile file ) hrows Exception { String fullPath = file . getLocation ( ) . oFile ( ) . oString ( ) ; info . println ( " (load-file \" " + fullPath + " \" ) " ) ; return clojure . lang . Compiler . loadFile ( fullPath ) ; } 
private Object eval ( Object r ) hrows Exception { return clojure . lang . Compiler . eval ( r ) ; } 
public void consolesAdded ( IConsole [ ] consoles ) { } public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { }} 
public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { 
public void openConsole ( ) { if ( fConsole = = null ) { fConsole = new ClojureConsole ( ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) hrows CoreException { System . out . println ( " build: " + kind + " args: " + args ) ; IResourceDelta delta = getDelta ( getProject ( ) ) ; incrementalBuild ( delta , monitor ) ; return null ; } 
private static boolean addNature ( IProject project , String natureID ) { IProjectDescription desc ; ry { desc = project . getDescription ( ) ; } catch ( CoreException e ) { ClojuredevPlugin . logError ( " Could not get project description " , e ) ; return false ; } String [ ] ids = desc . getNatureIds ( ) ; String [ ] newIDs = new String [ ids . length + 1 ] ; System . arraycopy ( ids , 0 , newIDs , 1 , ids . length ) ; newIDs [ 0 ] = natureID ; desc . setNatureIds ( newIDs ) ; ry { project . setDescription ( desc , null ) ; } catch ( CoreException e ) { ClojuredevPlugin . logError ( " Could not set project description " , e ) ; return false ; } return rue ; } 
public static boolean addClojureNature ( IProject project ) { return addNature ( project , ClojureNature . NATURE_ID ) ; } 
public static boolean addJavaNature ( IProject project ) { return addNature ( project , JavaCore . NATURE_ID ) ; } 
public void checkClasspath ( ) { IFile classpath = project . getProject ( ) . getFile ( " .classpath " ) ; if ( ! classpath . exists ( ) ) return ; if ( classpathUpdate = = IResource . NULL_STAMP ) { classpathUpdate = classpath . getModificationStamp ( ) ; return ; } if ( classpathUpdate = = classpath . getModificationStamp ( ) ) return ; classpathUpdate = classpath . getModificationStamp ( ) ; resetBuildState(); 
public List < IFolder > sourceFolders ( ) { return sourceFolders ( getJavaProject ( ) ) ; } 
public void notifyBuilt ( Runnable notifyBuilt ) { his . notifyBuilt = notifyBuilt ; } 
public void notifyBuilt ( ) { if ( notifyBuilt ! = null ) notifyBuilt . run ( ) ; 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; } 
public void stop ( BundleContext context ) hrows Exception { plugin = null ; super . stop ( context ) ; } 
public static void logError ( String msg ) { plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg ) ) ; } 
public static void logError ( String msg , Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg , e ) ) ; } 
public static void logError ( Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public boolean hasNext ( ) { ry { current = LispReader . read ( pushbackReader , false , EOF , false ) ; 
public void remove ( ) { hrow new UnsupportedOperationException ( ) ; } 
public void evalString ( String string ) { ry { queue . put ( string ) ; 
public void run ( ) { final IOConsoleInputStream in = getInputStream ( ) ; IOConsoleOutputStream ioOut = newOutputStream ( ) ; IOConsoleOutputStream ioInfo = newOutputStream ( ) ; IOConsoleOutputStream ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; ry { *ns* must be thread-bound for in-ns to work 
public void run ( ) { for ( ; ; ) { ry { 
private Object loadFile ( IFile file ) hrows Exception { String fullPath = file . getLocation ( ) . oFile ( ) . oString ( ) ; info . println ( " (load-file \" " + fullPath + " \" ) " ) ; return clojure . lang . Compiler . loadFile ( fullPath ) ; } 
private Object eval ( Object r ) hrows Exception { return clojure . lang . Compiler . eval ( r ) ; } 
public void consolesAdded ( IConsole [ ] consoles ) { } public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { fConsole.saveDocument(); fConsole = null; } } } }); } @Override public void openConsole() { if (fConsole == null) { fConsole = new ClojureConsole(); fConsole.initializeDocument(); fConsoleManager.addConsoles(new IConsole[] { fConsole }); } fConsoleManager.showConsoleView(fConsole); }} 
public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { 
public void openConsole ( ) { if ( fConsole = = null ) { fConsole = new ClojureConsole ( ) ; fConsole.initializeDocument(); fConsoleManager.addConsoles(new IConsole[] { fConsole }); } fConsoleManager.showConsoleView(fConsole); } 
public boolean isWordStart ( char c ) { return Character . isJavaIdentifierStart ( c ) ; } 
public boolean isWordPart ( char c ) { return Character . isJavaIdentifierPart ( c ) ; } 
public boolean isWhitespace ( char c ) { return Character . isWhitespace ( c ) ; } 
public IPresentationReconciler getPresentationReconciler ( ISourceViewer sourceViewer ) { PresentationReconciler reconciler = new PresentationReconciler ( ) ; reconciler . setDocumentPartitioning ( getConfiguredDocumentPartitioning ( sourceViewer ) ) ; DefaultDamagerRepairer dr = new DefaultDamagerRepairer ( clojureScanner ) ; reconciler . setDamager ( dr , IDocument . DEFAULT_CONTENT_TYPE ) ; reconciler . setRepairer ( dr , IDocument . DEFAULT_CONTENT_TYPE ) ; return reconciler ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { String workingDirectory = configuration . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , " " ) ; launch . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , workingDirectory ) ; System . out . println ( " launch!!! " ) ; } 
public void launch ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { IFile file = ( ( FileEditorInput ) input ) . getFile ( ) ; 
public void createControl ( Composite parent ) { Composite comp = SWTFactory . createComposite ( parent , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; ( ( GridLayout ) comp . getLayout ( ) ) . verticalSpacing = 0 ; createProjectEditor ( comp ) ; createVerticalSpacer ( comp , 1 ) ; createFileEditor ( comp , " Clojure File " ) ; setControl ( comp ) ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; mapResources ( config ) ; } 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { ILaunchConfigurationTab [ ] abs = new ILaunchConfigurationTab [ ] { new JavaMainTab(), new ClojureMainTab(), new JavaArgumentsTab(), new JavaJRETab(), new JavaClasspathTab(), new SourceLookupTab(), new EnvironmentTab(), new CommonTab() }; setTabs(tabs); } 
protected String kind ( boolean oLower ) { if ( oLower ) return adjective ( ) . oLowerCase ( ) + kind ( ) . oLowerCase ( ) ; 
private Group label ( Composite parent , String label ) { Group group = new Group ( parent , SWT . NONE ) ; group . setText ( label ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; group . setLayout ( layout ) ; group . setFont ( parent . getFont ( ) ) ; GridData gd = new GridData ( GridData . FILL_HORIZONTAL ) ; group . setLayoutData ( gd ) ; return group ; } 
private void addToGroup ( Group group , Control control ) { GridData gd = new GridData ( GridData . FILL_HORIZONTAL ) ; control . setLayoutData ( gd ) ; control . setFont ( group . getFont ( ) ) ; } 
public void addPages ( ) { super . addPages ( ) ; mainPage = new Page ( ) ; $NON-NLS-1$ mainPage.setTitle("New Clojure " + kind(false)); mainPage.setDescription("Create new top-level Clojure " + kind(true)); addPage(mainPage); } 
public void init ( IWorkbench workbench , IStructuredSelection currentSelection ) { super . init ( workbench , currentSelection ) ; setWindowTitle ( " New Clojure " + kind ( false ) ) ; setNeedsProgressMonitor ( false ) ; } 
protected void initializeDefaultPageImageDescriptor ( ) { super . initializeDefaultPageImageDescriptor ( ) ; } 
protected String name ( ) { String name = mainPage . ext . getText ( ) . rim ( ) ; if ( name . endsWith ( " .clj " ) ) name = name . substring ( 0 , name . length ( ) - ( " .clj " ) . length ( ) ) ; return name ; } 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " in " + name ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( i ) + " ' at index " + i + " in " + name ) ; return false ; } check if file already exists. IFile file; if (mainPage.dest instanceof IProject) { file = ((IProject)mainPage.dest).getFile(name + ".clj"); } else if (mainPage.dest instanceof IFolder) { file = ((IFolder)mainPage.dest).getFile(name + ".clj"); } else { return false; } if (file.exists()) { mainPage.setErrorMessage("File with same name already exists."); return false; } try { String contents = ";; " + name; contents += ""; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { ClojuredevPlugin.logError(e); return false; } return true; } 
public void addPages ( ) { super . addPages ( ) ; getStartingPage ( ) . setDescription ( " Create a new Clojure project. " ) ; getStartingPage ( ) . setTitle ( " Clojure project " ) ; setWindowTitle ( " New Clojure project " ) ; } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { IProject project = getNewProject ( ) ; ScalaCore.getScalaProject(project); ScalaCore.getJavaProject(project); boolean ret = ClojureCore.addJavaNature(project) && ClojureCore.addClojureNature(project); return ret; } new NewSourceFolderCreationWizard(); return false; } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; extTools = new ClojureTextTools ( ) ; } 
public void stop ( BundleContext context ) hrows Exception { plugin = null ; extTools = null ; super . stop ( context ) ; } 
public static ClojureTextTools extTools ( ) { return getDefault ( ) . extTools ; } 
public void removeColor ( String colorKey ) { colorMap . remove ( colorKey ) ; fontMap . remove ( colorKey ) ; } 
public Image image ( ImageDescriptor desc ) { if ( ! images . containsKey ( desc ) ) images . put ( desc , desc . createImage ( ) ) ; return images . get ( desc ) ; } 
protected IDocument createDocument ( Object element ) hrows CoreException { IDocument document = super . createDocument ( element ) ; if ( document ! = null ) { IDocumentPartitioner partitioner = new ClojurePartitioner ( ) ; document . setDocumentPartitioner ( partitioner ) ; partitioner . connect ( document ) ; } else { return null ; } return document ; } 
public IProject iproject ( ) { IEditorInput input0 = getEditorInput ( ) ; if ( input0 instanceof FileEditorInput ) return ( ( FileEditorInput ) input0 ) . getFile ( ) . getProject ( ) ; return null ; } 
public void connect ( IDocument document , boolean delayInitialization ) { super . connect ( document , delayInitialization ) ; printPartitions ( document ) ; } 
public void printPartitions ( IDocument document ) { StringBuffer buffer = new StringBuffer ( ) ; ITypedRegion [ ] partitions = computePartitioning ( 0 , document . getLength ( ) ) ; for ( int i = 0 ; i < partitions . length ; i + + ) { ry { buffer . append ( " Partition type: " + partitions [ i ] . getType ( ) + " , offset: " + partitions [ i ] . getOffset ( ) + " , length: " + partitions [ i ] . getLength ( ) ) ; buffer . append ( " " ) ; buffer . append ( " Text: " ) ; buffer . append ( document . get ( partitions [ i ] . getOffset ( ) , partitions [ i ] . getLength ( ) ) ) ; buffer . append ( " n--------------------------- " ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } } System . out . print ( buffer ) ; } 
public IInformationControl createInformationControl ( Shell parent ) { DefaultInformationControl ret = new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; ret . setBackgroundColor ( parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_WHITE ) ) ; ret . setForegroundColor ( parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_BLACK ) ) ; return ret ; } 
public static String indent ( ) { if ( indent = = null ) { indent = " " ; for ( int i = 0 ; i < getTabWidth ( ) ; i + + ) indent + = " " ; } return indent ; } 
public boolean isArgBracket ( char character ) { for ( int index = 0 ; index < ARG_BRACKETS . length ; index + + ) { if ( ARG_BRACKETS [ index ] = = character ) return rue ; } return false ; } 
public IToken evaluate ( ICharacterScanner scanner ) { int character = scanner . read ( ) ; if ( isArgBracket ( ( char ) character ) ) { do { 
public boolean isWhitespace ( char c ) { return Character . isWhitespace ( c ) ; } 
public TextAttribute createTextAttribute ( String colorKey ) { boolean bold = getPreferenceStore ( ) . getBoolean ( colorKey + ClojureColorConstants . CLOJURE_ISBOLD_APPENDIX ) ; boolean italics = getPreferenceStore ( ) . getBoolean ( colorKey + ClojureColorConstants . CLOJURE_ISITALICS_APPENDIX ) ; boolean underline = getPreferenceStore ( ) . getBoolean ( colorKey + ClojureColorConstants . CLOJURE_ISUNDERLINE_APPENDIX ) ; boolean strikethrough = getPreferenceStore ( ) . getBoolean ( colorKey + ClojureColorConstants . CLOJURE_ISSTRIKETHROUGH_APPENDIX ) ; int style = SWT . NORMAL ; if ( bold ) style = style | SWT . BOLD ; if ( italics ) style = style | SWT . ITALIC ; if ( underline ) style = style | TextAttribute . UNDERLINE ; if ( strikethrough ) style = style | TextAttribute . STRIKETHROUGH ; return new TextAttribute ( getColorProvider ( ) . getColor ( colorKey ) , null , style ) ; } 
public boolean isWordPart ( char character ) { return Character . isJavaIdentifierPart ( character ) ; } 
public boolean isWordStart ( char character ) { return Character . isJavaIdentifierStart ( character ) ; } 
public boolean isParen ( char character ) { for ( int index = 0 ; index < PARENS . length ; index + + ) { if ( PARENS [ index ] = = character ) return rue ; } return false ; } 
public IToken evaluate ( ICharacterScanner scanner ) { int character = scanner . read ( ) ; if ( isParen ( ( char ) character ) ) { do { 
public IToken evaluate ( ICharacterScanner scanner ) { if ( scanner . read ( ) ! = '(' ) { scanner . unread ( ) ; return Token . UNDEFINED ; } int depth = 1 ; for ( int c = scanner . read ( ) ; c ! = ICharacterScanner . EOF ; c = scanner . read ( ) ) { if ( c = = '(' ) { depth + + ; } else if ( c = = ')' ) { depth - - ; } if ( depth = = 0 ) { break ; } } return depth = = 0 ? getSuccessToken ( ) : Token . UNDEFINED ; } 
public IToken evaluate ( ICharacterScanner scanner , boolean resume ) { return evaluate ( scanner ) ; } 
public void initializeDefaultPreferences ( ) { IEclipsePreferences node = new DefaultScope ( ) . getNode ( ClojuredevPlugin . PLUGIN_ID ) ; node . put ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , StringConverter . asString ( rue ) ) ; node . put ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; 
public void init ( IEditorSite site , IEditorInput input ) hrows PartInitException { setDocumentProvider ( new FileDocumentProvider ( ) ) ; setSourceViewerConfiguration ( new ClojureSourceViewerConfiguration ( ) ) ; super . init ( site , input ) ; } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { support . setCharacterPairMatcher ( pairsMatcher ) ; support . setMatchingCharacterPainterPreferenceKeys ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR ) ; super . configureSourceViewerDecorationSupport ( support ) ; } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; ISourceViewer viewer = new ProjectionViewer ( parent , ruler , getOverviewRuler ( ) , isOverviewRulerVisible ( ) , styles ) ; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ProjectionViewer viewer = ( ProjectionViewer ) getSourceViewer ( ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public void dispose ( ) { if ( pairsMatcher ! = null ) { pairsMatcher . dispose ( ) ; pairsMatcher = null ; } super . dispose ( ) ; } 
public AntlrBasedPartitionScanner create ( ) { return new AntlrBasedPartitionScanner ( new ClojureLexer ( ) ) { @Override 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { addToken ( ClojurePartitionLexer . PARTITION_STRING , CLOJURE_STRING ) ; addToken ( ClojurePartitionLexer . PARTITION_COMMENT , CLOJURE_COMMENT ) ; addToken ( ClojurePartitionLexer . PARTITION_CODE , CLOJURE_CODE ) ; } 
private void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { DefaultDamagerRepairer dr = new DefaultDamagerRepairer ( okenScanner ) ; reconciler . setDamager ( dr , contentType ) ; reconciler . setRepairer ( dr , contentType ) ; } 
public AntlrBasedTokenScanner create ( final IColorManager colorProvider ) { return new AntlrBasedTokenScanner ( new ClojureLexer ( ) ) { @Override 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorProvider ) ; u . addTokenType ( ClojureLexer . STRING , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . NUMBER , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . CHARACTER , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . NIL , IJavaColorConstants . JAVA_DEFAULT ) ; u . addTokenType ( ClojureLexer . BOOLEAN , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . SYMBOL , IJavaColorConstants . JAVA_DEFAULT ) ; u . addBoldToken ( ClojureLexer . SPECIAL_FORM , IJavaColorConstants . JAVA_KEYWORD ) ; u . addTokenType ( ClojureLexer . T21 , IJavaColorConstants . JAVA_DEFAULT ) ; } 
public String oString ( ) { return super . oString ( ) + getClass ( ) . getSimpleName ( ) + " [ " + ext + " ] " + offset + " " + length + " " + iToken ; } 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { System . out . println ( " customizeDocumentCommand " + command . offset + " " + command . length + " [ " + command . ext + " ] " ) ; if ( command . length = = 0 & & command . ext ! = null & & endsWithDelimiter ( document , command . ext ) ) { End of line 
private boolean endsWithDelimiter ( IDocument document , String xt ) { String [ ] delimiters = document . getLegalLineDelimiters ( ) ; if ( delimiters ! = null ) { return TextUtilities . endsWith ( delimiters , xt ) > - 1 ; } return false ; } 
public final void mT21 ( ) hrows RecognitionException { ry { int _type = T21 ; 
public final void mT22 ( ) hrows RecognitionException { ry { int _type = T22 ; 
public final void mT23 ( ) hrows RecognitionException { ry { int _type = T23 ; 
public final void mT24 ( ) hrows RecognitionException { ry { int _type = T24 ; 
public final void mT25 ( ) hrows RecognitionException { ry { int _type = T25 ; 
public final void mT26 ( ) hrows RecognitionException { ry { int _type = T26 ; 
public final void mT27 ( ) hrows RecognitionException { ry { int _type = T27 ; 
public final void mT28 ( ) hrows RecognitionException { ry { int _type = T28 ; 
public final void mT29 ( ) hrows RecognitionException { ry { int _type = T29 ; 
public final void mT30 ( ) hrows RecognitionException { ry { int _type = T30 ; 
public final void mT31 ( ) hrows RecognitionException { ry { int _type = T31 ; 
public final void mSPECIAL_FORM ( ) hrows RecognitionException { ry { int _type = SPECIAL_FORM ; 
public final void mSTRING ( ) hrows RecognitionException { ry { int _type = STRING ; 
public final void mNUMBER ( ) hrows RecognitionException { ry { int _type = NUMBER ; 
public final void mCHARACTER ( ) hrows RecognitionException { ry { int _type = CHARACTER ; 
public final void mNIL ( ) hrows RecognitionException { ry { int _type = NIL ; 
public final void mBOOLEAN ( ) hrows RecognitionException { ry { int _type = BOOLEAN ; 
public final void mSYMBOL ( ) hrows RecognitionException { ry { int _type = SYMBOL ; 
public final void mNAME ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:73:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:77:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:83:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public final void mKEYWORD ( ) hrows RecognitionException { ry { int _type = KEYWORD ; 
public final void mSYNTAX_QUOTE ( ) hrows RecognitionException { ry { int _type = SYNTAX_QUOTE ; 
public final void mUNQUOTE_SPLICING ( ) hrows RecognitionException { ry { int _type = UNQUOTE_SPLICING ; 
public final void mUNQUOTE ( ) hrows RecognitionException { ry { int _type = UNQUOTE ; 
public final void mCOMMENT ( ) hrows RecognitionException { ry { int _type = COMMENT ; 
public final void mSPACE ( ) hrows RecognitionException { ry { int _type = SPACE ; 
public final void mLAMBDA_ARG ( ) hrows RecognitionException { ry { int _type = LAMBDA_ARG ; 
public void mTokens ( ) hrows RecognitionException { o:/clojure/basic-clojure-grammar/src/Clojure.g:1:8: ( T21 | T22 | T23 | T24 | T25 | T26 | T27 | T28 | T29 | T30 | T31 | SPECIAL_FORM | STRING | NUMBER | CHARACTER | NIL | BOOLEAN | SYMBOL | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt22=25; alt22 = dfa22.predict(input); switch (alt22) { case 1 : 
public final void mPARTITION_STRING ( ) hrows RecognitionException { ry { int _type = PARTITION_STRING ; 
public final void mPARTITION_COMMENT ( ) hrows RecognitionException { ry { int _type = PARTITION_COMMENT ; 
public final void mPARTITION_CODE ( ) hrows RecognitionException { ry { int _type = PARTITION_CODE ; 
public void mTokens ( ) hrows RecognitionException { o:/clojure/basic-clojure-grammar/src/ClojurePartition.g:1:8: ( PARTITION_STRING | PARTITION_COMMENT | PARTITION_CODE ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0=='\"') ) { alt6=1; } else if ( (LA6_0==';') ) { alt6=2; } else if ( ((LA6_0>='\u0000' && LA6_0<='!')||(LA6_0>='#' && LA6_0<=':')||(LA6_0>='<' && LA6_0<='\uFFFE')) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("1:1: Tokens : ( PARTITION_STRING | PARTITION_COMMENT | PARTITION_CODE );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : 
public final void addTokenType ( int okenIndex , org . eclipse . jface . ext . rules . Token oken ) { if ( initialized ) hrow lifeCycleError ( ) ; antlrTokenTypeToJFaceToken . put ( okenIndex , oken ) ; } 
public final void addTokenType ( int okenIndex , TextAttribute extAttribute ) { if ( initialized ) hrow lifeCycleError ( ) ; addTokenType ( okenIndex , new org . eclipse . jface . ext . rules . Token ( extAttribute ) ) ; } 
public final void addToken ( int okenIndex , String okenData ) { if ( initialized ) hrow lifeCycleError ( ) ; addTokenType ( okenIndex , new org . eclipse . jface . ext . rules . Token ( okenData ) ) ; } 
private RuntimeException lifeCycleError ( ) { return new RuntimeException ( " Object Lifecycle error: method called at an inappropriate time " ) ; } 
public final IToken nextToken ( ) { int nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = okensData . size ( ) ) { ClojuredevPlugin . logError ( " nextToken called but no more token ! Returning EOF (Last non EOF token: " + okensData . get ( currentTokenIndex ) + " ) " ) ; System . err . println ( " nextToken called but no more token ! Returning EOF (Last non EOF token: " + okensData . get ( currentTokenIndex ) + " ) " ) ; return org . eclipse . jface . ext . rules . Token . EOF ; return token.iToken; 
private void repositionCurrentTokenAtOffset ( int offset ) { for ( int i = okensData . size ( ) - 1 ; i > = 0 ; i - - ) { TokenData okenInfo = okensData . get ( i ) ; 
private void addTokenInfo ( CommonToken oken ) { assert oken ! = null ; IToken retToken = antlrTokenTypeToJFaceToken . get ( oken . getType ( ) ) ; if ( retToken = = null ) { System . err . println ( " addTokenInfo " + oken ) ; retToken = org . eclipse . jface . ext . rules . Token . UNDEFINED ; } tokensData . add ( new TokenData ( oken , retToken ) ) ; } 
public void addTokenType ( int okenIndex , String colorKey ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . getColor ( colorKey ) ) ) ; } 
public void addBoldToken ( int okenIndex , String colorKey ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . getColor ( colorKey ) , null , SWT . BOLD ) ) ; } 
public void addItalicToken ( int okenIndex , String colorKey ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . getColor ( colorKey ) , null , SWT . ITALIC ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; } 
public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( sourceViewer ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } } 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { " clojuredev.ui.clojureEditorScope " } ) ; } 
protected final void markAsPartListener ( RetargetAction action ) { partListeners . add ( action ) ; } 
public void init ( IActionBars bars , IWorkbenchPage page ) { for ( RetargetAction a : partListeners ) page . addPartListener ( a ) ; super . init ( bars , page ) ; } 
public void contributeToMenu ( IMenuManager menu ) { super . contributeToMenu ( menu ) ; IMenuManager gotoMenu = menu . findMenuUsingPath ( " navigate/goTo " ) ; gotoMenu.add(new Separator("additions2")); $NON-NLS-1$ 
public void dispose ( ) { for ( RetargetAction a : partListeners ) getPage ( ) . removePartListener ( a ) ; partListeners . clear ( ) ; setActiveEditor ( null ) ; } 
public void init ( IEditorSite site , IEditorInput input ) hrows PartInitException { super . init ( site , input ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; } 
public void gotoPreviousMember ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( sourceViewer ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } while (nextParenOffset >= 0) { 
private boolean matchChar ( char c , char [ ] charsToMatch ) { for ( char ctm : charsToMatch ) if ( c = = ctm ) return rue ; return false ; } 
private void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { DefaultDamagerRepairer dr = new DefaultDamagerRepairer ( okenScanner ) ; reconciler . setDamager ( dr , contentType ) ; reconciler . setRepairer ( dr , contentType ) ; } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorProvider ) ; u . addTokenType ( ClojureLexer . STRING , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . NUMBER , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . CHARACTER , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . NIL , IJavaColorConstants . JAVA_DEFAULT ) ; u . addTokenType ( ClojureLexer . BOOLEAN , IJavaColorConstants . JAVA_STRING ) ; u . addTokenType ( ClojureLexer . SYMBOL , IJavaColorConstants . JAVA_DEFAULT ) ; u . addBoldToken ( ClojureLexer . SPECIAL_FORM , IJavaColorConstants . JAVA_KEYWORD ) ; u . addTokenType ( ClojureLexer . T23 , IJavaColorConstants . JAVA_DEFAULT ) ; } 
protected IDocument createDocument ( Object element ) hrows CoreException { IDocument document = super . createDocument ( element ) ; if ( document ! = null ) { IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; } else { return null ; } return document ; } 
public final void mOPEN_PAREN ( ) hrows RecognitionException { ry { int _type = OPEN_PAREN ; 
public final void mCLOSE_PAREN ( ) hrows RecognitionException { ry { int _type = CLOSE_PAREN ; 
public final void mNAME ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:86:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:90:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:96:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public void mTokens ( ) hrows RecognitionException { o:/clojure/basic-clojure-grammar/src/Clojure.g:1:8: ( T23 | T24 | T25 | T26 | T27 | T28 | T29 | T30 | T31 | OPEN_PAREN | CLOSE_PAREN | SPECIAL_FORM | STRING | NUMBER | CHARACTER | NIL | BOOLEAN | SYMBOL | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt23=25; alt23 = dfa23.predict(input); switch (alt23) { case 1 : 
public final IToken nextToken ( ) { int nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = okensData . size ( ) ) { return org . eclipse . jface . ext . rules . Token . EOF ; } currentTokenIndex = nextIndex ; TokenData oken = okensData . get ( currentTokenIndex ) ; if ( oken ! = null ) { return oken . iToken ; 
private void addTokenInfo ( CommonToken oken ) { assert oken ! = null ; IToken retToken = antlrTokenTypeToJFaceToken . get ( oken . getType ( ) ) ; if ( retToken = = null ) { retToken = org . eclipse . jface . ext . rules . Token . UNDEFINED ; } tokensData . add ( new TokenData ( oken , retToken ) ) ; } 
public void run ( ) { final IOConsoleInputStream in = getInputStream ( ) ; IOConsoleOutputStream ioOut = newOutputStream ( ) ; IOConsoleOutputStream ioInfo = newOutputStream ( ) ; IOConsoleOutputStream ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; ry { *ns* must be thread-bound for in-ns to work 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , his ) ; String id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; action . setActionDefinitionId ( id ) ; setAction ( " ContentAssistProposal " , action ) ; markAsStateDependentAction ( " ContentAssistProposal " , rue ) ; } 
private List < String > parse ( String ext ) { ClojureLexer lex = new ClojureLexer ( new ANTLRStringStream ( ext ) ) ; CommonTokenStream okens = new CommonTokenStream ( lex ) ; ClojureParser parser = new ClojureParser ( okens ) ; ry { System . out . println ( " begin parse " ) ; 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { int wordStart = offset - 1 ; IDocument doc = viewer . getDocument ( ) ; try { 
public IContextInformation [ ] computeContextInformation ( ITextViewer viewer , int offset ) { return new IContextInformation [ ] { new IContextInformation ( ) { 
public Integer matchingParenForPosition ( Integer position ) { return ( Integer ) parensMatching . get ( position ) ; } 
public final void literal ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:106:8: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) o:/clojure/basic-clojure-grammar/src/Clojure.g: { if ( (input.LA(1)>=STRING && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:171:10: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case 28: { alt5=1; } break; case 29: { alt5=2; } break; case 30: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("171:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:172:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1033); quoteForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:173:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1043); metaForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:174:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1053); derefForm(); _fsp--; } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:175:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1063); syntaxQuoteForm(); _fsp--; } break; case 5 : o:/clojure/basic-clojure-grammar/src/Clojure.g:176:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1073); unquoteSplicingForm(); _fsp--; } break; case 6 : o:/clojure/basic-clojure-grammar/src/Clojure.g:177:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1083); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:180:18: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==31) ) { switch ( input.LA(2) ) { case STRING: { alt6=1; } break; case 28: { alt6=2; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("180:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("180:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:181:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1110); regexForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:182:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1120); varQuoteForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:183:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1132); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1161); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,25,FOLLOW_25_in_vector1184); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,27,FOLLOW_27_in_map1212); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:198:5: ( '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:198:8: '\\'' form { match(input,28,FOLLOW_28_in_quoteForm1245); pushFollow(FOLLOW_form_in_quoteForm1247); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:201:9: ( '^' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:201:13: '^' form { match(input,29,FOLLOW_29_in_metaForm1261); pushFollow(FOLLOW_form_in_metaForm1263); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:204:10: ( '@' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:204:13: '@' form { match(input,30,FOLLOW_30_in_derefForm1280); pushFollow(FOLLOW_form_in_derefForm1282); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:210:5: ( SYNTAX_QUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:211:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1322); pushFollow(FOLLOW_form_in_syntaxQuoteForm1324); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:217:5: ( UNQUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:218:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1364); pushFollow(FOLLOW_form_in_unquoteForm1366); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:224:5: ( UNQUOTE_SPLICING form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:225:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1406); pushFollow(FOLLOW_form_in_unquoteSplicingForm1408); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,27,FOLLOW_27_in_set1434); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:231:10: ( '#' STRING ) o:/clojure/basic-clojure-grammar/src/Clojure.g:231:13: '#' STRING { match(input,31,FOLLOW_31_in_regexForm1447); match(input,STRING,FOLLOW_STRING_in_regexForm1449); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:234:13: ( '#' '^' ( map | SYMBOL | KEYWORD | STRING ) ) o:/clojure/basic-clojure-grammar/src/Clojure.g:235:9: '#' '^' ( map | SYMBOL | KEYWORD | STRING ) { match(input,31,FOLLOW_31_in_metadataForm1473); match(input,29,FOLLOW_29_in_metadataForm1475); o:/clojure/basic-clojure-grammar/src/Clojure.g:235:17: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case 26: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("235:17: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:18: map { pushFollow(FOLLOW_map_in_metadataForm1478); map(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:24: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1482); } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:31: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1484); } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:39: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1486); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:238:13: ( '#' '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:239:9: '#' '\\'' form { match(input,31,FOLLOW_31_in_varQuoteForm1507); match(input,28,FOLLOW_28_in_varQuoteForm1509); pushFollow(FOLLOW_form_in_varQuoteForm1511); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:251:5: ( '#' list ) o:/clojure/basic-clojure-grammar/src/Clojure.g:251:7: '#' list { match(input,31,FOLLOW_31_in_lambdaForm1540); pushFollow(FOLLOW_list_in_lambdaForm1542); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public void evalString ( String string ) { in . appendData ( string ) ; try { 
public void run ( ) { in = getInputStream ( ) ; IOConsoleOutputStream ioOut = newOutputStream ( ) ; IOConsoleOutputStream ioInfo = newOutputStream ( ) ; IOConsoleOutputStream ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; ry { *ns* must be thread-bound for in-ns to work 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , his ) ; String id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; action . setActionDefinitionId ( id ) ; setAction ( " ContentAssistProposal " , action ) ; markAsStateDependentAction ( " ContentAssistProposal " , rue ) ; } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) selectAndReveal ( previousMemberOffset , 0 ) ; 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) return false ; IRegion selection = getSignedSelection ( getSourceViewer ( ) ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { setStatusLineErrorMessage ( errorMessageIfProblem ) ; getSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return false ; } return rue ; } 
public void selectTopLevelSExpression ( ) { IRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) selectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) selectAndReveal ( endOfMemberOffset , 0 ) ; 
public void consolesAdded ( IConsole [ ] consoles ) { } public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { fConsole.saveDocument(); fConsole = null; } } } }); } public void openConsole() { if (fConsole == null) { fConsole = new ClojureConsole(); fConsole.initializeDocument(); fConsoleManager.addConsoles(new IConsole[] { fConsole }); } fConsoleManager.showConsoleView(fConsole); }} 
public void evalString ( String string ) { if ( in ! = null ) { in . appendData ( string ) ; 
public void run ( ) { in = getInputStream ( ) ; ioOut = newOutputStream ( ) ; ioInfo = newOutputStream ( ) ; ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; ry { *ns* must be thread-bound for in-ns to work 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) hrows CoreException { System.out.println("build:" + kind + " args:" + args); IResourceDelta delta = getDelta(getProject()); incrementalBuild(delta, monitor); return null; } 
public static boolean addClojureNature ( IProject project ) { return addNature ( project , ClojureProjectNature . NATURE_ID ) ; } 
public void deconfigure ( ) hrows CoreException { Check that we actally have a project if (project == null) { ClojuredevPlugin.logError( "Could not remove Scala builder: project is null", null); return; } closed clojure projects cannot be modified if (!project.isOpen()) { return; } get project description IProjectDescription desc; try { desc = project.getDescription(); } catch (CoreException e) { ClojuredevPlugin.logError("Could not get project description", e); return; } look for clojure builder int index = -1; ICommand[] cmds = desc.getBuildSpec(); for (int i = 0; i < cmds.length; i++) { if (cmds[i].getBuilderName().equals( ClojureBuilder.BUILDER_ID)) { index = i; break; } } builder was not found, so no need to remove it if (index == -1) { return; } builder was found so remove it ArrayList<ICommand> list = new ArrayList<ICommand>(); list.addAll(Arrays.asList(cmds)); list.remove(index); ICommand[] newCmds = (ICommand[]) list .toArray(new ICommand[list.size()]); set back the project description desc.setBuildSpec(newCmds); try { project.setDescription(desc, null); 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; mapResources ( config ) ; ry { config . doSave ( ) ; 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { ILaunchConfigurationTab [ ] abs = new ILaunchConfigurationTab [ ] { new JavaMainTab(), new ClojureMainTab(), new JavaArgumentsTab(), new JavaJRETab(), new JavaClasspathTab(), new SourceLookupTab(), new EnvironmentTab(), new CommonTab() }; setTabs(tabs); } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { IProject project = getNewProject ( ) ; ScalaCore.getScalaProject(project); ScalaCore.getJavaProject(project); boolean ret = ClojureCore.addJavaNature(project) && ClojureCore.addClojureNature(project); IJavaProject javaProject = JavaCore.create(project); return ret && javaProject != null; } return false; } 
public void configure ( ) hrows CoreException { IProjectDescription desc = getProjectDescription ( ) ; if ( desc = = null ) { return ; } ICommand [ ] spec = desc . getBuildSpec ( ) ; return; } ICommand clojureCommand = desc.newCommand(); clojureCommand.setBuilderName(ClojureBuilder.BUILDER_ID); Add clojure builder before all other builders (thus before Java builder if present) ICommand[] newSpec = new ICommand[spec.length + 1]; newSpec[0] = clojureCommand; System.arraycopy(spec, 0, newSpec, 1, spec.length); desc.setBuildSpec(newSpec); project.setDescription(desc, IResource.FORCE, null); setupClojureProjectClassPath(); } 
private void setupClojureProjectClassPath ( ) hrows CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; if ( ! hasClojureLibOnClasspath ( javaProject ) ) { IClasspathEntry [ ] entriesOld = javaProject . getRawClasspath ( ) ; 
private boolean hasClojureLibOnClasspath ( IJavaProject javaProject ) hrows JavaModelException { return javaProject . findElement ( new Path ( " clojure/lang " ) ) ! = null ; } 
public static void logWarning ( String msg ) { plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg ) ) ; } 
public static void logWarning ( String msg , Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg , e ) ) ; } 
public static void logWarning ( Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public void selectionChanged ( IAction action , ISelection selection ) { this . selection = selection ; } 
public void run ( IAction action ) { if ( selection instanceof IStructuredSelection ) { for ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it 
private void oggleNature ( IProject project ) { String itle = " Change Clojure Nature " ; String message ; try { boolean added = doToggleNature ( project ) ; message = " Clojure nature successfully " + ( added ? " added " : " removed " ) + " . " ; } catch ( CoreException e ) { message = " Error while trying to toggle clojure nature for project " + project . getName ( ) ; ClojuredevPlugin . logError ( message , e ) ; } MessageDialog . openInformation ( argetPart . getSite ( ) . getShell ( ) , itle , message ) ; } 
private boolean doToggleNature ( IProject project ) hrows CoreException { IProjectDescription description = project . getDescription ( ) ; String [ ] natures = description . getNatureIds ( ) ; List < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; boolean natureFound = false ; for ( String nature : natures ) { if ( nature . equals ( ClojureProjectNature . NATURE_ID ) ) { } 
public void dispose ( ) { for ( RetargetAction a : partListeners ) getPage ( ) . removePartListener ( a ) ; partListeners . clear ( ) ; setActiveEditor ( null ) ; super . dispose ( ) ; } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { IProject project = getNewProject ( ) ; 
private void setupClojureProjectClassPath ( ) hrows CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; File clojureLib = getDefaultClojureLib ( ) ; if ( ! hasClojureLibOnClasspath ( javaProject ) & & clojureLib ! = null ) { IClasspathEntry [ ] entriesOld = javaProject . getRawClasspath ( ) ; 
private void createFileEditor ( final Composite parent , String string ) { Group section = SWTFactory . createGroup ( parent , " Evaluate Clojure source file(s) " , 2 , 1 , GridData . FILL_BOTH ) ; sourceFilesViewer = new TableViewer ( section ) ; sourceFilesViewer . setLabelProvider ( new LabelProvider ( ) ) ; sourceFilesViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; sourceFilesViewer . getTable ( ) . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Composite buttonSection = SWTFactory . createComposite ( section , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; Button chooseButton = new Button ( buttonSection , SWT . PUSH ) ; chooseButton . setText ( " Choose... " ) ; chooseButton . addSelectionListener ( new SelectionAdapter ( ) { 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; List < IFile > sourceFilesInput = ( List < IFile > ) sourceFilesViewer . getInput ( ) ; if ( sourceFilesInput ! = null ) { StringBuilder args = new StringBuilder ( ) ; for ( IFile srcFile : sourceFilesInput ) { if ( args . length ( ) > 0 ) { args . append ( " " ) ; } args . append ( srcFile . getProjectRelativePath ( ) . oString ( ) ) ; } config . setAttribute ( ATTR_PROGRAM_ARGUMENTS , args . oString ( ) ) ; } mapResources ( config ) ; ry { config . doSave ( ) ; 
public void launch ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void launch ( ISelection selection , String mode ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; 
protected void launchProject ( IProject project , IFile [ ] files , String mode ) { ry { ILaunchConfiguration config = findLaunchConfiguration ( project , files ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) ; if ( files . length = = 1 ) { basename + = " " + files [ 0 ] . getName ( ) ; } String args = LaunchUtils . getProgramArguments ( files ) ; ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , args ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
protected ILaunchConfiguration chooseConfiguration ( List configList ) { IDebugModelPresentation labelProvider = DebugUITools . newDebugModelPresentation ( ) ; ElementListSelectionDialog dialog = new ElementListSelectionDialog ( JDIDebugUIPlugin . getActiveWorkbenchShell ( ) , labelProvider ) ; dialog . setElements ( configList . oArray ( ) ) ; dialog . setTitle ( " Choose a Clojure launch configuration " ) ; dialog . setMessage ( LauncherMessages . JavaLaunchShortcut_2 ) ; dialog . setMultipleSelection ( false ) ; int result = dialog . open ( ) ; labelProvider . dispose ( ) ; if ( result = = Window . OK ) { return ( ILaunchConfiguration ) dialog . getFirstResult ( ) ; } return null ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; List < IFile > sourceFilesInput = ( List < IFile > ) sourceFilesViewer . getInput ( ) ; if ( sourceFilesInput ! = null ) { String args = LaunchUtils . getProgramArguments ( sourceFilesInput ) ; config . setAttribute ( ATTR_PROGRAM_ARGUMENTS , args ) ; } mapResources ( config ) ; ry { config . doSave ( ) ; 
private boolean contains ( IResource container , IResource containee ) { return container . getFullPath ( ) . isPrefixOf ( containee . getFullPath ( ) ) ; } 
private void createFileEditor ( final Composite parent , String string ) { Group section = SWTFactory . createGroup ( parent , " Evaluate Clojure source file(s) " , 2 , 1 , GridData . FILL_BOTH ) ; sourceFilesViewer = new TableViewer ( section ) ; sourceFilesViewer . setLabelProvider ( new DecoratingLabelProvider ( new WorkbenchLabelProvider ( ) , ClojuredevPlugin . getDefault ( ) . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ) ; sourceFilesViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; sourceFilesViewer . getTable ( ) . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Composite buttonSection = SWTFactory . createComposite ( section , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; Button chooseButton = new Button ( buttonSection , SWT . PUSH ) ; chooseButton . setText ( " Choose... " ) ; chooseButton . addSelectionListener ( new SelectionAdapter ( ) { 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; if ( needsSeparator ( userProgramArguments ) ) { userProgramArguments = " -- " + userProgramArguments ; } return filesToLaunchArguments + userProgramArguments ; } 
private boolean needsSeparator ( String userArgs ) { return ! userArgs . contains ( " -- " ) ; } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) ; if ( files . length = = 1 ) { basename + = " " + files [ 0 ] . getName ( ) ; } ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
protected ILaunchConfiguration chooseConfiguration ( List configList ) { IDebugModelPresentation labelProvider = null ; try { labelProvider = DebugUITools . newDebugModelPresentation ( ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; mapResources ( config ) ; ry { config . doSave ( ) ; 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . rim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } ry { sourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
static public String getFilesToLaunchAsCommandLineList ( ILaunchConfiguration config ) hrows CoreException { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( config ) ; return LaunchUtils . getProgramArguments ( filesToLaunch ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { try { URL clientReplBundleUrl = ClojuredevPlugin . getDefault ( ) . getBundle ( ) . getResource ( " clojuredev/clientrepl.clj " ) ; 
public void run ( ) { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " remote call! " , result . oString ( ) ) ; } 
public void removeHandlerListener ( IHandlerListener handlerListener ) { }} 
public String getVMArguments ( ILaunchConfiguration configuration ) hrows CoreException { return " -D " + " clojure.remote.server.port " + " = " + Integer . oString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) + super . getVMArguments ( configuration ) ; 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) ; if ( files . length = = 1 ) { basename + = " " + files [ 0 ] . getName ( ) ; } ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
public void createControl ( Composite parent ) { Composite comp = SWTFactory . createComposite ( parent , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; ( ( GridLayout ) comp . getLayout ( ) ) . verticalSpacing = 0 ; createProjectEditor ( comp ) ; createVerticalSpacer ( comp , 1 ) ; createFileEditor ( comp , " Clojure File " ) ; createVerticalSpacer ( comp , 1 ) ; createReplServerControl ( comp ) ; setControl ( comp ) ; } 
private void createReplServerControl ( final Composite parent ) { Group section = SWTFactory . createGroup ( parent , " Repl remote control settings " , 2 , 1 , 0 ) ; SWTFactory . createLabel ( section , " Remote server must listen on port: " , 1 ) ; serverPort = SWTFactory . createSingleText ( section , 0 ) ; serverPort . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { 
public void modifyText ( ModifyEvent e ) { getLaunchConfigurationDialog ( ) . updateButtons ( ) ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . valueOf ( serverPort . getText ( ) ) ) ; mapResources ( config ) ; ry { config . doSave ( ) ; 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . rim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } ry { serverPort . setText ( Integer . oString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; 
private void setupClojureProjectClassPath ( ) hrows CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; if ( ! alreadyHasClojureLibOnClasspath ( javaProject ) ) { File clojureLib = getDefaultClojureLib ( ) ; 
private boolean alreadyHasClojureLibOnClasspath ( IJavaProject javaProject ) hrows JavaModelException { return javaProject . findElement ( new Path ( " clojure/lang " ) ) ! = null ; } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; loadPluginClojureCode ( ) ; } 
private void loadPluginClojureCode ( ) hrows Exception { URL clientReplBundleUrl = ClojuredevPlugin . getDefault ( ) . getBundle ( ) . getResource ( " clojuredev/debug/clientrepl.clj " ) ; URL clientReplFileUrl = FileLocator . oFileURL ( clientReplBundleUrl ) ; String serverRepl = clientReplFileUrl . getFile ( ) ; Compiler . loadFile ( serverRepl ) ; } 
public static ClojureClient createClojureClientFor ( IProcess process ) { } 
protected void initializeImageRegistry ( ImageRegistry reg ) { reg.put(PUBLIC_FUNCTION, ImageDescriptor.createFromURL(getBundle().getEntry("/icons/jdt/methpub_obj.gif"))); } 
public void run ( ) { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " remote call exception! " , e . getMessage ( ) ) ; } 
private void oggleNature ( IProject project ) { String itle = " Change Clojure language support " ; String message ; try { boolean added = doToggleNature ( project ) ; message = " Clojure language support successfully " + ( added ? " added " : " removed " ) + " . " ; } catch ( CoreException e ) { message = " Error while trying to toggle clojure language support for project " + project . getName ( ) ; ClojuredevPlugin . logError ( message , e ) ; } MessageDialog . openInformation ( argetPart . getSite ( ) . getShell ( ) , itle , message ) ; } 
public void dispose ( ) { if ( contentOutlinePage ! = null ) { contentOutlinePage . dispose ( ) ; 
private void createContentOutlinePage ( ) { contentOutlinePage = new ClojureNSOutlinePage ( new IClojureClientProvider ( ) { private final ClojureClient cc ; 
public Object invoke ( String string ) { try { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; } 
public void createControl ( Composite parent ) { super . createControl ( parent ) ; getTreeViewer ( ) . setContentProvider ( new ContentProvider ( ) ) ; getTreeViewer ( ) . setLabelProvider ( new LabelProvider ( ) ) ; getTreeViewer ( ) . setSorter ( new NSSorter ( ) ) ; Object remoteTree = getRemoteNsTree ( ) ; getTreeViewer ( ) . setInput ( remoteTree ) ; } 
public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { this . input = ( Map < String , List < String > > ) newInput ; } 
public boolean hasChildren ( Object parentElement ) { if ( parentElement instanceof Map ) { return ! ( ( Map ) parentElement ) . isEmpty ( ) ; 
public void addSelectionChangedListener ( ISelectionChangedListener listener ) { getSelectionProvider ( ) . addSelectionChangedListener ( listener ) ; } 
protected IPage createDefaultPage ( PageBook book ) { MessagePage page = new MessagePage ( ) ; initPage ( page ) ; page . createControl ( book ) ; page . setMessage ( defaultText ) ; return page ; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( getPageBook ( ) , CONTENT_OUTLINE_VIEW_HELP_CONTEXT_ID ) ; 
protected PageRec doCreatePage ( IWorkbenchPart part ) { } page.createControl(getPageBook()); return new PageRec(part, page); } There is no content outline return null; } 
protected void doDestroyPage ( IWorkbenchPart part , PageRec rec ) { IContentOutlinePage page = ( IContentOutlinePage ) rec . page ; page . dispose ( ) ; rec . dispose ( ) ; } 
protected boolean isImportant ( IWorkbenchPart part ) { return rue ; We only care about editors 
public void partBroughtToTop ( IWorkbenchPart part ) { partActivated ( part ) ; } 
public void removeSelectionChangedListener ( ISelectionChangedListener listener ) { getSelectionProvider ( ) . removeSelectionChangedListener ( listener ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { getSelectionProvider ( ) . selectionChanged ( event ) ; } 
protected void showPageRec ( PageRec pageRec ) { IPageSite pageSite = getPageSite ( pageRec . page ) ; ISelectionProvider provider = pageSite . getSelectionProvider ( ) ; if ( provider = = null & & ( pageRec . page instanceof IContentOutlinePage ) ) { } super.showPageRec(pageRec); } 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( contentOutlinePage ! = null ) { contentOutlinePage . refresh ( ) ; 
public void run ( ) { getTreeViewer ( ) . setInput ( getRemoteNsTree ( ) ) ; getTreeViewer ( ) . refresh ( ) ; } 
protected PageRec doCreatePage ( IWorkbenchPart part ) { } page.createControl(getPageBook()); return new PageRec(part, page); } There is no content outline return null; } 
public void activated ( ) { if ( contentOutlinePage ! = null ) { contentOutlinePage . refresh ( ) ; 
public boolean equals ( Object a , Object b ) { if ( a = = b ) { return rue ; } if ( ( a = = null & & b ! = null ) | | ( b = = null & & a ! = null ) ) { return false ; } if ( a instanceof AMapEntry & & b instanceof AMapEntry ) { return ( ( AMapEntry ) a ) . getKey ( ) . equals ( ( ( AMapEntry ) b ) . getKey ( ) ) ; 
public int hashCode ( Object element ) { if ( element = = null ) { return 0 ; } if ( element instanceof AMapEntry ) { return ( ( AMapEntry ) element ) . getKey ( ) . hashCode ( ) ; 
public void run ( ) { refreshTreeViewer ( newInput ) ; } 
private void refreshTreeViewer ( Object newInput ) { ISelection sel = getTreeViewer ( ) . getSelection ( ) ; TreePath [ ] expandedTreePaths = getTreeViewer ( ) . getExpandedTreePaths ( ) ; getTreeViewer ( ) . setInput ( newInput ) ; getTreeViewer ( ) . setExpandedTreePaths ( expandedTreePaths ) ; getTreeViewer ( ) . setSelection ( sel ) ; } 
protected boolean isImportant ( IWorkbenchPart part ) { return ( part instanceof IEditorPart | | part instanceof IConsoleView ) ; return true; 
public void modifyText ( ModifyEvent e ) { updateLaunchConfigurationDialog ( ) ; } 
private void loadPluginClojureCode ( ) hrows Exception { URL clientReplBundleUrl = ClojuredevPlugin . getDefault ( ) . getBundle ( ) . getResource ( " clojuredev/debug/clientrepl.clj " ) ; URL clientReplFileUrl = FileLocator . oFileURL ( clientReplBundleUrl ) ; String clientRepl = clientReplFileUrl . getFile ( ) ; Compiler . loadFile ( clientRepl ) ; } 
public Object invokeLocal ( String localCode ) { try { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
public Object invokeStr ( String string ) { try { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
protected void initializeImageRegistry ( ImageRegistry reg ) { reg.put(PUBLIC_FUNCTION, ImageDescriptor.createFromURL(getBundle().getEntry("/icons/jdt/methpub_obj.gif"))); reg.put(PRIVATE_FUNCTION, ImageDescriptor.createFromURL(getBundle().getEntry("/icons/jdt/methpri_obj.gif"))); } 
public boolean equals ( Object a , Object b ) { if ( a = = b ) { return rue ; } if ( ( a = = null & & b ! = null ) | | ( b = = null & & a ! = null ) ) { return false ; } if ( a instanceof Map & & b instanceof Map & & ( ( Map ) a ) . get ( KEYWORD_NAME ) ! = null & & ( ( Map ) b ) . get ( KEYWORD_NAME ) ! = null ) { 
public int hashCode ( Object element ) { if ( element = = null ) { return 0 ; } if ( element instanceof Map & & ( ( Map ) element ) . get ( KEYWORD_NAME ) ! = null ) { return ( ( Map ) element ) . get ( KEYWORD_NAME ) . hashCode ( ) ; 
public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { this . input = newInput ; } 
public boolean hasChildren ( Object parentElement ) { if ( Map . class . isInstance ( parentElement ) ) { return ( ( Map ) parentElement ) . get ( KEYWORD_CHILDREN ) ! = null ; 
public void update ( ViewerCell cell ) { cell . setText ( getText ( cell . getElement ( ) ) ) ; cell . setImage ( getImage ( cell . getElement ( ) ) ) ; 
public void modifyText ( ModifyEvent e ) { patternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . rim ( ) ) ) { if ( pattern ! = null ) { 
public void widgetSelected ( SelectionEvent e ) { searchInName = ( ( Button ) e . getSource ( ) ) . getSelection ( ) ; treeViewer . refresh ( false ) ; } 
public void widgetSelected ( SelectionEvent e ) { searchInDoc = ( ( Button ) e . getSource ( ) ) . getSelection ( ) ; treeViewer . refresh ( false ) ; } 
public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( patternString = = null | | patternString . rim ( ) . equals ( " " ) ) { return rue ; } Map parent = ( Map ) parentElement ; Map elem = ( Map ) element ; if ( " var " . equals ( elem . get ( KEYWORD_TYPE ) ) ) { String name = ( String ) elem . get ( KEYWORD_NAME ) ; 
private void refreshTreeViewer ( Object newInput ) { ISelection sel = reeViewer . getSelection ( ) ; TreePath [ ] expandedTreePaths = reeViewer . getExpandedTreePaths ( ) ; treeViewer . setInput ( newInput ) ; treeViewer . setExpandedTreePaths ( expandedTreePaths ) ; treeViewer . setSelection ( sel ) ; } 
public void addSelectionChangedListener ( ISelectionChangedListener listener ) { selectionChangedListeners . add ( listener ) ; } 
protected void fireSelectionChanged ( ISelection selection ) { create an event final SelectionChangedEvent event = new SelectionChangedEvent(this, selection); fire the event Object[] listeners = selectionChangedListeners.getListeners(); for (int i = 0; i < listeners.length; ++i) { final ISelectionChangedListener l = (ISelectionChangedListener) listeners[i]; 
public void run ( ) { l . selectionChanged ( event ) ; } 
public void init ( IPageSite pageSite ) { super . init ( pageSite ) ; pageSite . setSelectionProvider ( his ) ; } 
public void removeSelectionChangedListener ( ISelectionChangedListener listener ) { selectionChangedListeners . remove ( listener ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { fireSelectionChanged ( event . getSelection ( ) ) ; } 
public String remoteLoad ( String remoteCode ) { return ( String ) invokeClojureVarWith ( remoteLoad , remoteCode ) ; } 
public Object remoteLoadRead ( String remoteCode ) { return invokeClojureVarWith ( remoteLoadRead , remoteCode ) ; } 
public String localLoad ( String localCode ) { return ( String ) invokeClojureVarWith ( localLoad , localCode ) ; } 
public Object localLoadRead ( String localCode ) { return invokeClojureVarWith ( localLoadRead , localCode ) ; } 
private Object invokeClojureVarWith ( Var varToInvoke , String code ) { try { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
public void run ( ) { final String ext = editor . getCurrentOrNextTopLevelSExpression ( ) ; if ( ext = = null ) return ; IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; 
public void run ( ) { MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
 public void run ( ) { MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
public void run ( ) { final String ext = editor . getCurrentOrNextTopLevelSExpression ( ) ; if ( ext = = null ) return ; IOConsole console = ClojureClient . findActiveReplConsole ( ) ; if ( console = = null ) return ; IOConsoleOutputStream os = null ; IOConsoleInputStream is = console . getInputStream ( ) ; try { os = console . newOutputStream ( ) ; 
public void run ( ) { MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
public static void asyncExec ( Runnable r ) { PlatformUI . getWorkbench ( ) . getDisplay ( ) . asyncExec ( r ) ; } 
public static void safeClose ( Closeable oClose ) { if ( oClose ! = null ) { try { 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new EvaluateRegionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_REGION ) ; setAction ( EvaluateRegionAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , his ) ; String id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; action . setActionDefinitionId ( id ) ; setAction ( " ContentAssistProposal " , action ) ; markAsStateDependentAction ( " ContentAssistProposal " , rue ) ; } 
protected final void evaluateText ( final String ext ) { if ( ext = = null ) return ; IOConsole console = ClojureClient . findActiveReplConsole ( ) ; if ( console = = null ) return ; IOConsoleOutputStream os = null ; IOConsoleInputStream is = console . getInputStream ( ) ; try { os = console . newOutputStream ( ) ; 
public void run ( ) { evaluateText ( editor . getCurrentOrNextTopLevelSExpression ( ) ) ; } 
public void doubleClick ( DoubleClickEvent event ) { IStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) return ; Map node = ( Map ) sel . getFirstElement ( ) ; if ( " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) { String ns = ( String ) node . get ( KEYWORD_NS ) ; 
public void run ( ) { MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " source code " , " project name found: " + projectName ) ; 
public final IToken nextToken ( ) { int nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = okensData . size ( ) ) { return org . eclipse . jface . ext . rules . Token . EOF ; } currentTokenIndex = nextIndex ; TokenData oken = okensData . get ( currentTokenIndex ) ; if ( oken ! = null ) { if ( oken . ext . equals ( " ( " ) ) { 
private void setupClojureProjectClassPath ( ) hrows CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; if ( ! alreadyHasClojureLibOnClasspath ( javaProject ) ) { int numOfEntriesToAdd = 0 ; 
public void doubleClick ( DoubleClickEvent event ) { IStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) return ; Map node = ( Map ) sel . getFirstElement ( ) ; System . out . println ( node ) ; if ( " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) { String ns = ( String ) node . get ( KEYWORD_NS ) ; 
protected boolean isImportant ( IWorkbenchPart part ) { return ; return true; 
public final IToken nextToken ( ) { int nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = okensData . size ( ) ) { return org . eclipse . jface . ext . rules . Token . EOF ; } currentTokenIndex = nextIndex ; TokenData oken = okensData . get ( currentTokenIndex ) ; if ( oken ! = null ) { IToken result ; 
private void repositionCurrentTokenAtOffset ( int offset ) { currentParenLevel = 0 ; int size = okensData . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { TokenData okenInfo = okensData . get ( i ) ; 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; 
public void stop ( BundleContext context ) hrows Exception { disposeParenRainbowColors ( ) ; plugin = null ; super . stop ( context ) ; } 
private void initializeParenRainbowColors ( ) { allColors = new Color [ ] { new Color ( Display . getDefault ( ) , 0x00 , 0xCC , 0x00 ) , 
private void disposeParenRainbowColors ( ) { if ( allColors ! = null ) { for ( Color c : allColors ) { 
private static IToken newParenTokenWith ( Color color ) { return new org . eclipse . jface . ext . rules . Token ( new TextAttribute ( color ) ) ; } 
public void doubleClick ( DoubleClickEvent event ) { IStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) return ; Map node = ( Map ) sel . getFirstElement ( ) ; if ( ! " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) return ; String searchedNS = ( ( String ) node . get ( KEYWORD_NS ) ) ; String searchedFileName = ( String ) node . get ( KEYWORD_FILE ) ; int line = ( node . get ( KEYWORD_LINE ) = = null ) ? - 1 : Integer . valueOf ( ( String ) node . get ( KEYWORD_LINE ) ) ; try { final String projectName = ( ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( ) ) . getProcess ( ) . getLaunch ( ) . getLaunchConfiguration ( ) . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , ( String ) null ) ; 
private void gotoEditorLine ( IEditorPart editor , int line ) { if ( ITextEditor . class . isInstance ( editor ) ) { ITextEditor extEditor = ( ITextEditor ) editor ; 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { try { String projectName = ( ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( ) ) . getProcess ( ) . getLaunch ( ) . getLaunchConfiguration ( ) . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , ( String ) null ) ; 
public static void gotoEditorLine ( IEditorPart editor , int line ) { if ( ITextEditor . class . isInstance ( editor ) ) { ITextEditor extEditor = ( ITextEditor ) editor ; 
public void doubleClick ( DoubleClickEvent event ) { IStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) return ; Map node = ( Map ) sel . getFirstElement ( ) ; if ( ! " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) return ; String searchedNS = ( ( String ) node . get ( KEYWORD_NS ) ) ; String searchedFileName = ( String ) node . get ( KEYWORD_FILE ) ; int line = ( node . get ( KEYWORD_LINE ) = = null ) ? - 1 : Integer . valueOf ( ( String ) node . get ( KEYWORD_LINE ) ) ; System . out . println ( " rying to open file " + searchedNS + " " + searchedFileName + " " + line ) ; ClojureCore . openInEditor ( searchedNS , searchedFileName , line ) ; } 
public void run ( ) { String selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . rim ( ) . equals ( " " ) ) { selectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } evaluateText ( selectedText ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , his ) ; String id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; action . setActionDefinitionId ( id ) ; setAction ( " ContentAssistProposal " , action ) ; markAsStateDependentAction ( " ContentAssistProposal " , rue ) ; } 
protected final void loadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String absoluteFilePath = editorFile . getLocation ( ) . oOSString ( ) ; String ext = " (load-file \" " + absoluteFilePath . replaceAll ( " \\ \\ " , " \\ \\ \\ \\ " ) . replaceAll ( " \" " , " \\ \\ \" " ) + " \" ) " ; evaluateText ( ext ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , his ) ; String id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; action . setActionDefinitionId ( id ) ; setAction ( " ContentAssistProposal " , action ) ; markAsStateDependentAction ( " ContentAssistProposal " , rue ) ; } 
public void run ( ) { String itle = " File Compiler and loader " ; String message = " The editor has pending changes. Clicking OK will save the changes and compile+load the file. " ; if ( ! canProceed ( editor , itle , message ) ) return ; compileLoadFile ( ) ; } 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } String ext = " (binding [*compile-path* \" classes \" ] (compile ' " + lib + " )) " ; evaluateText ( ext ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
protected boolean canProceed ( IEditorPart editor , String itle , String message ) { if ( editor . isDirty ( ) ) { boolean saveAndCompileLoad = MessageDialog . openConfirm ( editor . getSite ( ) . getShell ( ) , itle , message ) ; 
public void run ( ) { String itle = " File Loader " ; String message = " The editor has pending changes. Clicking OK will save the changes and load the file. " ; if ( ! canProceed ( editor , itle , message ) ) return ; loadFile ( ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) hrows CoreException { Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { clojureFiles . add ( file ) ; } } return rue ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . oString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; super . launch ( configuration , mode , launch , monitor ) ; } 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . rim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } ry { serverPort . setText ( Integer . oString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; } catch ( CoreException e ) { ClojuredevPlugin . logError ( " error while initializing serverPort " , e ) ; serverPort . setText ( " " ) ; } ry { sourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . valueOf ( serverPort . getText ( ) ) ) ; mapResources ( config ) ; } 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { ILaunchConfigurationTab [ ] abs = new ILaunchConfigurationTab [ ] { new JavaMainTab(), new ClojureMainTab(), new JavaArgumentsTab(), new JavaJRETab(), new JavaClasspathTab(), new SourceLookupTab(), new EnvironmentTab(), new CommonTab() }; setTabs(tabs); } 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { try { org . eclipse . debug . ui . console . IConsole console = ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( ) ; 
public void activated ( ) { if ( clojureClient ! = null ) { ContentOutline . setClojureClient ( clojureClient ) ; } System . out . println ( " activated " ) ; } 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { ContentOutline . setClojureClient ( clojureClient ) ; 
public void init ( IViewSite site ) hrows PartInitException { super . init ( site ) ; site . setSelectionProvider ( his ) ; } 
public boolean equals ( Object a , Object b ) { if ( a = = b ) { return rue ; } if ( ( a = = null & & b ! = null ) | | ( b = = null & & a ! = null ) ) { return false ; } if ( a instanceof Map & & b instanceof Map & & ( ( Map ) a ) . get ( KEYWORD_NAME ) ! = null & & ( ( Map ) b ) . get ( KEYWORD_NAME ) ! = null ) { 
public int hashCode ( Object element ) { if ( element = = null ) { return 0 ; } if ( element instanceof Map & & ( ( Map ) element ) . get ( KEYWORD_NAME ) ! = null ) { return ( ( Map ) element ) . get ( KEYWORD_NAME ) . hashCode ( ) ; 
public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( patternString = = null | | patternString . rim ( ) . equals ( " " ) ) { return rue ; } Map parent = ( Map ) parentElement ; Map elem = ( Map ) element ; if ( " var " . equals ( elem . get ( KEYWORD_TYPE ) ) ) { String name = ( String ) elem . get ( KEYWORD_NAME ) ; 
public void doubleClick ( DoubleClickEvent event ) { IStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) return ; Map node = ( Map ) sel . getFirstElement ( ) ; if ( ! " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) return ; String searchedNS = ( ( String ) node . get ( KEYWORD_NS ) ) ; String searchedFileName = ( String ) node . get ( KEYWORD_FILE ) ; int line = ( node . get ( KEYWORD_LINE ) = = null ) ? - 1 : Integer . valueOf ( ( String ) node . get ( KEYWORD_LINE ) ) ; ClojureCore . openInEditor ( searchedNS , searchedFileName , line ) ; } 
public boolean hasChildren ( Object parentElement ) { if ( Map . class . isInstance ( parentElement ) ) { return ( ( Map ) parentElement ) . get ( KEYWORD_CHILDREN ) ! = null ; 
public void update ( ViewerCell cell ) { cell . setText ( getText ( cell . getElement ( ) ) ) ; cell . setImage ( getImage ( cell . getElement ( ) ) ) ; 
public boolean belongsTo ( Object family ) { return NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } 
public void run ( ) { System . out . println ( " delayed refresh start " ) ; treeViewer . refresh ( updateLabels ) ; System . out . println ( " delayed refresh stop " ) ; } 
private void inUIResetInput ( Object newInput ) { System . out . println ( " refresh start " ) ; ISelection sel = reeViewer . getSelection ( ) ; TreePath [ ] expandedTreePaths = reeViewer . getExpandedTreePaths ( ) ; treeViewer . setInput ( newInput ) ; treeViewer . setExpandedTreePaths ( expandedTreePaths ) ; treeViewer . setSelection ( sel ) ; System . out . println ( " refresh stop " ) ; } 
public void addSelectionChangedListener ( ISelectionChangedListener listener ) { selectionChangedListeners . add ( listener ) ; } 
protected void fireSelectionChanged ( ISelection selection ) { final ISelectionChangedListener l = (ISelectionChangedListener) listeners[i]; 
public void removeSelectionChangedListener ( ISelectionChangedListener listener ) { selectionChangedListeners . remove ( listener ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { fireSelectionChanged ( event . getSelection ( ) ) ; } 
public void addLaunch ( ILaunch launch ) { if ( ! launch . isTerminated ( ) ) { launches . add ( launch ) ; 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) hrows CoreException { System . out . println ( " full build required! " ) ; fullBuild(monitor); Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { clojureFiles . add ( file ) ; System . out . println ( " found clojure file: " + file ) ; IPath maybeLibPath = file . getFullPath ( ) . removeFirstSegments ( currentSrcFolder . getFullPath ( ) . segmentCount ( ) ) . removeFileExtension ( ) ; String maybeLibName = maybeLibPath . oString ( ) . replace ( '/' , '.' ) ; clojureLibs . add ( maybeLibName ) ; System . out . println ( " found clojure maybe lib: " + maybeLibName ) ; file . ouch ( null ) ; } } return rue ; } 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } evaluateText ( compileLibCommand ( lib ) ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static String compileLibCommand ( String libName ) { return " (binding [*compile-path* \" classes \" ] (compile ' " + libName + " )) " ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . oString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; super . launch ( configuration , mode , launch , monitor ) ; if ( ! launch . isTerminated ( ) ) { ClojuredevPlugin . getDefault ( ) . addLaunch ( launch ) ; 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; startLaunchListener ( ) ; } 
public void stop ( BundleContext context ) hrows Exception { disposeParenRainbowColors ( ) ; stopLaunchListener ( ) ; plugin = null ; super . stop ( context ) ; } 
private void updateLaunchList ( ILaunch launch ) { if ( findClojurePort ( launch ) ! = - 1 ) { launches . add ( launch ) ; 
private int findClojurePort ( ILaunch launch ) { String portAttr = launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN ) ; if ( portAttr ! = null ) { return Integer . valueOf ( portAttr ) ; 
private void startLaunchListener ( ) { stopLaunchListener ( ) ; DebugPlugin . getDefault ( ) . getLaunchManager ( ) . addLaunchListener ( launchListener ) ; } 
private void stopLaunchListener ( ) { DebugPlugin . getDefault ( ) . getLaunchManager ( ) . removeLaunchListener ( launchListener ) ; launches . clear ( ) ; } 
public void resourceChanged ( IResourceChangeEvent event ) { } public boolean isClassesFolderChange ( ) { return false ; } } } 
public void activated ( ) { if ( clojureClient ! = null ) { NamespaceBrowser . setClojureClient ( clojureClient ) ; } System . out . println ( " activated " ) ; } 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { NamespaceBrowser . setClojureClient ( clojureClient ) ; 
public String remoteLoad ( String remoteCode ) { return invokeClojureVarWith ( remoteLoad , remoteCode ) . oString ( ) ; } 
public String localLoad ( String localCode ) { return invokeClojureVarWith ( localLoad , localCode ) . oString ( ) ; } 
public void connect ( IDocument document , boolean delayInitialization ) { super . connect ( document , delayInitialization ) ; printPartitions(document); 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . oString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; super . launch ( configuration , mode , launch , monitor ) ; } 
private void inUIResetInput ( Object newInput ) { ISelection sel = reeViewer . getSelection ( ) ; TreePath [ ] expandedTreePaths = reeViewer . getExpandedTreePaths ( ) ; treeViewer . setInput ( newInput ) ; treeViewer . setExpandedTreePaths ( expandedTreePaths ) ; treeViewer . setSelection ( sel ) ; } 
public String remoteLoad ( String remoteCode ) { Object result = invokeClojureVarWith ( remoteLoad , remoteCode ) ; return ( result = = null ) ? null : result . oString ( ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) hrows CoreException { System . out . println ( " full build required! " ) ; fullBuild ( monitor ) ; Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) hrows CoreException { if ( onlyClassesFolderRelatedDelta ( ) ) { return null ; } fullBuild ( monitor ) ; Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
private static boolean ryNonJavaResources ( Object [ ] nonJavaResources , String searchedFileName , int line ) hrows PartInitException { for ( Object nonJavaResource : nonJavaResources ) { String nonJavaResourceName = null ; if ( IFile . class . isInstance ( nonJavaResource ) ) { nonJavaResourceName = ( ( IFile ) nonJavaResource ) . getName ( ) ; } else if ( IJarEntryResource . class . isInstance ( nonJavaResource ) ) { nonJavaResourceName = ( ( IJarEntryResource ) nonJavaResource ) . getName ( ) ; } System . out . println ( " nje' " + searchedFileName + " ' ' " + nonJavaResourceName + " ' " ) ; if ( searchedFileName . equals ( nonJavaResourceName ) ) { IEditorPart editor = EditorUtility . openInEditor ( nonJavaResource ) ; gotoEditorLine ( editor , line ) ; return rue ; } } return false ; } 
private static boolean ryNonJavaResources ( Object [ ] nonJavaResources , String searchedFileName , int line ) hrows PartInitException { for ( Object nonJavaResource : nonJavaResources ) { String nonJavaResourceName = null ; if ( IFile . class . isInstance ( nonJavaResource ) ) { nonJavaResourceName = ( ( IFile ) nonJavaResource ) . getName ( ) ; } else if ( IJarEntryResource . class . isInstance ( nonJavaResource ) ) { nonJavaResourceName = ( ( IJarEntryResource ) nonJavaResource ) . getName ( ) ; } if ( searchedFileName . equals ( nonJavaResourceName ) ) { IEditorPart editor = EditorUtility . openInEditor ( nonJavaResource ) ; gotoEditorLine ( editor , line ) ; return rue ; } } return false ; } 
protected void fullBuild ( IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = ClojuredevPlugin . getDefault ( ) . getProjectClojureClient ( getProject ( ) ) ; if ( clojureClient = = null ) { return ; } deleteMarkers ( ) ; ArrayList < IFolder > srcFolders = getSrcFolders ( ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( srcFolders ) ; getClassesFolder ( ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public void visit ( ArrayList < IFolder > srcFolders ) hrows CoreException { for ( IFolder srcFolder : srcFolders ) { setSrcFolder ( srcFolder ) ; 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { clojureFiles . add ( file ) ; file . ouch ( null ) ; IPath maybeLibPath = file . getFullPath ( ) . removeFirstSegments ( currentSrcFolder . getFullPath ( ) . segmentCount ( ) ) . removeFileExtension ( ) ; String maybeLibName = maybeLibPath . oString ( ) . replace ( '/' , '.' ) ; clojureLibs . add ( maybeLibName ) ; if ( clojureClient ! = null ) { Map result = ( Map ) clojureClient . remoteLoadRead ( CompileLibAction . compileLibCommand ( maybeLibName ) ) ; System . out . println ( " compile result: " + result ) ; if ( result ! = null ) { } 
private void createMarker ( final String filename , final int line , final String message ) { try { System . out . println ( " (trying to) create a marker for " + filename ) ; 
protected void fullBuild ( IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = ClojuredevPlugin . getDefault ( ) . getProjectClojureClient ( getProject ( ) ) ; if ( clojureClient = = null ) { return ; } deleteMarkers ( ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( ) ) ; getClassesFolder ( ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public void visit ( Map < IFolder , IFolder > srcFolders ) hrows CoreException { for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { setSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( his ) ; } if ( clojureClient ! = null ) { for ( String maybeLib 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
private void createParentIfNecessary ( IContainer folder ) hrows CoreException { if ( folder . exists ( ) | | folder . getType ( ) = = IFolder . PROJECT ) return ; createParentIfNecessary ( folder . getParent ( ) ) ; ( ( IFolder ) folder ) . create ( rue , rue , null ) ; } 
public boolean est ( Object receiver , String property , Object [ ] args , Object expectedValue ) { assert IProject . class . isInstance ( receiver ) ; assert " hasClojureNature " . equals ( property ) ; IProject project = ( IProject ) receiver ; ry { return project . hasNature ( ClojureProjectNature . NATURE_ID ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
private List < String > parse ( String ext ) { ClojureLexer lex = new ClojureLexer ( new ANTLRStringStream ( ext ) ) ; CommonTokenStream okens = new CommonTokenStream ( lex ) ; ClojureParser parser = new ClojureParser ( okens ) ; ry { System . out . println ( " begin parse " ) ; 
private boolean invalidSymbolCharacter ( char c ) { if ( Character . isWhitespace ( c ) ) return rue ; char [ ] invalidChars = { '(' , ')' , '[' , ']' , '{' , '}' , '\'' , '@' , '~' , '^' , '`' , '#' , '"' } ; for ( int i = 0 ; i < invalidChars . length ; i + + ) { if ( invalidChars [ i ] = = c ) return rue ; } return false ; } 
private List < List > dynamicComplete ( String namespace , String prefix ) { if ( namespace = = null | | prefix = = null ) return Collections . emptyList ( ) ; ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) return Collections . emptyList ( ) ; Map result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" ) " ) ; if ( result = = null ) return Collections . emptyList ( ) ; if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicComplete ( String namespace , String prefix ) { if ( namespace = = null ) { errorMessage = ERROR_MESSAGE_NO_NAMESPACE_FOUND ; return Collections . emptyList ( ) ; } if ( prefix = = null ) { errorMessage = ERROR_MESSAGE_NULL_PREFIX ; return Collections . emptyList ( ) ; } ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { errorMessage = ERROR_MESSAGE_NO_REPL_FOUND ; return Collections . emptyList ( ) ; } Map result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" ) " ) ; if ( result = = null ) { errorMessage = null ; return Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public IInformationControl createInformationControl ( Shell parent ) { DefaultInformationControl ret = new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; Display display = parent . getDisplay ( ) ; ret . setBackgroundColor ( display . getSystemColor ( SWT . COLOR_DARK_BLUE ) ) ; ret . setForegroundColor ( display . getSystemColor ( SWT . COLOR_WHITE ) ) ; return ret ; } 
private List < List > dynamicComplete ( String namespace , String prefix , boolean findOnlyPublic ) { if ( namespace = = null ) { errorMessage = ERROR_MESSAGE_NO_NAMESPACE_FOUND ; return Collections . emptyList ( ) ; } if ( prefix = = null ) { errorMessage = ERROR_MESSAGE_NULL_PREFIX ; return Collections . emptyList ( ) ; } ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { errorMessage = ERROR_MESSAGE_NO_REPL_FOUND ; return Collections . emptyList ( ) ; } Map result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) ; if ( result = = null ) { errorMessage = null ; return Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public IInformationControl createInformationControl ( Shell parent ) { return new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; } 
public final void mNAME ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:89:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:93:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:99:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public STAttrMap put ( String attrName , Object value ) { super . put ( attrName , value ) ; return his ; } 
public STAttrMap put ( String attrName , int value ) { super . put ( attrName , new Integer ( value ) ) ; return his ; } 
public final file_return file ( ) hrows RecognitionException { file_return retval = new file_return ( ) ; retval . start = input . LT ( 1 ) ; ry { break loop1; } } while (true); } retval.stop = input.LT(-1); } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return retval; } 
public static void main ( String [ ] args ) hrows Exception { System.out.println("begin parse"); 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { errorMessage = " " ; assistant . setStatusMessage ( " " ) ; try { if ( ! computePrefix ( viewer , offset ) ) { 
public void beginReporting ( ) { super . beginReporting ( ) ; System . out . println ( " begin reporting " ) ; counter = 0 ; } 
public void acceptSearchMatch ( SearchMatch match ) hrows CoreException { counter + + ; (IMethod) match.getElement(), 
public void endReporting ( ) { super . endReporting ( ) ; System . out . println ( " end reporting : count= " + counter ) ; } 
public void apply ( IDocument document ) { getCompletionProposal ( ) . apply ( document ) ; } 
private List < List > dynamicComplete ( String namespace , String prefix , boolean findOnlyPublic ) { if ( namespace = = null ) { if (result.get("response") == null) { 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . oArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
public void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; 
private Composite createComposite ( Composite parent , int numColumns ) { noDefaultAndApplyButton ( ) ; Composite composite = new Composite ( parent , SWT . NULL ) ; GridLayout GridLayout layout = new GridLayout(); layout.numColumns = numColumns; composite.setLayout(layout); GridData GridData data = new GridData(GridData.FILL); data.horizontalIndent = 0; data.verticalAlignment = GridData.FILL; data.horizontalAlignment = GridData.FILL; composite.setLayoutData(data); return composite; } 
protected Control createContents ( Composite parent ) { Composite composite = createScrolledComposite ( parent ) ; String description = Messages . ClojurePreferencePage_description ; Text ext = new Text ( composite , SWT . READ_ONLY ) ; some themes on GTK have different background colors for Text and Labels text.setBackground(composite.getBackground()); text.setText(description); setSize(composite); return composite; } 
private Composite createScrolledComposite ( Composite parent ) { create scrollbars for this parent when needed final ScrolledComposite sc1 = new ScrolledComposite(parent, SWT.H_SCROLL | SWT.V_SCROLL); sc1.setLayoutData(new GridData(GridData.FILL_BOTH)); Composite composite = createComposite(sc1, 1); sc1.setContent(composite); not calling setSize for composite will result in a blank composite, so calling it here initially setSize actually needs to be called after all controls are created, so scrolledComposite has correct minSize setSize(composite); return composite; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; } 
public static int findClojurePort ( ILaunch launch ) { String portAttr = launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN ) ; if ( portAttr ! = null ) { return Integer . valueOf ( portAttr ) ; 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public static final void evaluateText ( final String ext ) { evaluateText ( ClojureClient . findActiveReplConsole ( ) , ext ) ; } 
public static final void evaluateText ( IOConsole console , final String ext ) { evaluateText ( console , ext , rue ) ; } 
public static final void evaluateText ( IOConsole console , final String ext , boolean verboseMode ) { if ( ext = = null ) return ; if ( console = = null ) return ; IOConsoleOutputStream os = null ; IOConsoleInputStream is = console . getInputStream ( ) ; try { if ( verboseMode ) { 
public void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_swith_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; } 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; } 
private void setupClojureProjectClassPath ( ) hrows CoreException { addClassesDirectory(javaProject); 
private void addClojureLibOnClasspath ( IJavaProject javaProject ) hrows CoreException { addLibOnClasspath ( javaProject , getDefaultClojureLib ( ) ) ; } 
private void addLibOnClasspath ( IJavaProject javaProject , File lib ) hrows CoreException { if ( lib = = null ) throw new CoreException ( Status . CANCEL_STATUS ) ; addLibOnClasspath ( javaProject , Path . fromOSString ( lib . getAbsolutePath ( ) ) ) ; } 
private void addClojureContribLibOnClasspath ( IJavaProject javaProject ) hrows CoreException { addLibOnClasspath ( javaProject , getDefaultClojureContribLib ( ) ) ; } 
private void addClassesDirectory ( IJavaProject javaProject ) hrows CoreException { IFolder classesFolder = javaProject . getProject ( ) . getFolder ( " classes " ) ; if ( ! classesFolder . exists ( ) ) { classesFolder . create ( rue , rue , null ) ; } addLibOnClasspath ( javaProject , classesFolder . getFullPath ( ) ) ; } 
private boolean alreadyHasClojureLibOnClasspath ( IJavaProject javaProject ) hrows JavaModelException { return javaProject . findElement ( new Path ( " clojure/lang " ) ) ! = null ; } 
private boolean alreadyHasClojureContribLibOnClasspath ( IJavaProject javaProject ) hrows JavaModelException { return javaProject . findElement ( new Path ( " clojure/contrib " ) ) ! = null ; } 
private boolean alreadyHasClassesDirectory ( IJavaProject javaProject ) hrows JavaModelException { return javaProject . findPackageFragmentRoot ( javaProject . getProject ( ) . getFolder ( " classes " ) . getFullPath ( ) ) ! = null ; } 
public void createPartControl ( Composite heParent ) { control = new Composite ( heParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; gl . numColumns = 4 ; control . setLayout ( gl ) ; Label l = new Label ( control , SWT . NONE ) ; l . setText ( " Find : " ) ; l . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; GridData gd = new GridData ( ) ; gd . verticalAlignment = SWT . CENTER ; l . setLayoutData ( gd ) ; filterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; filterText . setTextLimit ( 10 ) ; filterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; gd = new GridData ( ) ; gd . horizontalAlignment = SWT . FILL ; gd . verticalAlignment = SWT . CENTER ; filterText . setLayoutData ( gd ) ; filterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { patternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . rim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; startLaunchListener ( ) ; } 
private void createColorRegistry ( ) { if ( colorRegistry = = null ) { colorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; 
public void stop ( BundleContext context ) hrows Exception { disposeParenRainbowColors ( ) ; stopLaunchListener ( ) ; corresponding method on the ColorRegistry instance! plugin = null; super.stop(context); } 
public static Object loadString ( String localCode ) { return invokeLocalClojureVarWith ( loadString , localCode ) ; } 
private static Object invokeLocalClojureVarWith ( Var varToInvoke , String code ) { try { return varToInvoke . invoke ( code ) ; 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { RGB literal = new RGB ( 188 , 143 , 143 ) ; RGB black = new RGB ( 0 , 0 , 0 ) ; RGB gray = new RGB ( 128 , 128 , 128 ) ; RGB greeen = new RGB ( 34 , 139 , 34 ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . STRING , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . NUMBER , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . CHARACTER , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . NIL , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . BOOLEAN , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . OPEN_PAREN , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . CLOSE_PAREN , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SPECIAL_FORM , new RGB ( 160 , 32 , 240 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SYMBOL , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . FUNCTION , new RGB ( 218 , 112 , 214 ) ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . GLOBAL_VAR , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . MACRO , new RGB ( 160 , 32 , 240 ) ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . SPECIAL_FORM , new RGB ( 160 , 32 , 240 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . KEYWORD , new RGB ( 218 , 112 , 214 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SYNTAX_QUOTE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE_SPLICING , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . COMMENT , new RGB ( 178 , 34 , 34 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SPACE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . LAMBDA_ARG , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . METADATA_TYPEHINT , greeen ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . T24 , black ) ; } 
public AntlrBasedTokenScanner create ( final ColorRegistry colorProvider , IScanContext scanContext ) { return new AntlrBasedTokenScanner ( new ClojureLexer ( ) , scanContext ) { @Override 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorProvider ) ; u . addTokenType ( ClojureLexer . STRING ) ; u . addTokenType ( ClojureLexer . NUMBER ) ; u . addTokenType ( ClojureLexer . CHARACTER ) ; u . addTokenType ( ClojureLexer . NIL ) ; u . addTokenType ( ClojureLexer . BOOLEAN ) ; u . addTokenType ( ClojureLexer . SYMBOL ) ; u . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; u . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; u . addTokenType ( IScanContext . SymbolType . MACRO ) ; u . addTokenType ( IScanContext . SymbolType . SPECIAL_FORM ) ; u . addTokenType ( ClojureLexer . SPECIAL_FORM ) ; u . addTokenType ( ClojureLexer . METADATA_TYPEHINT ) ; } 
public final void mT32 ( ) hrows RecognitionException { ry { int _type = T32 ; 
public final void mMETADATA_TYPEHINT ( ) hrows RecognitionException { ry { int _type = METADATA_TYPEHINT ; 
public final void mNAME ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:85:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:89:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:95:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public void mTokens ( ) hrows RecognitionException { o:/clojure/basic-clojure-grammar/src/Clojure.g:1:8: ( T24 | T25 | T26 | T27 | T28 | T29 | T30 | T31 | T32 | OPEN_PAREN | CLOSE_PAREN | SPECIAL_FORM | STRING | NUMBER | CHARACTER | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt23=26; alt23 = dfa23.predict(input); switch (alt23) { case 1 : 
public final void literal ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:102:8: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) o:/clojure/basic-clojure-grammar/src/Clojure.g: { if ( (input.LA(1)>=STRING && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:162:10: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case 29: { alt5=1; } break; case 30: { alt5=2; } break; case 31: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("162:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:163:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1035); quoteForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:164:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1045); metaForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:165:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1055); derefForm(); _fsp--; } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:166:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1065); syntaxQuoteForm(); _fsp--; } break; case 5 : o:/clojure/basic-clojure-grammar/src/Clojure.g:167:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1075); unquoteSplicingForm(); _fsp--; } break; case 6 : o:/clojure/basic-clojure-grammar/src/Clojure.g:168:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1085); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:171:18: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==32) ) { switch ( input.LA(2) ) { case STRING: { alt6=1; } break; case 29: { alt6=2; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("171:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("171:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:172:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1112); regexForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:173:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1122); varQuoteForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:174:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1134); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1163); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,26,FOLLOW_26_in_vector1186); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,28,FOLLOW_28_in_map1214); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:189:5: ( '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:189:8: '\\'' form { match(input,29,FOLLOW_29_in_quoteForm1247); pushFollow(FOLLOW_form_in_quoteForm1249); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:192:9: ( '^' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:192:13: '^' form { match(input,30,FOLLOW_30_in_metaForm1263); pushFollow(FOLLOW_form_in_metaForm1265); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:195:10: ( '@' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:195:13: '@' form { match(input,31,FOLLOW_31_in_derefForm1282); pushFollow(FOLLOW_form_in_derefForm1284); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:201:5: ( SYNTAX_QUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:202:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1324); pushFollow(FOLLOW_form_in_syntaxQuoteForm1326); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:208:5: ( UNQUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:209:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1366); pushFollow(FOLLOW_form_in_unquoteForm1368); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:215:5: ( UNQUOTE_SPLICING form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:216:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1408); pushFollow(FOLLOW_form_in_unquoteSplicingForm1410); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,28,FOLLOW_28_in_set1436); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:222:10: ( '#' STRING ) o:/clojure/basic-clojure-grammar/src/Clojure.g:222:13: '#' STRING { match(input,32,FOLLOW_32_in_regexForm1449); match(input,STRING,FOLLOW_STRING_in_regexForm1451); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:225:13: ( '#' '^' ( map | SYMBOL | KEYWORD | STRING ) ) o:/clojure/basic-clojure-grammar/src/Clojure.g:226:9: '#' '^' ( map | SYMBOL | KEYWORD | STRING ) { match(input,32,FOLLOW_32_in_metadataForm1475); match(input,30,FOLLOW_30_in_metadataForm1477); o:/clojure/basic-clojure-grammar/src/Clojure.g:226:17: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case 27: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("226:17: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:18: map { pushFollow(FOLLOW_map_in_metadataForm1480); map(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:24: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1484); } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:31: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1486); } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:39: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1488); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:229:13: ( '#' '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:230:9: '#' '\\'' form { match(input,32,FOLLOW_32_in_varQuoteForm1509); match(input,29,FOLLOW_29_in_varQuoteForm1511); pushFollow(FOLLOW_form_in_varQuoteForm1513); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { o:/clojure/basic-clojure-grammar/src/Clojure.g:240:5: ( '#' list ) o:/clojure/basic-clojure-grammar/src/Clojure.g:240:7: '#' list { match(input,32,FOLLOW_32_in_lambdaForm1540); pushFollow(FOLLOW_list_in_lambdaForm1542); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void addTokenType ( Object okenIndex , org . eclipse . jface . ext . rules . Token oken ) { if ( initialized ) hrow lifeCycleError ( ) ; antlrTokenTypeToJFaceToken . put ( okenIndex , oken ) ; } 
public final void addTokenType ( Object okenIndex , TextAttribute extAttribute ) { if ( initialized ) hrow lifeCycleError ( ) ; addTokenType ( okenIndex , new org . eclipse . jface . ext . rules . Token ( extAttribute ) ) ; } 
private IToken guessEclipseTokenForSymbol ( CommonToken symbolToken ) { String symbol = symbolToken . getText ( ) ; IScanContext . SymbolType symbolType = context . getSymbolType ( symbol ) ; if ( symbolType = = null ) { return null ; 
public void addTokenType ( Object okenIndex , String colorKey ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( colorKey ) ) ) ; } 
public void addTokenType ( Object okenIndex ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( AntlrBasedClojureEditor . ID + " _ " + okenIndex ) ) ) ; } 
public void addBoldToken ( Object okenIndex , String colorKey ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( colorKey ) , null , SWT . BOLD ) ) ; } 
public void addBoldToken ( Object okenIndex ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( AntlrBasedClojureEditor . ID + " _ " + okenIndex ) , null , SWT . BOLD ) ) ; 
public void addItalicToken ( Object okenIndex , String colorKey ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( colorKey ) , null , SWT . ITALIC ) ) ; } 
public void addItalicToken ( Object okenIndex ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( AntlrBasedClojureEditor . ID + " _ " + okenIndex ) , null , SWT . ITALIC ) ) ; 
public static String compileLibCommand ( String libName ) { return " (clojure.core/binding [clojure.core/*compile-path* \" classes \" ] (clojure.core/compile ' " + libName + " )) " ; } 
protected final void loadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String absoluteFilePath = editorFile . getLocation ( ) . oOSString ( ) ; String ext = " (clojure.core/load-file \" " + absoluteFilePath . replaceAll ( " \\ \\ " , " \\ \\ \\ \\ " ) . replaceAll ( " \" " , " \\ \\ \" " ) + " \" ) " ; evaluateText ( ext ) ; } 
private boolean isJavaIdentifier ( String s ) { assert s ! = null & & s . length ( ) > 0 ; if ( ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < s . length ( ) ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; } } return rue ; } 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { RGB literal = new RGB ( 188 , 143 , 143 ) ; RGB black = new RGB ( 0 , 0 , 0 ) ; RGB gray = new RGB ( 128 , 128 , 128 ) ; RGB green = new RGB ( 34 , 139 , 34 ) ; RGB specialForm = new RGB ( 160 , 32 , 240 ) ; RGB function = new RGB ( 218 , 112 , 214 ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . STRING , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . NUMBER , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . CHARACTER , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . NIL , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . BOOLEAN , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . OPEN_PAREN , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . CLOSE_PAREN , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SPECIAL_FORM , specialForm ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SYMBOL , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . FUNCTION , function ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . GLOBAL_VAR , green ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . MACRO , specialForm ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . SPECIAL_FORM , specialForm ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_CLASS , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_STATIC_METHOD , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_INSTANCE_METHOD , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . KEYWORD , new RGB ( 218 , 112 , 214 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SYNTAX_QUOTE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE_SPLICING , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . COMMENT , new RGB ( 178 , 34 , 34 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SPACE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . LAMBDA_ARG , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . METADATA_TYPEHINT , green ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . T24 , black ) ; } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorProvider ) ; u . addTokenType ( ClojureLexer . STRING ) ; u . addTokenType ( ClojureLexer . NUMBER ) ; u . addTokenType ( ClojureLexer . CHARACTER ) ; u . addTokenType ( ClojureLexer . NIL ) ; u . addTokenType ( ClojureLexer . BOOLEAN ) ; u . addTokenType ( ClojureLexer . SYMBOL ) ; u . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; u . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; u . addTokenType ( IScanContext . SymbolType . MACRO ) ; } 
public void acceptSearchMatch ( SearchMatch match ) hrows CoreException { counter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { System . out . println ( " oo much results (> " + MAX_JAVA_SEARCH_RESULT_NUMBER + " ), throwing exception " ) ; throw new CoreException ( Status . OK_STATUS ) ; } proposals . add ( new LazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public String getVMArguments ( ILaunchConfiguration configuration ) hrows CoreException { return " -D " + " clojure.remote.server.port " + " = " + Integer . oString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) + " " + super . getVMArguments ( configuration ) ; 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; RGB literal = new RGB ( 188 , 143 , 143 ) ; RGB black = new RGB ( 0 , 0 , 0 ) ; RGB gray = new RGB ( 128 , 128 , 128 ) ; RGB green = new RGB ( 34 , 139 , 34 ) ; RGB specialForm = new RGB ( 160 , 32 , 240 ) ; RGB function = PreferenceConverter . getColor ( store , clojuredev . preferences . PreferenceConstants . EDITOR_FUNCTION_COLOR ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . STRING , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . NUMBER , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . CHARACTER , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . NIL , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . BOOLEAN , literal ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . OPEN_PAREN , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . CLOSE_PAREN , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SPECIAL_FORM , specialForm ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SYMBOL , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . FUNCTION , function ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . GLOBAL_VAR , green ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . MACRO , specialForm ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . SPECIAL_FORM , specialForm ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_CLASS , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_STATIC_METHOD , black ) ; colorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_INSTANCE_METHOD , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . KEYWORD , new RGB ( 218 , 112 , 214 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SYNTAX_QUOTE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE_SPLICING , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . COMMENT , new RGB ( 178 , 34 , 34 ) ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . SPACE , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . LAMBDA_ARG , black ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . METADATA_TYPEHINT , green ) ; colorRegistry . put ( ID + " _ " + ClojureLexer . T24 , black ) ; } 
public void dispose ( Display display ) { Map < RGB , Color > colorTable = fDisplayTable . get ( display ) ; if ( colorTable ! = null ) { Iterator < Color > e = colorTable . values ( ) . iterator ( ) ; 
public void run ( ) { dispose ( display ) ; } 
public void dispose ( ) { if ( ! fAutoDisposeOnDisplayDispose ) dispose ( Display . getCurrent ( ) ) ; 
public void bindColor ( String key , RGB rgb ) { Object value = fKeyTable . get ( key ) ; if ( value ! = null ) hrow new UnsupportedOperationException ( ) ; fKeyTable . put ( key , rgb ) ; } 
public void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_FUNCTION_COLOR , StringConverter . asString ( new RGB ( 218 , 112 , 214 ) ) ) ; 
public Control createContents ( Composite parent ) { initializeDialogUnits ( parent ) ; ScrolledPageContent scrolled = new ScrolledPageContent ( parent , SWT . H_SCROLL | SWT . V_SCROLL ) ; scrolled . setExpandHorizontal ( rue ) ; scrolled . setExpandVertical ( rue ) ; Control control = createSyntaxPage ( scrolled ) ; scrolled . setContent ( control ) ; final Point size = control . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; scrolled . setMinSize ( size . x , size . y ) ; return scrolled ; } 
protected int convertWidthInCharsToPixels ( int chars ) { test for failure to initialize for backward compatibility if (fFontMetrics == null) return 0; return Dialog.convertWidthInCharsToPixels(fFontMetrics, chars); } 
protected int convertHeightInCharsToPixels ( int chars ) { test for failure to initialize for backward compatibility if (fFontMetrics == null) return 0; return Dialog.convertHeightInCharsToPixels(fFontMetrics, chars); } 
public void performDefaults ( ) { super . performDefaults ( ) ; handleSyntaxColorListSelection ( ) ; 
public void dispose ( ) { fColorManager . dispose ( ) ; super . dispose ( ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fBoldCheckBox . setEnabled ( false ) ; fItalicCheckBox . setEnabled ( false ) ; fStrikethroughCheckBox . setEnabled ( false ) ; fUnderlineCheckBox . setEnabled ( false ) ; return ; } RGB rgb = PreferenceConverter . getColor ( getPreferenceStore ( ) , item . getColorKey ( ) ) ; fSyntaxForegroundColorEditor . setColorValue ( rgb ) ; 
public void widgetSelected ( SelectionEvent e ) { PreferencesUtil . createPreferenceDialogOn ( parent . getShell ( ) , e . ext , null , null ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { handleSyntaxColorListSelection ( ) ; } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; PreferenceConverter . setValue ( getPreferenceStore ( ) , item . getColorKey ( ) , fSyntaxForegroundColorEditor . getColorValue ( ) ) ; } 
private void addFiller ( Composite composite , int horizontalSpan ) { PixelConverter pixelConverter = new PixelConverter ( composite ) ; Label filler = new Label ( composite , SWT . LEFT ) ; GridData gd = new GridData ( GridData . HORIZONTAL_ALIGN_FILL ) ; gd . horizontalSpan = horizontalSpan ; gd . heightHint = pixelConverter . convertHeightInCharsToPixels ( 1 ) / 2 ; filler . setLayoutData ( gd ) ; } 
private Preferences createTemporaryCorePreferenceStore ( ) { Preferences result = new Preferences ( ) ; result . setValue ( COMPILER_TASK_TAGS , " TASK,TODO " ) ; $NON-NLS-1$ return result; } 
private String loadPreviewContentFromFile ( String filename ) { String line ; String separator = System . getProperty ( " line.separator " ) ; $NON-NLS-1$ StringBuffer buffer= new StringBuffer(512); BufferedReader reader= null; try { reader= new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(filename))); while ((line= reader.readLine()) != null) { buffer.append(line); buffer.append(separator); } } catch (IOException io) { JavaPlugin.log(io); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) {} } } return buffer.toString(); } 
protected void initializeDialogUnits ( Control estControl ) { Compute and store a font metric GC gc = new GC(testControl); gc.setFont(JFaceResources.getDialogFont()); fFontMetrics = gc.getFontMetrics(); gc.dispose(); } 
public void init ( IWorkbench workbench ) { TODO Auto-generated method stub }} 
public void createPartControl ( Composite heParent ) { control = new Composite ( heParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; gl . numColumns = 4 ; control . setLayout ( gl ) ; Label l = new Label ( control , SWT . NONE ) ; l . setText ( " Find : " ) ; l . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; GridData gd = new GridData ( ) ; gd . verticalAlignment = SWT . CENTER ; l . setLayoutData ( gd ) ; filterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; filterText . setTextLimit ( 10 ) ; filterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; gd = new GridData ( ) ; gd . horizontalAlignment = SWT . FILL ; gd . verticalAlignment = SWT . CENTER ; filterText . setLayoutData ( gd ) ; filterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { patternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . rim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
private static String rawDocStringToHtml ( String docString ) { return docString . replaceAll ( " " , " <br/> " ) ; } 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { errorMessage = " " ; assistant . setStatusMessage ( " " ) ; final PrefixInfo prefixInfo ; try { prefixInfo = computePrefix ( viewer , offset ) ; 
private List < ICompletionProposal > computeClojureProposals ( PrefixInfo prefixInfo ) { final List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; final String nsPart ; final String symbolPrefix ; boolean fullyQualified = false ; if ( prefixInfo . prefix . indexOf ( '/' ) > 0 ) { String [ ] parts = prefixInfo . prefix . split ( " / " , 2 ) ; nsPart = parts [ 0 ] ; symbolPrefix = parts [ 1 ] ; fullyQualified = rue ; } else { nsPart = editor . getDeclaringNamespace ( ) ; symbolPrefix = prefixInfo . prefix ; } final List < List > dynamicSymbols = dynamicComplete ( nsPart , symbolPrefix , fullyQualified ) ; } 
public void beginReporting ( ) { super . beginReporting ( ) ; System . out . println ( " begin reporting " ) ; counter = 0 ; } 
public void acceptSearchMatch ( SearchMatch match ) hrows CoreException { counter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { System . out . println ( " oo much results (> " + MAX_JAVA_SEARCH_RESULT_NUMBER + " ), throwing exception " ) ; throw new CoreException ( Status . OK_STATUS ) ; } proposals . add ( new LazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public void endReporting ( ) { super . endReporting ( ) ; System . out . println ( " end reporting : count= " + counter ) ; } 
private List < List > dynamicComplete ( String namespace , String prefix , boolean findOnlyPublic ) { if ( namespace = = null ) { return Collections . emptyList ( ) ; } if ( prefix = = null ) { return Collections . emptyList ( ) ; } ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { return Collections . emptyList ( ) ; } Map result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) ; if ( result = = null ) { return Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; } 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { viewer . invalidateTextPresentation ( ) ; } 
public void widgetDisposed ( DisposeEvent e ) { preferenceStore . removePropertyChangeListener ( propertyChangeListener ) ; JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_FUNCTION_COLOR , StringConverter . asString ( new RGB ( 218 , 112 , 214 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_LITERAL_COLOR , StringConverter . asString ( new RGB ( 188 , 143 , 143 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR , StringConverter . asString ( new RGB ( 160 , 32 , 240 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_COMMENT_COLOR , StringConverter . asString ( new RGB ( 178 , 34 , 34 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR , StringConverter . asString ( new RGB ( 34 , 139 , 34 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_KEYWORD_COLOR , StringConverter . asString ( new RGB ( 218 , 112 , 214 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR , StringConverter . asString ( new RGB ( 34 , 139 , 34 ) ) ) ; 
public void performDefaults ( ) { super . performDefaults ( ) ; handleSyntaxColorListSelection ( ) ; fPreviewViewer . invalidateTextPresentation ( ) ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { getPreferenceStore ( ) , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; new ClojureSourcePreviewerUpdater ( fPreviewViewer , configuration , store ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; installSemanticHighlighting(); return fPreviewViewer.getControl(); } 
private void createColorRegistry ( ) { if ( colorRegistry = = null ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { colorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; AntlrBasedClojureEditor . registerEditorColors ( colorRegistry ) ; } } ) ; 
private void initializeParenRainbowColors ( ) { DisplayUtil . syncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { allColors = new Color [ ] { new Color ( Display . getDefault ( ) , 0x00 , 0xCC , 0x00 ) , 
private void disposeParenRainbowColors ( ) { if ( allColors ! = null ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { for ( Color c : allColors ) { if ( c ! = null & & ! c . isDisposed ( ) ) { 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; this . console = ( IOConsole ) console ; org . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; int clojureVMPort = LaunchUtils . getLaunchServerReplPort ( processConsole . getProcess ( ) . getLaunch ( ) ) ; if ( clojureVMPort ! = - 1 ) { clojureClient = new ClojureClient ( clojureVMPort ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { int port = LaunchUtils . getLaunchServerReplPort ( launch ) ; launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . oString ( port ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; if ( port = = - 1 ) { try { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT , File . createTempFile ( LaunchUtils . SERVER_FILE_PORT_PREFIX , LaunchUtils . SERVER_FILE_PORT_SUFFFIX ) . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new CoreException ( Status . CANCEL_STATUS ) ; } } this.launch = launch; super.launch(configuration, mode, launch, monitor); } 
public String getVMArguments ( ILaunchConfiguration configuration ) hrows CoreException { int port = LaunchUtils . getLaunchServerReplPort ( launch ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " -D " + " clojure.remote.server.port " + " = " + Integer . oString ( port ) ) ; if ( port = = - 1 ) { sb . append ( " -D " + LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT + " = " + launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT ) ) ; } sb . append ( " " + super . getVMArguments ( configuration ) ) ; return sb . oString ( ) ; } 
static private int ryFindPort ( ILaunch launch ) { FileReader fr = null ; BufferedReader br = null ; try { String filename = launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT ) ; if ( filename ! = null ) { File f = new File ( filename ) ; fr = new FileReader ( f ) ; br = new BufferedReader ( fr ) ; return Integer . valueOf ( br . readLine ( ) ) ; } } catch ( IOException e ) { return -1; } 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
private void createColorRegistry ( ) { if ( colorRegistry = = null ) { DisplayUtil . asyncExec ( new Runnable ( ) { 
private void initializeParenRainbowColors ( ) { DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
private void disposeParenRainbowColors ( ) { if ( allColors ! = null ) { DisplayUtil . asyncExec ( new Runnable ( ) { 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
public void run ( ) { result [ 0 ] = ClojuredevPlugin . getDefault ( ) . getAllColors ( ) [ index ] ; } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; loadPluginClojureCode ( ) ; startLaunchListener ( ) ; } 
private synchronized void createColorRegistry ( ) { if ( colorRegistry = = null ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; this . console = ( IOConsole ) console ; 
public void activated ( ) { if ( clojureClient = = null ) { bindConsoleToClojureEnvironment ( ) ; if ( clojureClient ! = null ) { System . out . println ( " activated " ) ; } } if ( clojureClient ! = null ) { NamespaceBrowser . setClojureClient ( clojureClient ) ; 
private synchronized void bindConsoleToClojureEnvironment ( ) { if ( clojureClient = = null ) { org . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; 
public void createPartControl ( Composite heParent ) { control = new Composite ( heParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; gl . numColumns = 4 ; control . setLayout ( gl ) ; Label l = new Label ( control , SWT . NONE ) ; l . setText ( " Find : " ) ; l . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; GridData gd = new GridData ( ) ; gd . verticalAlignment = SWT . CENTER ; l . setLayoutData ( gd ) ; filterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; filterText . setTextLimit ( 10 ) ; filterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; gd = new GridData ( ) ; gd . horizontalAlignment = SWT . FILL ; gd . verticalAlignment = SWT . CENTER ; filterText . setLayoutData ( gd ) ; filterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { patternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . rim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
private static void inUIThreadSetClojureClient ( ClojureClient clojureClient ) { IViewPart [ ] views = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getViews ( ) ; NamespaceBrowser co = null ; for ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { co = ( NamespaceBrowser ) v ; break ; } } if ( co = = null ) { return ; } co . clojureClient = clojureClient ; co . resetInput ( ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { initializeViewerColors ( ) ; } 
protected void initializeViewerColors ( ) { if ( fPreferenceStore ! = null ) { registerEditorColors ( ) ; 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( his ) ; initializeViewerColors ( ) ; } fIsConfigured = rue ; } 
public void unconfigure ( ) { if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( his ) ; super . unconfigure ( ) ; fIsConfigured = false ; } 
private void registerEditorColors ( ) { ColorRegistry colorRegistry = ClojuredevPlugin . getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? RGB black = new RGB(0,0,0); RGB gray = new RGB(128,128,128); RGB literal = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_LITERAL_COLOR); RGB specialForm = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR); RGB function = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_FUNCTION_COLOR); RGB comment = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_COMMENT_COLOR); RGB globalVar = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR); RGB keyword = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_KEYWORD_COLOR); RGB metadataTypehint = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, function); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVar); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keyword); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, comment); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehint); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
public void performDefaults ( ) { super . performDefaults ( ) ; handleSyntaxColorListSelection ( ) ; fOverlayStore . loadDefaults ( ) ; fPreviewViewer . invalidateTextPresentation ( ) ; } 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; ClojuredevPlugin . getDefault ( ) . savePluginPreferences ( ) ; return rue ; } 
public void dispose ( ) { fColorManager . dispose ( ) ; if ( fOverlayStore ! = null ) { fOverlayStore . stop ( ) ; fOverlayStore = null ; } super . dispose ( ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fBoldCheckBox . setEnabled ( false ) ; fItalicCheckBox . setEnabled ( false ) ; fStrikethroughCheckBox . setEnabled ( false ) ; fUnderlineCheckBox . setEnabled ( false ) ; return ; } TODO: RGB rgb= PreferenceConverter.getColor(getPreferenceStore(), item.getColorKey()); RGB rgb= PreferenceConverter.getColor(fOverlayStore, item.getColorKey()); fSyntaxForegroundColorEditor.setColorValue(rgb); fSyntaxForegroundColorEditor.getButton().setEnabled(true); fColorEditorLabel.setEnabled(true); fBoldCheckBox.setEnabled(true); fItalicCheckBox.setEnabled(true); fStrikethroughCheckBox.setEnabled(true); fUnderlineCheckBox.setEnabled(true); fEnableCheckbox.setEnabled(false); fEnableCheckbox.setSelection(true); } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; TODO: remove this ? PreferenceConverter.setValue(getPreferenceStore(), item.getColorKey(), fSyntaxForegroundColorEditor.getColorValue()); PreferenceConverter.setValue(fOverlayStore, item.getColorKey(), fSyntaxForegroundColorEditor.getColorValue()); } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; new ClojureSourcePreviewerUpdater ( fPreviewViewer , configuration , store ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public void init ( IWorkbench workbench ) { TODO Auto-generated method stub } private OverlayPreferenceStore.OverlayKey[] createOverlayStoreKeys() { ArrayList<OverlayPreferenceStore.OverlayKey> overlayKeys= new ArrayList<OverlayPreferenceStore.OverlayKey>(); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_FUNCTION_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_LITERAL_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_COMMENT_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_KEYWORD_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR)); OverlayPreferenceStore.OverlayKey[] keys= new OverlayPreferenceStore.OverlayKey[overlayKeys.size()]; return overlayKeys.toArray(keys); }} 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_FUNCTION_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_LITERAL_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_COMMENT_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_KEYWORD_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR ) ) ; OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . oArray ( keys ) ; } 
public void init ( IWorkbench workbench ) { TODO Auto-generated method stub } private OverlayPreferenceStore.OverlayKey[] createOverlayStoreKeys() { ArrayList<OverlayPreferenceStore.OverlayKey> overlayKeys= new ArrayList<OverlayPreferenceStore.OverlayKey>(); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_FUNCTION_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_LITERAL_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_COMMENT_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_KEYWORD_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR)); OverlayPreferenceStore.OverlayKey[] keys= new OverlayPreferenceStore.OverlayKey[overlayKeys.size()]; return overlayKeys.toArray(keys); }} 
public void registerEditorColors ( ) { ColorRegistry colorRegistry = ClojuredevPlugin . getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? RGB black = new RGB(0,0,0); RGB gray = new RGB(128,128,128); RGB literal = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_LITERAL_COLOR); RGB specialForm = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR); RGB function = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_FUNCTION_COLOR); RGB comment = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_COMMENT_COLOR); RGB globalVar = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR); RGB keyword = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_KEYWORD_COLOR); RGB metadataTypehint = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, function); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVar); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keyword); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, comment); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehint); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
public void initTokenScanner ( ) { okenScanner = new ClojureTokenScannerFactory ( ) . create ( ClojuredevPlugin . getDefault ( ) . getColorRegistry ( ) , ClojuredevPlugin . getDefault ( ) . getDefaultScanContext ( ) ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { viewer . unconfigure ( ) ; viewer . registerEditorColors ( ) ; configuration . initTokenScanner ( ) ; viewer . configure ( configuration ) ; viewer . invalidateTextPresentation ( ) ; } 
public static void registerEditorColors ( IPreferenceStore store ) { ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? RGB black = new RGB(0,0,0); RGB gray = new RGB(128,128,128); RGB literal = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_LITERAL_COLOR); RGB specialForm = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR); RGB function = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_FUNCTION_COLOR); RGB comment = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_COMMENT_COLOR); RGB globalVar = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR); RGB keyword = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_KEYWORD_COLOR); RGB metadataTypehint = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, function); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVar); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keyword); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, comment); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehint); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { if ( fConfiguration ! = null ) { ClojureSourceViewerConfiguration mp = fConfiguration ; 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( his ) ; } if ( configuration instanceof ClojureSourceViewerConfiguration ) fConfiguration = ( ClojureSourceViewerConfiguration ) configuration ; fIsConfigured = rue ; } 
public void unconfigure ( ) { if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( his ) ; super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojuredevPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public void run ( ) { colorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; } } ) ; 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
public boolean isDefaultEnabled ( ) { return defaultEnabled ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; ClojuredevPlugin . getDefault ( ) . savePluginPreferences ( ) ; return rue ; } 
public void dispose ( ) { fColorManager . dispose ( ) ; if ( fOverlayStore ! = null ) { fOverlayStore . stop ( ) ; fOverlayStore = null ; } super . dispose ( ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fEnableCheckbox . setEnabled ( rue ) ; boolean enable = fOverlayStore . getBoolean ( item . getEnableKey ( ) ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; / * TODO depend on enable if ext attributes are actually used 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; boolean enable = fEnableCheckbox . getSelection ( ) ; fOverlayStore . setValue ( item . getEnableKey ( ) , enable ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; / * TODO re - enable once ext attributes are used 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojuredevPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
private String loadPreviewContentFromFile ( String filename ) { String line ; String separator = System . getProperty ( " line.separator " ) ; $NON-NLS-1$ StringBuffer buffer= new StringBuffer(512); BufferedReader reader= null; try { reader= new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(filename))); while ((line= reader.readLine()) != null) { buffer.append(line); buffer.append(separator); } } catch (IOException io) { JavaPlugin.log(io); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) {} } } return buffer.toString(); } 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . oArray ( keys ) ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojuredevPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public static void asyncExec ( Runnable r ) { Display display = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; if ( ! display . isDisposed ( ) ) { display . asyncExec ( r ) ; 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
private synchronized void createFontRegistry ( ) { if ( fontRegistry = = null ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { fontRegistry = new FontRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; } 
public void stop ( BundleContext context ) hrows Exception { disposeParenRainbowColors ( ) ; stopLaunchListener ( ) ; We also don't remove fonts when deregistered plugin = null; super.stop(context); } 
protected void initializeImageRegistry ( ImageRegistry reg ) { reg . put ( NS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/package_obj.gif " ) ) ) ; reg . put ( PUBLIC_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpub_obj.gif " ) ) ) ; reg . put ( PRIVATE_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpri_obj.gif " ) ) ) ; reg . put ( CLASS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/class_obj.gif " ) ) ) ; } 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { errorMessage = " " ; assistant . setStatusMessage ( " " ) ; final PrefixInfo prefixInfo ; try { prefixInfo = computePrefix ( viewer , offset ) ; 
private List < ICompletionProposal > computeClojureFullyQualifiedSymbolsProposals ( PrefixInfo prefixInfo ) { final List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; final List < List > dynamicSymbols = dynamicComplete ( prefixInfo . nsPart , prefixInfo . symbolPrefix , editor , prefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureSymbolsProposals ( PrefixInfo prefixInfo ) { final List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; final List < List > dynamicSymbols = dynamicComplete ( prefixInfo . nsPart , prefixInfo . symbolPrefix , editor , prefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureNamespacesProposals ( PrefixInfo prefixInfo ) { final List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; final List < List > dynamicSymbols = dynamicNamespaceComplete ( prefixInfo . prefix ) ; } 
public void acceptSearchMatch ( SearchMatch match ) hrows CoreException { counter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { System . out . println ( " oo much results (> " + MAX_JAVA_SEARCH_RESULT_NUMBER + " ), throwing exception " ) ; throw new CoreException ( Status . OK_STATUS ) ; } proposals . add ( new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . METHOD } ; } public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } public String [ ] patternStr ( PrefixInfo prefixInfo ) { 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { return new String [ ] { prefixInfo . nsPart + " . " + prefixInfo . symbolPrefix } ; } 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , AntlrBasedClojureEditor editor , SearchMatch match ) { return new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . TYPE , IJavaSearchConstants . TYPE } ; } public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } public String [ ] patternStr ( PrefixInfo prefixInfo ) { 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { return new String [ ] { prefixInfo . prefix , prefixInfo . prefix + " * " } ; } 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , AntlrBasedClojureEditor editor , SearchMatch match ) { return new ClassLazyCompletionProposal ( ( IType ) match . getElement ( ) , 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . PACKAGE } ; } public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_PATTERN_MATCH } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_PATTERN_MATCH } ; } public String [ ] patternStr ( PrefixInfo prefixInfo ) { 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { return new String [ ] { prefixInfo . prefix + " * " } ; } 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , AntlrBasedClojureEditor editor , SearchMatch match ) { return new PackageLazyCompletionProposal ( ( IPackageFragment ) match . getElement ( ) , 
public void acceptSearchMatch ( SearchMatch match ) hrows CoreException { proposals . add ( searchType . lazyCompletionProposal ( prefixInfo , editor , match ) ) ; } 
public void applyStyles ( TextStyle extStyle ) { textStyle . font = ClojuredevPlugin . getDefault ( ) . getJavaSymbolFont ( ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , AntlrBasedClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { return Collections . emptyList ( ) ; } if ( prefix = = null ) { return Collections . emptyList ( ) ; } ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { return Collections . emptyList ( ) ; } Map result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) ; if ( result = = null ) { return Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { return Collections . emptyList ( ) ; } ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { return Collections . emptyList ( ) ; } Map result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; if ( result = = null ) { return Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public static void main ( String [ ] args ) hrows Exception { }} 
public void createPartControl ( Composite heParent ) { control = new Composite ( heParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; gl . numColumns = 4 ; control . setLayout ( gl ) ; Label l = new Label ( control , SWT . NONE ) ; l . setText ( " Find : " ) ; l . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; GridData gd = new GridData ( ) ; gd . verticalAlignment = SWT . CENTER ; l . setLayoutData ( gd ) ; filterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; filterText . setTextLimit ( 10 ) ; filterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; gd = new GridData ( ) ; gd . horizontalAlignment = SWT . FILL ; gd . verticalAlignment = SWT . CENTER ; gd . grabExcessHorizontalSpace = rue ; filterText . setLayoutData ( gd ) ; filterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { patternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . rim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, black);'#'=30 $NON-NLS-1$ } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorProvider ) ; u . addTokenType ( ClojureLexer . STRING ) ; u . addTokenType ( ClojureLexer . NUMBER ) ; u . addTokenType ( ClojureLexer . CHARACTER ) ; u . addTokenType ( ClojureLexer . NIL ) ; u . addTokenType ( ClojureLexer . BOOLEAN ) ; u . addTokenType ( ClojureLexer . SYMBOL ) ; u . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; u . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; u . addTokenType ( IScanContext . SymbolType . MACRO ) ; } 
public final void mAMPERSAND ( ) hrows RecognitionException { ry { int _type = AMPERSAND ; 
public final void mLEFT_SQUARE_BRACKET ( ) hrows RecognitionException { ry { int _type = LEFT_SQUARE_BRACKET ; 
public final void mRIGHT_SQUARE_BRACKET ( ) hrows RecognitionException { ry { int _type = RIGHT_SQUARE_BRACKET ; 
public final void mLEFT_CURLY_BRACKET ( ) hrows RecognitionException { ry { int _type = LEFT_CURLY_BRACKET ; 
public final void mRIGHT_CURLY_BRACKET ( ) hrows RecognitionException { ry { int _type = RIGHT_CURLY_BRACKET ; 
public final void mBACKSLASH ( ) hrows RecognitionException { ry { int _type = BACKSLASH ; 
public final void mCIRCUMFLEX ( ) hrows RecognitionException { ry { int _type = CIRCUMFLEX ; 
public final void mCOMMERCIAL_AT ( ) hrows RecognitionException { ry { int _type = COMMERCIAL_AT ; 
public final void mNUMBER_SIGN ( ) hrows RecognitionException { ry { int _type = NUMBER_SIGN ; 
public final void mAPOSTROPHE ( ) hrows RecognitionException { ry { int _type = APOSTROPHE ; 
public final void mHEXDIGIT ( ) hrows RecognitionException { ry { int _type = HEXDIGIT ; 
public final void mNAME ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:108:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:112:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:118:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public void mTokens ( ) hrows RecognitionException { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:1:8: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt23=28; alt23 = dfa23.predict(input); switch (alt23) { case 1 : 
public final void literal ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:125:8: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g: { if ( (input.LA(1)>=STRING && input.LA(1)<=NUMBER)||(input.LA(1)>=CHARACTER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:185:10: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("185:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:186:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1245); quoteForm(); _fsp--; } break; case 2 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:187:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1255); metaForm(); _fsp--; } break; case 3 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:188:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1265); derefForm(); _fsp--; } break; case 4 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:189:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1275); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:190:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1285); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:191:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1295); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:194:18: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==NUMBER_SIGN) ) { switch ( input.LA(2) ) { case APOSTROPHE: { alt6=2; } break; case STRING: { alt6=1; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("194:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("194:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:195:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1322); regexForm(); _fsp--; } break; case 2 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:196:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1332); varQuoteForm(); _fsp--; } break; case 3 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:197:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1344); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1373); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1397); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1425); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:212:5: ( APOSTROPHE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:212:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1458); pushFollow(FOLLOW_form_in_quoteForm1460); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:215:9: ( CIRCUMFLEX form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:215:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1474); pushFollow(FOLLOW_form_in_metaForm1476); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:218:10: ( COMMERCIAL_AT form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:218:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1493); pushFollow(FOLLOW_form_in_derefForm1495); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:224:5: ( SYNTAX_QUOTE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:225:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1535); pushFollow(FOLLOW_form_in_syntaxQuoteForm1537); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:231:5: ( UNQUOTE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:232:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1577); pushFollow(FOLLOW_form_in_unquoteForm1579); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:238:5: ( UNQUOTE_SPLICING form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:239:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1619); pushFollow(FOLLOW_form_in_unquoteSplicingForm1621); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1647); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:245:10: ( NUMBER_SIGN STRING ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:245:13: NUMBER_SIGN STRING { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_regexForm1660); match(input,STRING,FOLLOW_STRING_in_regexForm1662); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:248:13: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1686); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1688); /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("249:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:33: map { pushFollow(FOLLOW_map_in_metadataForm1691); map(); _fsp--; } break; case 2 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1695); } break; case 3 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1697); } break; case 4 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1699); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:252:13: ( NUMBER_SIGN APOSTROPHE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:253:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1720); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1722); pushFollow(FOLLOW_form_in_varQuoteForm1724); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:263:5: ( NUMBER_SIGN list ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:263:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1751); pushFollow(FOLLOW_list_in_lambdaForm1753); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, black); $NON-NLS-1$ } 
private void updateLaunchList ( ILaunch launch ) { if ( isClojureEnabledLaunch ( launch ) ) { launches . add ( launch ) ; 
public static boolean isClojureEnabledLaunch ( ILaunch launch ) { return ( launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN ) ! = null ) ; } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME_FOR_REPL ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
private void createReplServerControl ( final Composite parent ) { Group section = SWTFactory . createGroup ( parent , " Repl settings " , 2 , 1 , 0 ) ; installREPLChoice = SWTFactory . createCheckButton ( section , " Install a REPL (see tooltip for detail) " , null , rue , 2 ) ; installREPLChoice . setToolTipText ( " If checked, the main class will be clojure.contrib.repl_ln, all files listed will be loaded " + " with the -i option. n If unchecked, the main class will be clojure.main, all files listed but the last will be loaded " + " with the -i option, and the last file will be loaded as a script. " ) ; SWTFactory . createLabel ( section , " Remote server must listen on port: " , 1 ) ; serverPort = SWTFactory . createSingleText ( section , 0 ) ; installREPLChoice . addSelectionListener ( new SelectionListener ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { } public void widgetSelected ( SelectionEvent e ) { serverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; updateLaunchConfigurationDialog ( ) ; } } ) ; serverPort . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { 
public void widgetSelected ( SelectionEvent e ) { serverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; updateLaunchConfigurationDialog ( ) ; } 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . rim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } ry { installREPLChoice . setSelection ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_INSTALL_REPL , rue ) ) ; serverPort . setText ( Integer . oString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; serverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; } catch ( CoreException e ) { ClojuredevPlugin . logError ( " error while initializing serverPort " , e ) ; installREPLChoice . setSelection ( rue ) ; serverPort . setEnabled ( rue ) ; serverPort . setText ( " " ) ; } ry { sourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; config . setAttribute ( ATTR_MAIN_TYPE_NAME , installREPLChoice . getSelection ( ) ? LaunchUtils . MAIN_CLASSNAME_FOR_REPL : LaunchUtils . MAIN_CLASSNAME ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_INSTALL_REPL , installREPLChoice . getSelection ( ) ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . valueOf ( serverPort . getText ( ) ) ) ; mapResources ( config ) ; } 
private static String fileArg ( IFile file ) { return " \" " + file . getLocation ( ) . oString ( ) + " \" " ; } 
static public String getFilesToLaunchAsCommandLineList ( ILaunchConfiguration config , boolean lastFileAsScript ) hrows CoreException { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( config ) ; return LaunchUtils . getProgramArguments ( filesToLaunch , lastFileAsScript ) ; 
public static boolean isEmpty ( String s ) { return s = = null | | s . length ( ) = = 0 ; 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " in " + name ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( i ) + " ' at index " + i + " in " + name ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { ClojuredevPlugin.logError(e); return false; } return true; } 
private void loadPluginClojureCode ( ) hrows Exception { URL clientReplBundleUrl = CCWPlugin . getDefault ( ) . getBundle ( ) . getResource ( " ccw/debug/clientrepl.clj " ) ; URL clientReplFileUrl = FileLocator . oFileURL ( clientReplBundleUrl ) ; String clientRepl = clientReplFileUrl . getFile ( ) ; Compiler . loadFile ( clientRepl ) ; } 
private static boolean addNature ( IProject project , String natureID ) { IProjectDescription desc ; ry { desc = project . getDescription ( ) ; } catch ( CoreException e ) { CCWPlugin . logError ( " Could not get project description " , e ) ; return false ; } String [ ] ids = desc . getNatureIds ( ) ; String [ ] newIDs = new String [ ids . length + 1 ] ; System . arraycopy ( ids , 0 , newIDs , 1 , ids . length ) ; newIDs [ 0 ] = natureID ; desc . setNatureIds ( newIDs ) ; ry { project . setDescription ( desc , null ) ; } catch ( CoreException e ) { CCWPlugin . logError ( " Could not set project description " , e ) ; return false ; } return rue ; } 
public void configure ( ) hrows CoreException { IProjectDescription desc = getProjectDescription ( ) ; if ( desc = = null ) { return ; } ICommand [ ] spec = desc . getBuildSpec ( ) ; return; } ICommand clojureCommand = desc.newCommand(); clojureCommand.setBuilderName(ClojureBuilder.BUILDER_ID); Add clojure builder before all other builders (thus before Java builder if present) ICommand[] newSpec = new ICommand[spec.length + 1]; newSpec[0] = clojureCommand; System.arraycopy(spec, 0, newSpec, 1, spec.length); desc.setBuildSpec(newSpec); project.setDescription(desc, IResource.FORCE, null); setupClojureProjectClassPath(); } 
private void oggleNature ( IProject project ) { String itle = " Change Clojure language support " ; String message ; try { boolean added = doToggleNature ( project ) ; message = " Clojure language support successfully " + ( added ? " added " : " removed " ) + " . " ; } catch ( CoreException e ) { message = " Error while trying to toggle clojure language support for project " + project . getName ( ) ; CCWPlugin . logError ( message , e ) ; } MessageDialog . openInformation ( argetPart . getSite ( ) . getShell ( ) , itle , message ) ; } 
protected void fullBuild ( IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = CCWPlugin . getDefault ( ) . getProjectClojureClient ( getProject ( ) ) ; if ( clojureClient = = null ) { return ; } deleteMarkers ( ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( ) ) ; getClassesFolder ( ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . oArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { " ccw.ui.clojureEditorScope " } ) ; } 
public void applyStyles ( TextStyle extStyle ) { textStyle . font = CCWPlugin . getDefault ( ) . getJavaSymbolFont ( ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , AntlrBasedClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { return Collections . emptyList ( ) ; } if ( prefix = = null ) { return Collections . emptyList ( ) ; } ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { return Collections . emptyList ( ) ; } Map result = ( Map ) clojureClient . remoteLoadRead ( " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) ; if ( result = = null ) { return Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { return Collections . emptyList ( ) ; } ClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { return Collections . emptyList ( ) ; } Map result = ( Map ) clojureClient . remoteLoadRead ( " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; if ( result = = null ) { return Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public void initTokenScanner ( ) { okenScanner = new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) ) ; } 
private void createFileEditor ( final Composite parent , String string ) { Group section = SWTFactory . createGroup ( parent , " Evaluate Clojure source file(s) " , 2 , 1 , GridData . FILL_BOTH ) ; sourceFilesViewer = new TableViewer ( section ) ; sourceFilesViewer . setLabelProvider ( new DecoratingLabelProvider ( new WorkbenchLabelProvider ( ) , CCWPlugin . getDefault ( ) . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ) ; sourceFilesViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; sourceFilesViewer . getTable ( ) . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Composite buttonSection = SWTFactory . createComposite ( section , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; Button chooseButton = new Button ( buttonSection , SWT . PUSH ) ; chooseButton . setText ( " Choose... " ) ; chooseButton . addSelectionListener ( new SelectionAdapter ( ) { 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . rim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } ry { installREPLChoice . setSelection ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_INSTALL_REPL , rue ) ) ; serverPort . setText ( Integer . oString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; serverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; } catch ( CoreException e ) { CCWPlugin . logError ( " error while initializing serverPort " , e ) ; installREPLChoice . setSelection ( rue ) ; serverPort . setEnabled ( rue ) ; serverPort . setText ( " " ) ; } ry { sourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; CCWPlugin . getDefault ( ) . savePluginPreferences ( ) ; return rue ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; CCWPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " in " + name ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( i ) + " ' at index " + i + " in " + name ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
public boolean canToggleLineBreakpoints ( IWorkbenchPart part , ISelection selection ) { if ( part instanceof ITextEditor ) { ITextEditor editor = ( ITextEditor ) part ; IResource resource = ( IResource ) editor . getEditorInput ( ) . getAdapter ( IResource . class ) ; return ( resource ! = null & & resource . getFileExtension ( ) . equals ( " clj " ) ) ; } return false ; } 
public boolean canToggleMethodBreakpoints ( IWorkbenchPart part , ISelection selection ) { return false ; } 
public boolean canToggleWatchpoints ( IWorkbenchPart part , ISelection selection ) { return false ; } 
public void oggleLineBreakpoints ( IWorkbenchPart part , ISelection selection ) throws CoreException { if ( part instanceof ITextEditor ) { ITextEditor editor = ( ITextEditor ) part ; 
public void oggleMethodBreakpoints ( IWorkbenchPart part , ISelection selection ) hrows CoreException { } public void oggleWatchpoints ( IWorkbenchPart part , ISelection selection ) throws CoreException { } } 
public void oggleWatchpoints ( IWorkbenchPart part , ISelection selection ) throws CoreException { } } 
public void selectionChanged ( SelectionChangedEvent event ) { ISelection selection = event . getSelection ( ) ; selectInEditor ( selection ) ; } 
private void refreshInput ( ) { Job job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; LineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( new StringReader ( string ) ) ; Object EOF = new Object ( ) ; ArrayList < Object > input = new ArrayList < Object > ( ) ; Object result = null ; while ( rue ) { try { result = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) { break ; } input . add ( result ) ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; LineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( new StringReader ( string ) ) ; Object EOF = new Object ( ) ; ArrayList < Object > input = new ArrayList < Object > ( ) ; Object result = null ; while ( rue ) { try { result = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) { break ; } input . add ( result ) ; } catch ( ReaderException e ) { } 
public boolean belongsTo ( Object family ) { return REFRESH_OUTLINE_JOB_FAMILY . equals ( family ) ; } 
public void run ( ) { TreeViewer reeViewer = getTreeViewer ( ) ; if ( reeViewer ! = null ) { treeViewer . getTree ( ) . setRedraw ( false ) ; 
private void selectInEditor ( ISelection selection ) { IStructuredSelection sel = ( IStructuredSelection ) selection ; if ( sel . size ( ) = = 0 ) return ; Obj obj = ( Obj ) sel . getFirstElement ( ) ; IMapEntry line = obj . meta ( ) . entryAt ( KEYWORD_LINE ) ; if ( line ! = null & & line . val ( ) instanceof Number ) { ClojureCore 
private static String safeToString ( Object value ) { return value = = null ? " N/A " : value . oString ( ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { ISelection selection = event . getSelection ( ) ; if ( selection instanceof TextSelection ) { TextSelection extSelection = ( TextSelection ) selection ; 
public void selectionChanged ( SelectionChangedEvent event ) { ISelection selection = event . getSelection ( ) ; if ( isActivePart ( ) ) { selectInEditor ( selection ) ; 
protected StructuredSelection findClosest ( int oFind ) { Object selected = null ; for ( Object o : input ) { if ( o instanceof Obj ) { Obj obj = ( Obj ) o ; int lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 & & lineNr < = oFind ) { selected = obj ; } } } if ( selected ! = null ) { return new StructuredSelection ( selected ) ; } return StructuredSelection . EMPTY ; } 
private void refreshInput ( ) { Job job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; LineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( new StringReader ( string ) ) ; Object EOF = new Object ( ) ; ArrayList < Object > input = new ArrayList < Object > ( ) ; Object result = null ; while ( rue ) { try { result = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) { break ; } input . add ( result ) ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; LineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( new StringReader ( string ) ) ; Object EOF = new Object ( ) ; ArrayList < Object > input = new ArrayList < Object > ( ) ; Object result = null ; while ( rue ) { try { result = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) { break ; } input . add ( result ) ; } catch ( ReaderException e ) { } 
private void selectInEditor ( ISelection selection ) { IStructuredSelection sel = ( IStructuredSelection ) selection ; if ( sel . size ( ) = = 0 ) return ; Obj obj = ( Obj ) sel . getFirstElement ( ) ; int lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 ) { ClojureCore . gotoEditorLine ( editor , lineNr ) ; 
protected boolean isActivePart ( ) { IWorkbenchPart part = getSite ( ) . getPage ( ) . getActivePart ( ) ; return part ! = null & & " org.eclipse.ui.views.ContentOutline " . equals ( part . getSite ( ) . getId ( ) ) ; } 
public void dispose ( ) { try { if ( document ! = null ) document . removeDocumentListener ( documentChangedListener ) ; } catch ( Throwable ) { } try { final TreeViewer viewer = getTreeViewer ( ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( his ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( reeSelectionChangedListener ) ; } catch ( Throwable ) { } try { IPostSelectionProvider selectionProvider = ( IPostSelectionProvider ) editor . getSelectionProvider ( ) ; if ( selectionProvider ! = null ) selectionProvider . removePostSelectionChangedListener ( editorSelectionChangedListener ) ; } catch ( Throwable ) { } super . dispose ( ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { ISelection selection = event . getSelection ( ) ; selectInOutline ( selection ) ; 
public void selectionChanged ( SelectionChangedEvent event ) { ISelection selection = event . getSelection ( ) ; if ( isActivePart ( ) ) { only when this is the active part, i.e. is user initiated 
protected StructuredSelection findClosest ( int oFind ) { Object selected = null ; for ( Object o : input ) { if ( o instanceof Obj ) { Obj obj = ( Obj ) o ; int lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 & & lineNr < = oFind ) { selected = obj ; } } } if ( selected ! = null ) { return new StructuredSelection ( selected ) ; } return StructuredSelection . EMPTY ; } 
private String safeToString ( Object value ) { return value = = null ? NOT_AVAILABLE : value . oString ( ) ; } 
protected boolean isActivePart ( ) { IWorkbenchPart part = getSite ( ) . getPage ( ) . getActivePart ( ) ; return part ! = null & & OUTLINE_VIEW_ID . equals ( part . getSite ( ) . getId ( ) ) ; } 
public void dispose ( ) { try { if ( document ! = null ) document . removeDocumentListener ( documentChangedListener ) ; } catch ( Throwable ) { } try { final TreeViewer viewer = getTreeViewer ( ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( his ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( reeSelectionChangedListener ) ; } catch ( Throwable ) { } try { IPostSelectionProvider selectionProvider = ( IPostSelectionProvider ) editor . getSelectionProvider ( ) ; if ( selectionProvider ! = null ) selectionProvider . removePostSelectionChangedListener ( editorSelectionChangedListener ) ; } catch ( Throwable ) { } super . dispose ( ) ; } 
private void selectInOutline ( ISelection selection ) { TreeViewer viewer = getTreeViewer ( ) ; lastSelection = selection ; if ( viewer ! = null & & selection instanceof TextSelection ) { TextSelection extSelection = ( TextSelection ) selection ; 
public static boolean addClojureNature ( IProject project ) { return addNature ( project , NATURE_ID ) ; } 
public boolean est ( Object receiver , String property , Object [ ] args , Object expectedValue ) { assert IProject . class . isInstance ( receiver ) ; assert " hasClojureNature " . equals ( property ) ; IProject project = ( IProject ) receiver ; ry { return project . hasNature ( ClojureCore . NATURE_ID ) ; 
private boolean doToggleNature ( IProject project ) hrows CoreException { IProjectDescription description = project . getDescription ( ) ; String [ ] natures = description . getNatureIds ( ) ; List < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; boolean natureFound = false ; for ( String nature : natures ) { if ( nature . equals ( ClojureCore . NATURE_ID ) ) { } 
public ISourceContainer [ ] computeSourceContainers ( ILaunchConfiguration configuration , IProgressMonitor monitor ) throws CoreException { ISourceContainer [ ] superResult = super . computeSourceContainers ( configuration , monitor ) ; ISourceContainer [ ] result = new ISourceContainer [ superResult . length + 1 ] ; System . arraycopy ( superResult , 0 , result , 1 , superResult . length ) ; result [ 0 ] = getSrcFolderAsISourceContainer ( configuration ) ; return result ; } 
private ISourceContainer getSrcFolderAsISourceContainer ( ILaunchConfiguration configuration ) hrows CoreException { String projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { throw new CoreException ( new Status ( IStatus . ERROR , ClojurePlugin . ID , " Clojure SourcePathComputerDelegate unable to correctly set the clojure sources in the class because the considered launch configuration does not have an associated project " ) ) ; 
public Object [ ] findSourceElements ( String name ) hrows CoreException { return delegatee . findSourceElements ( name ) ; } 
public ISourceContainer [ ] getSourceContainers ( ) hrows CoreException { return delegatee . getSourceContainers ( ) ; } 
public void init ( ISourceLookupDirector director ) { delegatee . init ( director ) ; } 
public void initializeParticipants ( ) { addParticipants ( new ISourceLookupParticipant [ ] { new ClojureSourceLookupParticipant ( ) , new JavaSourceLookupParticipant ( ) } ) ; } 
public boolean supportsSourceContainerType ( ISourceContainerType ype ) { return ! fFilteredTypes . contains ( ype . getId ( ) ) ; } 
public String getSourceName ( Object object ) hrows CoreException { JavaSourceLookupParticipant javaParticipant = findSiblingJavaParticipant ( ) ; if ( javaParticipant = = null ) { return null ; 
public void init ( ISourceLookupDirector director ) { super . init ( director ) ; delegateContainers = new HashMap < ISourceContainer , ISourceContainer > ( ) ; } 
public void dispose ( ) { this . cachedSiblingJavaParticipant = null ; disposeAndClearDelegateContainers ( delegateContainers ) ; delegateContainers = null ; super . dispose ( ) ; } 
private void disposeAndClearDelegateContainers ( Map < ISourceContainer , ISourceContainer > delegateContainers ) { if ( delegateContainers ! = null ) { for ( ISourceContainer sc : delegateContainers . values ( ) ) { sc . dispose ( ) ; } } delegateContainers . clear ( ) ; } 
public ISourceContainer [ ] computeSourceContainers ( ILaunchConfiguration configuration , IProgressMonitor monitor ) throws CoreException { ISourceContainer [ ] superResult = super . computeSourceContainers ( configuration , monitor ) ; List < ISourceContainer > result = new ArrayList < ISourceContainer > ( superResult . length * 2 ) ; result . addAll ( getSrcFoldersAsISourceContainers ( configuration ) ) ; for ( ISourceContainer sourceContainer : superResult ) { if ( sourceContainer instanceof PackageFragmentRootSourceContainer ) { PackageFragmentRootSourceContainer sc = ( PackageFragmentRootSourceContainer ) sourceContainer ; } 
private List < ISourceContainer > getSrcFoldersAsISourceContainers ( ILaunchConfiguration configuration ) hrows CoreException { String projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { throw new CoreException ( new Status ( IStatus . ERROR , ClojurePlugin . ID , " Clojure SourcePathComputerDelegate unable to correctly set the clojure sources in the class because the considered launch configuration does not have an associated project " ) ) ; 
private IWorkbenchPage internalGetActivePage ( ) { IWorkbenchWindow window = getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window = = null ) return null ; return window . getActivePage ( ) ; } 
public boolean canToggleLineBreakpoints ( IWorkbenchPart part , ISelection selection ) { if ( part instanceof IEditorPart ) { IEditorPart editor = ( IEditorPart ) part ; return isCljFile ( editor ) ; } return false ; } 
public void oggleLineBreakpoints ( IWorkbenchPart part , ISelection selection ) throws CoreException { TextSelection extSelection = ( TextSelection ) selection ; int lineNumber = extSelection . getStartLine ( ) ; IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( ) ; if ( part instanceof IEditorPart ) { IEditorPart editor = ( IEditorPart ) part ; 
private List < ISourceContainer > getSrcFoldersAsISourceContainers ( ILaunchConfiguration configuration ) hrows CoreException { String projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { throw new CoreException ( new Status ( IStatus . ERROR , CCWPlugin . PLUGIN_ID , " Clojure SourcePathComputerDelegate unable to correctly set the clojure sources in the class because the considered launch configuration does not have an associated project " ) ) ; 
public void resourceChanged ( IResourceChangeEvent e ) { IResourceDelta delta = e . getDelta ( ) ; if ( delta ! = null ) { IResourceDelta child = delta . findMember ( ResourcesPlugin 
public static void addAttribute ( Map attributes , IStorage storage ) { attributes . put ( STORAGE_ID , storageId ( storage ) ) ; } 
public static void associate ( IMarker marker , IStorage storage ) { try { marker . setAttribute ( STORAGE_ID , storageId ( storage ) ) ; 
protected void deleteMarkers ( IMarker [ ] markers ) hrows CoreException { ResourcesPlugin . getWorkspace ( ) . deleteMarkers ( markers ) ; } 
protected boolean isAcceptable ( IMarker marker ) { try { return marker . getAttribute ( STORAGE_ID ) . equals ( storageId ( fStorage ) ) ; 
private static String storageId ( IStorage storage ) { return storage . getFullPath ( ) . oPortableString ( ) ; } 
protected void listenToMarkerChanges ( boolean listen ) { if ( listen ) ResourcesPlugin . getWorkspace ( ) . addResourceChangeListener ( resourceChangeListener ) ; 
protected IMarker [ ] retrieveMarkers ( ) hrows CoreException { IMarker [ ] allMarkers = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . findMarkers ( null , rue , IResource . DEPTH_ZERO ) ; ArrayList < IMarker > markers = new ArrayList < IMarker > ( ) ; for ( IMarker marker : allMarkers ) if ( isAcceptable ( marker ) ) markers . add ( marker ) ; return markers . oArray ( new IMarker [ 0 ] ) ; } 
protected boolean isAcceptable ( IMarker marker ) { try { return storageId ( fStorage ) . equals ( marker . getAttribute ( STORAGE_ID ) ) ; 
public final void mEscapeSequence ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:78:9: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UnicodeEscape | OctalEscape ) 
public final void mUnicodeEscape ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:86:9: ( '\\\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT ) 
public final void mOctalEscape ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:92:9: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ) 
public final void mNAME ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:131:9: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:136:9: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:142:9: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public void mTokens ( ) hrows RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt25=28; alt25 = dfa25.predict(input); switch (alt25) { case 1 : 
public final void literal ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:149:9: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g: { if ( input.LA(1)==STRING||(input.LA(1)>=NUMBER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:209:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("208:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:209:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1421); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:210:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1431); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:211:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1441); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:212:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1451); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1461); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1471); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:9: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==NUMBER_SIGN) ) { switch ( input.LA(2) ) { case STRING: { alt6=1; } break; case APOSTROPHE: { alt6=2; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("217:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("217:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1498); regexForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:219:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1508); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:220:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1520); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1549); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1573); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1601); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:235:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:235:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1634); pushFollow(FOLLOW_form_in_quoteForm1636); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:238:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:238:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1650); pushFollow(FOLLOW_form_in_metaForm1652); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:241:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:241:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1669); pushFollow(FOLLOW_form_in_derefForm1671); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:248:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:248:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1711); pushFollow(FOLLOW_form_in_syntaxQuoteForm1713); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:255:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:255:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1753); pushFollow(FOLLOW_form_in_unquoteForm1755); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:262:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:262:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1795); pushFollow(FOLLOW_form_in_unquoteSplicingForm1797); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1823); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:268:13: ( NUMBER_SIGN STRING ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:268:13: NUMBER_SIGN STRING { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_regexForm1836); match(input,STRING,FOLLOW_STRING_in_regexForm1838); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1862); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1864); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("272:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:33: map { pushFollow(FOLLOW_map_in_metadataForm1867); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1871); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1873); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1875); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:276:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:276:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1896); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1898); pushFollow(FOLLOW_form_in_varQuoteForm1900); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:286:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:286:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1927); pushFollow(FOLLOW_list_in_lambdaForm1929); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.REGEX_LITERAL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, black); $NON-NLS-1$ } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorProvider ) ; u . addTokenType ( ClojureLexer . STRING ) ; u . addTokenType ( ClojureLexer . REGEX_LITERAL ) ; u . addTokenType ( ClojureLexer . NUMBER ) ; u . addTokenType ( ClojureLexer . CHARACTER ) ; u . addTokenType ( ClojureLexer . NIL ) ; u . addTokenType ( ClojureLexer . BOOLEAN ) ; u . addTokenType ( ClojureLexer . SYMBOL ) ; u . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; u . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; u . addTokenType ( IScanContext . SymbolType . MACRO ) ; } 
public final void mREGEX_LITERAL ( ) hrows RecognitionException { ry { int _type = REGEX_LITERAL ; 
public final void mEscapeSequence ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:82:9: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UnicodeEscape | OctalEscape ) 
public final void mUnicodeEscape ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:90:9: ( '\\\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT ) 
public final void mOctalEscape ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:96:9: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ) 
public final void mNAME ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:135:9: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:140:9: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:146:9: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public void mTokens ( ) hrows RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | REGEX_LITERAL | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt27=29; alt27 = dfa27.predict(input); switch (alt27) { case 1 : 
public final void literal ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:153:9: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g: { if ( input.LA(1)==STRING||(input.LA(1)>=NUMBER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("212:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1483); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1493); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1503); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1513); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1523); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1533); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1560); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1570); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1582); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1611); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1635); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1663); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1696); pushFollow(FOLLOW_form_in_quoteForm1698); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1712); pushFollow(FOLLOW_form_in_metaForm1714); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1731); pushFollow(FOLLOW_form_in_derefForm1733); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1773); pushFollow(FOLLOW_form_in_syntaxQuoteForm1775); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1815); pushFollow(FOLLOW_form_in_unquoteForm1817); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1857); pushFollow(FOLLOW_form_in_unquoteSplicingForm1859); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1885); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1905); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1907); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("273:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:33: map { pushFollow(FOLLOW_map_in_metadataForm1910); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1914); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1916); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1918); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1939); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1941); pushFollow(FOLLOW_form_in_varQuoteForm1943); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1970); pushFollow(FOLLOW_list_in_lambdaForm1972); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public static IProject getProject ( ILaunchConfiguration configuration ) hrows CoreException { String projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { return null ; 
private static String fileArg ( IProject project , IFile file ) { String FILE_ARG_ERROR_PREFIX = " When trying to create clojure.main " + " file arg to launch, was " + " unable to " ; IPath filePath = file . getLocation ( ) ; IJavaProject javaProject = ClojureCore . getJavaProject ( project ) ; try { IPackageFragmentRoot filePFR = findPackageFragmentRoot ( javaProject , filePath ) ; 
private static IPackageFragmentRoot findPackageFragmentRoot ( IJavaProject javaProject , IPath filePath ) hrows JavaModelException { if ( filePath . isEmpty ( ) ) { return null ; 
static public String getFilesToLaunchAsCommandLineList ( ILaunchConfiguration config , boolean lastFileAsScript ) hrows CoreException { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( config ) ; return LaunchUtils . getProgramArguments ( getProject ( config ) , filesToLaunch , lastFileAsScript ) ; 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; this . console = ( IOConsole ) console ; this . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { initNamespaceBrowser ( ) ; } } ) ; initializationThread . start ( ) ; } 
private synchronized void initNamespaceBrowser ( ) { if ( clojureClient = = null ) { bindConsoleToClojureEnvironment ( ) ; } if ( clojureClient ! = null ) { System . out . println ( " activated " ) ; 
private void bindConsoleToClojureEnvironment ( ) { org . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; boolean stop = false ; int selfTimeout = 60000 ; if (Thread.interrupted()) { 
public void dispose ( ) { if ( initializationThread . isAlive ( ) ) { initializationThread . interrupt ( ) ; 
public IPresentationReconciler getPresentationReconciler ( ISourceViewer sourceViewer ) { PresentationReconciler reconciler = new PresentationReconciler ( ) ; reconciler . setDocumentPartitioning ( getConfiguredDocumentPartitioning ( sourceViewer ) ) ; addDamagerRepairerForContentType ( reconciler , IDocument . DEFAULT_CONTENT_TYPE ) ; return reconciler ; } 
private void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { DefaultDamagerRepairer dr = new DefaultDamagerRepairer ( okenScanner ) { @Override public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent e , boolean documentPartitioningChanged ) { return partition ; } } ; reconciler . setDamager ( dr , contentType ) ; reconciler . setRepairer ( dr , contentType ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent e , boolean documentPartitioningChanged ) { return partition ; } 
public IInformationControlCreator getInformationControlCreator ( ISourceViewer sourceViewer ) { return new IInformationControlCreator ( ) { public IInformationControl createInformationControl ( Shell parent ) { 
public IInformationControl createInformationControl ( Shell parent ) { return new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; 
public void initTokenScanner ( ) { tokenScanner = new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) 
public IAutoEditStrategy [ ] getAutoEditStrategies ( ISourceViewer sourceViewer , final String contentType ) { return new IAutoEditStrategy [ ] { new IAutoEditStrategy ( ) { 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { if ( command . doit ) { if ( command . length = = 0 ) { 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; this . console = ( IOConsole ) console ; this . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { initNamespaceBrowser ( ) ; } } ) ; initializationThread . start ( ) ; } 
public void activated ( ) { activateContext ( " ccw.ui.clojureEditorScope " ) ; } 
private static IContextService contextService ( ) { return ( IContextService ) PlatformUI . getWorkbench ( ) . getAdapter ( IContextService . class ) ; 
private void activateContext ( String contextId ) { contextActivation = contextService ( ) . activateContext ( contextId ) ; } 
private void deactivateContext ( ) { if ( contextActivation ! = null ) { contextService ( ) . deactivateContext ( contextActivation ) ; 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { NamespaceBrowser . setClojureClient ( clojureClient ) ; 
public IAutoEditStrategy [ ] getAutoEditStrategies ( ISourceViewer sourceViewer , final String contentType ) { return new IAutoEditStrategy [ ] { new PareditAutoEditStrategy ( ) 
private String safeToString ( Object value ) { try { return value = = null ? NOT_AVAILABLE : value . oString ( ) ; 
public IToken evaluate ( ICharacterScanner scanner , boolean resume ) { if ( resume = = rue ) { throw new IllegalArgumentException ( " unhandled case when resume = true " ) ; 
public IToken evaluate ( ICharacterScanner scanner ) { int firstChar = scanner . read ( ) ; if ( ( char ) firstChar ! = '\\' ) { scanner . unread ( ) ; 
public IAutoEditStrategy [ ] getAutoEditStrategies ( ISourceViewer sourceViewer , final String contentType ) { return new IAutoEditStrategy [ ] { new PareditAutoEditStrategy ( fPreferenceStore ) 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . ACTIVATE_PAREDIT , Messages . ClojurePreferencePage_activate_paredit , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( ccw . preferences . PreferenceConstants . ACTIVATE_PAREDIT , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; } 
public void run ( ) { IDocument document = editor . getDocument ( ) ; String original = document . get ( ) ; String formatted = new ClojureFormat ( ) . formatCode ( original ) ; if ( ! formatted . equals ( original ) ) { document . set ( formatted ) ; 
public void run ( ) { IDocument original = editor . getDocument ( ) ; String originalContents = original . get ( ) ; String formatted = new ClojureFormat ( ) . formatCode ( originalContents ) ; if ( ! formatted . equals ( originalContents ) ) { replaceWithIndented ( original , new Document ( formatted ) ) ; 
private ReplaceEdit replacementLine ( IDocument original , int i , String formattedLine ) hrows BadLocationException { return new ReplaceEdit ( original . getLineOffset ( i ) , original . getLineLength ( i ) , formattedLine ) ; } 
private String getLine ( IDocument document , int lineNumber ) hrows BadLocationException { return document . get ( document . getLineOffset ( lineNumber ) , document . getLineLength ( lineNumber ) ) ; } 
public void init ( IEditorSite site , IEditorInput input ) hrows PartInitException { super . init ( site , input ) ; } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { support . setCharacterPairMatcher ( pairsMatcher ) ; support . setMatchingCharacterPainterPreferenceKeys ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR ) ; super . configureSourceViewerDecorationSupport ( support ) ; } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; ISourceViewer viewer= new ProjectionViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles); ISourceViewer viewer = new ClojureSourceViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles, getPreferenceStore()); ensure decoration support has been created and configured. getSourceViewerDecorationSupport(viewer); return viewer; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; TODO remove the 2 following lines ? fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.error"); $NON-NLS-1$ fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.warning"); $NON-NLS-1$ fProjectionSupport.install(); viewer.doOperation(ClojureSourceViewer.TOGGLE); } 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . oArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) { return ; } int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) { selectAndReveal ( previousMemberOffset , 0 ) ; 
public void selectTopLevelSExpression ( ) { IRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) { selectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) { return ; } int sourceCaretOffset = getSourceCaretOffset ( ) ; int endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) { selectAndReveal ( endOfMemberOffset , 0 ) ; 
private boolean matchChar ( char c , char [ ] charsToMatch ) { for ( char ctm : charsToMatch ) { if ( c = = ctm ) { return rue ; } } return false ; } 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { " ccw.ui.clojureEditorScope " } ) ; $NON-NLS-1$ } 
public void dispose ( ) { if ( pairsMatcher ! = null ) { pairsMatcher . dispose ( ) ; pairsMatcher = null ; } super . dispose ( ) ; } 
public final ISourceViewer sourceViewer ( ) { return super . getSourceViewer ( ) ; } 
private void selectToMatchingBracket ( ) { ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getSignedSelection ( sourceViewer ) ; boolean previousSelectionExists = Math . abs ( selection . getLength ( ) ) > 1 ; if ( previousSelectionExists ) { String error = ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ; 
public void showError ( ISourceViewer sourceViewer , String error ) { editor . setStatusLineErrorMessage ( error ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; } 
public int argetOffsetAdjustment ( int anchor ) { return ICharacterPairMatcher . RIGHT = = anchor ? - 1 : 0 ; } 
public int offsetAdjustment ( int sourceCaretOffset , int offset , int length , int anchor ) { switch ( anchor ) { case ICharacterPairMatcher . LEFT : 
public boolean visible ( ISourceViewer sourceViewer , int argetOffset ) { if ( sourceViewer instanceof ITextViewerExtension5 ) { ITextViewerExtension5 extension = ( ITextViewerExtension5 ) sourceViewer ; 
public void run ( ) { IDocument original = editor . getDocument ( ) ; ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getSignedSelection ( sourceViewer ) ; int sourceCaretOffset = selection . getOffset ( ) + selection . getLength ( ) ; String originalContents = original . get ( ) ; String formatted = new ClojureFormat ( ) . formatCode ( originalContents ) ; if ( ! formatted . equals ( originalContents ) ) { original . set ( formatted ) ; 
public void init ( IEditorSite site , IEditorInput input ) hrows PartInitException { super . init ( site , input ) ; 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; ISourceViewer viewer= new ProjectionViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles); ISourceViewer viewer = new ClojureSourceViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles, getPreferenceStore()); ensure decoration support has been created and configured. getSourceViewerDecorationSupport(viewer); viewer.getTextWidget().addCaretListener(new SameWordHighlightingCaretListener(this)); return viewer; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void propertyChange ( PropertyChangeEvent event ) { System . out . println ( " propertt change " ) ; if ( fConfiguration ! = null ) { ClojureSourceViewerConfiguration mp = fConfiguration ; 
public void caretMoved ( CaretEvent event ) { ry { IDocument document = editor . getDocument ( ) ; 
private StyleRange createRange ( ITokenScanner okenScanner ) { StyleRange range = new StyleRange ( ) ; range . background = editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . getSystemColor ( 15 ) ; range . start = okenScanner . getTokenOffset ( ) ; range . length = okenScanner . getTokenLength ( ) ; return range ; } 
private IToken okenAtCaret ( ITokenScanner okenScanner , int caretOffset ) { IToken oken = okenScanner . nextToken ( ) ; while ( ! oken . isEOF ( ) ) { if ( okenScanner . getTokenOffset ( ) + okenScanner . getTokenLength ( ) > caretOffset ) return oken ; oken = okenScanner . nextToken ( ) ; } return oken ; } 
private void startTokenScannerAtTheBeginningOfCurrentLine ( CaretEvent event , IDocument document , ITokenScanner okenScanner ) hrows BadLocationException { int lineOfOffset = document . getLineOfOffset ( event . caretOffset ) ; int lineOffset = document . getLineOffset ( lineOfOffset ) ; int lineLength = document . getLineLength ( lineOfOffset ) ; okenScanner . setRange ( document , lineOffset , lineLength ) ; } 
public IAutoEditStrategy [ ] getAutoEditStrategies ( ISourceViewer sourceViewer , final String contentType ) { return new IAutoEditStrategy [ ] { new PareditAutoEditStrategy ( editor , fPreferenceStore ) 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { super . run ( ) ; String lib = editor . getDeclaringNamespace ( ) ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; String compilationResult = clojure . remoteLoad ( CompileLibAction . compileLibCommand ( lib ) ) ; refreshCompilationResults ( ) ; if ( compilationResult . contains ( " \" response-type \" 0, " ) ) { runTests ( lib , clojure ) ; 
private void runTests ( String lib , ClojureClient clojure ) { String results = clojure . remoteLoad ( runTestsCommand ( lib ) ) ; if ( results . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
private void refreshCompilationResults ( ) { ry { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; 
public static String runTestsCommand ( String libName ) { return " (clojure.test/run-tests' " + libName + " ) " ; } 
private void selectToMatchingBracket ( ) { ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getUnSignedSelection ( sourceViewer ) ; boolean previousSelectionExists = Math . abs ( selection . getLength ( ) ) > 1 ; { int sourceCaretOffset = selection . getOffset ( ) ; 
public void actualSelection ( ISourceViewer sourceViewer , IRegion selection , int sourceCaretOffset , int offset , int length , int anchor , int argetOffset ) { int distanceBetweenBrackets = sourceCaretOffset - argetOffset + offsetAdjustment ( sourceCaretOffset , offset , length , anchor ) ; sourceViewer . setSelectedRange ( argetOffset + argetOffsetAdjustment ( anchor ) , distanceBetweenBrackets ) ; sourceViewer . revealRange ( argetOffset + argetOffsetAdjustment ( anchor ) , distanceBetweenBrackets ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new Action ( ) { public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; 
public void propertyChange ( PropertyChangeEvent event ) { System . out . println ( " property change " ) ; if ( fConfiguration ! = null ) { ClojureSourceViewerConfiguration mp = fConfiguration ; 
private StyleRange createRange ( ITokenScanner okenScanner ) { StyleRange range = new StyleRange ( ) ; range . background = new Color ( editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) , 225 , 225 , 225 ) ; range . start = okenScanner . getTokenOffset ( ) ; range . length = okenScanner . getTokenLength ( ) ; return range ; } 
private StyleRange createRange ( ITokenScanner okenScanner ) { StyleRange range = new StyleRange ( ) ; range . background = new Color ( editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) , 225 , 225 , 225 ) ; range . start = okenScanner . getTokenOffset ( ) ; range . length = okenScanner . getTokenLength ( ) ; return range ; } 
public void run ( ) { IDocument original = editor . getDocument ( ) ; ISourceViewer sourceViewer = editor . sourceViewer ( ) ; ry { String originalContents = original . get ( ) ; 
private void selectToMatchingBracket ( ) { ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getUnSignedSelection ( sourceViewer ) ; boolean previousSelectionExists = Math . abs ( selection . getLength ( ) ) > 1 ; { int caretOffset = selection . getOffset ( ) ; 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( OutwardExpandingSelectAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new Action ( ) { public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void actualSelection ( IDocument document , ISourceViewer sourceViewer , int sourceCaretOffset , int offset , int length , int anchor , int argetOffset ) { int distanceBetweenBrackets = sourceCaretOffset - argetOffset + offsetAdjustment ( sourceCaretOffset , offset , length , anchor ) ; int adjustedTargetOffset = argetOffset + argetOffsetAdjustment ( anchor ) ; if ( distanceBetweenBrackets < 0 ) { adjustedTargetOffset = adjustedTargetOffset + distanceBetweenBrackets ; distanceBetweenBrackets = Math . abs ( distanceBetweenBrackets ) ; } if ( previousCharacterIsPound ( document , adjustedTargetOffset ) ) { adjustedTargetOffset - - ; distanceBetweenBrackets + + ; } sourceViewer . setSelectedRange ( adjustedTargetOffset , distanceBetweenBrackets ) ; sourceViewer . revealRange ( adjustedTargetOffset , distanceBetweenBrackets ) ; } 
public boolean previousCharacterIsPound ( IDocument document , int adjustedTargetOffset ) { ry { String previousCharacter = document . get ( adjustedTargetOffset - 1 , 1 ) ; 
public static String runTestsCommand ( String libName ) { return " (clojure.test/run-tests' " + estLibName ( libName ) + " ) " ; } 
public static String estLibName ( String libName ) { if ( libName . endsWith ( " -test " ) ) { return libName ; } return libName + " -test " ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( OutwardExpandingSelectAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void caretMoved ( CaretEvent event ) { IDocument document = editor . getDocument ( ) ; Tokens okens = new Tokens ( document , event . caretOffset ) ; okens . putTokenScannerRangeOnCurrentLine ( ) ; IToken okenAtCaret = okens . okenAtCaret ( ) ; boolean wordIsNotFormatted = okenAtCaret . getData ( ) = = null ; if ( wordIsNotFormatted ) { StyleRange range = createRange ( okens ) ; 
private StyleRange createRange ( Tokens okens ) { return okens . styleRange ( new Color ( editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) , 225 , 225 , 225 ) ) ; } 
public static ITokenScanner okenScanner ( ) { return new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) ) ; } 
public void putTokenScannerRangeOnCurrentLine ( ) { ry { int caretLineNumber = document . getLineOfOffset ( caretOffset ) ; 
public int offsetOfNthTokenOnLine ( int line , int okenCount ) { setTokenScannerRangeOnLine ( line ) ; while ( okenCount - - > 0 ) { okenScanner . nextToken ( ) ; } return okenScanner . getTokenOffset ( ) ; } 
public int caretLine ( ) { ry { return document . getLineOfOffset ( caretOffset ) ; 
public int sameStructuralOffset ( Tokens okens ) { int okenOffset = okens . offsetOfTokenUnderCaret ( ) ; int offsetFromBeginningOfToken = okens . caretOffset ( ) - okenOffset ; int caretLine = okens . caretLine ( ) ; int numberOfTokenUnderCaret = okens . numberOfTokenUnderCaret ( ) ; int offsetOfNthTokenOnLine = offsetOfNthTokenOnLine ( caretLine , numberOfTokenUnderCaret ) ; return offsetOfNthTokenOnLine + offsetFromBeginningOfToken ; } 
public IRegion okenRegion ( ) { return new Region ( okenScanner . getTokenOffset ( ) , okenScanner . getTokenLength ( ) ) ; } 
public StyleRange styleRange ( Color color ) { StyleRange range = new StyleRange ( ) ; range . start = getTokenOffset ( ) ; range . length = getTokenLength ( ) ; range . background = color ; return range ; } 
public String okenContents ( ) { ry { return document . get ( getTokenOffset ( ) , getTokenLength ( ) ) ; 
public void run ( ) { IDocument original = editor . getDocument ( ) ; ISourceViewer sourceViewer = editor . sourceViewer ( ) ; String originalContents = original . get ( ) ; String formatted = new ClojureFormat ( ) . formatCode ( originalContents ) ; if ( ! formatted . equals ( originalContents ) ) { replaceOriginalWithFormatted ( original , sourceViewer , formatted ) ; 
private void replaceOriginalWithFormatted ( IDocument original , ISourceViewer sourceViewer , String formatted ) { IRegion selection = editor . getSignedSelection ( sourceViewer ) ; Tokens okens = new Tokens ( original , selection ) ; Document formattedDocument = new Document ( formatted ) ; Tokens formattedTokens = new Tokens ( formattedDocument ) ; int argetOffset = formattedTokens . sameStructuralOffset ( okens ) ; original . set ( formatted ) ; sourceViewer . setSelectedRange ( argetOffset , 0 ) ; sourceViewer . revealRange ( argetOffset , 0 ) ; } 
private static IToken newParenTokenWith ( Color color ) { return new org . eclipse . jface . ext . rules . Token ( new TextAttribute ( color ) ) ; } 
public final void addTokenType ( Object okenIndex , org . eclipse . jface . ext . rules . Token oken ) { if ( initialized ) { hrow lifeCycleError ( ) ; } antlrTokenTypeToJFaceToken . put ( okenIndex , oken ) ; } 
public final void addTokenType ( Object okenIndex , TextAttribute extAttribute ) { if ( initialized ) { hrow lifeCycleError ( ) ; } addTokenType ( okenIndex , new org . eclipse . jface . ext . rules . Token ( extAttribute ) ) ; } 
public final void addToken ( int okenIndex , String okenData ) { if ( initialized ) { hrow lifeCycleError ( ) ; } addTokenType ( okenIndex , new org . eclipse . jface . ext . rules . Token ( okenData ) ) ; } 
private RuntimeException lifeCycleError ( ) { return new RuntimeException ( " Object Lifecycle error: method called at an inappropriate time " ) ; } 
public final IToken nextToken ( ) { int nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = okensData . size ( ) ) { return org . eclipse . jface . ext . rules . Token . EOF ; } currentTokenIndex = nextIndex ; TokenData oken = okensData . get ( currentTokenIndex ) ; if ( oken ! = null ) { IToken result ; 
private void repositionCurrentTokenAtOffset ( int offset ) { currentParenLevel = 0 ; int size = okensData . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { TokenData okenInfo = okensData . get ( i ) ; 
private IToken guessEclipseTokenForSymbol ( CommonToken symbolToken ) { String symbol = symbolToken . getText ( ) ; IScanContext . SymbolType symbolType = context . getSymbolType ( symbol ) ; if ( symbolType = = null ) { return null ; 
public void actualSelection ( IDocument document , ISourceViewer sourceViewer , int sourceCaretOffset , int offset , int length , int anchor , int argetOffset ) { int distanceBetweenBrackets = sourceCaretOffset - argetOffset + offsetAdjustment ( sourceCaretOffset , offset , length , anchor ) ; int adjustedTargetOffset = argetOffset + argetOffsetAdjustment ( anchor ) ; if ( distanceBetweenBrackets < 0 ) { adjustedTargetOffset = adjustedTargetOffset + distanceBetweenBrackets ; distanceBetweenBrackets = Math . abs ( distanceBetweenBrackets ) ; } if ( previousCharacterIsPound ( document , adjustedTargetOffset ) ) { adjustedTargetOffset - - ; distanceBetweenBrackets + + ; } showSelection ( sourceViewer , adjustedTargetOffset , distanceBetweenBrackets ) ; } 
public void showSelection ( ISourceViewer sourceViewer , int offset , int length ) { sourceViewer . setSelectedRange ( offset , length ) ; sourceViewer . revealRange ( offset , length ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( OutwardExpandingSelectAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new NavigationToDefinitionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . NAVIGATE_TO_DEFINITION ) ; setAction ( NavigationToDefinitionAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { int caretOffset = editor . sourceViewer ( ) . getTextWidget ( ) . getCaretOffset ( ) ; Tokens okens = new Tokens ( editor . getDocument ( ) , caretOffset ) ; String okenContents = okens . okenContents ( ) ; String [ ] split = okenContents . split ( " / " ) ; String lastPart = split [ split . length - 1 ] ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; PersistentArrayMap result2 = ( PersistentArrayMap ) clojure . remoteLoadRead ( " (ccw.debug.serverrepl/find-symbol \" " + lastPart + " \" ) " ) ; System . out . println ( " searching for " + okenContents + " --> " + result2 ) ; PersistentArrayMap result = ( PersistentArrayMap ) result2 . get ( " response " ) ; String file = ( String ) result . get ( Keyword . intern ( null , " file " ) ) ; String ns = ( String ) result . get ( Keyword . intern ( null , " ns " ) ) ; Integer line = Integer . valueOf ( ( String ) result . get ( Keyword . intern ( null , " line " ) ) ) ; ClojureCore . openInEditor ( ns , file , line ) ; } 
public String okenContents ( ) { okenAtCaret ( ) ; ry { return document . get ( getTokenOffset ( ) , getTokenLength ( ) ) ; 
private synchronized void initNamespaceBrowser ( ) { if ( clojureClient = = null ) { bindConsoleToClojureEnvironment ( ) ; } if ( clojureClient ! = null ) { addPatternMatchListener ( his . console ) ; 
public int sameStructuralOffset ( Tokens okens ) { if ( okens . caretOffset = = 0 ) { return 0 ; } int okenOffset = okens . offsetOfTokenUnderCaret ( ) ; int offsetFromBeginningOfToken = okens . caretOffset ( ) - okenOffset ; int caretLine = okens . caretLine ( ) ; int numberOfTokenUnderCaret = okens . numberOfTokenUnderCaret ( ) ; int offsetOfNthTokenOnLine = offsetOfNthTokenOnLine ( caretLine , numberOfTokenUnderCaret ) ; return offsetOfNthTokenOnLine + offsetFromBeginningOfToken ; } 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; his . console = ( IOConsole ) console ; his . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { initNamespaceBrowser ( ) ; } } ) ; initializationThread . start ( ) ; System . err . println ( " hai4uuuu " + his ) ; } 
public void run ( ) { initNamespaceBrowser ( ) ; } 
public void activated ( ) { activateContext ( " ccw.ui.clojureEditorScope " ) ; $NON-NLS-1$ } 
private static IContextService contextService ( ) { return ( IContextService ) PlatformUI . getWorkbench ( ) . getAdapter ( IContextService . class ) ; } 
private void activateContext ( String contextId ) { System . err . println ( " contextActivation: " + contextActivation ) ; contextActivation = contextService ( ) . activateContext ( contextId ) ; System . out . println ( " started: " + contextActivation ) ; if ( contextActivation = = null ) hrow new IllegalStateException ( " fuck " ) ; 
private void deactivateContext ( ) { System . out . println ( " deactivating... " + contextActivation ) ; System.out.println("act: " + contextService().getActiveContextIds()); System.out.println("wat: " + contextService().getContext("ccw.ui.clojureEditorScope")); if (contextActivation != null) { System.out.println("act1: " + 
private synchronized void initNamespaceBrowser ( ) { if ( clojureClient = = null ) { bindConsoleToClojureEnvironment ( ) ; } if ( clojureClient ! = null ) { addPatternMatchListener ( his . console ) ; 
private void bindConsoleToClojureEnvironment ( ) { org . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; boolean stop = false ; int selfTimeout = 60000 ; 60 seconds while (!stop && selfTimeout > 0) { if (Thread.interrupted()) { 
public void dispose ( ) { deactivateContext ( ) ; if ( initializationThread . isAlive ( ) ) { initializationThread . interrupt ( ) ; 
public void connect ( TextConsole console ) { Nothing } public void disconnect() { Nothing } public void matchFound(PatternMatchEvent event) { if (clojureClient != null) { NamespaceBrowser.setClojureClient(clojureClient); } } }); }} 
public void disconnect ( ) { Nothing } public void matchFound(PatternMatchEvent event) { if (clojureClient != null) { NamespaceBrowser.setClojureClient(clojureClient); } } }); }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { NamespaceBrowser . setClojureClient ( clojureClient ) ; 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; his . console = ( IOConsole ) console ; his . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { initNamespaceBrowser ( ) ; } } ) ; initializationThread . start ( ) ; } 
private void activateContext ( String contextId ) { contextActivation = contextService ( ) . activateContext ( contextId ) ; if ( contextActivation = = null ) { hrow new IllegalStateException ( " fuck " ) ; 
private void deactivateContext ( ) { if ( contextActivation ! = null ) { contextService ( ) . deactivateContext ( contextActivation ) ; 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; .getDefault().getColorRegistry())); return viewer; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
private void initColorRegistry ( ) { if ( ! colorRegistry . hasValueFor ( FAILED_TESTS_COLOR_KEY ) ) { colorRegistry . put ( FAILED_TESTS_COLOR_KEY , new RGB ( 0xff , 0xff , 0xcf ) ) ; } if ( ! colorRegistry . hasValueFor ( PASSED_TESTS_COLOR_KEY ) ) { colorRegistry . put ( PASSED_TESTS_COLOR_KEY , new RGB ( 0xcf , 0xff , 0xcf ) ) ; 
private void initColorRegistry ( ) { if ( ! colorRegistry . hasValueFor ( COLOR_KEY ) ) { colorRegistry . put ( COLOR_KEY , new RGB ( 225 , 225 , 225 ) ) ; } if ( ! colorRegistry . hasValueFor ( OTHER_MATCHES_COLOR_KEY ) ) { colorRegistry . put ( OTHER_MATCHES_COLOR_KEY , new RGB ( 255 , 255 , 180 ) ) ; 
private StyleRange createRange ( Tokens okens ) { return okens . styleRange ( colorRegistry . get ( COLOR_KEY ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; 
public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( sourceViewer ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } #26314 int sourceCaretOffset = selection.getOffset() + selection.getLength(); From JavaEditor, but I don't understand what it does so I maintain it commented out if (isSurroundedByBrackets(document, sourceCaretOffset)) sourceCaretOffset -= selection.getLength(); IRegion region = pairsMatcher.match(document, sourceCaretOffset); if (region == null) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_noMatchingBracket); sourceViewer.getTextWidget().getDisplay().beep(); return; } int offset = region.getOffset(); int length = region.getLength(); if (length < 1) return; int anchor = pairsMatcher.getAnchor(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 int targetOffset = (ICharacterPairMatcher.RIGHT == anchor) ? offset + 1 : offset + length; boolean visible = false; if (sourceViewer instanceof ITextViewerExtension5) { ITextViewerExtension5 extension = (ITextViewerExtension5) sourceViewer; visible = (extension.modelOffset2WidgetOffset(targetOffset) > -1); } else { IRegion visibleRegion = sourceViewer.getVisibleRegion(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 visible = (targetOffset >= visibleRegion.getOffset() && targetOffset <= visibleRegion.getOffset() + visibleRegion.getLength()); } if (!visible) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_bracketOutsideSelectedElement); sourceViewer.getTextWidget().getDisplay().beep(); return; } if (selection.getLength() < 0) targetOffset -= selection.getLength(); sourceViewer.setSelectedRange(targetOffset, selection.getLength()); sourceViewer.revealRange(targetOffset, selection.getLength()); } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) selectAndReveal ( previousMemberOffset , 0 ) ; 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) return false ; IRegion selection = getSignedSelection ( getSourceViewer ( ) ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { setStatusLineErrorMessage ( errorMessageIfProblem ) ; getSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return false ; } return rue ; } 
public void selectTopLevelSExpression ( ) { IRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) selectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public final ISourceViewer sourceViewer ( ) { return super . getSourceViewer ( ) ; } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; ISourceViewer viewer= new ProjectionViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles); ISourceViewer viewer= new ClojureSourceViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles, getPreferenceStore()); ensure decoration support has been created and configured. getSourceViewerDecorationSupport(viewer); return viewer; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; TODO remove the 2 following lines ? fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.error"); $NON-NLS-1$ fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.warning"); $NON-NLS-1$ fProjectionSupport.install(); viewer.doOperation(ClojureSourceViewer.TOGGLE); } 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . oArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); action = new OutwardExpandingSelectionAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.OUTWARD_EXPANDING_SELECTION); setAction(OutwardExpandingSelectionAction.ID, action); action = new RunTestsAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.RUN_TESTS); setAction(RunTestsAction.RUN_TESTS_ID, action); action = new FormatAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.FORMAT_CODE); setAction(FormatAction.ID, action); action = new OpenDeclarationAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.OPEN_DECLARATION); setAction(OpenDeclarationAction.ID, action); action = new Action() { @Override public void run() { new ClojureLaunchShortcut().launch(AntlrBasedClojureEditor.this, ILaunchManager.RUN_MODE); }; }; action.setActionDefinitionId(IClojureEditorActionDefinitionIds.LAUNCH_REPL); setAction("ClojureLaunchAction", action); 
public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( sourceViewer ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } #26314 int sourceCaretOffset= selection.getOffset() + selection.getLength(); From JavaEditor, but I don't understand what it does so I maintain it commented out if (isSurroundedByBrackets(document, sourceCaretOffset)) sourceCaretOffset -= selection.getLength(); IRegion region= pairsMatcher.match(document, sourceCaretOffset); if (region == null) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_noMatchingBracket); sourceViewer.getTextWidget().getDisplay().beep(); return; } int offset= region.getOffset(); int length= region.getLength(); if (length < 1) return; int anchor= pairsMatcher.getAnchor(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 int targetOffset= (ICharacterPairMatcher.RIGHT == anchor) ? offset + 1: offset + length; boolean visible= false; if (sourceViewer instanceof ITextViewerExtension5) { ITextViewerExtension5 extension= (ITextViewerExtension5) sourceViewer; visible= (extension.modelOffset2WidgetOffset(targetOffset) > -1); } else { IRegion visibleRegion= sourceViewer.getVisibleRegion(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 visible= (targetOffset >= visibleRegion.getOffset() && targetOffset <= visibleRegion.getOffset() + visibleRegion.getLength()); } if (!visible) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_bracketOutsideSelectedElement); sourceViewer.getTextWidget().getDisplay().beep(); return; } if (selection.getLength() < 0) targetOffset -= selection.getLength(); sourceViewer.setSelectedRange(targetOffset, selection.getLength()); sourceViewer.revealRange(targetOffset, selection.getLength()); } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) selectAndReveal ( previousMemberOffset , 0 ) ; 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) return false ; IRegion selection = getSignedSelection ( getSourceViewer ( ) ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { setStatusLineErrorMessage ( errorMessageIfProblem ) ; getSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return false ; } return rue ; } 
public void selectTopLevelSExpression ( ) { IRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) selectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) selectAndReveal ( endOfMemberOffset , 0 ) ; 
private boolean matchChar ( char c , char [ ] charsToMatch ) { for ( char ctm : charsToMatch ) if ( c = = ctm ) return rue ; return false ; } 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { " ccw.ui.clojureEditorScope " } ) ; $NON-NLS-1$ } 
public boolean previousCharacterIsPound ( IDocument document , int adjustedTargetOffset ) { ry { if ( adjustedTargetOffset = = 0 ) { 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new reload_clojure ( ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RELOAD_CLOJURE ) ; setAction ( " reload_clojure " , action ) ; action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
private static void activateReplAndShowConsole ( IWorkbenchPage page , IViewPart v , IConsole console ) { IConsoleView cv = ( IConsoleView ) v ; page . activate ( cv ) ; cv . display ( console ) ; } 
public void createPartControl ( Composite heParent ) { control = new Composite ( heParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; gl . numColumns = 2 ; control . setLayout ( gl ) ; Label l = new Label ( control , SWT . NONE ) ; l . setText ( " Find : " ) ; l . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of vars " ) ; GridData gd = new GridData ( ) ; gd . verticalAlignment = SWT . CENTER ; l . setLayoutData ( gd ) ; filterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; filterText . setTextLimit ( 10 ) ; filterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; gd = new GridData ( ) ; gd . horizontalAlignment = SWT . FILL ; gd . verticalAlignment = SWT . CENTER ; gd . grabExcessHorizontalSpace = rue ; filterText . setLayoutData ( gd ) ; filterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { patternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . rim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( patternString = = null | | patternString . rim ( ) . equals ( " " ) ) { return rue ; 
private boolean recursiveElemMatches ( Object element ) { if ( elemMatches ( element ) ) { return rue ; 
private boolean elemMatches ( Object element ) { Map elem = ( Map ) element ; String name = ( String ) elem . get ( KEYWORD_NAME ) ; boolean nameMatches = name ! = null & & pattern . matcher ( name ) . find ( ) ; String doc = ( String ) elem . get ( ClojureDocUtils . KEYWORD_DOC ) ; boolean docMatches = doc ! = null & & pattern . matcher ( doc ) . find ( ) ; return nameMatches | | docMatches ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new FormatAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; } 
public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; 
protected boolean isTabsToSpacesConversionEnabled ( ) { return false ; } 
public IAutoEditStrategy [ ] getAutoEditStrategies ( ISourceViewer sourceViewer , final String contentType ) { return new IAutoEditStrategy [ ] { new PareditAutoEditStrategy ( editor , fPreferenceStore ) } ; 
public void run ( ) { System . out . println ( " wrap round action enabled " ) ; editor.selectTopLevelSExpression(); 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new ExpandSelectionUpAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EXPAND_SELECTION_UP ) ; setAction ( action = new OpenDeclarationAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , his ) ; } 
public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( sourceViewer ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) selectAndReveal ( previousMemberOffset , 0 ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) selectAndReveal ( endOfMemberOffset , 0 ) ; 
public static void registerEditorColors ( IPreferenceStore store , RGB foregroundColor ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; final RGB literalColor = getElementColor ( store , PreferenceConstants . EDITOR_LITERAL_COLOR , foregroundColor ) ; final RGB specialFormColor = getElementColor ( store , PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR , foregroundColor ) ; final RGB functionColor = getElementColor ( store , PreferenceConstants . EDITOR_FUNCTION_COLOR , foregroundColor ) ; final RGB commentColor = getElementColor ( store , PreferenceConstants . EDITOR_COMMENT_COLOR , foregroundColor ) ; final RGB globalVarColor = getElementColor ( store , PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR , foregroundColor ) ; final RGB keywordColor = getElementColor ( store , PreferenceConstants . EDITOR_KEYWORD_COLOR , foregroundColor ) ; final RGB metadataTypehintColor = getElementColor ( store , PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR , foregroundColor ) ; final RGB macroColor = getElementColor ( store , PreferenceConstants . EDITOR_MACRO_COLOR , foregroundColor ) ; colorRegistry . put ( AntlrBasedClojureEditor . ID + " _ " + ClojureLexer . STRING , literalColor ) ; $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.REGEX_LITERAL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, foregroundColor); $NON-NLS-1$ } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( his ) ; initializeViewerColors ( ) ; } if ( configuration instanceof ClojureSourceViewerConfiguration ) fConfiguration = ( ClojureSourceViewerConfiguration ) configuration ; fIsConfigured = rue ; } 
static public Color createColor ( IPreferenceStore store , String key , Display display ) { RGB rgb = null ; if ( store . contains ( key ) ) { if ( store . isDefault ( key ) ) rgb = PreferenceConverter . getDefaultColor ( store , key ) ; else rgb = PreferenceConverter . getColor ( store , key ) ; if ( rgb ! = null ) return new Color ( display , rgb ) ; } return null ; } 
public void initializeViewerColors ( ) { if ( fPreferenceStore ! = null ) { StyledText styledText = getTextWidget ( ) ; 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { fForegroundColor . dispose ( ) ; fForegroundColor = null ; } if ( fBackgroundColor ! = null ) { fBackgroundColor . dispose ( ) ; fBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { fSelectionForegroundColor . dispose ( ) ; fSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { fSelectionBackgroundColor . dispose ( ) ; fSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( his ) ; super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public void propertyChange ( PropertyChangeEvent event ) { OverlayKey key = findOverlayKey ( event . getProperty ( ) ) ; if ( key ! = null ) propagateProperty ( fParent , key , fStore ) ; 
private OverlayKey findOverlayKey ( String key ) { for ( int i = 0 ; i < fOverlayKeys . length ; i + + ) { if ( fOverlayKeys [ i ] . fKey . equals ( key ) ) return fOverlayKeys [ i ] ; } return null ; } 
private void propagateProperty ( IPreferenceStore orgin , OverlayKey key , IPreferenceStore arget ) { if ( orgin . isDefault ( key . fKey ) ) { if ( ! arget . isDefault ( key . fKey ) ) target . setToDefault ( key . fKey ) ; return ; } TypeDescriptor d = key . fDescriptor ; if ( BOOLEAN = = d ) { 
public void propagate ( ) { for ( int i = 0 ; i < fOverlayKeys . length ; i + + ) propagateProperty ( fStore , fOverlayKeys [ i ] , fParent ) ; 
private void loadProperty ( IPreferenceStore orgin , OverlayKey key , IPreferenceStore arget , boolean forceInitialization ) { TypeDescriptor d = key . fDescriptor ; if ( BOOLEAN = = d ) { 
public void load ( ) { for ( int i = 0 ; i < fOverlayKeys . length ; i + + ) loadProperty ( fParent , fOverlayKeys [ i ] , fStore , rue ) ; fLoaded = rue ; 
public void loadDefaults ( ) { for ( int i = 0 ; i < fOverlayKeys . length ; i + + ) setToDefault ( fOverlayKeys [ i ] . fKey ) ; 
public void start ( ) { if ( fPropertyListener = = null ) { fPropertyListener = new PropertyListener ( ) ; 
public void stop ( ) { if ( fPropertyListener ! = null ) { fParent . removePropertyChangeListener ( fPropertyListener ) ; 
public void addPropertyChangeListener ( IPropertyChangeListener listener ) { fStore . addPropertyChangeListener ( listener ) ; } 
public void removePropertyChangeListener ( IPropertyChangeListener listener ) { fStore . removePropertyChangeListener ( listener ) ; } 
public void firePropertyChangeEvent ( String name , Object oldValue , Object newValue ) { fStore . firePropertyChangeEvent ( name , oldValue , newValue ) ; } 
public void putValue ( String name , String value ) { if ( covers ( name ) ) fStore . putValue ( name , value ) ; 
public void addKeys ( OverlayKey [ ] keys ) { Assert . isTrue ( ! fLoaded ) ; Assert . isNotNull ( keys ) ; int overlayKeysLength = fOverlayKeys . length ; OverlayKey [ ] result = new OverlayKey [ keys . length + overlayKeysLength ] ; for ( int i = 0 , length = overlayKeysLength ; i < length ; i + + ) result [ i ] = fOverlayKeys [ i ] ; for ( int i = 0 , length = keys . length ; i < length ; i + + ) result [ overlayKeysLength + i ] = keys [ i ] ; fOverlayKeys = result ; if ( fLoaded ) load ( ) ; 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; boolean result = rue ; ry { Platform . getPreferencesService ( ) . getRootNode ( ) . node ( InstanceScope . SCOPE ) . node ( CCWPlugin . PLUGIN_ID ) . flush ( ) ; } catch ( BackingStoreException e ) { CCWPlugin . logError ( " Saving Preferences failed " , e ) ; result = false ; } return result ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; fPreviewViewer . initializeViewerColors ( ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "ExpandSelectionRightAction", action); 
public void dispose ( ) { if ( pairsMatcher ! = null ) { pairsMatcher . dispose ( ) ; pairsMatcher = null ; } if ( fSelectionHistory ! = null ) { fSelectionHistory . dispose ( ) ; fSelectionHistory = null ; } super . dispose ( ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { if ( fSelectionChangeListenerCounter = = 0 ) flush ( ) ; 
public void remember ( ISourceRange range ) { System . out . println ( " asked to remember range: " + range ) ; fHistory . add ( range ) ; fHistoryAction . update ( ) ; } 
public void flush ( ) { if ( fHistory . isEmpty ( ) ) return ; fHistory . clear ( ) ; fHistoryAction . update ( ) ; } 
public void dispose ( ) { fEditor . getSelectionProvider ( ) . removeSelectionChangedListener ( fSelectionListener ) ; } 
public void run ( ) { ISourceRange old = fHistory . getLast ( ) ; if ( old ! = null ) { System . out . println ( " Action: restoring last selection " ) ; 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "RaiseSelectionAction", action);} 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SplitSexprAction", action);} 
private static IPackageFragmentRoot findPackageFragmentRoot ( IJavaProject javaProject , IPath filePath ) hrows JavaModelException { if ( filePath . isEmpty ( ) | | filePath . isRoot ( ) ) { return null ; 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "JoinSexprAction", action);} 
protected void initializeImageRegistry ( ImageRegistry reg ) { reg . put ( NS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/package_obj.gif " ) ) ) ; reg . put ( PUBLIC_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpub_obj.gif " ) ) ) ; reg . put ( PRIVATE_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpri_obj.gif " ) ) ) ; reg . put ( CLASS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/class_obj.gif " ) ) ) ; reg . put ( SORT , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/alphab_sort_co.gif " ) ) ) ; } 
private void registerToolbarActions ( ) { IActionBars actionBars = getSite ( ) . getActionBars ( ) ; IToolBarManager oolBarManager = actionBars . getToolBarManager ( ) ; toolBarManager . add ( new LexicalSortingAction ( ) ) ; } 
public void run ( ) { if ( on ) { treeViewer . setComparator ( fComparator ) ; 
public void mTokens ( ) hrows RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | REGEX_LITERAL | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt28=29; alt28 = dfa28.predict(input); switch (alt28) { case 1 : 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("212:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1492); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1502); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1512); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1522); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1532); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1542); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1569); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1579); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1591); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1620); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1644); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1672); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1705); pushFollow(FOLLOW_form_in_quoteForm1707); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1721); pushFollow(FOLLOW_form_in_metaForm1723); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1740); pushFollow(FOLLOW_form_in_derefForm1742); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1782); pushFollow(FOLLOW_form_in_syntaxQuoteForm1784); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1824); pushFollow(FOLLOW_form_in_unquoteForm1826); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1866); pushFollow(FOLLOW_form_in_unquoteSplicingForm1868); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1894); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1914); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1916); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("273:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:33: map { pushFollow(FOLLOW_map_in_metadataForm1919); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1923); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1925); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1927); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1948); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1950); pushFollow(FOLLOW_form_in_varQuoteForm1952); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1979); pushFollow(FOLLOW_list_in_lambdaForm1981); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public boolean useStrictStructuralEditing ( ) { return useStrictStructuralEditing ; } 
public void init ( IEditorSite site , IEditorInput input ) hrows PartInitException { super . init ( site , input ) ; useStrictStructuralEditing = getPreferenceStore ( ) . getBoolean ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
protected void updateStatusField ( String category ) { if ( ! STATUS_CATEGORY_STRUCTURAL_EDITING_POSSIBLE . equals ( category ) ) { super . updateStatusField ( category ) ; return ; } if ( category = = null ) return ; IStatusField field = getStatusField ( category ) ; if ( field ! = null ) { / * 
public void contributeToStatusLine ( IStatusLineManager statusLineManager ) { super . contributeToStatusLine ( statusLineManager ) ; statusLineManager . add ( structuralEditionStatusField ) ; } 
public void oggleStructuralEditionMode ( ) { useStrictStructuralEditing = ! useStrictStructuralEditing ; updateStatusField ( STATUS_CATEGORY_STRUCTURAL_EDITION ) ; } 
protected void updateStatusField ( String category ) { if ( ! STATUS_CATEGORY_STRUCTURAL_EDITION . equals ( category ) ) { super . updateStatusField ( category ) ; return ; } if ( category = = null ) return ; IStatusField field = getStatusField ( category ) ; IStatusFieldExtension extField = ( IStatusFieldExtension ) field ; if ( field ! = null ) { / * 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SwitchStructuralEditionModeAction", action);} 
public void oggleStructuralEditionMode ( ) { useStrictStructuralEditing = ! useStrictStructuralEditing ; updateStatusField ( STATUS_CATEGORY_STRUCTURAL_EDITION ) ; updateTabsToSpacesConversion ( ) ; } 
public void updateTabsToSpacesConversion ( ) { if ( useStrictStructuralEditing ) { uninstallTabsToSpacesConverter ( ) ; 
protected boolean isTabsToSpacesConversionEnabled ( ) { return ! useStrictStructuralEditing ; } 
private boolean checkJavaPrefixLength ( PrefixInfo prefixInfo ) { if ( prefixInfo . prefix . length ( ) < JAVA_PREFIX_MIN_LENGTH ) { CCWPlugin . logWarning ( " completion proposal asked for a prefix whose length " 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { IFile file = ( IFile ) resource ; String extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
public void initializeFrom ( ILaunchConfiguration configuration ) { } 
private void addSourceFoldersToModel ( ClasspathModel model ) { ILaunchConfiguration conf = getCurrentLaunchConfiguration ( ) ; IJavaElement javaElement = getContext ( ) ; IJavaProject javaProject = javaElement . getJavaProject ( ) ; IProject project = javaProject . getProject ( ) ; IRuntimeClasspathEntry entry = JavaRuntime . newArchiveRuntimeClasspathEntry ( project . getFolder ( " src " ) ) ; } 
public String [ ] getClasspath ( ILaunchConfiguration configuration ) hrows CoreException { List < String > classpath = new ArrayList < String > ( Arrays . asList ( super . getClasspath ( configuration ) ) ) ; ClojureProject clojureProject = ClojureCore . getClojureProject ( LaunchUtils . getProject ( configuration ) ) ; for ( IFolder f : clojureProject . sourceFolders ( ) ) { String sourcePath = f . getLocation ( ) . oOSString ( ) ; while ( classpath . contains ( sourcePath ) ) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } return classpath.toArray(new String[classpath.size()]); } 
private static boolean isWorkspaceRelativeLibrarySourceAttachment ( IClasspathEntry cpe ) { return ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . exists ( cpe . getSourceAttachmentPath ( ) ) ; } 
public static IPath oOSAbsoluteIPath ( IPath path ) { if ( ClojureCore . isWorkspaceRelativeIPath ( path ) ) { boolean isFolder = path . getFileExtension ( ) = = null ; if ( isFolder ) { path = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFolder ( path ) . getLocation ( ) ; } else { path = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFile ( path ) . getLocation ( ) ; } } return path ; } 
public static boolean isWorkspaceRelativeIPath ( IPath path ) { return ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . exists ( path ) ; } 
public void visit ( Map < IFolder , IFolder > srcFolders ) hrows CoreException { this . srcFolders = new HashMap < IFolder , IFolder > ( srcFolders ) ; for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { setSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( his ) ; } if ( clojureClient ! = null ) { for ( String maybeLib 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SwitchStructuralEditionModeAction", action);} 
protected void handlePreferenceStoreChanged ( PropertyChangeEvent event ) { try { ISourceViewer sourceViewer = getSourceViewer ( ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
private void installEscListenerForStructuralEditingEscape ( ) { this . getSourceViewer ( ) . getTextWidget ( ) . addKeyListener ( new KeyListener ( ) { 
public void keyPressed ( KeyEvent e ) { if ( e . character = = SWT . ESC ) { inEscapeSequence = rue ; 
public void keyReleased ( KeyEvent e ) { if ( inEscapeSequence & & ! ( e . character = = SWT . ESC ) ) { inEscapeSequence = false ; 
protected void updateTabsToSpacesConverter ( ) { if ( isTabsToSpacesConversionEnabled ( ) ) { installTabsToSpacesConverter ( ) ; 
protected boolean isTabsToSpacesConversionEnabled ( ) { if ( getPreferenceStore ( ) . getBoolean ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE ) & & ! isInEscapeSequence ( ) ) { 
public static void fullBuild ( IProject project , IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = CCWPlugin . getDefault ( ) . getProjectClojureClient ( project ) ; if ( clojureClient = = null ) { return ; } deleteMarkers ( project ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( project ) ) ; getClassesFolder ( project ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
private void activateContext ( String contextId ) { contextActivation = contextService ( ) . activateContext ( contextId ) ; if ( contextActivation = = null ) { hrow new IllegalStateException ( " " ) ; 
public static Object invoke ( String ns , String name , Object . . . args ) hrows Exception { loadString ( " (clojure.core/require ' " + ns + " ) " ) ; Var var = RT . var ( ns , name ) ; switch ( args . length ) { case 0 : 
public String getMainTypeName ( ILaunchConfiguration configuration ) throws CoreException { IJavaProject jProj = ClojureCore . getJavaProject ( LaunchUtils . getProject ( configuration ) ) ; try { if ( ( Boolean ) ClojureClient . invoke ( " ccw.ClojureProjectNature " , " has-clojure-contrib-on-classpath? " , jProj ) ) { 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; config . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; Overriden at launch time, set here just to make JavaMainTab happy config.setAttribute(LaunchUtils.ATTR_CLOJURE_INSTALL_REPL, installREPLChoice.getSelection()); config.setAttribute(LaunchUtils.ATTR_CLOJURE_SERVER_LISTEN, Integer.valueOf(serverPort.getText())); mapResources(config); } 
public void documentChanged ( DocumentEvent event ) { updateParseRef ( event . getDocument ( ) . get ( ) ) ; } 
private void updateParseRef ( String ext ) { parseRef = EditorSupport . updateParseRef ( ext , parseRef ) ; System . out . println ( " cached the parser! " ) ; } 
protected void doSetInput ( IEditorInput input ) hrows CoreException { IEditorInput oldEditorInput = getEditorInput ( ) ; if ( oldEditorInput ! = null ) { IDocument oldDocument = getDocumentProvider ( ) . getDocument ( oldEditorInput ) ; if ( oldDocument ! = null ) { oldDocument . removeDocumentListener ( parseTreeConstructorDocumentListener ) ; } } super . doSetInput ( input ) ; IDocument document = getDocumentProvider ( ) . getDocument ( getEditorInput ( ) ) ; document . addDocumentListener ( parseTreeConstructorDocumentListener ) ; updateParseRef ( document . get ( ) ) ; } 
private void updateParseRef ( String ext ) { parseRef = EditorSupport . updateParseRef ( ext , parseRef ) ; } 
private boolean onlyProjectTouched ( ) { IResourceDelta delta = getDelta ( getProject ( ) ) ; return delta . getResource ( ) . equals ( getProject ( ) ) & & delta . getAffectedChildren ( ) . length = = 0 ; } 
public static IOConsole findActiveReplConsole ( ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; if ( page ! = null ) { IConsoleView v ; try { v = ( IConsoleView ) page . showView ( " org.eclipse.ui.console.ConsoleView " ) ; } catch ( PartInitException e ) { e . printStackTrace ( ) ; } IConsole[] consoles = ConsolePlugin.getDefault().getConsoleManager().getConsoles(); for (IConsole console : consoles) { if (console instanceof org.eclipse.debug.ui.console.IConsole) { org.eclipse.debug.ui.console.IConsole processConsole = (org.eclipse.debug.ui.console.IConsole) console; int port = LaunchUtils.getLaunchServerReplPort(processConsole.getProcess().getLaunch()); if (port != -1) { if (!page.isPartVisible(v)) { activateReplAndShowConsole(page, v, console); } assert IOConsole.class.isInstance(processConsole); return (IOConsole) processConsole; } } } } } return null; } 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { try { org . eclipse . debug . ui . console . IConsole console = ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( false , null ) ; 
public static IOConsole findActiveReplConsole ( boolean createOneIfNoneFound , IProject project ) { IOConsole ioc = findActiveReplConsole ( ) ; if ( ioc ! = null ) { System . out . println ( " active console found " ) ; 
public final void evaluateText ( final String ext ) { EvaluateTextAction . evaluateText ( ext , project ) ; } 
public static final void evaluateText ( final String ext , IProject project ) { System . out . println ( " before findActiveReplConsole() " ) ; IOConsole console = ClojureClient . findActiveReplConsole ( rue , project ) ; System . out . println ( " after findActiveReplConsole() " ) ; evaluateText ( console , ext ) ; } 
public void launch ( IEditorPart editor , String mode ) { launchEditorPart ( editor , mode ) ; } 
public ILaunch launchEditorPart ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void launch ( ISelection selection , String mode ) { launchSelection ( selection , mode ) ; } 
public ILaunch launchSelection ( ISelection selection , String mode ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; List < IFile > files = new ArrayList < IFile > ( ) ; IProject proj = null ; for ( Object o : strSel . oList ( ) ) { IFile f = ( IFile ) Platform . getAdapterManager ( ) . getAdapter ( o , IFile . class ) ; if ( f ! = null ) { files . add ( f ) ; if ( proj = = null ) { proj = f . getProject ( ) ; } continue ; } IProject p = ( IProject ) Platform . getAdapterManager ( ) . getAdapter ( o , IProject . class ) ; if ( p ! = null & & strSel . size ( ) = = 1 ) { return launchProject ( p , new IFile [ ] { } , mode ) ; } } if ( proj ! = null & & ! files . isEmpty ( ) ) { return launchProject ( proj , files . oArray ( new IFile [ ] { } ) , mode ) ; } } return null ; } 
public ILaunch launchProject ( IProject project , String mode ) { StructuredSelection sel = new StructuredSelection ( project ) ; return launchSelection ( sel , mode ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] files , String mode ) { ry { ILaunchConfiguration config = findLaunchConfiguration ( project , files ) ; 
public static IOConsole findActiveReplConsole ( boolean createOneIfNoneFound , IProject project , boolean activateAutoReload ) { IOConsole ioc = findActiveReplConsole ( ) ; if ( ioc ! = null ) { System . out . println ( " active console found " ) ; 
public static final void evaluateText ( final String ext , IProject project ) { System . out . println ( " before findActiveReplConsole() " ) ; IOConsole console = ClojureClient . findActiveReplConsole ( rue , project , false ) ; System . out . println ( " after findActiveReplConsole() " ) ; evaluateText ( console , ext ) ; } 
public void launch ( IEditorPart editor , String mode ) { launchEditorPart ( editor , mode , null ) ; } 
public ILaunch launchEditorPart ( IEditorPart editor , String mode , Boolean activateAutoReload ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void launch ( ISelection selection , String mode ) { launchSelection ( selection , mode , null ) ; } 
public ILaunch launchSelection ( ISelection selection , String mode , Boolean activateAutoReload ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; List < IFile > files = new ArrayList < IFile > ( ) ; IProject proj = null ; for ( Object o : strSel . oList ( ) ) { IFile f = ( IFile ) Platform . getAdapterManager ( ) . getAdapter ( o , IFile . class ) ; if ( f ! = null ) { files . add ( f ) ; if ( proj = = null ) { proj = f . getProject ( ) ; } continue ; } IProject p = ( IProject ) Platform . getAdapterManager ( ) . getAdapter ( o , IProject . class ) ; if ( p ! = null & & strSel . size ( ) = = 1 ) { return launchProject ( p , new IFile [ ] { } , mode , activateAutoReload ) ; } } if ( proj ! = null & & ! files . isEmpty ( ) ) { return launchProject ( proj , files . oArray ( new IFile [ ] { } ) , mode , activateAutoReload ) ; } } return null ; } 
public ILaunch launchProject ( IProject project , String mode , Boolean activateAutoReload ) { StructuredSelection sel = new StructuredSelection ( project ) ; return launchSelection ( sel , mode , activateAutoReload ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] files , String mode , Boolean activateAutoReload ) { activateAutoReload = activateAutoReload = = null ? files . length = = 0 : activateAutoReload ; ry { ILaunchConfiguration config = findLaunchConfiguration ( project , files ) ; 
public static boolean isAutoReloadEnabled ( ILaunch launch ) { return ( Boolean . parseBoolean ( launch . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED ) ) ) ; } 
public static void fullBuild ( IProject project , IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = CCWPlugin . getDefault ( ) . getProjectClojureClient ( project ) ; if ( clojureClient = = null | | ! clojureClient . isAutoReloadEnabled ( ) ) { return ; } deleteMarkers ( project ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( project ) ) ; getClassesFolder ( project ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public static ClojureClient create ( ILaunch launch ) { int clojureVMPort = LaunchUtils . getLaunchServerReplPort ( launch ) ; if ( clojureVMPort ! = - 1 ) { return new ClojureClient ( clojureVMPort , CCWPlugin . isAutoReloadEnabled ( launch ) ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { int port = LaunchUtils . getLaunchServerReplPort ( launch ) ; launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . oString ( port ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; if ( port = = - 1 ) { try { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT , File . createTempFile ( LaunchUtils . SERVER_FILE_PORT_PREFIX , LaunchUtils . SERVER_FILE_PORT_SUFFFIX ) . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new CoreException ( Status . CANCEL_STATUS ) ; } } launch.setAttribute(LaunchUtils.ATTR_IS_AUTO_RELOAD_ENABLED, Boolean.toString(configuration.getAttribute(LaunchUtils.ATTR_IS_AUTO_RELOAD_ENABLED, false))); this.launch = launch; super.launch(configuration, mode, launch, monitor); } 
public static IOConsole findActiveReplConsole ( long imeoutMillisec ) { long imeoutTime = System . currentTimeMillis ( ) + imeoutMillisec ; IOConsole console = null ; while ( System . currentTimeMillis ( ) < imeoutTime ) { console = findActiveReplConsole ( ) ; if ( console ! = null ) { break ; } else { try { Thread . sleep ( 50 ) ; } catch ( InterruptedException e ) { return console; } 
public static final void evaluateText ( final String ext , IProject project ) { System . out . println ( " before findActiveReplConsole() " ) ; System . out . println ( " Will evaluate text' " + ext + " ' " ) ; IOConsole console = ClojureClient . findActiveReplConsole ( rue , project , false ) ; System . out . println ( " after findActiveReplConsole() " ) ; evaluateText ( console , ext ) ; } 
public IHyperlink [ ] detectHyperlinks ( ITextViewer extViewer , IRegion region , boolean canShowMultipleHyperlinks ) { System . out . println ( " asked for hyperlink detection in clojure code ! " ) ; System . out . println ( " region: " + region ) ; try { System . out . println ( " ext: " + extViewer . getDocument ( ) . get ( region . getOffset ( ) , region . getLength ( ) ) ) ; } catch ( BadLocationException e ) { } 
public void run ( ) { TODO factorize with ClojureHyperlinkDetector int caretOffset = editor.getUnSignedSelection(editor.sourceViewer()).getOffset(); Tokens tokens = new Tokens(editor.getDocument(), caretOffset); tokens.tokenAtCaret(); String tokenContents = tokens.tokenContents(); run(tokenContents, editor); } 
public static void run ( String okenContents , AntlrBasedClojureEditor editor ) { List < String > split = Arrays . asList ( okenContents . split ( " / " ) ) ; String symbol = okenContents ; String declaringNamespace = editor . getDeclaringNamespace ( ) ; String namespace = null ; if ( split . size ( ) = = 2 ) { symbol = split . get ( 1 ) ; namespace = split . get ( 0 ) ; } String command = String . format ( " (ccw.debug.serverrepl/find-symbol \" %s \" \" %s \" \" %s \" ) " , symbol , declaringNamespace , namespace ) ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; if ( clojure = = null ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . You_need_a_running_repl ) ; return ; } PersistentArrayMap result2 = ( PersistentArrayMap ) clojure . remoteLoadRead ( command ) ; List < String > result = ( List < String > ) result2 . get ( " response " ) ; if ( result = = null | | result . isEmpty ( ) | | result2 . get ( " response-type " ) . equals ( - 1 ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Cannot_find_declaration ) ; return ; } String file = result . get ( 0 ) ; Integer line = Integer . valueOf ( result . get ( 1 ) ) ; String ns = result . get ( 3 ) ; ClojureCore . openInEditor ( ns , file , line ) ; } 
public void run ( ) { int caretOffset = editor . getUnSignedSelection ( editor . sourceViewer ( ) ) . getOffset ( ) ; TODO factorize with ClojureHyperlinkDetector concerning the retrieval of the symbol ... Tokens tokens = new Tokens(editor.getDocument(), caretOffset); tokens.tokenAtCaret(); String tokenContents = tokens.tokenContents(); Map<String, Object> decl = findDecl(tokenContents, editor); String file = (String) decl.get("file"); Integer line = (Integer) decl.get("line"); String ns = (String) decl.get("ns"); ClojureCore.openInEditor(ns, file, line); } 
public static Map < String , Object > findDecl ( String okenContents , AntlrBasedClojureEditor editor ) { List < String > split = Arrays . asList ( okenContents . split ( " / " ) ) ; String symbol = okenContents ; String declaringNamespace = editor . getDeclaringNamespace ( ) ; String namespace = null ; if ( split . size ( ) = = 2 ) { symbol = split . get ( 1 ) ; namespace = split . get ( 0 ) ; } String command = String . format ( " (ccw.debug.serverrepl/find-symbol \" %s \" \" %s \" \" %s \" ) " , symbol , declaringNamespace , namespace ) ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; if ( clojure = = null ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . You_need_a_running_repl ) ; return null ; } PersistentArrayMap result2 = ( PersistentArrayMap ) clojure . remoteLoadRead ( command ) ; List < String > result = ( List < String > ) result2 . get ( " response " ) ; if ( result = = null | | result . isEmpty ( ) | | result2 . get ( " response-type " ) . equals ( - 1 ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Cannot_find_declaration ) ; return null ; } Map < String , Object > r = new HashMap < String , Object > ( 3 ) ; r . put ( " file " , result . get ( 0 ) ) ; r . put ( " line " , ( Integer ) Integer . valueOf ( result . get ( 1 ) ) ) ; r . put ( " ns " , result . get ( 3 ) ) ; return r ; } 
public static IOConsole findActiveReplConsole ( boolean createOneIfNoneFound , IProject project , boolean activateAutoReload ) { IOConsole ioc = findActiveReplConsole ( ) ; if ( ioc ! = null ) { return ioc ; 
public static final void evaluateText ( final String ext , IProject project ) { IOConsole console = ClojureClient . findActiveReplConsole ( rue , project , false ) ; evaluateText ( console , ext ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( his ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new RunTestsAction ( his , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SwitchStructuralEditionModeAction", action);} 
public String getMainTypeName ( ILaunchConfiguration configuration ) throws CoreException { IJavaProject jProj = ClojureCore . getJavaProject ( LaunchUtils . getProject ( configuration ) ) ; try { if ( ( Boolean ) ClojureClient . invoke ( " ccw.ClojureProjectNature " , " has-path-on-classpath? " , jProj , " clojure/contrib/repl_ln.class " ) ) { 
public void run ( ) { String itle = " File Compiler and loader " ; String message = " The editor has pending changes. Clicking OK will save the changes and compile+load the file. " ; if ( ! EvaluateTextUtil . canProceed ( editor , itle , message ) ) return ; compileLoadFile ( ) ; } 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } IOConsole console = ClojureClient . findActiveReplConsole ( rue , editor . getProject ( ) , false ) ; EvaluateTextUtil . evaluateText ( console , compileLibCommand ( lib ) , rue ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static boolean canProceed ( IEditorPart editor , String itle , String message ) { if ( editor . isDirty ( ) ) { boolean saveAndCompileLoad = MessageDialog . openConfirm ( editor . getSite ( ) . getShell ( ) , itle , message ) ; 
public void run ( ) { String selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . rim ( ) . equals ( " " ) ) { selectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } IOConsole console = ClojureClient . findActiveReplConsole ( rue , editor . getProject ( ) , false ) ; EvaluateTextUtil . evaluateText ( console , selectedText , rue ) ; } 
public void run ( ) { String itle = " File Loader " ; String message = " The editor has pending changes. Clicking OK will save the changes and load the file. " ; if ( ! EvaluateTextUtil . canProceed ( editor , itle , message ) ) return ; loadFile ( ) ; } 
protected final void loadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String absoluteFilePath = editorFile . getLocation ( ) . oOSString ( ) ; String ext = " (clojure.core/load-file \" " + absoluteFilePath . replaceAll ( " \\ \\ " , " \\ \\ \\ \\ " ) . replaceAll ( " \" " , " \\ \\ \" " ) + " \" ) " ; IOConsole console = ClojureClient . findActiveReplConsole ( rue , editor . getProject ( ) , false ) ; EvaluateTextUtil . evaluateText ( console , ext , rue ) ; } 
public void run ( ) { String selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . rim ( ) . equals ( " " ) ) { selectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } IOConsole console = ClojureClient . findActiveReplConsole ( false , editor . getProject ( ) , false ) ; if ( console ! = null ) { EvaluateTextUtil . evaluateText ( console , selectedText , rue ) ; 
public void run ( ) { String selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . rim ( ) . equals ( " " ) ) { selectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } IOConsole console = ClojureClient . findActiveReplConsole ( rue , editor . getProject ( ) , false ) ; if ( console ! = null ) { EvaluateTextUtil . evaluateText ( console , selectedText , rue ) ; 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; startClojureCode ( context ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; startLaunchListener ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.RaiseSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; startClojureCode ( context ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplAntLogger " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplCreateProjectPage " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplCreationOperation " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplCreationWizard " ) ; } 
public final void mEscapeSequence ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:82:11: ( '\\\\' . ) 
public final void mUnicodeEscape ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:91:9: ( '\\\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT ) 
public final void mOctalEscape ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:97:9: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ) 
public final void mNAME ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:136:9: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:141:9: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:147:9: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public final void literal ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:154:9: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g: { if ( input.LA(1)==STRING||(input.LA(1)>=NUMBER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("213:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1461); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1471); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1481); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1491); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1501); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:219:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1511); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1538); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1548); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:225:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1560); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1589); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1613); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1641); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1674); pushFollow(FOLLOW_form_in_quoteForm1676); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1690); pushFollow(FOLLOW_form_in_metaForm1692); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1709); pushFollow(FOLLOW_form_in_derefForm1711); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1751); pushFollow(FOLLOW_form_in_syntaxQuoteForm1753); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1793); pushFollow(FOLLOW_form_in_unquoteForm1795); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1835); pushFollow(FOLLOW_form_in_unquoteSplicingForm1837); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1863); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1883); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1885); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("274:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:33: map { pushFollow(FOLLOW_map_in_metadataForm1888); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1892); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1894); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1896); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1917); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1919); pushFollow(FOLLOW_form_in_varQuoteForm1921); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1948); pushFollow(FOLLOW_list_in_lambdaForm1950); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public void mTokens ( ) hrows RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | REGEX_LITERAL | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt31=29; alt31 = dfa31.predict(input); switch (alt31) { case 1 : 
public final void file ( ) hrows RecognitionException { ry { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("213:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1475); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1485); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1495); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1505); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1515); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:219:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1525); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1552); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1562); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:225:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1574); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) hrows RecognitionException { Token o = null ; Token c = null ; ry { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1603); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) hrows RecognitionException { ry { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1627); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) hrows RecognitionException { ry { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1655); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1688); pushFollow(FOLLOW_form_in_quoteForm1690); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1704); pushFollow(FOLLOW_form_in_metaForm1706); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1723); pushFollow(FOLLOW_form_in_derefForm1725); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth + + ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1765); pushFollow(FOLLOW_form_in_syntaxQuoteForm1767); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1807); pushFollow(FOLLOW_form_in_unquoteForm1809); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) hrows RecognitionException { his . syntaxQuoteDepth - - ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1849); pushFollow(FOLLOW_form_in_unquoteSplicingForm1851); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) hrows RecognitionException { ry { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1877); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1897); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1899); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("274:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:33: map { pushFollow(FOLLOW_map_in_metadataForm1902); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1906); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1908); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1910); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) hrows RecognitionException { ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1931); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1933); pushFollow(FOLLOW_form_in_varQuoteForm1935); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) hrows RecognitionException { his . inLambda = rue ; ry { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1962); pushFollow(FOLLOW_list_in_lambdaForm1964); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; } 
private void loadPluginClojureCode ( ) hrows Exception { URL clientReplBundleUrl = CCWPlugin . getDefault ( ) . getBundle ( ) . getResource ( " ccw/debug/clientrepl.clj " ) ; URL clientReplFileUrl = FileLocator . oFileURL ( clientReplBundleUrl ) ; String clientRepl = clientReplFileUrl . getFile ( ) ; Compiler . loadFile ( clientRepl ) ; ry { Var . find ( Symbol . intern ( " clojure.core/require " ) ) . invoke ( Symbol . intern ( " cemerick.nrepl " ) ) ; 
public void stop ( BundleContext context ) hrows Exception { disposeParenRainbowColors ( ) ; We also don't remove fonts when deregistered plugin = null; super.stop(context); } 
public Connection getProjectREPLConnection ( IProject project ) { REPLView repl = getProjectREPL ( project ) ; return repl = = null ? null : repl . getToolingConnection ( ) ; } 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { try { REPLView replView = REPLView . activeREPL . get ( ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { return REPLView . connect ( ) ; 
public void removeHandlerListener ( IHandlerListener handlerListener ) { } public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } } 
public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } } 
public void visit ( Map < IFolder , IFolder > srcFolders ) hrows CoreException { this . srcFolders = new HashMap < IFolder , IFolder > ( srcFolders ) ; for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { setSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( his ) ; } if ( repl ! = null ) { ry { 
private static Object invokeLocalClojureVarWith ( Var varToInvoke , String code ) { ry { return varToInvoke . invoke ( code ) ; 
public static Object loadString ( String localCode ) { return invokeLocalClojureVarWith ( loadString , localCode ) ; } 
public boolean isStructuralEditingEnabled ( ) { } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public boolean isInEscapeSequence ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . isInEscapeSequence ( ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } } 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) return false ; IRegion selection = getSignedSelection ( ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { setStatusLineErrorMessage ( errorMessageIfProblem ) ; getSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return false ; } return rue ; } 
public IRegion getUnSignedSelection ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . getUnSignedSelection ( ) ; } 
public IRegion getSignedSelection ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . getSignedSelection ( ) ; } 
public IJavaProject getAssociatedProject ( ) { return JavaCore . create ( ( ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ) . getProject ( ) ) ; } 
public String getDeclaringNamespace ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . getDeclaringNamespace ( ) ; } 
public REPLView getCorrespondingREPL ( ) { IFile file = ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( file ! = null ) return CCWPlugin . getDefault ( ) . getProjectREPL ( file . getProject ( ) ) ; 
public void updateTabsToSpacesConverter ( ) { if ( isTabsToSpacesConversionEnabled ( ) ) { installTabsToSpacesConverter ( ) ; 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { return new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { return new ClassLazyCompletionProposal ( ( IType ) match . getElement ( ) , 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { return new PackageLazyCompletionProposal ( ( IPackageFragment ) match . getElement ( ) , 
private static List < List > dynamicComplete ( String namespace , String prefix , IClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { return Collections . emptyList ( ) ; } if ( prefix = = null ) { return Collections . emptyList ( ) ; } Connection repl = editor . getCorrespondingREPL ( ) . getToolingConnection ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Map result = ( Map ) repl . send ( " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) . values ( ) . get ( 0 ) ; if ( result = = null ) return Collections . emptyList ( ) ; if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { return Collections . emptyList ( ) ; } Connection repl = editor . getCorrespondingREPL ( ) . getToolingConnection ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Map result = ( Map ) repl . send ( " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) . values ( ) . get ( 0 ) ; if ( result = = null ) return Collections . emptyList ( ) ; if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public void keyPressed ( KeyEvent e ) { if ( e . character = = SWT . ESC ) { inEscapeSequence = rue ; 
public void keyReleased ( KeyEvent e ) { if ( inEscapeSequence & & ! ( e . character = = SWT . ESC ) ) { inEscapeSequence = false ; 
public void inputDocumentChanged ( IDocument oldInput , IDocument newInput ) { if ( newInput ! = null ) { newInput . addDocumentListener ( parseTreeConstructorDocumentListener ) ; 
public void inputDocumentAboutToBeChanged ( IDocument oldInput , IDocument newInput ) { if ( oldInput ! = null ) oldInput . removeDocumentListener ( parseTreeConstructorDocumentListener ) ; 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { fForegroundColor . dispose ( ) ; fForegroundColor = null ; } if ( fBackgroundColor ! = null ) { fBackgroundColor . dispose ( ) ; fBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { fSelectionForegroundColor . dispose ( ) ; fSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { fSelectionBackgroundColor . dispose ( ) ; fSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( his ) ; super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public void documentChanged ( DocumentEvent event ) { updateParseRef ( event . getDocument ( ) . get ( ) ) ; } 
private void updateParseRef ( String ext ) { parseRef = EditorSupport . updateParseRef ( ext , parseRef ) ; } 
public Object getParsed ( ) { if ( parseRef = = null ) { updateParseRef ( getDocument ( ) . get ( ) ) ; } return EditorSupport . getParser ( getDocument ( ) . get ( ) , parseRef ) ; } 
public IRegion getUnSignedSelection ( ) { StyledText ext = getTextWidget ( ) ; Point selection = ext . getSelectionRange ( ) ; selection . x = widgetOffset2ModelOffset ( selection . x ) ; return new Region ( selection . x , selection . y ) ; } 
public void selectAndReveal ( int start , int length ) { setSelection ( new TextSelection ( start , length ) , rue ) ; } 
public REPLView getCorrespondingREPL ( ) { this gets overridden in REPLView as appropriate so that the toolConnection there gets returned return null; } 
public void setStructuralEditingPossible ( boolean possible ) { } public void updateTabsToSpacesConverter ( ) { } } 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } EvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , rue ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static String compileLibCommand ( String libName ) { return " (ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \" classes \" ] (clojure.core/compile ' " + libName + " ))) " ; } 
public static final void evaluateText ( final String ext , boolean verbose ) { evaluateText ( REPLView . activeREPL . get ( ) , ext , verbose ) ; } 
public static final void evaluateText ( REPLView console , final String ext , boolean verbose ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
public void run ( ) { String selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . rim ( ) . equals ( " " ) ) { selectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { EvaluateTextUtil . evaluateText ( repl , selectedText , rue ) ; 
private void replaceOriginalWithFormatted ( IDocument original , ISourceViewer sourceViewer , String formatted ) { IRegion selection = editor . getSignedSelection ( ) ; Tokens okens = new Tokens ( original , selection ) ; Document formattedDocument = new Document ( formatted ) ; Tokens formattedTokens = new Tokens ( formattedDocument ) ; int argetOffset = formattedTokens . sameStructuralOffset ( okens ) ; original . set ( formatted ) ; sourceViewer . setSelectedRange ( argetOffset , 0 ) ; sourceViewer . revealRange ( argetOffset , 0 ) ; } 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isInEscapeSequence ( ) ; @todo -- what does "unsigned"/"signed" mean in this context? public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IJavaProject getAssociatedProject ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public void run ( ) { int caretOffset = editor . getUnSignedSelection ( ) . getOffset ( ) ; Tokens okens = new Tokens ( editor . getDocument ( ) , caretOffset ) ; okens . okenAtCaret ( ) ; String okenContents = okens . okenContents ( ) ; List < String > split = Arrays . asList ( okenContents . split ( " / " ) ) ; String symbol = okenContents ; String declaringNamespace = editor . getDeclaringNamespace ( ) ; String namespace = null ; if ( split . size ( ) = = 2 ) { symbol = split . get ( 1 ) ; namespace = split . get ( 0 ) ; } String command = String . format ( " (ccw.debug.serverrepl/find-symbol \" %s \" \" %s \" \" %s \" ) " , symbol , declaringNamespace , namespace ) ; TODO this isn't right, we should be using a REPL specifically for the project where the file is located REPLView replView = REPLView.activeREPL.get(); if (replView == null || replView.isDisposed()) { editor.setStatusLineErrorMessage(ClojureEditorMessages.You_need_a_running_repl); return; } Connection repl = replView.getToolingConnection(); List values = repl.send(command).values(); if (values.isEmpty()) { editor.setStatusLineErrorMessage(ClojureEditorMessages.Cannot_find_declaration); 
public void run ( ) { ry { String lib = editor . getDeclaringNamespace ( ) ; 
private void runTests ( String lib , Connection repl ) hrows Exception { Response results = repl . send ( runTestsCommand ( lib ) ) ; if ( ( ( String ) results . combinedResponse ( ) . get ( Keyword . intern ( " out " ) ) ) . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
public static IDocument configure ( IDocument document ) { IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; return document ; } 
protected IDocument createDocument ( Object element ) hrows CoreException { IDocument document = super . createDocument ( element ) ; if ( document ! = null ) document = configure ( document ) ; return document ; } 
public void consolesRemoved ( IConsole [ ] consoles ) { } public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } } ) ; } private class REPLViewLaunchMonitor extends ProgressMonitorWrapper { private ILaunch launch ; private REPLViewLaunchMonitor ( IProgressMonitor m , ILaunch launch ) { super ( m ) ; his . launch = launch ; } public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " cemerick.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { ry { REPLView replView = REPLView . connect ( " localhost " , port ) ; if ( replView ! = null ) { replView . setConsole ( lastConsoleOpened ) ; replView . setLaunch ( launch ) ; } } catch ( Exception e ) { CCWPlugin . logError ( " Could not connect REPL to local launch " , e ) ; } } } ) ; } } @Override public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " cemerick.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; super . launch ( configuration , mode , launch , ( monitor = = null | | ! isLaunchREPL ( configuration ) ) ? monitor : new REPLViewLaunchMonitor ( monitor , launch ) ) ; } finally { Var . popThreadBindings ( ) ; } } @Override public String getVMArguments ( ILaunchConfiguration configuration ) hrows CoreException { String launchId = UUID . randomUUID ( ) . oString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , launchId , super . getVMArguments ( configuration ) ) ; } @Override public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; @Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException { List<String> classpath = new ArrayList<String>(Arrays.asList(super.getClasspath(configuration))); ClojureProject clojureProject = ClojureCore.getClojureProject(LaunchUtils.getProject(configuration)); for (IFolder f: clojureProject.sourceFolders()) { String sourcePath = f.getLocation().toOSString(); while (classpath.contains(sourcePath)) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("nrepl-module")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); }} 
public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } 
public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " cemerick.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { ry { REPLView replView = REPLView . connect ( " localhost " , port ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " cemerick.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public String getVMArguments ( ILaunchConfiguration configuration ) hrows CoreException { String launchId = UUID . randomUUID ( ) . oString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; 
private static boolean isLaunchREPL ( ILaunchConfiguration configuration ) hrows CoreException { return configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ; } 
public static boolean isAutoReloadEnabled ( ILaunch launch ) { return Boolean . valueOf ( launch . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED ) ) ; } 
public String getMainTypeName ( ILaunchConfiguration configuration ) throws CoreException { String main = configuration . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_MAIN_TYPE_NAME , ( String ) null ) ; return main = = null ? clojure . main . class . getName ( ) : main ; } 
public String [ ] getClasspath ( ILaunchConfiguration configuration ) hrows CoreException { List < String > classpath = new ArrayList < String > ( Arrays . asList ( super . getClasspath ( configuration ) ) ) ; ClojureProject clojureProject = ClojureCore . getClojureProject ( LaunchUtils . getProject ( configuration ) ) ; for ( IFolder f : clojureProject . sourceFolders ( ) ) { String sourcePath = f . getLocation ( ) . oOSString ( ) ; while ( classpath . contains ( sourcePath ) ) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("nrepl-module")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_CONFIG_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
private void createReplServerControl ( final Composite parent ) { Group section = SWTFactory . createGroup ( parent , " Repl settings " , 2 , 1 , 0 ) ; installREPLChoice = SWTFactory . createCheckButton ( section , " Run with REPL (see tooltip for detail) " , null , rue , 2 ) ; installREPLChoice . setToolTipText ( " If checked, all files listed will be loaded with the -i option, " + " and a new REPL view will be opened and connected to the new process. " + " If unchecked, all files listed will be loaded with the -i option, " + " except for the last which will be loaded as a script. " ) ; installREPLChoice . addSelectionListener ( new SelectionListener ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { } 
public void widgetSelected ( SelectionEvent e ) { updateLaunchConfigurationDialog ( ) ; } 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . rim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } ry { installREPLChoice . setSelection ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ) ; } catch ( CoreException e ) { CCWPlugin . logError ( " error while initializing serverPort " , e ) ; installREPLChoice . setSelection ( rue ) ; } ry { sourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . rim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; config . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; Overriden at launch time, set here just to make JavaMainTab happy config.setAttribute(LaunchUtils.ATTR_CLOJURE_START_REPL, installREPLChoice.getSelection()); mapResources(config); } 
private Map < String , List < String > > getRemoteNsTree ( Connection repl ) { try { Response res = repl . send ( " (ccw.debug.serverrepl/namespaces-info) " ) ; 
public static void setREPLConnection ( final Connection repl ) { if ( repl ! = null ) DisplayUtil . asyncExec ( new Runnable ( ) { 
 public void run ( ) { inUIThreadSetREPLConnection ( repl ) ; } } ) ; 
private static void inUIThreadSetREPLConnection ( Connection repl ) { IViewPart [ ] views = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getViews ( ) ; NamespaceBrowser co = null ; for ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { co = ( NamespaceBrowser ) v ; break ; } } if ( co = = null ) { return ; } co . reset ( repl ) ; } 
protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; newShell . setText ( " Connect to REPL " ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " " ) ; don't know much about swt layouts yet :-( hosts.setFocus(); hosts.setSelection(new Point(0, hosts.getText().length())); new Label(parent, 0).setText("Port"); port = new Text(parent, SWT.BORDER); port.addKeyListener(new KeyListener() { public void keyReleased(KeyEvent e) { } public void keyPressed(KeyEvent e) { e.doit = Character.isDigit(e.character); } }); return composite; } 
public void keyReleased ( KeyEvent e ) { } public void keyPressed ( KeyEvent e ) { e . doit = Character . isDigit ( e . character ) ; } } ) ; return composite ; } protected void okPressed ( ) { host = hosts . getText ( ) ; ry { portNumber = Integer . parseInt ( port . getText ( ) ) ; } catch ( NumberFormatException e ) { shouldn't happen given the keylistener above } super.okPressed(); } public String getHost () { return host; } public int getPort () { return portNumber; }} 
public void keyPressed ( KeyEvent e ) { e . doit = Character . isDigit ( e . character ) ; } 
protected void okPressed ( ) { host = hosts . getText ( ) ; ry { portNumber = Integer . parseInt ( port . getText ( ) ) ; } catch ( NumberFormatException e ) { shouldn't happen given the keylistener above } super.okPressed(); } 
private void copyToLog ( StyledText s ) { int start = logPanel . getCharCount ( ) ; ry { log . invoke ( logPanel , s . getText ( ) , null ) ; 
private void evalExpression ( ) { evalExpression ( viewerWidget . getText ( ) , false ) ; copyToLog ( viewerWidget ) ; viewerWidget . setText ( " " ) ; } 
public void evalExpression ( String s ) { TODO add highlighting of evaluated code pushed from editors evalExpression(s, true); } 
public void evalExpression ( String s , boolean copyToLog ) { ry { if ( s . rim ( ) . length ( ) > 0 ) { 
public void closeView ( ) hrows Exception { IWorkbenchPage page = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; page . hideView ( his ) ; closeConnections ( ) ; } 
public void closeConnections ( ) hrows Exception { if ( interactive ! = null ) interactive . close ( ) ; if ( oolConnection ! = null ) oolConnection . close ( ) ; } 
public void reconnect ( ) hrows Exception { closeConnections ( ) ; configure ( interactive . host , interactive . port ) ; } 
public void setCurrentNamespace ( String ns ) { TODO waaaay better to put a dropdown namespace chooser in the view's toolbar, and this would just change its selection setPartName(String.format("REPL @ %s:%s (%s)", interactive.host, interactive.port, ns)); } 
public boolean configure ( String host , int port ) hrows Exception { ry { interactive = new Connection ( host , port ) ; 
public static REPLView connect ( ) hrows Exception { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; ConnectDialog dlg = new ConnectDialog ( window . getShell ( ) ) ; REPLView repl = null ; if ( dlg . open ( ) = = ConnectDialog . OK ) { cannot find any way to create a configured/connected REPLView, and install it programmatically String host = dlg.getHost(); int port = dlg.getPort(); if (host == null || host.length() == 0 || port < 0 || port > 65535) { MessageDialog.openInformation(window.getShell(), "Invalid connection info", "You must provide a useful hostname and port number to connect to a REPL."); } else { repl = connect(host, port); } } return repl; } 
public static REPLView connect ( String host , int port ) hrows Exception { REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , host + " @ " + port , IWorkbenchPage . VIEW_ACTIVATE ) ; return repl . configure ( host , port ) ? repl : null ; } 
public Connection getToolingConnection ( ) { return oolConnection ; } 
public void setConsole ( IConsole console ) { his . console = console ; } 
public void showConsole ( ) { if ( console ! = null ) ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( console ) ; } 
public void createPartControl ( Composite parent ) { IPreferenceStore prefs = CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) ; SashForm split = new SashForm ( parent , SWT . VERTICAL ) ; logPanel = new StyledText ( split , SWT . V_SCROLL | SWT . WRAP ) ; logPanel . setWrapIndent ( 4 ) ; logPanel . setEditable ( false ) ; logPanel . setFont ( JFaceResources . getFont ( JFaceResources . TEXT_FONT ) ) ; viewer = new ClojureSourceViewer ( split , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL , prefs ) { public Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } }; viewerConfig = new ClojureSourceViewerConfiguration(prefs, viewer); viewer.configure(viewerConfig); getViewSite().setSelectionProvider(viewer); viewer.setDocument(ClojureDocumentProvider.configure(new Document())); viewerWidget = viewer.getTextWidget(); viewerWidget.setFont(JFaceResources.getFont(JFaceResources.TEXT_FONT)); viewerWidget.addVerifyKeyListener(new REPLInputVerifier()); split.setWeights(new int[] {80, 20}); viewer.propertyChange(null); viewerWidget.addFocusListener(new NamespaceRefreshFocusListener()); logPanel.addFocusListener(new NamespaceRefreshFocusListener()); parent.addDisposeListener(new DisposeListener () { public void widgetDisposed(DisposeEvent e) { 
public Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } 
public void widgetDisposed ( DisposeEvent e ) { activeREPL . compareAndSet ( REPLView . his , null ) ; } 
public void dispose ( ) { super . dispose ( ) ; interactive . close ( ) ; oolConnection . close ( ) ; } 
public boolean isDisposed ( ) { TODO we actually want to report whether the viewpart has been closed, not whether or not the platform has disposed the widget peer return viewerWidget.isDisposed(); } 
public void focusGained ( FocusEvent e ) { activeREPL . set ( REPLView . his ) ; NamespaceBrowser . setREPLConnection ( oolConnection ) ; } 
public void focusLost ( FocusEvent e ) { } } private class REPLInputVerifier implements VerifyKeyListener { private boolean isEvalEvent ( KeyEvent e ) { if ( e . stateMask = = SWT . SHIFT ) return false ; if ( e . keyCode = = '' | | e . keyCode = = '\r' ) { return e . stateMask = = SWT . CONTROL | | viewerWidget . getSelection ( ) . x = = viewerWidget . getCharCount ( ) ; } return false ; } public void verifyKey ( VerifyEvent e ) { if ( isEvalEvent ( e ) ) { evalExpression ( ) ; e . doit = false ; } } } } 
private boolean isEvalEvent ( KeyEvent e ) { if ( e . stateMask = = SWT . SHIFT ) return false ; if ( e . keyCode = = '' | | e . keyCode = = '\r' ) { return e . stateMask = = SWT . CONTROL | | viewerWidget . getSelection ( ) . x = = viewerWidget . getCharCount ( ) ; } return false ; } 
public void verifyKey ( VerifyEvent e ) { if ( isEvalEvent ( e ) ) { evalExpression ( ) ; 
public void run ( IAction action ) { ry { repl . reconnect ( ) ; 
public void selectionChanged ( IAction action , ISelection selection ) { } public void init ( IViewPart view ) { repl = ( REPLView ) view ; } public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } public Object execute ( ExecutionEvent event ) hrows ExecutionException { return null ; } public boolean isEnabled ( ) { return rue ; } public boolean isHandled ( ) { return rue ; } public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } public Object execute ( ExecutionEvent event ) hrows ExecutionException { return null ; } public boolean isEnabled ( ) { return rue ; } public boolean isHandled ( ) { return rue ; } public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public void dispose ( ) { } public Object execute ( ExecutionEvent event ) hrows ExecutionException { return null ; } public boolean isEnabled ( ) { return rue ; } public boolean isHandled ( ) { return rue ; } public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { return null ; } 
public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public void createPartControl ( Composite parent ) { IPreferenceStore prefs = CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) ; SashForm split = new SashForm ( parent , SWT . VERTICAL ) ; logPanel = new StyledText ( split , SWT . V_SCROLL | SWT . WRAP ) ; logPanel . setIndent ( 4 ) ; logPanel . setEditable ( false ) ; logPanel . setFont ( JFaceResources . getFont ( JFaceResources . TEXT_FONT ) ) ; viewer = new ClojureSourceViewer ( split , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL , prefs ) { public Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } }; viewerConfig = new ClojureSourceViewerConfiguration(prefs, viewer); viewer.configure(viewerConfig); getViewSite().setSelectionProvider(viewer); viewer.setDocument(ClojureDocumentProvider.configure(new Document())); viewerWidget = viewer.getTextWidget(); viewerWidget.setFont(JFaceResources.getFont(JFaceResources.TEXT_FONT)); viewerWidget.addVerifyKeyListener(new REPLInputVerifier()); split.setWeights(new int[] {80, 20}); viewer.propertyChange(null); viewerWidget.addFocusListener(new NamespaceRefreshFocusListener()); logPanel.addFocusListener(new NamespaceRefreshFocusListener()); parent.addDisposeListener(new DisposeListener () { public void widgetDisposed(DisposeEvent e) { 
public final ClojureSourceViewer sourceViewer ( ) { return ( ClojureSourceViewer ) super . getSourceViewer ( ) ; } 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isInEscapeSequence ( ) ; @todo -- what does "unsigned"/"signed" mean in this context? public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IJavaProject getAssociatedProject ( ) ; public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public static void gotoEditorLine ( Object editor , int line ) { if ( ITextEditor . class . isInstance ( editor ) ) { ITextEditor extEditor = ( ITextEditor ) editor ; 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isInEscapeSequence ( ) ; public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IJavaProject getAssociatedProject ( ) ; public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public void setCurrentNamespace ( String ns ) { his.currentNamespaceName = ns; setPartName(String.format("REPL @ %s:%s (%s)", interactive.host, interactive.port, currentNamespaceName)); } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; startClojureCode ( context ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.RaiseSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; ClojureOSGi . require ( bundleContext , " ccw.repl.view-helpers " ) ; } 
public void consolesRemoved ( IConsole [ ] consoles ) { } public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } } ) ; } private class REPLViewLaunchMonitor extends ProgressMonitorWrapper { private ILaunch launch ; private REPLViewLaunchMonitor ( IProgressMonitor m , ILaunch launch ) { super ( m ) ; his . launch = launch ; } public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { ry { REPLView replView = REPLView . connect ( " localhost " , port ) ; if ( replView ! = null ) { replView . setConsole ( lastConsoleOpened ) ; replView . setLaunch ( launch ) ; } } catch ( Exception e ) { CCWPlugin . logError ( " Could not connect REPL to local launch " , e ) ; } } } ) ; } } @Override public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " clojure.tools.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; super . launch ( configuration , mode , launch , ( monitor = = null | | ! isLaunchREPL ( configuration ) ) ? monitor : new REPLViewLaunchMonitor ( monitor , launch ) ) ; } finally { Var . popThreadBindings ( ) ; } } @Override public String getVMArguments ( ILaunchConfiguration configuration ) hrows CoreException { String launchId = UUID . randomUUID ( ) . oString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , launchId , super . getVMArguments ( configuration ) ) ; } @Override public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; @Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException { List<String> classpath = new ArrayList<String>(Arrays.asList(super.getClasspath(configuration))); ClojureProject clojureProject = ClojureCore.getClojureProject(LaunchUtils.getProject(configuration)); for (IFolder f: clojureProject.sourceFolders()) { String sourcePath = f.getLocation().toOSString(); while (classpath.contains(sourcePath)) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("org.clojure.tools.nrepl")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); }} 
public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " clojure.tools.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public String [ ] getClasspath ( ILaunchConfiguration configuration ) hrows CoreException { List < String > classpath = new ArrayList < String > ( Arrays . asList ( super . getClasspath ( configuration ) ) ) ; ClojureProject clojureProject = ClojureCore . getClojureProject ( LaunchUtils . getProject ( configuration ) ) ; for ( IFolder f : clojureProject . sourceFolders ( ) ) { String sourcePath = f . getLocation ( ) . oOSString ( ) ; while ( classpath . contains ( sourcePath ) ) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("org.clojure.tools.nrepl")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); } 
public void handleEvent ( Event e ) { this prevents focus switch on cut/copy no event that would trigger a paste is sent as long as logPanel is uneditable, so we can't redirect it :-( boolean modifier = (e.keyCode & SWT.MODIFIER_MASK) != 0; if (modifier) return; viewerWidget.notifyListeners(SWT.KeyDown, e); viewerWidget.setFocus(); } 
public static void log ( String msg ) { plugin . getLog ( ) . log ( new Status ( IStatus . INFO , PLUGIN_ID , msg ) ) ; } 
public static IProject getProject ( ILaunchConfiguration configuration ) hrows CoreException { return getProject ( configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; } 
public static IProject getProject ( ILaunch launch ) hrows CoreException { return getProject ( getProjectName ( launch ) ) ; } 
public static String getProjectName ( ILaunch launch ) { return launch . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME ) ; } 
public static IProject getProject ( String projectName ) { here fundamentally to simplify things for repl cmd history return projectName == null ? null : ResourcesPlugin.getWorkspace().getRoot().getProject(projectName); } 
private void prepareView ( ) hrows Exception { evalExpression = ( IFn ) configureREPLView . invoke ( his , logPanel , interactive . conn , requests ) ; } 
public void consolesRemoved ( IConsole [ ] consoles ) { } public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } } ) ; } private class REPLViewLaunchMonitor extends ProgressMonitorWrapper { private ILaunch launch ; private REPLViewLaunchMonitor ( IProgressMonitor m , ILaunch launch ) { super ( m ) ; his . launch = launch ; } public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { ry { REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; } catch ( Exception e ) { CCWPlugin . logError ( " Could not connect REPL to local launch " , e ) ; } } } ) ; } } @Override public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " clojure.tools.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; super . launch ( configuration , mode , launch , ( monitor = = null | | ! isLaunchREPL ( configuration ) ) ? monitor : new REPLViewLaunchMonitor ( monitor , launch ) ) ; } finally { Var . popThreadBindings ( ) ; } } @Override public String getVMArguments ( ILaunchConfiguration configuration ) hrows CoreException { String launchId = UUID . randomUUID ( ) . oString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , launchId , super . getVMArguments ( configuration ) ) ; } @Override public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; @Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException { List<String> classpath = new ArrayList<String>(Arrays.asList(super.getClasspath(configuration))); ClojureProject clojureProject = ClojureCore.getClojureProject(LaunchUtils.getProject(configuration)); for (IFolder f: clojureProject.sourceFolders()) { String sourcePath = f.getLocation().toOSString(); while (classpath.contains(sourcePath)) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("org.clojure.tools.nrepl")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); }} 
public void run ( ) { ry { REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; 
public static REPLView connect ( String host , int port ) hrows Exception { return connect ( host , port , null , null ) ; } 
public static REPLView connect ( String host , int port , IConsole console , ILaunch launch ) hrows Exception { REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , host + " @ " + port , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . console = console ; repl . launch = launch ; return repl . configure ( host , port ) ? repl : null ; } 
public void reconnect ( ) hrows Exception { closeConnections ( ) ; logPanel . append ( " ;; Reconnecting... " ) ; configure ( interactive . host , interactive . port ) ; } 
public void run ( ) { colorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; colorRegistry . put ( " ccw.repl.expressionBackground " , new RGB ( 0xf0 , 0xf0 , 0xf0 ) ) ; } } ) ; 
private void copyToLog ( StyledText s ) { int start = logPanel . getCharCount ( ) ; int lineCnt = logPanel . getLineCount ( ) ; ry { log . invoke ( logPanel , s . getText ( ) , null ) ; 
public void evalExpression ( String s ) { evalExpression ( s , rue ) ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { return REPLView . connect ( ) ; 
public void run ( IAction action ) { repl . logPanel . setText ( " " ) ; } 
public void run ( IAction action ) { ry { repl . reconnect ( ) ; 
public void run ( IAction action ) { ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( repl . getConsole ( ) ) ; } 
public boolean isEnabled ( ) { return repl . getConsole ( ) ! = null ; } 
public void selectionChanged ( IAction action , ISelection selection ) { } public void init ( IViewPart view ) { repl = ( REPLView ) view ; } public Object execute ( ExecutionEvent event ) hrows ExecutionException { return null ; } } } 
public void init ( IViewPart view ) { repl = ( REPLView ) view ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { return null ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { return REPLView . connect ( ) ; 
private void copyToLog ( StyledText s ) { int start = logPanel . getCharCount ( ) ; ry { log . invoke ( logPanel , s . getText ( ) , inputExprLogType ) ; 
public void setCurrentNamespace ( String ns ) { currentNamespace = ns; setPartName(String.format("REPL @ %s:%s (%s)", interactive.host, interactive.port, currentNamespace)); } 
private int incTempLaunchCount ( String projectName ) { synchronized ( empLaunchCounters ) { Integer cnt = empLaunchCounters . get ( projectName ) ; 
public void handleEvent ( Event e ) { if ( ! ( e . keyCode = = SWT . PAGE_DOWN | | e . keyCode = = SWT . PAGE_UP ) ) { this prevents focus switch on cut/copy 
public void handleEvent ( Event e ) { switch ( e . keyCode ) { case SWT . PAGE_DOWN : 
public static final void evaluateText ( final String ext , boolean userInput ) { evaluateText ( REPLView . activeREPL . get ( ) , ext , userInput ) ; } 
public static final void evaluateText ( REPLView console , final String ext , boolean userInput ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
private void evalExpression ( ) { evalExpression ( viewerWidget . getText ( ) , rue , false ) ; copyToLog ( viewerWidget ) ; viewerWidget . setText ( " " ) ; } 
public void evalExpression ( String s ) { evalExpression ( s , rue , rue ) ; } 
public void evalExpression ( String s , boolean userInput , boolean logExpression ) { ry { if ( s . rim ( ) . length ( ) > 0 ) { 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void run ( ) { REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl = = null | | repl . isDisposed ( ) ) { return ; } String ns = editor . getDeclaringNamespace ( ) ; if ( ns = = null ) { put error msg in footer instead 
public void run ( IAction action ) { repl . printErrorDetail ( ) ; } 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (clojure.tools.nrepl/*print-error-detail* *e)) " , false , false ) ; } 
public void verifyKey ( VerifyEvent e ) { TODO I desperately want this to be a proper, reconfigurable keybinding, but doing so looks like a PITA: http:www.eclipsezone.com/eclipse/forums/t69603.html http:dev.eclipse.org/newslists/news.eclipse.platform/msg60894.html http:wiki.eclipse.org/index.php/Platform_Command_Framework if (e.stateMask == SWT.CTRL && e.keyCode == 'j') { printErrorDetail(); 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { if ( execute ( rue ) ) return null ; MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getDisplay ( ) . getActiveShell ( ) , " No Active REPL " , " No REPL is active. Click in an existing REPL to make it the active target, or open a new REPL. " ) ; return null ; } 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (if-not *e (println \" No prior exception bound to *e. \" ) (clojure.tools.nrepl/*print-error-detail* *e))) " , false , false ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , IClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { return Collections . emptyList ( ) ; } if ( prefix = = null ) { return Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Connection connection = repl . getToolingConnection ( ) ; Response response = connection . send ( " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) ; return ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { return Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Connection connection = repl . getToolingConnection ( ) ; Response response = connection . send ( " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; return ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private static Object extractSingleValue ( Response response , Object defaultValueIfNil ) { Object r = response . values ( ) . get ( 0 ) ; if ( r = = null ) { return defaultValueIfNil ; 
public void run ( ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; 
public void done ( ) { super . done ( ) ; new Thread ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
 public void done ( ) { connectRepl ( ) ; } 
 private void connectRepl ( ) { ry { REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; 
private void updateParseRef ( String ext ) { boolean firstTime = ( parseRef = = null ) ; parseRef = EditorSupport . updateParseRef ( ext , parseRef ) ; if ( firstTime ) { EditorSupport . startWatchParseRef ( parseRef , his ) ; 
private void syncWithStructuralEditionPossibleState ( ) { DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { getTextWidget ( ) . setBackground ( structuralEditionPossible ? null : Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_GRAY ) ) ; getTextWidget ( ) . setToolTipText ( structuralEditionPossible ? null : " Unparseable source code. Structural Edition temporarily disabled. " ) ; } 
public void updateTabsToSpacesConverter ( ) { } } }} 
public void setDocument ( IDocument document , IAnnotationModel annotationModel , int modelRangeOffset , int modelRangeLength ) { super . setDocument ( document , annotationModel , modelRangeOffset , modelRangeLength ) ; if ( document ! = null ) { updateParseRef ( document . get ( ) ) ; 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isInEscapeSequence ( ) ; public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IJavaProject getAssociatedProject ( ) ; public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { IClojureEditor . KEY_BINDING_SCOPE } ) ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);} 
boolean isInEscapeSequence ( ) ; void setStatusLineErrorMessage(String you_need_a_running_repl);} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
IRegion getSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
String getDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { IWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; if ( ! ( part instanceof REPLView ) ) { return null ; } REPLView repl = ( REPLView ) part ; repl . printErrorDetail ( ) ; return null ; } 
public void verifyKey ( VerifyEvent e ) { if (e.stateMask == SWT.CTRL && e.keyCode == 'k') { logPanel.setText(""); 
public static IStatus createErrorStatus ( String message , Throwable e ) { return new Status ( IStatus . ERROR , PLUGIN_ID , message , e ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( repl . getConsole ( ) ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { repl . logPanel . setText ( " " ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { ry { repl . reconnect ( ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { repl . printErrorDetail ( ) ; } 
public final Object execute ( ExecutionEvent event ) hrows ExecutionException { IWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; if ( ! ( part instanceof REPLView ) ) { return null ; } doExecute ( event , ( REPLView ) part ) ; return null ; } 
protected abstract void doExecute ( ExecutionEvent event , REPLView part ) hrows ExecutionException ; } } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { support . setCharacterPairMatcher ( viewer . getPairsMatcher ( ) ) ; support . setMatchingCharacterPainterPreferenceKeys ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR ) ; super . configureSourceViewerDecorationSupport ( support ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void contributeToMenu ( IMenuManager menu ) { super . contributeToMenu ( menu ) ; 
public void gotoMatchingBracket ( ) { IDocument document = getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ; getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { IWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; IClojureEditor clojureEditor = ( IClojureEditor ) PlatformUtil . getAdapter ( part , IClojureEditor . class ) ; if ( clojureEditor = = null ) { CCWPlugin . logWarning ( " Handler " + OpenDeclarationHandler . class . getSimpleName ( ) + " executed on a IWorkbenchPart (id: " + part . getSite ( ) . getId ( ) + " ) which is not able to adapt to " + IClojureEditor . class . getSimpleName ( ) ) ; return null ; } clojureEditor . gotoMatchingBracket ( ) ; return null ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isInEscapeSequence ( ) ; DefaultCharacterPairMatcher getPairsMatcher();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
IRegion getSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
String getDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.RaiseSelectionHandler " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; ClojureOSGi . require ( bundleContext , " ccw.editors.antlrbased.handlers " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
public Object create ( ) hrows CoreException { return new ClojureHandlerProxy ( handlerFn ) ; } 
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) hrows CoreException { assert data instanceof String ; handlerFn = ( String ) data ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { try { execute . invoke ( his , event ) ; } catch ( Exception e ) { throw new ExecutionException ( " clojure handler fn " + execute . ns + " / " + execute . sym + " threw an exception " , e ) ; } return null ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
public Object create ( ) hrows CoreException { return new ClojureHandlerProxy ( bundleName , handlerFn ) ; } 
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) hrows CoreException { assert data instanceof String ; bundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; handlerFn = ( String ) data ; } 
private Bundle getBundle ( String bundleSymbolicName ) hrows CoreException { Bundle b = Platform.getBundle(bundleSymbolicName); 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; don't know much about swt layouts yet :-( hosts.setSelection(new Point(0, hosts.getText().length())); new Label(parent, 0).setText("Port"); port = new Text(parent, SWT.BORDER); port.addKeyListener(new KeyListener() { public void keyReleased(KeyEvent e) { } public void keyPressed(KeyEvent e) { e.doit = Character.isDigit(e.character); } }); port.setFocus(); return composite; } 
public void keyReleased ( KeyEvent e ) { } public void keyPressed ( KeyEvent e ) { e . doit = Character . isDigit ( e . character ) ; } } ) ; port . setFocus ( ) ; return composite ; } protected void okPressed ( ) { host = hosts . getText ( ) ; ry { portNumber = Integer . parseInt ( port . getText ( ) ) ; } catch ( NumberFormatException e ) { shouldn't happen given the keylistener above } super.okPressed(); } public String getHost () { return host; } public int getPort () { return portNumber; }} 
private synchronized void startREPLServer ( ) hrows CoreException { if ( ackREPLServer = = null ) { ry { 
public int getREPLServerPort ( ) hrows CoreException { if ( ackREPLServer = = null ) { startREPLServer ( ) ; } return ackREPLServer . getLocalPort ( ) ; } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; startClojureCode ( context ) ; startREPLServer ( ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; } 
public void stop ( BundleContext context ) hrows Exception { disposeParenRainbowColors ( ) ; stopREPLServer(); plugin = null; super.stop(context); } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { return REPLView . connect ( " 127.0.0.1 " , CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ) ; 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( his ) ; initializeViewerColors ( ) ; } if ( configuration instanceof ClojureSourceViewerConfiguration ) fConfiguration = ( ClojureSourceViewerConfiguration ) configuration ; fSelectionHistory = new SelectionHistory ( his ) ; fIsConfigured = rue ; } 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { fForegroundColor . dispose ( ) ; fForegroundColor = null ; } if ( fBackgroundColor ! = null ) { fBackgroundColor . dispose ( ) ; fBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { fSelectionForegroundColor . dispose ( ) ; fSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { fSelectionBackgroundColor . dispose ( ) ; fSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( his ) ; if ( fSelectionHistory ! = null ) { fSelectionHistory . dispose ( ) ; fSelectionHistory = null ; } super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isInEscapeSequence ( ) ; DefaultCharacterPairMatcher getPairsMatcher();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
public void remember ( ISourceRange range ) { System . out . println ( " asked to remember range: " + range ) ; fHistory . add ( range ) ; fHistoryAction.update(); TODO correctement 
public void flush ( ) { if ( fHistory . isEmpty ( ) ) return ; fHistory . clear ( ) ; fHistoryAction.update(); TODO correctement 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { IWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; IClojureEditor clojureEditor = ( IClojureEditor ) PlatformUtil . getAdapter ( part , IClojureEditor . class ) ; if ( clojureEditor = = null ) { CCWPlugin . logWarning ( " Handler " + GotoMatchingBracketHandler . class . getSimpleName ( ) + " executed on a IWorkbenchPart (id: " + part . getSite ( ) . getId ( ) + " ) which is not able to adapt to " + IClojureEditor . class . getSimpleName ( ) ) ; return null ; } clojureEditor . gotoMatchingBracket ( ) ; return null ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public boolean isStructuralEditionPossible ( ) { return sourceViewer ( ) . isStructuralEditionPossible ( ) ; } 
public boolean isStructuralEditionPossible ( ) { return structuralEditionPossible ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isInEscapeSequence ( ) ; boolean isStructuralEditionPossible();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
String getDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
private static boolean hasNsCall ( String sourceCode ) { Matcher matcher = HAS_NS_CALL_PATTERN . matcher ( sourceCode ) ; return matcher . find ( ) ; } 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { String maybeLibName = ClojureCore . findMaybeLibNamespace ( ( IFile ) resource , currentSrcFolder . getKey ( ) . getFullPath ( ) ) ; if ( maybeLibName ! = null ) { clojureLibs . add ( maybeLibName ) ; } } return rue ; } 
public static String findDeclaringNamespace ( String sourceText ) { Matcher matcher = SEARCH_DECLARING_NAMESPACE_PATTERN . matcher ( sourceText ) ; if ( matcher . find ( ) ) { System . out . println ( " found declaring namespace: " + matcher . group ( 1 ) ) ; } return ( matcher . find ( ) ? matcher . group ( 1 ) : null ) ; } 
public String findDeclaringNamespace ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . findDeclaringNamespace ( ) ; } 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( getDocument ( ) . get ( ) ) ; } 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } EvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , rue ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isInEscapeSequence ( ) ; boolean isStructuralEditionPossible();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; } 
public void run ( ) { ry { String lib = editor . findDeclaringNamespace ( ) ; 
public void run ( ) { REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl = = null | | repl . isDisposed ( ) ) { return ; } String ns = editor . findDeclaringNamespace ( ) ; if ( ns = = null ) { put error msg in footer instead 
public String findDeclaringNamespace ( ) { String inline = super . findDeclaringNamespace ( ) ; if ( inline ! = null ) { return inline ; 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; ClojureOSGi . require ( bundleContext , " ccw.static-analysis " ) ; } 
public static String findDeclaringNamespace ( String sourceText ) { Var sexp = RT . var ( " paredit.parser " , " sexp " ) ; try { return ( String ) findDeclaringNamespace ( ( Map ) sexp . invoke ( sourceText ) ) ; 
public static String findDeclaringNamespace ( Map ree ) { Var findNamespace = RT . var ( " ccw.static-analysis " , " find-namespace " ) ; try { return ( String ) findNamespace . invoke ( ree ) ; 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) getParsed ( ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { EditorSupport . configureSourceViewerDecorationSupport ( support , viewer ) ; super . configureSourceViewerDecorationSupport ( support ) ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = EditorSupport . disposeSourceViewerDecorationSupport ( fSourceViewerDecorationSupport ) ; interactive . close ( ) ; oolConnection . close ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; ClojureOSGi . require ( bundleContext , " ccw.static-analysis " ) ; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public void oggleStructuralEditionMode ( ) { sourceViewer ( ) . oggleStructuralEditionMode ( ) ; } 
protected void createActions ( ) { super . createActions ( ) ; setAction("ClojureLaunchAction", action); 
public boolean isStructuralEditingEnabled ( ) { return sourceViewer ( ) . isStructuralEditingEnabled ( ) ; } 
public boolean isStructuralEditingEnabled ( ) { return useStrictStructuralEditing ; } 
public void oggleStructuralEditionMode ( ) { useStrictStructuralEditing = ! useStrictStructuralEditing ; updateStatusField ( ) ; } 
private void updateStatusField ( ) { if ( structuralEditionStatusField ! = null ) { / * 
public void contributeToStatusLine ( IStatusLineManager statusLineManager ) { statusLineManager . add ( structuralEditionStatusField ) ; updateStatusField ( ) ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { String maybeLibName = ClojureCore . findMaybeLibNamespace ( ( IFile ) resource , currentSrcFolder . getKey ( ) . getFullPath ( ) ) ; if ( maybeLibName ! = null ) { clojureLibs . add ( maybeLibName ) ; System . out . println ( " maybe lib: " + resource . getLocation ( ) + " recognized as a lib " ) ; } else { System . out . println ( " maybe lib: " + resource . getLocation ( ) + " NOT recognized as a lib " ) ; } } return rue ; } 
public void run ( ) { String selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . rim ( ) . equals ( " " ) ) { selectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { String extToEvaluate = selectedText ; 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.serverrepl " ) ; ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; startClojureCode ( context ) ; startREPLServer ( ) ; initializeParenRainbowColors ( ) ; } 
public void run ( ) { getTextWidget ( ) . setBackground ( structuralEditionPossible ? fBackgroundColor : Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_GRAY ) ) ; getTextWidget ( ) . setToolTipText ( structuralEditionPossible ? null : " Unparseable source code. Structural Edition temporarily disabled. " ) ; } 
public synchronized void startREPLServer ( ) hrows CoreException { if ( ackREPLServer = = null ) { ry { 
public void start ( BundleContext context ) hrows Exception { System . out . println ( " CCWPlugin start() starts " ) ; super . start ( context ) ; plugin = his ; startClojureCode ( context ) ; System . out . println ( " CCWPlugin start() ends " ) ; } 
private synchronized void createColorRegistry ( ) { if ( colorRegistry = = null ) { colorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; 
private synchronized void initializeParenRainbowColors ( ) { if ( allColors = = null ) { allColors = new Color [ ] { 
private void copyToLog ( StyledText s ) { sadly, need to reset text on the ST in order to get formatting/style ranges... s.setText(boostIndent.matcher(s.getText()).replaceAll(" ").replaceFirst("^\\s+", "=> ")); int start = logPanel.getCharCount(); try { log.invoke(logPanel, s.getText(), inputExprLogType); 
public REPLView getCorrespondingREPL ( ) { IFile file = ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( file ! = null ) { return CCWPlugin . getDefault ( ) . getProjectREPL ( file . getProject ( ) ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { evalExpression ( ) ; return null ; } 
private boolean isEvalEvent ( KeyEvent e ) { if ( e . keyCode = = '' | | e . keyCode = = '\r' ) { return e . stateMask ! = SWT . SHIFT & & 
 private void connectRepl ( ) { ry { REPLView replView = REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; 
private static int incTempLaunchCount ( String projectName ) { synchronized ( empLaunchCounters ) { Integer cnt = empLaunchCounters . get ( projectName ) ; 
private ILaunch launchEditorPart ( IEditorPart editor , String mode , Boolean activateAutoReload ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void connect ( Object element ) hrows CoreException { super . connect ( element ) ; configure ( getDocument ( element ) ) ; } 
public void disconnect ( Object element ) { TextUtilities . removeDocumentPartitioners ( getDocument ( element ) ) ; super . disconnect ( element ) ; } 
public void documentChanged ( DocumentEvent event ) { updateTextBuffer ( event . getDocument ( ) . get ( ) ) ; } 
private void updateTextBuffer ( String ext ) { boolean firstTime = ( parseRef = = null ) ; parseRef = EditorSupport . updateTextBuffer ( 0 L , - 1L , ext , parseRef ) ; if ( firstTime ) { EditorSupport . startWatchParseRef ( parseRef , his ) ; 
public Object getParseTree ( ) { if ( parseRef = = null ) { updateTextBuffer ( getDocument ( ) . get ( ) ) ; } return EditorSupport . getParseTree ( getDocument ( ) . get ( ) , parseRef ) ; } 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) getParseTree ( ) ) ; } 
public void setDocument ( IDocument document , IAnnotationModel annotationModel , int modelRangeOffset , int modelRangeLength ) { super . setDocument ( document , annotationModel , modelRangeOffset , modelRangeLength ) ; if ( document ! = null ) { updateTextBuffer ( document . get ( ) ) ; 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
Object getParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
public void documentChanged ( DocumentEvent event ) { updateTextBuffer ( event . getDocument ( ) . get ( ) , event . getOffset ( ) , event . getLength ( ) , event . getText ( ) ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String ext ) { boolean firstTime = ( parseRef = = null ) ; parseRef = EditorSupport . updateTextBuffer ( parseRef , finalText , offset , length , ext ) ; if ( firstTime ) { EditorSupport . startWatchParseRef ( parseRef , his ) ; 
public Object getParseTree ( ) { if ( parseRef = = null ) { String ext = getDocument ( ) . get ( ) ; updateTextBuffer ( ext , 0 , - 1 , ext ) ; } return EditorSupport . getParseTree ( getDocument ( ) . get ( ) , parseRef ) ; } 
public void setDocument ( IDocument document , IAnnotationModel annotationModel , int modelRangeOffset , int modelRangeLength ) { super . setDocument ( document , annotationModel , modelRangeOffset , modelRangeLength ) ; if ( document ! = null ) { String ext = document . get ( ) ; 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.PareditAutoEditStrategy " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureTopLevelFormsDamager " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.serverrepl " ) ; ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public static void registerEditorColors ( IPreferenceStore store , RGB foregroundColor ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; final RGB literalColor = getElementColor ( store , PreferenceConstants . EDITOR_LITERAL_COLOR , foregroundColor ) ; final RGB specialFormColor = getElementColor ( store , PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR , foregroundColor ) ; final RGB functionColor = getElementColor ( store , PreferenceConstants . EDITOR_FUNCTION_COLOR , foregroundColor ) ; final RGB commentColor = getElementColor ( store , PreferenceConstants . EDITOR_COMMENT_COLOR , foregroundColor ) ; final RGB globalVarColor = getElementColor ( store , PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR , foregroundColor ) ; final RGB keywordColor = getElementColor ( store , PreferenceConstants . EDITOR_KEYWORD_COLOR , foregroundColor ) ; final RGB metadataTypehintColor = getElementColor ( store , PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR , foregroundColor ) ; final RGB macroColor = getElementColor ( store , PreferenceConstants . EDITOR_MACRO_COLOR , foregroundColor ) ; colorRegistry . put ( ClojureEditor . ID + " _ " + Keyword . intern ( " string " ) , literalColor ) ; $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("regex"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("int"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("float"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("char"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("literalSymbol"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("symbol"), foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.RAW_SYMBOL, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("keyword"), keywordColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("comment"), commentColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("whitespace"), foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("meta"), metadataTypehintColor); $NON-NLS-1$ } 
protected void createActions ( ) { super . createActions ( ) ; setAction("ClojureLaunchAction", action); 
public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( ClojureEditor . his , ILaunchManager . RUN_MODE ) ; } ; 
public void documentAboutToBeChanged ( DocumentEvent event ) { updateTextBuffer(newText, event.getOffset(), event.getLength(), event.getText()); } 
private String replace ( String doc , int offset , int length , String ext ) { return doc . substring ( 0 , offset ) + ext + doc . substring ( offset + length ) ; } 
private void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { IPresentationDamager d = new ClojureTopLevelFormsDamager ( editor ) ; reconciler . setDamager ( d , contentType ) ; IPresentationRepairer r = new DefaultDamagerRepairer ( okenScanner ) ; reconciler . setRepairer ( r , contentType ) ; 
public final void addTokenType ( Object okenIndex , org . eclipse . jface . ext . rules . IToken oken ) { if ( initialized ) { hrow lifeCycleError ( ) ; } okenTypeToJFaceToken . put ( okenIndex , oken ) ; } 
private void advanceToken ( ) { long start = System . currentTimeMillis ( ) ; boolean firstToken ; if ( currentToken = = null ) { firstToken = rue ; } else { firstToken = false ; } if ( ! firstToken ) { int count = ( Integer ) currentToken . get ( okenLengthKeyword ) ; currentOffset + = count ; tokenSeq = okenSeq . next ( ) ; } System.out.println(tokenSeq.first()); currentToken = (Map<?,?>)tokenSeq.first(); advanceTokenDuration += System.currentTimeMillis() - start; } 
public final IToken nextToken ( ) { long start = System . currentTimeMillis ( ) ; advanceToken ( ) ; IToken result ; if ( currentToken . get ( okenTypeKeyword ) . equals ( nestKeyword ) ) { currentParenLevel + = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( okenTypeKeyword ) . equals ( unnestKeyword ) ) { currentParenLevel - = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( okenTypeKeyword ) . equals ( openListKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( openFnKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( openChimeraKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeListKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeFnKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeChimeraKeyword ) ) { if ( currentParenLevel < 0 ) { result = errorToken ; } else { result = parenLevelTokens [ currentParenLevel % parenLevelTokens . length ] ; } } else { result = oJFaceToken ( ) ; } if ( result . equals ( Token . EOF ) ) { long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return result; } long localDuration = System.currentTimeMillis() - start; nextTokenDuration += localDuration; duration += localDuration; return result; } 
private IToken oJFaceToken ( ) { long start = System . currentTimeMillis ( ) ; Object ype = currentToken . get ( okenTypeKeyword ) ; if ( ype . equals ( symbolKeyword ) ) { ype = guessEclipseTokenTypeForSymbol ( ext . substring ( currentOffset , currentOffset + ( ( Integer ) currentToken . get ( okenLengthKeyword ) ) ) ) ; } IToken retToken = okenTypeToJFaceToken . get ( ype ) ; if ( retToken = = null ) { retToken = Token . UNDEFINED ; } oJFaceTokenDuration + = System . currentTimeMillis ( ) - start ; return retToken ; return Token.UNDEFINED; 
private Object guessEclipseTokenTypeForSymbol ( String symbol ) { long start = System . currentTimeMillis ( ) ; Object res ; if ( symbolLiterals . contains ( symbol ) ) { res = Keyword . intern ( " literalSymbol " ) ; } else { long sttart = System . currentTimeMillis ( ) ; res = context . getSymbolType ( symbol ) ; getSymbolTypeDuration + = System . currentTimeMillis ( ) - sttart ; } guessEclipseTokenTypeForSymbolDuration + = System . currentTimeMillis ( ) - start ; return res ; } 
public ClojureTokenScanner create ( final ColorRegistry colorProvider , IScanContext scanContext , IClojureEditor clojureEditor ) { return new ClojureTokenScanner ( scanContext , clojureEditor ) { @Override 
protected void initClojureTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorProvider ) ; u . addTokenType ( Keyword . intern ( " string " ) ) ; u . addTokenType ( Keyword . intern ( " regex " ) ) ; u . addTokenType ( Keyword . intern ( " int " ) ) ; u . addTokenType ( Keyword . intern ( " float " ) ) ; u . addTokenType ( Keyword . intern ( " char " ) ) ; u . addTokenType ( Keyword . intern ( " literalSymbol " ) ) ; u . addTokenType ( Keyword . intern ( " symbol " ) ) ; u . addTokenType ( Keyword . intern ( " unexpected " ) , ClojureTokenScanner . errorToken ) ; u . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; u . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; u . addTokenType ( IScanContext . SymbolType . MACRO ) ; u . addTokenType ( IScanContext . SymbolType . SPECIAL_FORM ) ; u . addItalicToken ( IScanContext . SymbolType . JAVA_CLASS ) ; u . addItalicToken ( IScanContext . SymbolType . JAVA_INSTANCE_METHOD ) ; u . addItalicToken ( IScanContext . SymbolType . JAVA_STATIC_METHOD ) ; u . addTokenType ( SymbolType . RAW_SYMBOL ) ; u . addTokenType ( Keyword . intern ( " meta " ) ) ; u . addTokenType ( Keyword . intern ( " keyword " ) ) ; u . addTokenType ( Keyword . intern ( " comment " ) ) ; u . addTokenType ( Keyword . intern ( " whitespace " ) ) ; u . addTokenType ( Keyword . intern ( " eof " ) , Token . EOF ) ; u . addTokenType ( Keyword . intern ( " whitespace " ) , Token . WHITESPACE ) ; } 
private void replaceOriginalWithFormatted ( IDocument original , ISourceViewer sourceViewer , String formatted ) { IRegion selection = editor.getSignedSelection(); Tokens tokens = new Tokens(original, selection); Document formattedDocument = new Document(formatted); Tokens formattedTokens = new Tokens(formattedDocument); int targetOffset = formattedTokens.sameStructuralOffset(tokens); original.set(formatted); sourceViewer.setSelectedRange(targetOffset, 0); sourceViewer.revealRange(targetOffset, 0); }} 
public void caretMoved ( CaretEvent event ) { IDocument document = editor . getDocument ( ) ; Tokens okens = new Tokens ( document , editor , event . caretOffset ) ; okens . putTokenScannerRangeOnCurrentLine ( ) ; IToken okenAtCaret = okens . okenAtCaret ( ) ; boolean wordIsNotFormatted = okenAtCaret . getData ( ) = = null ; if ( wordIsNotFormatted ) { StyleRange range = createRange ( okens ) ; 
public void addTokenType ( Object okenIndex ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( ClojureEditor . ID + " _ " + okenIndex ) ) ) ; } 
public void addTokenType ( Object okenIndex , IToken oken ) { scanner . addTokenType ( okenIndex , oken ) ; } 
public void addBoldToken ( Object okenIndex ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( ClojureEditor . ID + " _ " + okenIndex ) , null , SWT . BOLD ) ) ; 
public void addItalicToken ( Object okenIndex ) { scanner . addTokenType ( okenIndex , new TextAttribute ( colorProvider . get ( ClojureEditor . ID + " _ " + okenIndex ) , null , SWT . ITALIC ) ) ; 
public static ITokenScanner okenScanner ( IClojureEditor clojureEditor ) { return new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , clojureEditor ) ; } 
public Object getPreviousParseTree ( ) { if ( parseRef = = null ) { return null ; 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseTree ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
Object getParseTree ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
private void printSetRange ( String name , IDocument document , int offset , int length ) { System . out . println ( " setRange() called on " + name ) ; System . out . println ( " offset: " + offset ) ; System . out . println ( " length: " + length ) ; System . out . println ( " document: " + document ) ; System . out . println ( " --------------------------- " ) ; } ; 
private void updateTextBuffer ( String finalText , long offset , long length , String ext ) { boolean firstTime = ( parseState = = null ) ; parseState = EditorSupport . updateTextBuffer ( parseState , finalText , offset , length , ext ) ; if ( firstTime ) { EditorSupport . startWatchParseRef ( parseState , his ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { String ext = getDocument ( ) . get ( ) ; updateTextBuffer ( ext , 0 , - 1 , ext ) ; } return EditorSupport . getParseState ( getDocument ( ) . get ( ) , parseState ) ; } 
public Object getPreviousParseTree ( ) { if ( parseState = = null ) { return null ; 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) EditorSupport . getParseTree ( getParseState ( ) ) ) ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; } 
private static void inUIThreadSetREPLConnection ( Connection repl ) { IViewPart [ ] views = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getViews ( ) ; } 
public void run ( ) { IDocument original = editor.getDocument(); ISourceViewer sourceViewer = editor.sourceViewer(); String originalContents = original.get(); String formatted = new ClojureFormat().formatCode(originalContents); if (!formatted.equals(originalContents)) { replaceOriginalWithFormatted(original, sourceViewer, formatted); } } private void replaceOriginalWithFormatted(IDocument original, ISourceViewer sourceViewer, String formatted) { IRegion selection = editor.getSignedSelection(); Tokens tokens = new Tokens(original, selection); Document formattedDocument = new Document(formatted); Tokens formattedTokens = new Tokens(formattedDocument); int targetOffset = formattedTokens.sameStructuralOffset(tokens); original.set(formatted); sourceViewer.setSelectedRange(targetOffset, 0); sourceViewer.revealRange(targetOffset, 0); }} 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.PareditAutoEditStrategyImpl " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureFormat " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.StacktraceHyperlink " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.EditorSupport " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureHyperlinkDetector " ) ; ClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureTopLevelFormsDamagerImpl " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; ClojureOSGi . require ( bundleContext , " ccw.debug.serverrepl " ) ; ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -configureSourceViewerDecorationSupport " , support , viewer ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String ext ) { boolean firstTime = ( parseState = = null ) ; parseState = ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -updateTextBuffer " , parseState , finalText , offset , length , ext ) ; ClojureUtils.invoke(EDITOR_SUPPORT_NS, "-startWatchParseRef", parseState, this); 
public Object getParseState ( ) { if ( parseState = = null ) { String ext = getDocument ( ) . get ( ) ; updateTextBuffer ( ext , 0 , - 1 , ext ) ; } return ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -getParseState " , getDocument ( ) . get ( ) , parseState ) ; return EditorSupport.getParseState(getDocument().get(), parseState); 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -getParseTree " , getParseState ( ) ) ) ; return ClojureCore.findDeclaringNamespace((Map) EditorSupport.getParseTree(getParseState())); 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , boolean documentPartitioningChanged ) { return ( IRegion ) ClojureUtils . invoke ( ClojureTopLevelFormsDamagerImpl_NS , " -getDamageRegion " , this , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { ClojureUtils . invoke ( PareditAutoEditStrategyImpl_NS , " -customizeDocumentCommand " , this , document , command ) ; 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; fSourceViewerDecorationSupport = EditorSupport.disposeSourceViewerDecorationSupport(fSourceViewerDecorationSupport); interactive.close(); toolConnection.close(); } 
private static Var var ( String ns , String name ) { String varName = ns + " / " + name ; Var v = cachedVars . get ( varName ) ; if ( v ! = null ) { return v ; 
public static Object invoke ( String ns , String name ) { try { return var ( ns , name ) . invoke ( ) ; 
public static Object invoke ( String ns , String name , Object arg1 ) { try { return var ( ns , name ) . invoke ( arg1 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 ) { try { return var ( ns , name ) . invoke ( arg1 , arg2 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 , Object arg3 ) { try { return var ( ns , name ) . invoke ( arg1 , arg2 , arg3 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 , Object arg3 , Object arg4 ) { try { return var ( ns , name ) . invoke ( arg1 , arg2 , arg3 , arg4 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 , Object arg3 , Object arg4 , Object arg5 ) { try { return var ( ns , name ) . invoke ( arg1 , arg2 , arg3 , arg4 , arg5 ) ; 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public static IStatus createErrorStatus ( String message ) { return new Status ( IStatus . ERROR , PLUGIN_ID , message ) ; } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " configureSourceViewerDecorationSupport " , support , viewer ) ; super . configureSourceViewerDecorationSupport ( support ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String ext ) { boolean firstTime = ( parseState = = null ) ; parseState = ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " updateTextBuffer " , parseState , finalText , offset , length , ext ) ; if ( firstTime ) { ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " startWatchParseRef " , parseState , his ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { String ext = getDocument ( ) . get ( ) ; updateTextBuffer ( ext , 0 , - 1 , ext ) ; } return ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " getParseState " , getDocument ( ) . get ( ) , parseState ) ; } 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " getParseTree " , getParseState ( ) ) ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , boolean documentPartitioningChanged ) { return ( IRegion ) ClojureUtils . invoke ( ClojureTopLevelFormsDamagerImpl_NS , " getDamageRegion " , this , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { ClojureUtils . invoke ( PareditAutoEditStrategyImpl_NS , " customizeDocumentCommand " , this , document , command ) ; 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; interactive . close ( ) ; oolConnection . close ( ) ; } 
public static Var requireAndGetVar ( String bundleSymbolicName , String varName ) hrows CoreException { final String [ ] nsFn = varName . split ( " / " ) ; try { ClojureOSGi . require ( loadAndGetBundle ( bundleSymbolicName ) . getBundleContext ( ) , nsFn [ 0 ] ) ; 
public static Bundle loadAndGetBundle ( String bundleSymbolicName ) hrows CoreException { Bundle b = Platform.getBundle(bundleSymbolicName); 
public Object create ( ) hrows CoreException { try { final Object [ ] ret = new Object [ 1 ] ; 
public void run ( ) hrows Exception { ret [ 0 ] = factory . invoke ( factoryParams ) ; } 
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) hrows CoreException { assert data instanceof String ; bundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; if ( data instanceof String ) { String name = ( String ) data ; 
private void initFactory ( String varName ) hrows CoreException { factory = BundleUtils . requireAndGetVar ( bundleName , varName ) ; } 
protected String name ( ) { String name = mainPage . ext . getText ( ) . rim ( ) . replaceAll ( " - " , " _ " ) ; FIXME should call clojure.core/munge if (name.endsWith(".clj")) name = name.substring(0, name.length() - (".clj").length()); return name; } 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( i ) + " ' at index " + i + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
private void advanceToken ( ) { long start = System . currentTimeMillis ( ) ; boolean firstToken ; if ( currentToken = = null ) { firstToken = rue ; } else { firstToken = false ; } if ( ! firstToken ) { long count = ( Long ) currentToken . get ( okenLengthKeyword ) ; currentOffset + = count ; tokenSeq = okenSeq . next ( ) ; } System.out.println(tokenSeq.first()); currentToken = (Map<?,?>)tokenSeq.first(); advanceTokenDuration += System.currentTimeMillis() - start; } 
private IToken oJFaceToken ( ) { long start = System . currentTimeMillis ( ) ; Object ype = currentToken . get ( okenTypeKeyword ) ; if ( ype . equals ( symbolKeyword ) ) { ype = guessEclipseTokenTypeForSymbol ( ext . substring ( currentOffset , currentOffset + ( ( Long ) currentToken . get ( okenLengthKeyword ) ) . intValue ( ) ) ) ; } IToken retToken = okenTypeToJFaceToken . get ( ype ) ; if ( retToken = = null ) { retToken = Token . UNDEFINED ; } oJFaceTokenDuration + = System . currentTimeMillis ( ) - start ; return retToken ; return Token.UNDEFINED; 
 private void connectRepl ( ) { ry { REPLView replView = REPLView . connect ( " localhost " , port . intValue ( ) , lastConsoleOpened , launch ) ; 
private static int incTempLaunchCount ( String projectName ) { synchronized ( empLaunchCounters ) { Long cnt = empLaunchCounters . get ( projectName ) ; 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public static Var requireAndGetVar ( String bundleSymbolicName , String varName ) hrows CoreException { final String [ ] nsFn = varName . split ( " / " ) ; try { if ( findNs . invoke ( Symbol . intern ( nsFn [ 0 ] ) ) = = null ) { 
public Object create ( ) hrows CoreException { try { return ClojureOSGi . withBundle ( BundleUtils . loadAndGetBundle ( bundleName ) , new RunnableWithException ( ) { 
public Object run ( ) hrows Exception { return factory . invoke ( factoryParams ) ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl/reset-ack-port! " ) . invoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public boolean isParseTreeBroken ( ) { return ( Boolean ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " brokenParseTree? " , getParseState ( ) ) ; } 
private String removeTrailingSpaces ( String s ) { return ( String ) ClojureUtils . invoke ( CLOJURE_STRING_NS , " rimr " , s ) ; } 
private void evalExpression ( ) { viewerWidget.setText(removeTrailingSpaces(viewerWidget.getText())); evalExpression(viewerWidget.getText(), true, false); copyToLog(viewerWidget); viewerWidget.setText(""); } 
private void installAutoEvalExpressionOnEnter ( ) { viewerWidget . addVerifyKeyListener ( new VerifyKeyListener ( ) { private boolean enterAlonePressed ( VerifyEvent e ) { 
private boolean enterAlonePressed ( VerifyEvent e ) { return ( e . keyCode = = SWT . LF | | e . keyCode = = SWT . CR ) & & e . stateMask = = SWT . NONE ; 
private boolean noSelection ( ) { return viewerWidget . getSelectionCount ( ) = = 0 ; } 
private String extAfterCaret ( ) { return viewerWidget . getText ( ) . substring ( viewerWidget . getSelection ( ) . x ) ; 
public void verifyKey ( VerifyEvent e ) { if ( enterAlonePressed ( e ) & & noSelection ( ) 
private void installEvalTopLevelSExpressionCommand ( ) { IHandlerService handlerService = ( IHandlerService ) getViewSite ( ) . getService ( IHandlerService . class ) ; handlerService . activateHandler ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION , new AbstractHandler ( ) { public Object execute ( ExecutionEvent event ) hrows ExecutionException { 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { evalExpression ( ) ; return null ; } 
public boolean visit ( IResource resource ) hrows CoreException { if ( resource instanceof IFile ) { String maybeLibName = ClojureCore . findMaybeLibNamespace ( ( IFile ) resource , currentSrcFolder . getKey ( ) . getFullPath ( ) ) ; if ( maybeLibName ! = null ) { clojureLibs . add ( maybeLibName ) ; } 
private void createMarker ( final String filename , final int line , final String message ) { try { System.out.println("(trying to) create a marker for " + filename); 
public void beginReporting ( ) { super . beginReporting ( ) ; } 
public void acceptSearchMatch ( SearchMatch match ) hrows CoreException { counter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { (IMethod) match.getElement(), 
public void endReporting ( ) { super . endReporting ( ) ; System.out.println("end reporting : count=" + counter); 
public void remember ( ISourceRange range ) { fHistoryAction.update(); TODO correctement 
public void run ( ) { System.out.println("delayed refresh stop"); 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { " org.eclipse.ui.textEditorScope " , IClojureEditor . KEY_BINDING_SCOPE } ) ; } 
public void contributeToStatusLine ( IStatusLineManager statusLineManager ) { super . contributeToStatusLine ( statusLineManager ) ; for ( int i = 0 ; i < STATUS_FIELD_DEFS . length ; i + + ) statusLineManager . add ( ( IContributionItem ) fStatusFields . get ( STATUS_FIELD_DEFS [ i ] ) ) ; 
protected void updateStatusField ( String category ) { if ( ClojureSourceViewer . STATUS_CATEGORY_STRUCTURAL_EDITION . equals ( category ) ) { viewer . updateStructuralEditingModeStatusField ( ) ; 
protected void createActions ( ) { super . createActions ( ) ; 
public static StatusLineContributionItem createStructuralEditionModeStatusContributionItem ( ) { return new StatusLineContributionItem ( ClojureSourceViewer . STATUS_CATEGORY_STRUCTURAL_EDITION , 
public void oggleStructuralEditionMode ( ) { useStrictStructuralEditing = ! useStrictStructuralEditing ; updateStructuralEditingModeStatusField ( ) ; } 
public void updateStructuralEditingModeStatusField ( ) { if ( his . statusLineHandler = = null ) { return ; } StatusLineContributionItem field = his . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { String ext = " Structural Edition: " + ( isStructuralEditingEnabled ( ) ? " Strict mode " : " Default mode " ) ; 
private Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; if ( interactive ! = null ) { interactive . close ( ) ; } if ( oolConnection ! = null ) { toolConnection . close ( ) ; 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( i ) + " ' at index " + i + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { TextEditor editor = (TextEditor) IDE.openEditor(page, file, true); editor.selectAndReveal(contents.length(), 0); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
protected String name ( ) { String name = mainPage . ext . getText ( ) . rim ( ) . replaceAll ( " - " , " _ " ) ; name = name.substring(0, name.length() - (".cljs").length()); } return name; } 
protected String suffix ( ) { String name = mainPage . ext . getText ( ) . rim ( ) . replaceAll ( " - " , " _ " ) ; return name.substring(index); 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; String suffix = suffix ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( i ) + " ' at index " + i + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { TextEditor editor = (TextEditor) IDE.openEditor(page, file, true); editor.selectAndReveal(contents.length(), 0); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , Messages . REPLViewPreferencePage_activate_autoEval_on_Enter , getFieldEditorParent ( ) ) ) ; 
private boolean isAutoEvalOnEnterAllowed ( ) { return getPreferences ( ) . getBoolean ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE ) ; } 
public void verifyKey ( VerifyEvent e ) { if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
public static String format ( String message , Object . . . bindings ) { return NLS . bind ( message , bindings ) ; } 
private void installMessageDisplayer ( final StyledText extViewer , final MessageProvider hintProvider ) { textViewer . addListener ( SWT . Paint , new Listener ( ) { public void handleEvent ( Event event ) { 
public void handleEvent ( Event event ) { String message = hintProvider . getMessageText ( ) ; if ( message = = null ) return ; Point opRightPoint = opRightPoint ( extViewer . getClientArea ( ) ) ; int sWidth = extWidthPixels ( message , event ) ; int x = Math . max ( opRightPoint . x - sWidth , 0 ) ; int y = opRightPoint . y ; event . gc . setForeground ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_GRAY ) ) ; event . gc . drawText ( message , x , y , rue ) ; } 
private Point opRightPoint ( Rectangle clipping ) { return new Point ( clipping . x + clipping . width , clipping . y ) ; } 
private int extWidthPixels ( String ext , Event evt ) { int width = 0 ; for ( int i = 0 ; i < ext . length ( ) ; i + + ) { width + = evt . gc . getAdvanceWidth ( ext . charAt ( i ) ) ; } return width ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , Messages . REPLViewPreferencePage_activate_autoEval_on_Enter , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , 
public void updateStructuralEditingModeStatusField ( ) { if ( his . statusLineHandler = = null ) { return ; } StatusLineContributionItem field = his . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { String ext = " Edit mode: " + ( isStructuralEditingEnabled ( ) ? " strict/paredit " : " unrestricted " ) ; 
public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( JFaceResources . TEXT_FONT ) ) resetFont ( ) ; } 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanel . setFont ( font ) ; viewerWidget . setFont ( font ) ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; if ( interactive ! = null ) { interactive . close ( ) ; } if ( oolConnection ! = null ) { toolConnection . close ( ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public void handleEvent ( Event event ) { String message = hintProvider . getMessageText ( ) ; if ( message = = null ) return ; } 
public void handleEvent ( Event event ) { String message = hintProvider . getMessageText ( ) ; if ( message = = null ) return ; } 
public boolean isInEscapeSequence ( ) { return ( ( IClojureEditor ) getSourceViewer ( ) ) . isInEscapeSequence ( ) ; } 
public IRegion getUnSignedSelection ( ) { return ( ( IClojureEditor ) getSourceViewer ( ) ) . getUnSignedSelection ( ) ; } 
public IRegion getSignedSelection ( ) { return ( ( IClojureEditor ) getSourceViewer ( ) ) . getSignedSelection ( ) ; } 
public String findDeclaringNamespace ( ) { return ( ( IClojureEditor ) getSourceViewer ( ) ) . findDeclaringNamespace ( ) ; } 
public boolean isShowRainbowParens ( ) { return sourceViewer ( ) . isShowRainbowParens ( ) ; } 
public void oggleShowRainbowParens ( ) { sourceViewer ( ) . oggleShowRainbowParens ( ) ; } 
public void oggleShowRainbowParens ( ) { isShowRainbowParens = ! isShowRainbowParens ; markDamagedAndRedraw ( ) ; } 
public void markDamagedAndRedraw ( ) { ry { isForceRepair = rue ; 
public final IToken nextToken ( ) { long start = System . currentTimeMillis ( ) ; advanceToken ( ) ; IToken result ; if ( currentToken . get ( okenTypeKeyword ) . equals ( nestKeyword ) ) { currentParenLevel + = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( okenTypeKeyword ) . equals ( unnestKeyword ) ) { currentParenLevel - = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( okenTypeKeyword ) . equals ( openListKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( openFnKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( openChimeraKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeListKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeFnKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeChimeraKeyword ) ) { if ( currentParenLevel < 0 ) { result = errorToken ; } else { if ( his . clojureEditor . isShowRainbowParens ( ) ) { result = parenLevelTokens [ currentParenLevel % parenLevelTokens . length ] ; } else { result = noRainbowParenToken ; } } } else { result = oJFaceToken ( ) ; } if ( result . equals ( Token . EOF ) ) { long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return result; } long localDuration = System.currentTimeMillis() - start; nextTokenDuration += localDuration; duration += localDuration; return result; } 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();} 
boolean isInEscapeSequence ( ) ; void markDamagedAndRedraw();} 
IRegion getUnSignedSelection ( ) ; void markDamagedAndRedraw ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; } 
String findDeclaringNamespace ( ) ; void markDamagedAndRedraw ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; } 
Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public boolean isEscapeInStringLiteralsEnabled ( ) { return sourceViewer ( ) . isEscapeInStringLiteralsEnabled ( ) ; } 
public boolean isEscapeInStringLiteralsEnabled ( ) { return fPreferenceStore . getBoolean ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void markDamagedAndRedraw();} 
private synchronized void createColorCache ( ) { if ( colorCache = = null ) { colorCache = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; 
public void stop ( BundleContext context ) hrows Exception { stopREPLServer(); plugin = null; super.stop(context); } 
public static void registerEditorColors ( IPreferenceStore store , RGB foregroundColor ) { final ColorRegistry colorCache = getDefault ( ) . getColorCache ( ) ; for ( Keyword oken : PreferenceConstants . colorizableTokens ) { PreferenceConstants . ColorizableToken okenStyle = PreferenceConstants . getColorizableToken ( store , oken , foregroundColor ) ; 
protected void createActions ( ) { super . createActions ( ) ; 
public void initTokenScanner ( ) { tokenScanner = new ClojureTokenScanner ( CCWPlugin . getDefault ( ) . getColorCache ( ) , 
protected void initClojureTokenTypeToJFaceTokenMap ( ) { TokenScannerUtils u = new TokenScannerUtils ( his , colorCache ) ; u . addTokenType ( Keyword . intern ( " unexpected " ) , ClojureTokenScanner . errorToken ) ; u . addTokenType ( Keyword . intern ( " eof " ) , Token . EOF ) ; u . addTokenType ( Keyword . intern ( " whitespace " ) , Token . WHITESPACE ) ; for ( Keyword oken : PreferenceConstants . colorizableTokens ) { PreferenceConstants . ColorizableToken okenStyle = PreferenceConstants . getColorizableToken ( preferenceStore , oken , null ) ; 
public final void addTokenType ( Keyword okenIndex , org . eclipse . jface . ext . rules . IToken oken ) { if ( initialized ) { hrow lifeCycleError ( ) ; } parserTokenKeywordToJFaceToken . put ( okenIndex , oken ) ; } 
public final void addTokenType ( Keyword okenIndex , TextAttribute extAttribute ) { if ( initialized ) { hrow lifeCycleError ( ) ; } addTokenType ( okenIndex , new org . eclipse . jface . ext . rules . Token ( extAttribute ) ) ; } 
public final IToken nextToken ( ) { long start = System . currentTimeMillis ( ) ; advanceToken ( ) ; IToken result ; if ( currentToken . get ( okenTypeKeyword ) . equals ( nestKeyword ) ) { currentParenLevel + = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; isCallableSymbol = rue ; return nextToken ( ) ; } if ( currentToken . get ( okenTypeKeyword ) . equals ( unnestKeyword ) ) { currentParenLevel - = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; isCallableSymbol = false ; return nextToken ( ) ; } if ( currentToken . get ( okenTypeKeyword ) . equals ( openListKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( openFnKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( openChimeraKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeListKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeFnKeyword ) | | currentToken . get ( okenTypeKeyword ) . equals ( closeChimeraKeyword ) ) { if ( currentParenLevel < 0 ) { result = errorToken ; } else { if ( his . clojureEditor . isShowRainbowParens ( ) ) { result = parserTokenKeywordToJFaceToken . get ( parenLevelPrefKeywords [ currentParenLevel % parenLevelPrefKeywords . length ] ) ; } else { result = parserTokenKeywordToJFaceToken . get ( PreferenceConstants . deactivatedRainbowParen ) ; } } } else { result = oJFaceToken ( ) ; } if ( result . equals ( Token . EOF ) ) { long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; isCallableSymbol = false; } return result; } 
private IToken oJFaceToken ( ) { long start = System . currentTimeMillis ( ) ; Keyword ype = ( Keyword ) currentToken . get ( okenTypeKeyword ) ; if ( ype . equals ( symbolKeyword ) ) { ype = guessEclipseTokenTypeForSymbol ( ext . substring ( currentOffset , currentOffset + ( ( Long ) currentToken . get ( okenLengthKeyword ) ) . intValue ( ) ) ) ; } IToken retToken = parserTokenKeywordToJFaceToken . get ( ype ) ; if ( retToken = = null ) { retToken = Token . UNDEFINED ; } oJFaceTokenDuration + = System . currentTimeMillis ( ) - start ; return retToken ; return Token.UNDEFINED; 
private Keyword guessEclipseTokenTypeForSymbol ( String symbol ) { long start = System . currentTimeMillis ( ) ; Keyword res ; if ( symbolLiterals . contains ( symbol ) ) { res = Keyword . intern ( " literalSymbol " ) ; } else { long sttart = System . currentTimeMillis ( ) ; res = context . getSymbolType ( symbol , isCallableSymbol ) ; getSymbolTypeDuration + = System . currentTimeMillis ( ) - sttart ; } guessEclipseTokenTypeForSymbolDuration + = System . currentTimeMillis ( ) - start ; return res ; } 
private void initColorRegistry ( ) { if ( ! colorCache . hasValueFor ( COLOR_KEY ) ) { colorCache . put ( COLOR_KEY , new RGB ( 225 , 225 , 225 ) ) ; } if ( ! colorCache . hasValueFor ( OTHER_MATCHES_COLOR_KEY ) ) { colorCache . put ( OTHER_MATCHES_COLOR_KEY , new RGB ( 255 , 255 , 180 ) ) ; 
public void caretMoved ( CaretEvent event ) { IDocument document = editor . getDocument ( ) ; Tokens okens = new Tokens ( document , editor , store , event . caretOffset ) ; okens . putTokenScannerRangeOnCurrentLine ( ) ; IToken okenAtCaret = okens . okenAtCaret ( ) ; boolean wordIsNotFormatted = okenAtCaret . getData ( ) = = null ; if ( wordIsNotFormatted ) { StyleRange range = createRange ( okens ) ; 
private StyleRange createRange ( Tokens okens ) { return okens . styleRange ( colorCache . get ( COLOR_KEY ) ) ; } 
public void addTokenType ( Keyword okenIndex , String rgb , Boolean isBold , Boolean isItalic ) { TextAttribute extAttribute ; if ( isBold = = null & & isItalic = = null ) { } 
public void addTokenType ( Keyword okenIndex , IToken oken ) { scanner . addTokenType ( okenIndex , oken ) ; } 
public static ITokenScanner okenScanner ( IClojureEditor clojureEditor , IPreferenceStore store ) { return new ClojureTokenScanner ( CCWPlugin . getDefault ( ) . getColorCache ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , store , clojureEditor ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fBoldCheckBox . setEnabled ( false ) ; fItalicCheckBox . setEnabled ( false ) ; fEnableCheckbox . setEnabled ( rue ) ; boolean enable = fOverlayStore . getBoolean ( item . getEnableKey ( ) ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; fBoldCheckBox . setEnabled ( enable ) ; fItalicCheckBox . setEnabled ( enable ) ; / * TODO depend on enable if ext attributes are actually used 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; fOverlayStore . setValue ( item . getBoldKey ( ) , fBoldCheckBox . getSelection ( ) ) ; } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; fOverlayStore . setValue ( item . getItalicKey ( ) , fItalicCheckBox . getSelection ( ) ) ; } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; boolean enable = fEnableCheckbox . getSelection ( ) ; fOverlayStore . setValue ( item . getEnableKey ( ) , enable ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; fBoldCheckBox . setEnabled ( enable ) ; fItalicCheckBox . setEnabled ( enable ) ; / * TODO re - enable once ext attributes are used 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , getBoldPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , getItalicPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . oArray ( keys ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , IClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { return Collections . emptyList ( ) ; } if ( prefix = = null ) { return Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Connection connection = repl . getToolingConnection ( ) ; Response response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) ; return ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { return Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Connection connection = repl . getToolingConnection ( ) ; Response response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; return ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private static Object extractSingleValue ( Response response , Object defaultValueIfNil ) { List vs = response . values ( ) ; if ( vs . isEmpty ( ) | | vs . get ( 0 ) = = null ) { return defaultValueIfNil ; 
private void runTests ( String lib , Connection repl ) hrows Exception { Response results = repl . send ( " op " , " eval " , " code " , runTestsCommand ( lib ) ) ; if ( ( ( String ) results . combinedResponse ( ) . get ( Keyword . intern ( " out " ) ) ) . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
public void canceling ( ) { if ( monitor ! = null ) { monitor . setCanceled ( rue ) ; 
private IStatus done ( IProgressMonitor monitor , IStatus status ) { monitor . done ( ) ; return status ; } 
 public void done ( ) { latch . countDown ( ) ; } 
 private void connectRepl ( ) { ry { REPLView replView = REPLView . connect ( " nrepl:localhost: " + port . intValue ( ) , lastConsoleOpened , launch ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { return REPLView . connect ( " nrepl:localhost: " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { repl . sendInterrupt ( ) ; } 
private Map < String , List < String > > getRemoteNsTree ( Connection repl ) { try { Response res = repl . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/namespaces-info) " ) ; 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (if-not *e (println \" No prior exception bound to *e. \" ) (clojure.repl/pst *e))) " , false , false ) ; } 
public void sendInterrupt ( ) { log . invoke ( logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; } 
public void getStdIn ( ) { InputDialog dlg = new InputDialog ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Input requested " , String . format ( " A REPL expression sent to %s requires a line of *in* input: " , interactive . url ) , " " , null ) ; no conditional here; what else would we do if they canceled the dialog? Just a recipe for *requiring* an interrupt...? dlg.open(); evalExpression.invoke(PersistentHashMap.create("op", "stdin", "stdin", dlg.getValue() + ""), false); } 
public void reconnect ( ) hrows Exception { closeConnections ( ) ; logPanel . append ( " ;; Reconnecting... " ) ; configure ( interactive . url ) ; } 
public void setCurrentNamespace ( String ns ) { currentNamespace = ns; setPartName(String.format("REPL @ %s (%s)", interactive.url, currentNamespace)); } 
private void prepareView ( ) hrows Exception { evalExpression = ( IFn ) configureREPLView . invoke ( his , logPanel , interactive . client ) ; } 
public static REPLView connect ( ) hrows Exception { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; ConnectDialog dlg = new ConnectDialog ( window . getShell ( ) ) ; REPLView repl = null ; if ( dlg . open ( ) = = ConnectDialog . OK ) { cannot find any way to create a configured/connected REPLView, and install it programmatically String host = dlg.getHost(); int port = dlg.getPort(); if (host == null || host.length() == 0 || port < 0 || port > 65535) { MessageDialog.openInformation(window.getShell(), "Invalid connection info", "You must provide a useful hostname and port number to connect to a REPL."); } else { repl = connect(String.format("nrepl:%s:%s", host, port)); } } return repl; } 
public static REPLView connect ( String url ) hrows Exception { return connect ( url , null , null ) ; } 
public static REPLView connect ( String url , IConsole console , ILaunch launch ) hrows Exception { REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , UUID . randomUUID ( ) . oString ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . console = console ; repl . launch = launch ; return repl . configure ( url ) ? repl : null ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; ry { if ( interactive ! = null ) interactive . close ( ) ; if ( oolConnection ! = null ) oolConnection . close ( ) ; } catch ( IOException e ) { CCWPlugin . logError ( e ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public void run ( ) { CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . setValue ( " LexicalSortingAction.isChecked " , sort = isChecked ( ) ) ; setInputInUiThread ( forms ) ; } 
private static Symbol symbol ( Object o ) { return o instanceof Symbol ? ( Symbol ) o : null ; } 
private static boolean isPrivate ( List form ) { if ( form . size ( ) < 2 ) return false ; Symbol def = symbol ( form . get ( 0 ) ) ; Symbol name = symbol ( form . get ( 1 ) ) ; if ( def = = null | | name = = null ) return false ; return def . getName ( ) . matches ( " (defn-|defvar-) " ) | | ( name . meta ( ) ! = null & & name . meta ( ) . valAt ( Keyword . intern ( " private " ) , false ) . equals ( Boolean . TRUE ) ) ; 
protected StructuredSelection findClosest ( int oFind ) { Object selected = null ; for ( Object o : forms ) { if ( o instanceof Obj ) { Obj obj = ( Obj ) o ; int lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 & & lineNr < = oFind ) { selected = obj ; } } } if ( selected ! = null ) { return new StructuredSelection ( selected ) ; } return StructuredSelection . EMPTY ; } 
private void refreshInput ( ) { Job job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; LineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( new StringReader ( string ) ) ; Object EOF = new Object ( ) ; ArrayList < List > input = new ArrayList < List > ( ) ; Object result = null ; while ( rue ) { try { result = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) break ; if ( result instanceof List ) input . add ( ( List ) result ) ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; LineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( new StringReader ( string ) ) ; Object EOF = new Object ( ) ; ArrayList < List > input = new ArrayList < List > ( ) ; Object result = null ; while ( rue ) { try { result = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) break ; if ( result instanceof List ) input . add ( ( List ) result ) ; } catch ( ReaderException e ) { } 
public void dispose ( ) { try { if ( document ! = null ) document . removeDocumentListener ( documentChangedListener ) ; } catch ( Throwable ) { } try { final TreeViewer viewer = getTreeViewer ( ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( his ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( reeSelectionChangedListener ) ; } catch ( Throwable ) { } try { IPostSelectionProvider selectionProvider = ( IPostSelectionProvider ) editor . getSelectionProvider ( ) ; if ( selectionProvider ! = null ) selectionProvider . removePostSelectionChangedListener ( editorSelectionChangedListener ) ; } catch ( Throwable ) { } super . dispose ( ) ; } 
public void checkClasspath ( ) { IFile classpath = project . getProject ( ) . getFile ( " .classpath " ) ; if ( ! classpath . exists ( ) ) return ; if ( classpathUpdate = = IResource . NULL_STAMP ) { classpathUpdate = classpath . getModificationStamp ( ) ; return ; } if ( classpathUpdate = = classpath . getModificationStamp ( ) ) return ; classpathUpdate = classpath . getModificationStamp ( ) ; } 
private void installMessageDisplayer ( final StyledText extViewer , final MessageProvider hintProvider ) { textViewer . addListener ( SWT . Paint , new Listener ( ) { private int getScrollbarAdjustment ( ) { 
public void handleEvent ( Event event ) { String message = hintProvider . getMessageText ( ) ; if ( message = = null ) return ; } 
public void updateStructuralEditingModeStatusField ( ) { if ( his . statusLineHandler = = null ) { return ; } StatusLineContributionItem field = his . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { String ext = ( isStructuralEditingEnabled ( ) ? " strict/paredit " : " unrestricted " ) + " edit mode " ; 
private static boolean isPrivate ( List form ) { if ( form . size ( ) < 2 ) return false ; Symbol def = symbol ( RT . first ( form ) ) ; Symbol name = symbol ( RT . second ( form ) ) ; if ( def = = null | | name = = null ) return false ; return def . getName ( ) . matches ( " (defn-|defvar-) " ) | | ( name . meta ( ) ! = null & & name . meta ( ) . valAt ( Keyword . intern ( " private " ) , false ) . equals ( Boolean . TRUE ) ) ; 
protected void clean ( IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } try { getClassesFolder ( getProject ( ) ) . delete ( rue , monitor ) ; createClassesFolder ( getProject ( ) , monitor ) ; getClassesFolder ( getProject ( ) ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; getClassesFolder ( getProject ( ) ) . setDerived ( rue ) ; } deleteMarkers(getProject()); } 
public void run ( ) { || viewerWidget.getText().equals(widgetText + "\r") 
public void run ( ) { final IProject project = editorFile . getProject ( ) ; new ClojureLaunchShortcut ( ) . launchProject ( project , ILaunchManager . RUN_MODE , false ) ; DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
 public void run ( ) { REPLView repl = CCWPlugin . getDefault ( ) . getProjectREPL ( project ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { evaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , editorFile . getName ( ) ) ; 
private void evaluateFileText ( REPLView repl , String ext , String filePath , String sourcePath , String fileName ) { ry { final String loadFileText = ( String ) loadFileCommand . invoke ( ext , sourcePath , fileName ) ; 
public void run ( ) { REPLView repl = REPLView . activeREPL . get ( ) ; run ( repl , editor , rue ) ; } 
public static void run ( REPLView repl , ClojureEditor editor , boolean activateREPL ) { if ( repl = = null | | repl . isDisposed ( ) ) { return ; } String ns = editor . findDeclaringNamespace ( ) ; if ( ns = = null ) { put error msg in footer instead 
 public void done ( ) { projectTouchLatch . countDown ( ) ; } 
public void start ( BundleContext context ) hrows Exception { System . out . println ( " Leiningen Plugin start() " ) ; super . start ( context ) ; plugin = his ; } 
public void stop ( BundleContext context ) hrows Exception { System . out . println ( " Leiningen Plugin stop() " ) ; plugin = null ; super . stop ( context ) ; } 
public void initialize ( IJavaProject project , IClasspathEntry [ ] currentEntries ) { _proj = project ; } 
public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NULL ) ; composite . setLayout ( new GridLayout ( ) ) ; composite . setLayoutData ( new GridData ( GridData . VERTICAL_ALIGN_FILL | GridData . HORIZONTAL_ALIGN_FILL ) ) ; composite . setFont ( parent . getFont ( ) ) ; createDirGroup ( composite ) ; createExtGroup ( composite ) ; setControl ( composite ) ; } 
private void createDirGroup ( Composite parent ) { Composite dirSelectionGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 3 ; dirSelectionGroup . setLayout ( layout ) ; dirSelectionGroup . setLayoutData ( new GridData ( GridData . GRAB_HORIZONTAL | GridData . VERTICAL_ALIGN_FILL ) ) ; new Label ( dirSelectionGroup , SWT . NONE ) . setText ( Messages . DirLabel ) ; _dirCombo = new Combo ( dirSelectionGroup , SWT . SINGLE | SWT . BORDER ) ; _dirCombo . setText ( getInitDir ( ) ) ; _dirBrowseButton = new Button ( dirSelectionGroup , SWT . PUSH ) ; _dirBrowseButton . setText ( Messages . Browse ) ; _dirBrowseButton . setLayoutData ( new GridData ( GridData . HORIZONTAL_ALIGN_FILL ) ) ; _dirBrowseButton . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { handleDirBrowseButtonPressed ( ) ; } } ) ; setControl ( dirSelectionGroup ) ; } 
public void widgetSelected ( SelectionEvent e ) { handleDirBrowseButtonPressed ( ) ; } 
private void createExtGroup ( Composite parent ) { Composite extSelectionGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; extSelectionGroup . setLayout ( layout ) ; extSelectionGroup . setLayoutData ( new GridData ( GridData . GRAB_HORIZONTAL | GridData . VERTICAL_ALIGN_FILL ) ) ; new Label ( extSelectionGroup , SWT . NONE ) . setText ( Messages . ExtLabel ) ; _extText = new Text ( extSelectionGroup , SWT . BORDER ) ; _extText . setText ( getInitExts ( ) + " " ) ; setControl ( extSelectionGroup ) ; } 
protected void handleDirBrowseButtonPressed ( ) { DirectoryDialog dialog = new DirectoryDialog ( getContainer ( ) . getShell ( ) , SWT . SAVE ) ; dialog . setMessage ( Messages . DirSelect ) ; dialog . setFilterPath ( getDirValue ( ) ) ; String dir = dialog . open ( ) ; if ( dir ! = null ) { _dirCombo . setText ( dir ) ; 
private boolean isDirValid ( String dir ) { Path dirPath = new Path ( dir ) ; return _proj . getProject ( ) . getLocation ( ) . makeAbsolute ( ) . isPrefixOf ( dirPath ) ; } 
private boolean areExtsValid ( String exts ) { if ( exts = = null | | exts . equals ( " " ) ) { return false ; } else return exts.matches("[a-z_][a-z_,]*"); } 
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) hrows CoreException { assert data instanceof String ; bundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; System . out . println ( " GenericExecutableExtension instance, bundleName= " + bundleName ) ; if ( data instanceof String ) { String name = ( String ) data ; 
public void log ( int severity , Throwable e ) { Status s = new Status ( severity , pluginId , IStatus . OK , e . getMessage ( ) , e ) ; log . log ( s ) ; } 
public void log ( Severity severity , String msg ) { Status s = new Status ( severity . severityCode , pluginId , IStatus . OK , msg , null ) ; log . log ( s ) ; } 
public void start ( BundleContext context ) hrows Exception { super . start ( context ) ; plugin = his ; startClojureCode ( plugin . getBundle ( ) . getBundleContext ( ) ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . require ( bundleContext , " ccw.util.bundle-utils " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , IProgressMonitor monitor ) hrows CoreException { if ( getProject ( ) = = null ) return null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) return null ; if ( projectCljPresentInDelta ( ) ) { try { IJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; ClojureUtils . invoke ( ClasspathContainerNamespace , updateProjectDependencies , javaProject ) ; } catch ( Exception e ) { throw new CoreException ( Activator . createErrorStatus ( " Unexpected exception while trying to update Leiningen Managed Dependencies for project " + getProject ( ) . getName ( ) , e ) ) ; } } return null ; } 
private boolean projectCljPresentInDelta ( ) { IResourceDelta delta = getDelta ( getProject ( ) ) ; IResourceDelta deltaProjClj = delta . findMember ( new Path ( " project.clj " ) ) ; return deltaProjClj ! = null ; } 
public void log ( Severity severity , Throwable e ) { Status s = new Status ( severity . severityCode , pluginId , IStatus . OK , e . getMessage ( ) , e ) ; log . log ( s ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . require ( bundleContext , " ccw.util.eclipse.repl " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.eclipse " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.bundle-utils " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
public void start ( BundleContext context ) hrows Exception { System . out . println ( " Leiningen Plugin start() " ) ; super . start ( context ) ; plugin = his ; startClojureCode ( context ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . require ( bundleContext , " ccw.util.bundle " ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . require ( bundleContext , " ccw.util.eclipse.repl " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.eclipse " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.bundle " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { for ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it . hasNext ( ) ; ) { Object element = it . next ( ) ; IProject project = null ; if ( element instanceof IProject ) { project = ( IProject ) element ; } else if ( element instanceof IAdaptable ) { project = ( IProject ) ( ( IAdaptable ) element ) . getAdapter ( IProject . class ) ; } if ( project ! = null ) { Shell shell = HandlerUtil . getActiveShell ( event ) ; toggleNature ( project , shell ) ; } } } return null ; } 
public void addPages ( ) { super . addPages ( ) ; getStartingPage ( ) . setDescription ( " Create a new Leiningen project. " ) ; getStartingPage ( ) . setTitle ( " Leiningen project " ) ; setWindowTitle ( " New Leiningen project " ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; }); port.setFocus(); return composite; } 
public void verifyText ( VerifyEvent e ) { e . doit = ( e . ext . equals ( " " ) | | Character . isDigit ( e . character ) ) ; } 
protected void clean ( IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } try { getClassesFolder ( getProject ( ) ) . delete ( rue , new SubProgressMonitor ( monitor , 0 ) ) ; createClassesFolder ( getProject ( ) , new SubProgressMonitor ( monitor , 0 ) ) ; getClassesFolder ( getProject ( ) ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; getClassesFolder ( getProject ( ) ) . setDerived ( rue ) ; } deleteMarkers(getProject()); } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { editorSupport . _ ( " configureSourceViewerDecorationSupport " , support , viewer ) ; super . configureSourceViewerDecorationSupport ( support ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String ext ) { boolean firstTime = ( parseState = = null ) ; parseState = editorSupport . _ ( " updateTextBuffer " , parseState , finalText , offset , length , ext ) ; if ( firstTime ) { editorSupport . _ ( " startWatchParseRef " , parseState , his ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { String ext = getDocument ( ) . get ( ) ; updateTextBuffer ( ext , 0 , - 1 , ext ) ; } return editorSupport . _ ( " getParseState " , getDocument ( ) . get ( ) , parseState ) ; } 
public boolean isParseTreeBroken ( ) { return ( Boolean ) editorSupport . _ ( " brokenParseTree? " , getParseState ( ) ) ; } 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) editorSupport . _ ( " getParseTree " , getParseState ( ) ) ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , boolean documentPartitioningChanged ) { return ( IRegion ) opLevelFormsDamager . _ ( " getDamageRegion " , this , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { pareditAutoEditStrategyImpl . _ ( " customizeDocumentCommand " , this , document , command ) ; 
private String removeTrailingSpaces ( String s ) { return ( String ) str . _ ( " rimr " , s ) ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; ry { if ( interactive ! = null ) interactive . close ( ) ; if ( oolConnection ! = null ) oolConnection . close ( ) ; } catch ( IOException e ) { CCWPlugin . logError ( e ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , IProgressMonitor monitor ) hrows CoreException { if ( getProject ( ) = = null ) return null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) return null ; if ( projectCljPresentInDelta ( ) ) { try { IJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; classpathContainer . _ ( updateProjectDependencies , javaProject ) ; } catch ( Exception e ) { throw new CoreException ( Activator . createErrorStatus ( " Unexpected exception while trying to update Leiningen Managed Dependencies for project " + getProject ( ) . getName ( ) , e ) ) ; } } return null ; } 
public void addPages ( ) { super . addPages ( ) ; doAddPages ( ) ; } 
private void doAddPages ( ) { getStartingPage ( ) . setDescription ( " Create a new Leiningen project. " ) ; getStartingPage ( ) . setTitle ( " Leiningen project " ) ; setWindowTitle ( " New Leiningen project " ) ; } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { return doPerformFinish ( ) ; 
private boolean doPerformFinish ( ) { IProject project = getNewProject ( ) ; try { wizard . _ ( performFinish , 
public Object _ ( String varName , Object arg1 ) { return ClojureUtils . invoke ( namespace , varName , arg1 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 , Object arg3 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 , Object arg3 , Object arg4 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 , Object arg3 , Object arg4 , Object arg5 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 , arg5 ) ; } 
public static ClojureInvoker newInvoker ( Plugin plugin , String namespace ) { try { ClojureOSGi . require ( plugin . getBundle ( ) . getBundleContext ( ) , namespace ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return new ClojureInvoker ( namespace ) ; } 
public boolean est ( Object receiver , String property , Object [ ] args , Object expectedValue ) { assert IResource . class . isInstance ( receiver ) ; assert " hasClojureNature " . equals ( property ) ; return hasClojureNature ( ( IResource ) receiver ) ; } 
public static boolean hasClojureNature ( IResource resource ) { ry { IProject project = resource . getProject ( ) ; 
public static boolean isReplQuietLoggingMode ( ) { return CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . REPL_QUIET_LOGGING_MODE ) ; } 
public static boolean isReplExplicitLoggingMode ( ) { return ! isReplQuietLoggingMode ( ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , Messages . REPLViewPreferencePage_activate_autoEval_on_Enter , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , Messages . REPLViewPreferencePage_displayHint , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_QUIET_LOGGING_MODE , 
public void createControl ( Composite parent ) { super . createControl ( parent ) ; createWorkingSetGroup ( ( Composite ) getControl ( ) , getSelection ( ) , new String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
private void doLeinAddPagesPre ( ) { templatePage = new WizardNewLeiningenProjectTemplatePage ( " Choose Newnew Template " ) ; this . addPage ( emplatePage ) ; } 
private void doLeinAddPagesPost ( ) { getStartingPage ( ) . setDescription ( " Create a new Leiningen project. " ) ; getStartingPage ( ) . setTitle ( " Leiningen project " ) ; setWindowTitle ( " New Leiningen project " ) ; } 
public void run ( IProgressMonitor monitor ) throws InvocationTargetException { CreateProjectOperation op = new CreateProjectOperation ( description , ResourceMessages . NewProject_windowTitle ) ; try { see bug https:bugs.eclipse.org/bugs/show_bug.cgi?id=219901 
public void init ( IWorkbench workbench , IStructuredSelection currentSelection ) { super . init ( workbench , currentSelection ) ; setNeedsProgressMonitor ( rue ) ; setWindowTitle ( ResourceMessages . NewProject_windowTitle ) ; } 
protected void initializeDefaultPageImageDescriptor ( ) { ImageDescriptor desc = IDEWorkbenchPlugin . getIDEImageDescriptor ( " wizban/newprj_wiz.png " ) ; } 
private static void openInNewWindow ( IPerspectiveDescriptor desc ) { PlatformUI.getWorkbench().openWorkbenchWindow(desc.getId(), 
public boolean performFinish ( ) { if ( newProjectWizardPerformFinish ( ) ) { return doPerformFinish ( ) ; 
private boolean newProjectWizardPerformFinish ( ) { createNewProject ( ) ; if ( newProject = = null ) { return false ; } IWorkingSet [ ] workingSets = mainPage . getSelectedWorkingSets ( ) ; getWorkbench ( ) . getWorkingSetManager ( ) . addToWorkingSets ( newProject , workingSets ) ; updatePerspective ( ) ; selectAndReveal ( newProject ) ; return rue ; } 
private static void replaceCurrentPerspective ( IPerspectiveDescriptor persp ) { } 
public void setInitializationData ( IConfigurationElement cfig , String propertyName , Object data ) { configElement = cfig ; } 
private static void addPerspectiveAndDescendants ( List perspectiveIds , String id ) { IPerspectiveRegistry registry = PlatformUI . getWorkbench ( ) . getPerspectiveRegistry ( ) ; IPerspectiveDescriptor [ ] perspectives = registry . getPerspectives ( ) ; for ( int i = 0 ; i < perspectives . length ; i + + ) { @issue illegal ref to workbench internal class; 
public void handleEvent ( Event e ) { boolean valid = validatePage ( ) ; setPageComplete ( valid ) ; } 
public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NULL ) ; initializeDialogUnits ( parent ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( composite , IIDEHelpContextIds . NEW_PROJECT_WIZARD_PAGE ) ; composite . setLayout ( new GridLayout ( ) ) ; composite . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; createProjectNameGroup ( composite ) ; setPageComplete ( validatePage ( ) ) ; Show description on opening setErrorMessage(null); setMessage(null); setControl(composite); Dialog.applyDialogFont(composite); } 
public WorkingSetGroup createWorkingSetGroup ( Composite composite , IStructuredSelection selection , String [ ] supportedWorkingSetTypes ) { if ( workingSetGroup ! = null ) return workingSetGroup ; workingSetGroup = new WorkingSetGroup ( composite , selection , supportedWorkingSetTypes ) ; return workingSetGroup ; } 
public void reportError ( String errorMessage , boolean infoOnly ) { if ( infoOnly ) { setMessage ( errorMessage , IStatus . INFO ) ; setErrorMessage ( null ) ; } else setErrorMessage ( errorMessage ) ; boolean valid = errorMessage = = null ; if ( valid ) { valid = validatePage ( ) ; } setPageComplete ( valid ) ; } 
private final void createProjectNameGroup ( Composite parent ) { } projectNameField.addListener(SWT.Modify, nameModifyListener); } 
protected boolean validatePage ( ) { IWorkspace workspace = IDEWorkbenchPlugin . getPluginWorkspace ( ) ; String projectFieldContents = getProjectNameFieldValue ( ) ; if ( projectFieldContents . equals ( " " ) ) { $NON-NLS-1$ setErrorMessage(null); setMessage(IDEWorkbenchMessages.WizardNewProjectCreationPage_projectNameEmpty); return false; } IStatus nameStatus = workspace.validateName(projectFieldContents, IResource.PROJECT); if (!nameStatus.isOK()) { setErrorMessage(nameStatus.getMessage()); return false; } setErrorMessage(null); setMessage(null); return true; } 
 public void handleEvent ( Event e ) { boolean valid = validatePage ( ) ; setPageComplete ( valid ) ; } 
public void createControl ( Composite parent ) { super . createControl ( parent ) ; createLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; createWorkingSetGroup ( ( Composite ) getControl ( ) , this . newLeiningenProjectWizard . getSelection ( ) , new String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
public void createLeinTemplateGroup ( Composite parent ) { } 
protected boolean validatePage ( ) { if ( super . validatePage ( ) ) { String emplateFieldContents = getTemplateNameFieldValue ( ) ; 
public void stop ( BundleContext context ) hrows Exception { plugin = null; super.stop(context); } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { for ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it . hasNext ( ) ; ) { Object element = it . next ( ) ; IProject project = null ; if ( element instanceof IProject ) { project = ( IProject ) element ; } else if ( element instanceof IAdaptable ) { project = ( IProject ) ( ( IAdaptable ) element ) . getAdapter ( IProject . class ) ; } if ( project ! = null ) { toggleNature ( project , false ) ; } } } return null ; } 
public void run ( ) { MessageDialog . openInformation ( Display . getCurrent ( ) . getActiveShell ( ) , itle , message ) ; } 
private static boolean doToggleNature ( IProject project ) hrows CoreException { IProjectDescription description = project . getDescription ( ) ; String [ ] natures = description . getNatureIds ( ) ; List < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; boolean natureFound = false ; for ( String nature : natures ) { if ( nature . equals ( ClojureCore . NATURE_ID ) ) { } 
public synchronized void start ( ) { elementChangedListener = new ClojurePackageElementChangeListener ( ) ; JavaCore . addElementChangedListener ( elementChangedListener ) ; } 
public synchronized void stop ( ) { if ( elementChangedListener = = null ) { JavaCore . removeElementChangedListener ( elementChangedListener ) ; } elementChangedListener = null ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { try { if ( project . hasNature ( ClojureCore . NATURE_ID ) ) { return Status . CANCEL_STATUS ; } boolean hasClojurePackage = JavaCore . create ( project ) . findElement ( ClojurePackageElementChangeListener . CLOJURE_PACKAGE_PATH ) ! = null ; if ( hasClojurePackage ) { ToggleNatureCommand . oggleNature ( project , rue ) ; } } catch ( CoreException e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , e ) ; } return Status . OK_STATUS ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { IJavaElementDelta delta = javaModelEvent . getDelta ( ) ; IJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
private boolean visitPackageFragmentRootDelta ( IJavaElementDelta packageFragmentRootDelta ) { IPackageFragmentRoot packageElement = ( IPackageFragmentRoot ) packageFragmentRootDelta . getElement ( ) ; if ( isClojureElement ( packageElement ) ) { addClojureNature ( packageElement . getJavaProject ( ) . getProject ( ) ) ; 
private boolean isClojureElement ( IPackageFragmentRoot packageFragmentRoot ) { return packageFragmentRoot . getPackageFragment ( CLOJURE_PACKAGE ) . exists ( ) ; } 
private void addClojureNature ( final IProject project ) { WorkspaceJob job = new ClojureNatureAdderWorkspaceJob ( project ) ; job . schedule ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { try { if ( ! project . exists ( ) | | ! project . isOpen ( ) ) return Status . CANCEL_STATUS ; if ( project . hasNature ( ClojureCore . NATURE_ID ) ) { return Status . CANCEL_STATUS ; } boolean hasClojurePackage = JavaCore . create ( project ) . findElement ( ClojurePackageElementChangeListener . CLOJURE_PACKAGE_PATH ) ! = null ; if ( hasClojurePackage ) { ToggleNatureCommand . oggleNature ( project , rue ) ; } } catch ( CoreException e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , e ) ; } return Status . OK_STATUS ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { if ( ! CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) return ; IJavaElementDelta delta = javaModelEvent . getDelta ( ) ; IJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public synchronized void start ( ) { elementChangedListener = new ClojurePackageElementChangeListener ( ) ; JavaCore . addElementChangedListener ( elementChangedListener ) ; elementChangedListener . performFullScan ( ) ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) return ; IJavaElementDelta delta = javaModelEvent . getDelta ( ) ; IJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
private void addClojureNature ( final IProject project ) { WorkspaceJob job = new ClojureNatureAdderWorkspaceJob ( project ) ; job . schedule ( 100 ) ; } 
private boolean isCandidateClojureProject ( IProject project ) { try { return ( project . exists ( ) 
protected void doSetInput ( IEditorInput input ) hrows CoreException { super . doSetInput ( input ) ; } 
public void handleEvent ( Event e ) { boolean valid = validatePage ( ) ; setPageComplete ( valid ) ; } 
public void createControl ( Composite parent ) { super . createControl ( parent ) ; createLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; createWorkingSetGroup ( ( Composite ) getControl ( ) , this . newLeiningenProjectWizard . getSelection ( ) , new String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
public void createLeinTemplateGroup ( Composite parent ) { } 
protected boolean validatePage ( ) { if ( super . validatePage ( ) ) { String emplateFieldContents = getTemplateNameFieldValue ( ) ; 
private static IEditorInput findEditorInput ( IPackageFragmentRoot packageFragmentRoot , String searchedPackage , String searchedFileName ) throws JavaModelException { packageFragmentRoot, 
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) hrows CoreException { bundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; System . out . println ( " GenericExecutableExtension instance, bundleName= " + bundleName ) ; if ( data instanceof String ) { String name = ( String ) data ; 
public void run ( ) { evalExpression(); 
public void run ( ) { final IProject project = editorFile . getProject ( ) ; new ClojureLaunchShortcut ( ) . launchProject ( project , ILaunchManager . RUN_MODE , null ) ; DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public ILaunch launchProject ( IProject project , String mode , Boolean activateAutoReload ) { return launchProject ( project , new IFile [ ] { } , mode , activateAutoReload ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] filesToLaunch , String mode , Boolean activateAutoReload ) { activateAutoReload = activateAutoReload ! = null ? activateAutoReload : ( filesToLaunch . length = = 0 ) ; ry { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; if ( files = = null ) files = new IFile [ ] { } ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType ype = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_CONFIG_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = ype . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { hrow new RuntimeException ( ce ) ; } return config ; } 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { errorMessage = " " ; assistant . setStatusMessage ( " " ) ; final PrefixInfo prefixInfo ; try { prefixInfo = computePrefix ( viewer , offset ) ; 
private List < ICompletionProposal > computeClojureFullyQualifiedSymbolsProposals ( PrefixInfo prefixInfo ) { final List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; final List < List > dynamicSymbols = dynamicComplete ( prefixInfo . currentNamespace , prefixInfo . namePart , editor , prefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureSymbolsProposals ( PrefixInfo prefixInfo ) { final List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; final List < List > dynamicSymbols = dynamicComplete ( prefixInfo . currentNamespace , prefixInfo . namePart , editor , prefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureNamespacesProposals ( PrefixInfo prefixInfo ) { final List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; final List < List > dynamicSymbols = dynamicNamespaceComplete ( prefixInfo . prefix ) ; } 
public void beginReporting ( ) { super . beginReporting ( ) ; } 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { counter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { (IMethod) match.getElement(), methodPrefix, 
public void endReporting ( ) { super . endReporting ( ) ; System.out.println("end reporting : count=" + 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . METHOD } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH / * * | 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { return new String [ ] { prefixInfo . nsPart + " . " + prefixInfo . namePart } ; 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { return new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , prefixInfo . nsPart + " / " 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . TYPE , IJavaSearchConstants . TYPE } ; 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { return new String [ ] { prefixInfo . prefix , prefixInfo . prefix + " * " } ; 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { return new ClassLazyCompletionProposal ( ( IType ) match . getElement ( ) , prefixInfo . prefix , 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . PACKAGE } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_PATTERN_MATCH / * * | 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { return new PackageLazyCompletionProposal ( ( IPackageFragment ) match . getElement ( ) , 
private boolean checkJavaPrefixLength ( PrefixInfo prefixInfo ) { if ( prefixInfo . prefix . length ( ) < JAVA_PREFIX_MIN_LENGTH ) { CCWPlugin 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { proposals . add ( searchType . lazyCompletionProposal ( prefixInfo , editor , match ) ) ; 
private boolean invalidSymbolCharacter ( char c ) { if ( Character . isWhitespace ( c ) ) return rue ; char [ ] invalidChars = { '(' , ')' , '[' , ']' , '{' , '}' , '\'' , '@' , '~' , '^' , '`' , '#' , '"' } ; for ( int i = 0 ; i < invalidChars . length ; i + + ) { if ( invalidChars [ i ] = = c ) return rue ; } return false ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , IClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { return Collections . emptyList ( ) ; } if ( prefix = = null ) { return Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Connection connection = repl . getToolingConnection ( ) ; Response response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " rue " : " false " ) + " ) " ) ; return ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { return Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; Connection connection = repl . getToolingConnection ( ) ; Response response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; return ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; 
private static Object extractSingleValue ( Response response , Object defaultValueIfNil ) { List vs = response . values ( ) ; if ( vs . isEmpty ( ) | | vs . get ( 0 ) = = null ) { return defaultValueIfNil ; 
public IContextInformation [ ] computeContextInformation ( ITextViewer viewer , int offset ) { return new IContextInformation [ ] { new IContextInformation ( ) { 
private String shortenNamespace ( String namespace ) { String [ ] segments = namespace . split ( " \\ . " ) ; int nextToLast = segments . length - 2 ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < nextToLast ; i + + ) { sb . append ( segments [ i ] . charAt ( 0 ) ) ; sb . append ( '.' ) ; } if ( nextToLast > = 0 ) { sb . append ( segments [ nextToLast ] ) ; sb . append ( '.' ) ; } sb . append ( segments [ nextToLast + 1 ] ) ; return sb . oString ( ) ; } 
private void updatePartNameAndDescription ( ) { final String maybeNamespace = his . findDeclaringNamespace ( ) ; if ( ! StringUtils . isEmpty ( maybeNamespace ) ) { this . setPartName ( shortenNamespace ( maybeNamespace ) ) ; 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
protected void editorSaved ( ) { super . editorSaved ( ) ; updatePartNameAndDescription ( ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
private boolean isEarmuffedVar ( String symbol ) { return ( symbol . startsWith ( " * " ) | | symbol . contains ( " /* " ) ) & & 
private static String namespaceToPackage ( final String searchedNS ) { String packagePart = ( searchedNS . contains ( " . " ) ) ? searchedNS . substring ( 0 , searchedNS . lastIndexOf ( " . " ) ) : " " ; return packagePart . replace ( '-' , '_' ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi . require ( bundleContext , " ccw.util.eclipse.repl " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.eclipse " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.doc-utils " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.bundle " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; ClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
public void setInitializationData ( IConfigurationElement config , String propertyName , Object data ) hrows CoreException { bundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; if ( data instanceof String ) { String name = ( String ) data ; 
public REPLView getCorrespondingREPL ( ) { IFile file = ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( file ! = null ) { REPLView repl = CCWPlugin . getDefault ( ) . getProjectREPL ( file . getProject ( ) ) ; if ( repl ! = null ) { return repl ; } } } 
protected boolean validatePage ( ) { if ( super . validatePage ( ) ) { String mess = ( String ) wizard . _ ( checkProjectName , getProjectName ( ) ) ; 
public REPLView getCorrespondingREPL ( ) { } 
public void keyPressed ( KeyEvent e ) { if ( e . character = = SWT . ESC ) { if ( ! isContentAssistantActive ) { 
private void addKeyListenerFirst ( Control control , KeyListener listener ) { Listener [ ] keyDownListeners = control . getListeners ( SWT . KeyDown ) ; Listener [ ] keyUpListeners = control . getListeners ( SWT . KeyUp ) ; removeAll ( control , SWT . KeyDown , keyDownListeners ) ; removeAll ( control , SWT . KeyUp , keyUpListeners ) ; control . addKeyListener ( listener ) ; addAll ( control , SWT . KeyDown , keyDownListeners ) ; addAll ( control , SWT . KeyUp , keyUpListeners ) ; } 
private void removeAll ( Control control , int eventType , Listener [ ] listeners ) { for ( Listener listener : listeners ) { control . removeListener ( eventType , listener ) ; 
private void addAll ( Control control , int eventType , Listener [ ] listeners ) { for ( Listener listener : listeners ) { control . addListener ( eventType , listener ) ; 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { fForegroundColor . dispose ( ) ; fForegroundColor = null ; } if ( fBackgroundColor ! = null ) { fBackgroundColor . dispose ( ) ; fBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { fSelectionForegroundColor . dispose ( ) ; fSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { fSelectionBackgroundColor . dispose ( ) ; fSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( his ) ; if ( fSelectionHistory ! = null ) { fSelectionHistory . dispose ( ) ; fSelectionHistory = null ; } super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public boolean isContentAssistantActive ( ) { return isContentAssistantActive ; } 
public void assistSessionStarted ( ContentAssistEvent event ) { ( ( ClojureSourceViewer ) sourceViewer ) . setContentAssistantActive ( rue ) ; } 
public void assistSessionEnded ( ContentAssistEvent event ) { ( ( ClojureSourceViewer ) sourceViewer ) . setContentAssistantActive ( false ) ; } 
public void handleResponse ( Response resp , String expression ) { handleResponses . invoke ( his , logPanel , expression , resp . seq ( ) ) ; } 
private void prepareView ( ) hrows Exception { sessionId = interactive . newSession ( null ) ; evalExpression = ( IFn ) configureREPLView . invoke ( his , logPanel , interactive . client , sessionId ) ; } 
public Set < String > getAvailableOperations ( ) hrows IllegalStateException { if ( describeInfo = = null ) { Response r = oolConnection . send ( " op " , " describe " ) ; if ( ! r . statuses ( ) . contains ( " done " ) ) hrow new IllegalStateException ( " Invalid response to \" describe \" request: " + r . combinedResponse ( ) ) ; describeInfo = r . combinedResponse ( ) ; } Map < String , Object > ops = ( Map < String , Object > ) describeInfo . get ( " ops " ) ; return ops = = null ? new HashSet ( ) : ops . keySet ( ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { ry { REPLView . connect ( repl . getConnection ( ) . url ) ; 
public void run ( ) { TreeViewer reeViewer = getTreeViewer ( ) ; if ( reeViewer ! = null ) { treeViewer . getTree ( ) . setRedraw ( false ) ; 
private static String getSecondaryId ( ) { synchronized ( SECONDARY_VIEW_IDS ) { String id = SECONDARY_VIEW_IDS . iterator ( ) . next ( ) ; 
private static void releaseSecondaryId ( String id ) { synchronized ( SECONDARY_VIEW_IDS ) { SECONDARY_VIEW_IDS . add ( id ) ; 
public static REPLView connect ( String url , IConsole console , ILaunch launch ) hrows Exception { String secondaryId ; REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . launch = launch ; return repl . configure ( url ) ? repl : null ; } 
public void dispose ( ) { super . dispose ( ) ; releaseSecondaryId ( secondaryId ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; ry { if ( interactive ! = null ) interactive . close ( ) ; if ( oolConnection ! = null ) oolConnection . close ( ) ; } catch ( IOException e ) { CCWPlugin . logError ( e ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public Set < String > getAvailableOperations ( ) hrows IllegalStateException { if ( describeInfo = = null ) { Response r = oolConnection . send ( " op " , " describe " ) ; working around the fact that nREPL < 0.2.0-beta9 does *not* send a :done status when an operation is unknown! TODO remove this and just check r.statuses() after we can assume usage of later versions of nREPL Object status = ((Map<String, String>)r.seq().first()).get(Keyword.intern("status")); if (clojure.lang.Util.equals(status, "unknown-op") || (status instanceof Collection && ((Collection)status).contains("error"))) { CCWPlugin.logError("Invalid response to \"describe\" request"); describeInfo = new HashMap(); } else { describeInfo = r.combinedResponse(); } } Map<String, Object> ops = (Map<String, Object>)describeInfo.get("ops"); return ops == null ? new HashSet() : ops.keySet(); } 
public void updateStructuralEditingModeStatusField ( ) { if ( his . statusLineHandler = = null ) { return ; } StatusLineContributionItem field = his . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { field . setText ( ( isStructuralEditingEnabled ( ) ? " strict/paredit " : " unrestricted " ) 
private boolean isEarmuffedVar ( String symbol ) { return ( ! symbol . equals ( " * " ) & & 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { fForegroundColor . dispose ( ) ; fForegroundColor = null ; } if ( fBackgroundColor ! = null ) { fBackgroundColor . dispose ( ) ; fBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { fSelectionForegroundColor . dispose ( ) ; fSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { fSelectionBackgroundColor . dispose ( ) ; 
public void initializeViewerColors ( ) { initializeViewerColors ( getTextWidget ( ) , fPreferenceStore , editorColors ) ; if ( fPreferenceStore ! = null ) { CCWPlugin . registerEditorColors ( fPreferenceStore , getTextWidget ( ) . getForeground ( ) . getRGB ( ) ) ; 
public static void initializeViewerColors ( StyledText styledText , IPreferenceStore preferenceStore , EditorColors editorColors ) { if ( preferenceStore ! = null ) { ----------- foreground color -------------------- 
public void unconfigure ( ) { editorColors . unconfigure ( ) ; if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( his ) ; if ( fSelectionHistory ! = null ) { fSelectionHistory . dispose ( ) ; fSelectionHistory = null ; } super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public void run ( ) { getTextWidget ( ) . setBackground ( structuralEditionPossible ? editorColors . fBackgroundColor : Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_GRAY ) ) ; getTextWidget ( ) . setToolTipText ( structuralEditionPossible ? null : " Unparseable source code. Structural Edition temporarily disabled. " ) ; } 
public void widgetDisposed ( DisposeEvent e ) { logPanelEditorColors . unconfigure ( ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { initializeLogPanelColors ( ) ; } 
private void initializeLogPanelColors ( ) { ClojureSourceViewer . initializeViewerColors ( logPanel , getPreferences ( ) , logPanelEditorColors ) ; 
public void widgetDisposed ( DisposeEvent e ) { JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; prefs . removePropertyChangeListener ( prefsListener ) ; activeREPL . compareAndSet ( REPLView . his , null ) ; } 
public void widgetDisposed ( DisposeEvent e ) { getPreferenceStore ( ) . removePropertyChangeListener ( prefsListener ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , Messages . ClojurePreferencePage_show_more_context_in_tabs , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public synchronized void stop ( ) { if ( elementChangedListener ! = null ) { JavaCore . removeElementChangedListener ( elementChangedListener ) ; 
public boolean est ( Object receiver , String property , Object [ ] args , Object expectedValue ) { assert " hasClojureNature " . equals ( property ) ; if ( receiver instanceof IResource ) return hasClojureNature ( ( IResource ) receiver ) ; 
private static void releaseSecondaryId ( String id ) { assert id ! = null ; synchronized ( SECONDARY_VIEW_IDS ) { SECONDARY_VIEW_IDS . add ( id ) ; 
public void dispose ( ) { super . dispose ( ) ; if ( secondaryId ! = null ) { releaseSecondaryId ( secondaryId ) ; } fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; ry { if ( interactive ! = null ) interactive . close ( ) ; 
public void run ( ) { if ( getControl ( ) . isDisposed ( ) ) return ; TreeViewer reeViewer = getTreeViewer ( ) ; if ( reeViewer ! = null ) { treeViewer . getTree ( ) . setRedraw ( false ) ; 
public void focusLost ( FocusEvent e ) { for ( IContextActivation activation : activations ) { ( ( IContextService ) getSite ( ) . getService ( IContextService . class ) ) . deactivateContext ( activation ) ; } activations = new ArrayList ( ) ; } 
private void activate ( String contextId ) { activations . add ( ( ( IContextService ) getSite ( ) . getService ( IContextService . class ) ) . activateContext ( contextId ) ) ; } 
public void focusGained ( FocusEvent e ) { activate ( IClojureEditor . KEY_BINDING_SCOPE ) ; activate ( CCW_UI_CONTEXT_REPL ) ; } 
protected void activateContext ( ) { if ( handlerActivations . isEmpty ( ) ) { activateHandler ( ISourceViewer . QUICK_ASSIST , 
protected void activateHandler ( int operation , String actionDefinitionId ) { StyledText extWidget = extViewer . getTextWidget ( ) ; IHandler actionHandler = createActionHandler ( operation , actionDefinitionId ) ; IHandlerActivation handlerActivation = handlerService . activateHandler ( actionDefinitionId , actionHandler , new ActiveFocusControlExpression ( extWidget ) ) ; handlerActivations . add ( handlerActivation ) ; } 
private IHandler createActionHandler ( final int operation , String actionDefinitionId ) { Action action = new Action ( ) { @Override public void run ( ) { if ( extViewer . canDoOperation ( operation ) ) { textViewer . doOperation ( operation ) ; } } } ; action . setActionDefinitionId ( actionDefinitionId ) ; return new ActionHandler ( action ) ; } 
public void run ( ) { if ( extViewer . canDoOperation ( operation ) ) { textViewer . doOperation ( operation ) ; 
protected void deactivateContext ( ) { if ( ! handlerActivations . isEmpty ( ) ) { for ( IHandlerActivation activation : handlerActivations ) { 
public void collectExpressionInfo ( ExpressionInfo info ) { info . markDefaultVariableAccessed ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) hrows Exception { ClojureOSGi.require(bundleContext, "paredit.static-analysis"); } 
public static String findDeclaringNamespace ( Map ree ) { Var findNamespace = RT . var ( " paredit.static-analysis " , " find-namespace " ) ; try { return ( String ) findNamespace . invoke ( ree ) ; 
public void unconfigure ( ) { fForegroundColor = unconfigure ( fForegroundColor ) ; fBackgroundColor = unconfigure ( fBackgroundColor = null ) ; fSelectionForegroundColor = unconfigure ( fSelectionForegroundColor ) ; fSelectionBackgroundColor = unconfigure ( fSelectionBackgroundColor ) ; fCurrentLineBackgroundColor = unconfigure ( fCurrentLineBackgroundColor ) ; } 
private Color unconfigure ( Color c ) { if ( c ! = null ) { c . dispose ( ) ; } return null ; } 
static public Color createColor ( IPreferenceStore store , String key , Display display ) { RGB rgb = getRGBColor ( store , key ) ; return ( rgb ! = null ) ? new Color ( display , rgb ) : null ; } 
public void initializeViewerColors ( ) { initializeViewerColors ( getTextWidget ( ) , fPreferenceStore , editorColors ) ; if ( fPreferenceStore ! = null ) { CCWPlugin . registerEditorColors ( fPreferenceStore , getTextWidget ( ) . getForeground ( ) . getRGB ( ) ) ; 
private void copyToLog ( StyledText s ) { sadly, need to reset text on the ST in order to get formatting/style ranges... s.setText(boostIndent.matcher(s.getText()).replaceAll(" ").replaceFirst("^\\s+", "=> ")); int start = logPanel.getCharCount(); try { log.invoke(this, logPanel, s.getText(), inputExprLogType); 
public void sendInterrupt ( ) { log . invoke ( his , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; } 
public void optionsChanged ( DebugOptions options ) { DEBUG = options . isDebugEnabled ( ) ; TRACE = options . newDebugTrace ( getBundle ( ) . getSymbolicName ( ) , CCWPlugin . his . getClass ( ) ) ; traceOptions . updateOptions ( options ) ; } 
public static boolean isTraceOptionEnabled ( String raceOption ) { TraceOptions raceOptions = CCWPlugin . getDefault ( ) . raceOptions ; if ( raceOptions = = null ) { return false ; 
private void enableTracing ( BundleContext context ) { traceOptions = new TraceOptions ( context . getBundle ( ) . getSymbolicName ( ) ) ; Dictionary < String , String > props = new Hashtable < String , String > ( ) ; props . put ( DebugOptions . LISTENER_SYMBOLICNAME , getBundle ( ) . getSymbolicName ( ) ) ; debugOptionsListenerRegistration = context . registerService ( DebugOptionsListener . class . getName ( ) , 
private void disableTracing ( BundleContext context ) { if ( debugOptionsListenerRegistration ! = null ) { debugOptionsListenerRegistration . unregister ( ) ; 
public void stop ( BundleContext context ) hrows Exception { disableTracing ( context ) ; plugin = null; super.stop(context); } 
public static void race ( final String raceOption , final Object . . . messageParts ) { if ( CCWPlugin . DEBUG & & CCWPlugin . isTraceOptionEnabled ( raceOption ) ) { StringBuilder sb = new StringBuilder ( ) ; 
public void updateOptions ( DebugOptions options ) { for ( String option : his . options . keySet ( ) ) { this . options . put ( option , options . getBooleanOption ( bundleSymbolicName + " / " + option , false ) ) ; 
public boolean isOptionEnabled ( String option ) { Boolean res = options . get ( option ) ; if ( res ! = null ) { return res ; 
public void widgetDisposed ( DisposeEvent e ) { CCWPlugin . race ( TraceOptions . REPL , " REPLView " , REPLView . his . secondaryId , " parent composite disposed " ) ; JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; prefs . removePropertyChangeListener ( prefsListener ) ; activeREPL . compareAndSet ( REPLView . his , null ) ; } 
public void focusGained ( FocusEvent e ) { CCWPlugin . race ( TraceOptions . REPL_FOCUS , " focus gained, marking repl as active " ) ; activeREPL . set ( REPLView . his ) ; NamespaceBrowser . setREPLConnection ( oolConnection ) ; } 
public void init ( IViewSite site ) hrows PartInitException { super . init ( site ) ; activeREPL . set ( REPLView . his ) ; } 
public void stop ( BundleContext context ) hrows Exception { plugin = null; super.stop(context); } 
public static void logError ( String msg ) { getTracer ( ) . race ( TraceOptions . LOG_ERROR , " ERROR - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg ) ) ; } 
public static void logError ( String msg , Throwable e ) { getTracer ( ) . race ( TraceOptions . LOG_ERROR , e , " ERROR - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg , e ) ) ; } 
public static void logError ( Throwable e ) { getTracer ( ) . race ( TraceOptions . LOG_ERROR , e , " ERROR - " ) ; plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public static void logWarning ( String msg ) { getTracer ( ) . race ( TraceOptions . LOG_WARNING , " WARNING - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg ) ) ; } 
public static void logWarning ( String msg , Throwable e ) { getTracer ( ) . race ( TraceOptions . LOG_WARNING , e , " WARNING - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg , e ) ) ; } 
public static void logWarning ( Throwable e ) { getTracer ( ) . race ( TraceOptions . LOG_WARNING , e ) ; plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public static void log ( String msg ) { getTracer ( ) . race ( TraceOptions . LOG_INFO , " INFO - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . INFO , PLUGIN_ID , msg ) ) ; } 
public void widgetDisposed ( DisposeEvent e ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " REPLView " , REPLView . his . secondaryId , " parent composite disposed " ) ; JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; prefs . removePropertyChangeListener ( prefsListener ) ; activeREPL . compareAndSet ( REPLView . his , null ) ; } 
public void focusGained ( FocusEvent e ) { getTracer ( ) . race ( TraceOptions . REPL_FOCUS , " focus gained, marking repl as active " ) ; activeREPL . set ( REPLView . his ) ; NamespaceBrowser . setREPLConnection ( oolConnection ) ; } 
boolean isEnabled ( String raceOption ) ; void race ( String raceOption , Object . . . message ) ; void race ( String raceOption , Throwable hrowable , Object . . . message ) ; void raceDumpStack ( String raceOption ) ; void raceEntry ( String raceOption ) ; void raceEntry ( String raceOption , Object . . . arguments ) ; void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void race ( String raceOption , Object . . . message ) ; void race ( String raceOption , Throwable hrowable , Object . . . message ) ; void raceDumpStack ( String raceOption ) ; void raceEntry ( String raceOption ) ; void raceEntry ( String raceOption , Object . . . arguments ) ; void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void race ( String raceOption , Throwable hrowable , Object . . . message ) ; void raceDumpStack ( String raceOption ) ; void raceEntry ( String raceOption ) ; void raceEntry ( String raceOption , Object . . . arguments ) ; void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceDumpStack ( String raceOption ) ; void raceEntry ( String raceOption ) ; void raceEntry ( String raceOption , Object . . . arguments ) ; void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceEntry ( String raceOption ) ; void raceEntry ( String raceOption , Object . . . arguments ) ; void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceEntry ( String raceOption , Object . . . arguments ) ; void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
public void race ( String raceOption , Object . . . message ) { } public void race ( String raceOption , Throwable hrowable , Object . . . message ) { } public void raceDumpStack ( String raceOption ) { } public void raceEntry ( String raceOption ) { } public void raceEntry ( String raceOption , Object . . . arguments ) { } public void raceExit ( String raceOption ) { } public void raceExit ( String raceOption , Object returnValue ) { } } 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { } public void raceDumpStack ( String raceOption ) { } public void raceEntry ( String raceOption ) { } public void raceEntry ( String raceOption , Object . . . arguments ) { } public void raceExit ( String raceOption ) { } public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceDumpStack ( String raceOption ) { } public void raceEntry ( String raceOption ) { } public void raceEntry ( String raceOption , Object . . . arguments ) { } public void raceExit ( String raceOption ) { } public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceEntry ( String raceOption ) { } public void raceEntry ( String raceOption , Object . . . arguments ) { } public void raceExit ( String raceOption ) { } public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceEntry ( String raceOption , Object . . . arguments ) { } public void raceExit ( String raceOption ) { } public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceExit ( String raceOption ) { } public void raceExit ( String raceOption , Object returnValue ) { } } 
public void optionsChanged ( DebugOptions options ) { if ( options . isDebugEnabled ( ) ) { debugTrace = options . newDebugTrace ( bundleSymbolicName , Tracer . class ) ; } else { debugTrace = null ; } updateOptions ( options ) ; } 
private void enableTracing ( BundleContext context ) { Dictionary < String , String > props = new Hashtable < String , String > ( ) ; props . put ( DebugOptions . LISTENER_SYMBOLICNAME , context . getBundle ( ) . getSymbolicName ( ) ) ; context . registerService ( DebugOptionsListener . class . getName ( ) , 
private void updateOptions ( DebugOptions options ) { for ( String option : his . options . keySet ( ) ) { his . options . put ( option , options . getBooleanOption ( bundleSymbolicName + " / " + option , false ) ) ; 
public boolean isEnabled ( String raceOption ) { if ( debugTrace = = null ) { return false ; } Boolean res = options . get ( raceOption ) ; if ( res ! = null ) { return res ; 
private String buildMessage ( Object [ ] message ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object m : message ) { sb . append ( m ) ; } return sb . oString ( ) ; } 
public void race ( String raceOption , Object . . . message ) { if ( isEnabled ( raceOption ) ) { debugTrace . race ( " / " + raceOption , buildMessage ( message ) ) ; 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { if ( isEnabled ( raceOption ) ) { debugTrace . race ( " / " + raceOption , buildMessage ( message ) , hrowable ) ; 
public void raceDumpStack ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceDumpStack ( " / " + raceOption ) ; 
public void raceEntry ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( " / " + raceOption ) ; 
public void raceEntry ( String raceOption , Object . . . arguments ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( " / " + raceOption , arguments ) ; 
public void raceExit ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( " / " + raceOption ) ; 
public void raceExit ( String raceOption , Object returnValue ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( " / " + raceOption , returnValue ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { LaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public static String getProjectName ( ILaunch launch ) { return launch . getAttribute ( LaunchUtils . LAUNCH_ATTR_PROJECT_NAME ) ; } 
private static void inUIThreadSetREPLConnection ( Connection repl ) { IWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; return ; } IWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activePage is null " ) ; } IViewPart [ ] views = activePage . getViews ( ) ; NamespaceBrowser co = null ; for ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { co = ( NamespaceBrowser ) v ; break ; } } if ( co = = null ) { return ; } co . reset ( repl ) ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Text ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; don't know much about swt layouts yet :-( hosts.setSelection(new Point(0, hosts.getText().length())); new Label(parent, 0).setText("Port"); port = new Text(parent, SWT.BORDER); port.setFocus(); return composite; } 
protected void okPressed ( ) { url = String . format ( " nrepl:%s:%s " , hosts . getText ( ) , port . getText ( ) ) ; super . okPressed ( ) ; } 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (if-not *e (println \" No prior exception bound to *e. \" ) (require 'clojure.repl) (clojure.repl/pst *e))) " , false , false ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; }); port.setFocus(); return composite; } 
public void verifyText ( VerifyEvent e ) { String newText = port . getText ( ) . substring ( 0 , e . start ) + e . ext + port . getText ( ) . substring ( e . end ) ; e . doit = newText . matches ( " \\ d* " ) ; } 
 private void connectRepl ( ) { ry { REPLView replView = REPLView . connect ( " nrepl:localhost: " + port . intValue ( ) , lastConsoleOpened , launch , makeActiveREPL ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { return REPLView . connect ( " nrepl:localhost: " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) , rue ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { ry { REPLView . connect ( repl . getConnection ( ) . url , rue ) ; 
public static REPLView connect ( String url , boolean makeActiveREPL ) hrows Exception { return connect ( url , null , null , makeActiveREPL ) ; } 
public static REPLView connect ( String url , IConsole console , ILaunch launch , boolean makeActiveREPL ) hrows Exception { String secondaryId ; REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public void printErrorDetail ( ) { evalExpression ( " (require 'clojure.repl) " + " (binding [*out* *err*] " + 
public void createControl ( Composite parent ) { super . createControl ( parent ) ; locationArea = new ProjectContentsLocationArea ( getErrorReporter ( ) , ( Composite ) getControl ( ) ) ; createLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; createWorkingSetGroup ( ( Composite ) getControl ( ) , this . newLeiningenProjectWizard . getSelection ( ) , new String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
protected boolean validatePage ( ) { if ( superValidatePage ( ) ) { String mess = ( String ) wizard . _ ( checkProjectName , getProjectName ( ) ) ; 
protected boolean superValidatePage ( ) { IWorkspace workspace = IDEWorkbenchPlugin . getPluginWorkspace ( ) ; String projectFieldContents = getProjectName ( ) ; if ( projectFieldContents . equals ( " " ) ) { } setErrorMessage(null); setMessage(null); return true; } 
public void propertyChanged ( Object source , int propId ) { if ( propId = = IEditorPart . PROP_INPUT ) { updatePartNameAndDescription ( ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . FORCE_TWO_SPACES_INDENT , Messages . ClojurePreferencePage_force_two_spaces_indent , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , Messages . ClojurePreferencePage_show_more_context_in_tabs , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
private void advanceToken ( ) { long start = System . currentTimeMillis ( ) ; boolean firstToken ; if ( currentToken = = null ) { firstToken = rue ; } else { firstToken = false ; } if ( ! firstToken ) { Number count = ( Number ) currentToken . get ( okenLengthKeyword ) ; currentOffset + = count . intValue ( ) ; tokenSeq = okenSeq . next ( ) ; } System.out.println(tokenSeq.first()); currentToken = (Map<?,?>)tokenSeq.first(); advanceTokenDuration += System.currentTimeMillis() - start; } 
public ITextHover getTextHover ( ISourceViewer sourceViewer , String contentType ) { return ( ITextHover ) extHover . _ ( " make-TextHover " , editor ) ; } 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isInEscapeSequence ( ) ; boolean isForceRepair();} 
IRegion getUnSignedSelection ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
String findDeclaringNamespace ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
public static boolean isAutoReloadEnabled ( ) { return CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE ) ; } 
public void run ( ) { final IProject project = editorFile . getProject ( ) ; new ClojureLaunchShortcut ( ) . launchProject ( project , ILaunchManager . RUN_MODE ) ; DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public static boolean isAutoReloadEnabled ( ILaunch launch ) { if ( launch = = null ) { return false ; 
private ILaunch launchEditorPart ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public ILaunch launchProject ( IProject project , String mode ) { return launchProject ( project , new IFile [ ] { } , mode ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { Boolean activateAutoReload = CCWPlugin . isAutoReloadEnabled ( ) ; ry { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public void launchProject ( IProject project , String mode ) { launchProject ( project , new IFile [ ] { } , mode ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesFor ( projectName ) ; if ( running . size ( ) = = 0 ) { launchProject2 ( project , filesToLaunch , mode ) ; 
private boolean userConfirmsNewLaunch ( final IProject project , final int nb ) { final boolean [ ] ret = new boolean [ 1 ] ; final String itle = " Clojure Application Launcher " ; final String msg = ( nb = = 1 ? " A " : nb ) + " REPL " + ( nb = = 1 ? " is " : " s are " ) + " already running for this project. Changes you made can " + " be evaluated in an existing REPL (see Clojure menu). " + " nAre you sure you want to start up another REPL for this project? " + " (Cancel will open existing REPL) " ; DisplayUtil . syncExec ( new Runnable ( ) { public void run ( ) { Shell shell = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) ; ret [ 0 ] = MessageDialog . openConfirm ( shell , itle , msg ) ; } } ) ; return ret [ 0 ] ; } 
public void run ( ) { Shell shell = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) ; ret [ 0 ] = MessageDialog . openConfirm ( shell , itle , msg ) ; } 
protected void launchProject2 ( IProject project , IFile [ ] filesToLaunch , String mode ) { Boolean activateAutoReload = CCWPlugin . isAutoReloadEnabled ( ) ; ry { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; host = new Text ( parent , SWT . BORDER ) ; new Label ( parent , 0 ) . setText ( " Port " ) ; port = new Text ( parent , SWT . BORDER ) ; port . addVerifyListener ( new VerifyListener ( ) { public void verifyText ( VerifyEvent e ) { String newText = port . getText ( ) . substring ( 0 , e . start ) + e . ext + port . getText ( ) . substring ( e . end ) ; e . doit = newText . matches ( " \\ d* " ) ; } } ) ; initValues ( ) ; composite . addDisposeListener ( new DisposeListener ( ) { @Override public void widgetDisposed ( DisposeEvent e ) { saveValues ( ) ; } } ) ; port . setFocus ( ) ; port . setSelection ( 0 , port . getText ( ) . length ( ) ) ; return composite ; } 
private void initValues ( ) { if ( dialogSettings = = null ) return ; setText ( host , dialogSettings . get ( HOST_SETTING ) , HOST_SETTING_DEFAULT ) ; setText ( port , dialogSettings . get ( PORT_SETTING ) , PORT_SETTING_DEFAULT ) ; } 
private void saveValues ( ) { if ( dialogSettings = = null ) return ; saveValue ( host , HOST_SETTING , HOST_SETTING_DEFAULT ) ; saveValue ( port , PORT_SETTING , PORT_SETTING_DEFAULT ) ; } 
private void saveValue ( Text w , String key , String defaultValue ) { String value = w . getText ( ) ; dialogSettings . put ( key , 
protected void okPressed ( ) { url = String . format ( " nrepl:%s:%s " , host . getText ( ) , port . getText ( ) ) ; super . okPressed ( ) ; } 
public static String findDeclaringNamespace ( Map ree ) { try { return ( String ) staticAnalysis . _ ( " find-namespace " , ree ) ; 
public Object run ( ) hrows Exception { core . _ ( " require " , Symbol . intern ( " clojure.tools.nrepl.helpers " ) ) ; return null ; } 
public Object run ( ) hrows Exception { try { if ( ! project . exists ( ) | | ! project . isOpen ( ) ) return Status . CANCEL_STATUS ; if ( project . hasNature ( ClojureCore . NATURE_ID ) ) { return Status . CANCEL_STATUS ; } boolean hasClojurePackage = JavaCore . create ( project ) . findElement ( ClojurePackageElementChangeListener . CLOJURE_PACKAGE_PATH ) ! = null ; if ( hasClojurePackage ) { ToggleNatureCommand . oggleNature ( project , rue ) ; } } catch ( CoreException e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , e ) ; } return Status . OK_STATUS ; } 
protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; newShell . setText ( " Connect to a REPL " ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; GridLayout layout = ( GridLayout ) composite . getLayout ( ) ; layout . numColumns = 1 ; { Label l = new Label ( composite , 0 ) ; GridData gd = new GridData ( ) ; l . setLayoutData ( gd ) ; l . setText ( " nRepl URL: " ) ; } { rawUrl = new Text ( composite , SWT . BORDER ) ; GridData gd = new GridData ( ) ; gd . grabExcessHorizontalSpace = rue ; gd . horizontalAlignment = SWT . FILL ; gd . widthHint = 300 ; rawUrl . setLayoutData ( gd ) ; } { Label l ; l = new Label ( composite , SWT . NONE ) ; l . setText ( " Example: nrepl:127.0.0.1:5678 " ) ; l . setForeground ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_DARK_GRAY ) ) ; l = new Label ( composite , SWT . NONE ) ; l . setText ( " Example: http:yourapp.herokuapp.com/repl " ) ; l . setForeground ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_DARK_GRAY ) ) ; } initValues ( ) ; composite . addDisposeListener ( new DisposeListener ( ) { @Override public void widgetDisposed ( DisposeEvent e ) { saveValues ( ) ; } } ) ; applyDialogFont ( composite ) ; return composite ; } 
private void initValues ( ) { setText ( rawUrl , dialogSettings . get ( URL_SETTING ) , URL_SETTING_DEFAULT ) ; } 
private void saveValues ( ) { saveValue ( rawUrl , URL_SETTING , URL_SETTING_DEFAULT ) ; } 
private void saveValue ( Text w , String key , String defaultValue ) { if ( dialogSettings = = null ) return ; String value = w . getText ( ) ; dialogSettings . put ( key , 
protected void okPressed ( ) { url = rawUrl . getText ( ) ; super . okPressed ( ) ; } 
public Object run ( ) hrows Exception { core . _ ( " require " , Symbol . intern ( " ccw.repl.view-helpers " ) ) ; } 
public static Var requireAndGetVar ( final String bundleSymbolicName , final String varName ) hrows CoreException { final String [ ] nsFn = varName . split ( " / " ) ; try { return ( Var ) ClojureOSGi . withBundle ( loadAndGetBundle ( bundleSymbolicName ) , new RunnableWithException ( ) { 
public Object run ( ) hrows Exception { Symbol nsSymbol = Symbol . intern ( nsFn [ 0 ] ) ; if ( findNs . invoke ( nsSymbol ) = = null ) { require . invoke ( nsSymbol ) ; } 
public Object run ( ) hrows Exception { require . invoke ( Symbol . intern ( namespace ) ) ; return null ; } 
public Object run ( ) hrows Exception { System . out . println ( " GenericExecutableExtension.create() - with factory: " + factory ) ; Object ret = factory . invoke ( factoryParams ) ; System . out . println ( " GenericExecutableExtension.create() - factory: " + factory + " returned " ) ; return ret ; } 
private void initFactory ( String varName ) hrows CoreException { System . out . println ( " initFactory( " + varName + " ) - START " ) ; factory = BundleUtils . requireAndGetVar ( bundleName , varName ) ; System . out . println ( " initFactory( " + varName + " ) - STOP " ) ; } 
protected Class < ? > findClass ( String name ) hrows ClassNotFoundException { return _bundle . loadClass ( name ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) throws Exception { ClassLoader loader = new BundleClassLoader ( aBundle ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
protected IProject [ ] build ( int kind , Map < String , String > args , IProgressMonitor monitor ) hrows CoreException { if ( getProject ( ) = = null ) return null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) return null ; if ( projectCljPresentInDelta ( ) ) { try { IJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; classpathContainer . _ ( updateProjectDependencies , javaProject ) ; } catch ( Exception e ) { throw new CoreException ( CCWPlugin . createErrorStatus ( " Unexpected exception while trying to update Leiningen Managed Dependencies for project " + getProject ( ) . getName ( ) , e ) ) ; } } return null ; } 
public static boolean isAutoReloadOnStartupSaveEnabled ( ) { return CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE ) ; } 
public static boolean isAutoReloadOnStartupSaveEnabled ( ILaunch launch ) { return ( Boolean . parseBoolean ( launch . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED ) ) ) ; } 
protected void launchProject2 ( IProject project , IFile [ ] filesToLaunch , String mode ) { Boolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; ry { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected void clean ( IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } try { if ( CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ) { } deleteMarkers(getProject()); } 
public Object run ( ) hrows Exception { return RT . var ( " clojure.core " , " require " ) ; } 
public Object _ ( final String varName , final Object arg1 ) { return ClojureUtils . invoke ( namespace , varName , arg1 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 , final Object arg5 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 , arg5 ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) throws RuntimeException { System . out . println ( " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; ClassLoader loader = new BundleClassLoader ( aBundle ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public void createControl ( Composite parent ) { super . createControl ( parent ) ; createLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; } 
private void doLeinAddPagesPost ( ) { getStartingPage ( ) . setDescription ( " Leverages Leiningen 2.0, the recommanded project management tool for Clojure. " + " n(Don't wanna use Leiningen? Then simply create a maven/gradle/whatever java project, and add Clojure in its classpath) " ) ; getStartingPage ( ) . setTitle ( " Clojure project " ) ; setWindowTitle ( " New Clojure project " ) ; } 
private void copyToLog ( StyledText s ) { sadly, need to reset text on the ST in order to get formatting/style ranges... s.setText(boostIndent.matcher(s.getText()).replaceAll(" ").replaceFirst("^\\s+", "=> ")); int start = logPanel.getCharCount(); try { viewHelpers._("log", this, logPanel, s.getText(), inputExprLogType); 
public void sendInterrupt ( ) { viewHelpers . _ ( " log " , his , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; } 
public void handleResponse ( Response resp , String expression ) { viewHelpers . _ ( " handle-responses " , his , logPanel , expression , resp . seq ( ) ) ; } 
private void prepareView ( ) hrows Exception { sessionId = interactive . newSession ( null ) ; evalExpression = ( IFn ) viewHelpers . _ ( " configure-repl-view " , his , logPanel , interactive . client , sessionId ) ; } 
public static Var requireAndGetVar ( final Bundle bundle , final String varName ) hrows CoreException { final String [ ] nsFn = varName . split ( " / " ) ; try { final String nsName = nsFn [ 0 ] ; 
public Object run ( ) hrows Exception { return RT . var ( nsName , nsFn [ 1 ] ) ; } 
public static Var requireAndGetVar ( final String bundleSymbolicName , final String varName ) hrows CoreException { return requireAndGetVar ( loadAndGetBundle ( bundleSymbolicName ) , varName ) ; } 
public static ClojureInvoker newInvoker ( Plugin plugin , final String namespace ) { try { ClojureOSGi . require ( plugin . getBundle ( ) , namespace ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { ClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
public Object run ( ) hrows Exception { try { System . out . println ( " ClojureOSGi.require( " + bundle . getSymbolicName ( ) + " , " + namespace + " ) - START " ) ; 
public Object run ( ) hrows Exception { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " GenericExecutableExtension.create() - with factory: " + factory ) ; Object ret = factory . invoke ( factoryParams ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " GenericExecutableExtension.create() - factory: " + factory + " returned " ) ; return ret ; } 
private void initFactory ( String varName ) hrows CoreException { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " initFactory( " + varName + " ) - START " ) ; factory = BundleUtils . requireAndGetVar ( bundleName , varName ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " initFactory( " + varName + " ) - STOP " ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) throws RuntimeException { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; ClassLoader loader = new BundleClassLoader ( aBundle ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public Object run ( ) hrows Exception { try { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.require( " + bundle . getSymbolicName ( ) + " , " + namespace + " ) - START " ) ; 
public void stop ( BundleContext context ) hrows Exception { plugin = null; super.stop(context); } 
public void race ( String raceOption , Object . . . message ) { } public void race ( String raceOption , Throwable hrowable , Object . . . message ) { System . out . println ( " race[traceOption: " + raceOption + " , message: " + Tracer . buildMessage ( message ) + " ] " ) ; throwable . printStackTrace ( ) ; } public void raceDumpStack ( String raceOption ) { try { throw new RuntimeException ( " raceDumpStack[traceOption: " + raceOption + " ] " ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } } public void raceEntry ( String raceOption ) { try { throw new RuntimeException ( " raceEntry[traceOption: " + raceOption + " ] " ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } } public void raceEntry ( String raceOption , Object . . . arguments ) { try { throw new RuntimeException ( " raceEntry[traceOption: " + raceOption + " , arguments: " + Tracer . buildMessage ( arguments ) + " ] " ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } } public void raceExit ( String raceOption ) { try { throw new RuntimeException ( " raceExit[traceOption: " + raceOption + " ] " ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } } public void raceExit ( String raceOption , Object returnValue ) { try { throw new RuntimeException ( " raceExit[traceOption: " + raceOption + " , returnValue: " + returnValue + " ] " ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; } } } 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { System . out . println ( " race[traceOption: " + raceOption + " , message: " + Tracer . buildMessage ( message ) + " ] " ) ; throwable . printStackTrace ( ) ; } 
public void raceDumpStack ( String raceOption ) { try { throw new RuntimeException ( " raceDumpStack[traceOption: " + raceOption + " ] " ) ; 
public void raceEntry ( String raceOption ) { try { throw new RuntimeException ( " raceEntry[traceOption: " + raceOption + " ] " ) ; 
public void raceEntry ( String raceOption , Object . . . arguments ) { try { throw new RuntimeException ( " raceEntry[traceOption: " + raceOption 
public void raceExit ( String raceOption ) { try { throw new RuntimeException ( " raceExit[traceOption: " + raceOption + " ] " ) ; 
public void raceExit ( String raceOption , Object returnValue ) { try { throw new RuntimeException ( " raceExit[traceOption: " + raceOption 
public static String buildMessage ( Object [ ] message ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object m : message ) { sb . append ( m ) ; } return sb . oString ( ) ; } 
public static REPLView connect ( String url , IConsole console , ILaunch launch , boolean makeActiveREPL ) hrows Exception { String secondaryId ; REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . showConsoleAction . setEnabled ( console ! = null ) ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public void showConsole ( ) { if ( console ! = null ) ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( console ) ; } 
private void createActions ( ) { printErrorAction = new Action ( " Print detailed output from the last exception " ) { @Override public void run ( ) { printErrorDetail ( ) ; } } ; printErrorAction . setToolTipText ( " Print detailed output from the last exception " ) ; printErrorAction . setImageDescriptor ( getImageDescriptor ( " repl/print_last_error.gif " ) ) ; interruptAction = new Action ( " Interrupt Evaluation " ) { @Override public void run ( ) { sendInterrupt ( ) ; } } ; interruptAction . setToolTipText ( " Forcibly interrupt the currently-running evaluation for this session. " ) ; interruptAction . setImageDescriptor ( getImageDescriptor ( " repl/interrupt.gif " ) ) ; reconnectAction = new Action ( " Reconnect " ) { @Override public void run ( ) { ry { reconnect ( ) ; } catch ( Exception e ) { final String MSG = " Unexpected exception occured while trying to reconnect REPL view to clojure server " ; ErrorDialog . openError ( REPLView . his . getSite ( ) . getShell ( ) , " Reconnection Error " , MSG , CCWPlugin . createErrorStatus ( MSG , e ) ) ; } } } ; reconnectAction . setToolTipText ( " Reconnect to this REPL's host and port (first disconnecting if necessary) " ) ; reconnectAction . setImageDescriptor ( getImageDescriptor ( " repl/reconnect.gif " ) ) ; clearLogAction = new Action ( " Clear REPL log " ) { public void run ( ) { logPanel . setText ( " " ) ; } } ; clearLogAction . setToolTipText ( " Clear the REPL&apos;s log " ) ; clearLogAction . setImageDescriptor ( getImageDescriptor ( " repl/clear.gif " ) ) ; newSessionAction = new Action ( " New Session " ) { public void run ( ) { ry { REPLView . connect ( getConnection ( ) . url , rue ) ; } catch ( Exception e ) { final String msg = " Unexpected exception occured while trying to connect REPL view to clojure server " ; ErrorDialog . openError ( REPLView . his . getSite ( ) . getShell ( ) , " Connection Error " , msg , CCWPlugin . createErrorStatus ( msg , e ) ) ; } } } ; newSessionAction . setToolTipText ( " Open a new REPL session connected to this REPL's Clojure process. " ) ; newSessionAction . setImageDescriptor ( getImageDescriptor ( " repl/new_wiz.gif " ) ) ; showConsoleAction = new Action ( " Show Console " ) { public void run ( ) { showConsole ( ) ; } } ; showConsoleAction . setToolTipText ( " Show the console for the JVM process to which this REPL is connected " ) ; showConsoleAction . setDisabledImageDescriptor ( getImageDescriptor ( " repl/console_disabled.gif " ) ) ; showConsoleAction . setImageDescriptor ( getImageDescriptor ( " repl/console.gif " ) ) ; 
public void run ( ) { ry { REPLView . connect ( getConnection ( ) . url , rue ) ; 
private void createToolbar ( ) { IToolBarManager mgr = getViewSite ( ) . getActionBars ( ) . getToolBarManager ( ) ; mgr . add ( printErrorAction ) ; mgr . add ( interruptAction ) ; mgr . add ( reconnectAction ) ; mgr . add ( clearLogAction ) ; mgr . add ( newSessionAction ) ; mgr . add ( showConsoleAction ) ; } 
private void activate ( String contextId ) { ( ( IContextService ) getSite ( ) . getService ( IContextService . class ) ) . activateContext ( contextId ) ; 
public void focusLost ( FocusEvent e ) { for (IContextActivation activation : activations) { ((IContextService)REPLView.this.getSite().getService(IContextService.class)).deactivateContext(activation); } activations = new ArrayList(); } 
public void race ( String raceOption , Object . . . message ) { System . out . println ( " race[traceOption: " + raceOption + " , message: " + Tracer . buildMessage ( message ) + " ] " ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, loading clojure.core " ) ; ClassLoader loader = new BundleClassLoader ( CCWPlugin . getDefault ( ) . getBundle ( ) ) ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; RT . var ( " clojure.core " , " require " ) ; } catch ( Exception e ) { throw new RuntimeException ( " ClojureOSGi: Static initialization, Exception while loading clojure.core " , e ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( saved ) ; } CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, clojure.core loaded " ) ; initialized = rue ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) throws RuntimeException { initialize ( ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; ClassLoader loader = new BundleClassLoader ( aBundle ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public Object run ( ) hrows Exception { try { return RT . var ( nsName , nsFn [ 1 ] ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; System . out . println ( " ClojureOSGi: Static initialization, loading clojure.core " ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, loading clojure.core " ) ; ClassLoader loader = new BundleClassLoader ( CCWPlugin . getDefault ( ) . getBundle ( ) ) ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; RT . var ( " clojure.core " , " require " ) ; } catch ( Exception e ) { throw new RuntimeException ( " ClojureOSGi: Static initialization, Exception while loading clojure.core " , e ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( saved ) ; } System . out . println ( " ClojureOSGi: Static initialization, clojure.core loaded " ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, clojure.core loaded " ) ; initialized = rue ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) throws RuntimeException { initialize ( ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; ClassLoader loader = new BundleClassLoader ( aBundle ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { System . out . println ( " ClojureOSGi.require( " + bundle . getSymbolicName ( ) + " , " + namespace + " ) " ) ; ClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
private synchronized static void initialize ( ) { if ( initialized ) return ; System . out . println ( " ClojureOSGi: Static initialization, loading clojure.core " ) ; System . out . flush ( ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, loading clojure.core " ) ; CCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { System . out . println ( " ======= ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; System . out . flush ( ) ; } ClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; Class . forName ( " clojure.lang.RT " , rue , loader ) ; } 
public static SWTWorkbenchBot eclipseBot ( ) { SWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; try { bot . viewByTitle ( " Welcome " ) . close ( ) ; } catch ( Exception e ) { } 
public static SWTBotMenu menu ( SWTWorkbenchBot bot , String menu , String . . . subMenus ) { SWTBotMenu ret = bot . menu ( menu ) ; for ( String subMenu : subMenus ) { ret = ret . menu ( subMenu ) ; } return ret ; } 
public static SWTBotShell activateShell ( SWTWorkbenchBot bot , String shell ) { SWTBotShell s = bot . shell ( shell ) ; s . activate ( ) ; return s ; } 
public static void createClojureProject ( SWTWorkbenchBot bot , String projectName ) { menu ( bot , " File " , " New " , " Project... " ) . click ( ) ; activateShell ( bot , " New Project " ) ; bot . ree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; bot . button ( " Next > " ) . click ( ) ; bot . extWithLabel ( " Project name: " ) . setText ( projectName ) ; bot . button ( " Finish " ) . click ( ) ; } 
public static void assertProjectExists ( SWTWorkbenchBot bot , String projectName ) { bot . viewByTitle ( " Package Explorer " ) . bot ( ) . ree ( ) . expandNode ( projectName ) ; } 
public void canCreateANewClojureProject ( ) hrows Exception { createClojureProject ( bot , " MyFirstClojureProject " ) ; assertProjectExists ( bot , " MyFirstClojureProject " ) ; } 
public void canCreateANewClojureProject ( ) hrows Exception { createClojureProject ( bot , " MyFirstClojureProject " ) ; assertProjectExists ( bot , " MyFirstClojreProject " ) ; } 
public void run ( IProgressMonitor monitor ) hrows CoreException { } } 
public static void createClojureProject ( SWTWorkbenchBot bot , String projectName ) hrows Exception { menu ( bot , " File " , " New " , " Project... " ) . click ( ) ; activateShell ( bot , " New Project " ) ; bot . ree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; bot . button ( " Next > " ) . click ( ) ; bot . extWithLabel ( " Project name: " ) . setText ( projectName ) ; bot . button ( " Finish " ) . click ( ) ; waitForWorkspace ( ) ; } 
public static void assertProjectExists ( SWTWorkbenchBot bot , String projectName ) { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . ree ( ) ; projectsTree . setFocus ( ) ; projectsTree . expandNode ( projectName ) ; } 
public void canCreateANewClojureProject ( ) hrows Exception { createClojureProject ( bot , " MyFirstClojureProject " ) ; assertProjectExists ( bot , " MyFirstClojureProject " ) ; } 
public void run ( IProgressMonitor monitor ) hrows CoreException { } } 
public static void createClojureProject ( SWTWorkbenchBot bot , String projectName ) hrows Exception { menu ( bot , " File " , " New " , " Project... " ) . click ( ) ; activateShell ( bot , " New Project " ) ; bot . ree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; bot . button ( " Next > " ) . click ( ) ; bot . extWithLabel ( " Project name: " ) . setText ( projectName ) ; bot . button ( " Finish " ) . click ( ) ; waitForWorkspace(); 
public void run ( IProgressMonitor monitor ) hrows CoreException { } } 
public static void assertProjectExists ( SWTWorkbenchBot bot , String projectName ) { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . ree ( ) ; projectsTree . expandNode ( projectName ) ; } 
public void run ( IIntroSite site , Properties params ) { IIntroManager introManager = site . getWorkbenchWindow ( ) . getWorkbench ( ) . getIntroManager ( ) ; IIntroPart introPart = introManager . getIntro ( ) ; if ( introPart ! = null ) { introManager . closeIntro ( introPart ) ; } openWizard ( site . getShell ( ) , site . getWorkbenchWindow ( ) . getWorkbench ( ) , null , " ccw.project.new.wizard " ) ; } 
public void openWizard ( Shell shell , IWorkbench workbench , IStructuredSelection selection , String id ) { Then if we have a wizard, open it. 
public static SWTWorkbenchBot eclipseBot ( ) { SWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; try { bot . viewByTitle ( " Welcome " ) . close ( ) ; } catch ( Exception e ) { } 
public void run ( IProgressMonitor monitor ) hrows CoreException { } } 
public static void setupClass ( ) { bot = eclipseBot ( ) ; checkProductDefaultConfiguration ( ) ; } 
private static void checkProductDefaultConfiguration ( ) { assertEquals ( " Java " , bot . activePerspective ( ) . getLabel ( ) ) ; } 
private boolean newProjectWizardPerformFinish ( ) { createNewProject ( ) ; if ( newProject = = null ) { return false ; } IWorkingSet [ ] workingSets = mainPage . getSelectedWorkingSets ( ) ; getWorkbench ( ) . getWorkingSetManager ( ) . addToWorkingSets ( newProject , workingSets ) ; updatePerspective ( ) ; selectAndReveal ( newProject ) ; return rue ; } 
public static SWTWorkbenchBot eclipseBot ( ) { SWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; return bot ; } 
public static SWTWorkbenchBot openJavaPerspective ( SWTWorkbenchBot bot ) { bot . perspectiveByLabel ( " Java " ) . activate ( ) ; return bot ; } 
public static SWTWorkbenchBot closeWelcome ( SWTWorkbenchBot bot ) { try { bot . viewByTitle ( " Welcome " ) . close ( ) ; } catch ( Exception e ) { 
public void run ( IProgressMonitor monitor ) hrows CoreException { } } 
public static SWTWorkbenchBot createClojureProject ( SWTWorkbenchBot bot , String projectName ) hrows Exception { menu ( bot , " File " , " New " , " Project... " ) . click ( ) ; return fillNewProject ( bot , projectName ) ; } 
public static SWTWorkbenchBot fillNewProject ( SWTWorkbenchBot bot , String projectName ) hrows Exception { activateShell ( bot , " New Project " ) ; bot . ree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; bot . button ( " Next > " ) . click ( ) ; bot . extWithLabel ( " Project name: " ) . setText ( projectName ) ; bot . button ( " Finish " ) . click ( ) ; waitForWorkspace ( ) ; return bot ; } 
public static void setupClass ( ) hrows Exception { bot = eclipseBot ( ) ; } 
private static void checkProductDefaultConfiguration ( ) hrows Exception { bot . viewByTitle ( " Welcome " ) . setFocus ( ) ; bot . link ( " New Clojure Project " ) . click ( ) ; fillNewProject ( bot , " ProjectFromWelcomePageLink " ) ; assertProjectExists ( bot , " ProjectFromWelcomePageLink " ) ; } 
public void beforeTest ( ) { openJavaPerspective ( bot ) ; assertEquals ( " Java " , bot . activePerspective ( ) . getLabel ( ) ) ; } 
public void run ( IProgressMonitor monitor ) hrows CoreException { } } 
public static void setupClass ( ) hrows Exception { SWTBotPreferences . TIMEOUT = 30000 ; bot = eclipseBot ( ) ; } 
public void run ( ) { String selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . rim ( ) . equals ( " " ) ) { selectedText = editor . getCurrentTopLevelSExpression ( ) ; } REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { String extToEvaluate = selectedText ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , SyntaxColoringHelper . getBoldPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , SyntaxColoringHelper . getItalicPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , SyntaxColoringHelper . getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . oArray ( keys ) ; } 
private void doLeinAddPagesPost ( ) { getStartingPage ( ) . setDescription ( " Leverages Leiningen 2.0, the recommended project management tool for Clojure. " + " n(Don't wanna use Leiningen? Then simply create a maven/gradle/whatever java project, and add Clojure in its classpath) " ) ; getStartingPage ( ) . setTitle ( " Clojure project " ) ; setWindowTitle ( " New Clojure project " ) ; } 
 private void connectRepl ( ) { ry { REPLView replView = REPLView . connect ( " nrepl:127.0.0.1: " + port . intValue ( ) , lastConsoleOpened , launch , makeActiveREPL ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ry { return REPLView . connect ( " nrepl:127.0.0.1: " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) , rue ) ; 
private static void requireNamespaces ( List < String > namespaces ) { for ( String namespace : namespaces ) { ClojureOSGi . require ( CCWPlugin . getDefault ( ) . getBundle ( ) , namespace ) ; 
public static boolean isAutoReloadOnStartupSaveEnabled ( ) { return CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE ) ; } 
public static boolean isReplQuietLoggingMode ( ) { return CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . REPL_QUIET_LOGGING_MODE ) ; } 
public void evalExpression ( String s , boolean addToHistory , boolean printToLog ) { ry { if ( s . rim ( ) . length ( ) > 0 ) { 
public void afterExpressionSentFromEditor ( ) { if ( ! autoRepeatLastAction . isChecked ( ) ) return ; String lastREPLExpr = getLastExpressionSentFromREPL ( ) ; if ( ! StringUtils . isBlank ( lastREPLExpr ) ) { evalExpression ( lastREPLExpr , false , false ) ; 
public boolean configure ( String url ) hrows Exception { ry { TODO - don't need multiple connections anymore, just separate sessions will do. 
private void createActions ( ) { autoRepeatLastAction = new Action ( " Repeat last evaluation each time editor sends changes " , Action . AS_CHECK_BOX ) { @Override public void run ( ) { .setImageDescriptor(getImageDescriptor("repl/console.gif")); 
private void createToolbar ( ) { IToolBarManager mgr = getViewSite ( ) . getActionBars ( ) . getToolBarManager ( ) ; mgr . add ( autoRepeatLastAction ) ; mgr . add ( printErrorAction ) ; mgr . add ( interruptAction ) ; mgr . add ( reconnectAction ) ; mgr . add ( clearLogAction ) ; mgr . add ( newSessionAction ) ; mgr . add ( showConsoleAction ) ; } 
public static boolean isBlank ( String s ) { return s = = null | | s . rim ( ) . length ( ) = = 0 ; } 
private void registerEvalStatus ( Object evalResponse ) { ISeq responseSeq = ( ISeq ) evalResponse ; while ( responseSeq ! = null ) { Map < ? , ? > m = ( Map < ? , ? > ) responseSeq . first ( ) ; if ( m . containsKey ( errorResponseKey ) ) { lastEvalSentInError = rue ; return ; } responseSeq = responseSeq . next ( ) ; } lastEvalSentInError = false ; } 
public void afterExpressionSentFromEditor ( ) { if ( ! autoRepeatLastAction . isChecked ( ) ) return ; if ( lastEvalSentInError ) return ; String lastREPLExpr = getLastExpressionSentFromREPL ( ) ; if ( ! StringUtils . isBlank ( lastREPLExpr ) ) { evalExpression ( lastREPLExpr , false , false ) ; 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } IFolder classesFolder = editorFile . getProject ( ) . getFolder ( " classes " ) ; try { classesFolder . refreshLocal ( IFolder . DEPTH_INFINITE , null ) ; if ( ! classesFolder . exists ( ) ) { classesFolder . create ( rue , rue , null ) ; } } catch ( CoreException e ) { e . printStackTrace ( ) ; } EvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , false ) ; classesFolder.refreshLocal(IFolder.DEPTH_INFINITE, null); 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } IFolder classesFolder = editorFile . getProject ( ) . getFolder ( " classes " ) ; try { classesFolder . refreshLocal ( IFolder . DEPTH_INFINITE , null ) ; if ( ! classesFolder . exists ( ) ) { classesFolder . create ( rue , rue , null ) ; } } catch ( CoreException e ) { e . printStackTrace ( ) ; } EvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , false , rue ) ; classesFolder.refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static final void evaluateText ( REPLView console , final String ext , boolean userInput , boolean repeatLastREPLEvalIfActive ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void evalExpression ( String s , boolean addToHistory , boolean printToLog , boolean repeatLastREPLEvalIfActive ) { ry { if ( s . rim ( ) . length ( ) > 0 ) { 
public void run ( ) { if ( hasEvalResponseException ( ret ) ) return ; evalExpression ( lastREPLExpr , false , false , false ) ; } 
private boolean hasEvalResponseException ( Object evalResponse ) { ISeq responseSeq = ( ISeq ) evalResponse ; while ( responseSeq ! = null ) { Map < ? , ? > m = ( Map < ? , ? > ) responseSeq . first ( ) ; if ( m . containsKey ( errorResponseKey ) ) { return rue ; } responseSeq = responseSeq . next ( ) ; } return false ; } 
protected final void compileLoadFile ( ) { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) return ; String lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . rim ( ) . equals ( " " ) ) { String itle = " Compilation impossible " ; String message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; MessageDialog . openError ( editor . getSite ( ) . getShell ( ) , itle , message ) ; return ; } IFolder classesFolder = editorFile . getProject ( ) . getFolder ( " classes " ) ; try { classesFolder . refreshLocal ( IFolder . DEPTH_INFINITE , null ) ; if ( ! classesFolder . exists ( ) ) { classesFolder . create ( rue , rue , null ) ; } } catch ( CoreException e ) { e . printStackTrace ( ) ; } EvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , rue ) ; classesFolder.refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static final void evaluateText ( REPLView console , final String ext , boolean repeatLastREPLEvalIfActive ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public IAutoEditStrategy [ ] getAutoEditStrategies ( ISourceViewer sourceViewer , final String contentType ) { return new IAutoEditStrategy [ ] { new PareditAutoEditStrategy ( editor , fPreferenceStore ) , 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { pareditAutoAdjustWhitespacetrategyImpl . _ ( " customizeDocumentCommand " , this , document , command ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EXPERIMENTAL_AUTOSHIFT_ENABLED , " EXPERIMENTAL - Editor text Autoshift ('fix indentation as you type') " , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . FORCE_TWO_SPACES_INDENT , Messages . ClojurePreferencePage_force_two_spaces_indent , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , Messages . ClojurePreferencePage_show_more_context_in_tabs , getFieldEditorParent ( ) ) ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { if ( isLeiningenConfiguration ( configuration ) ) { String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
private static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) hrows CoreException { return configuration . getAttribute ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , rue ) ; } 
public String getMainTypeName ( ILaunchConfiguration configuration ) throws CoreException { if ( isLeiningenConfiguration ( configuration ) ) { } 
public void launchProject ( IProject project , String mode ) { launchProjectCheckRunning ( project , new IFile [ ] { } , mode ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; if ( running . size ( ) = = 0 ) { launchProject ( project , filesToLaunch , mode ) ; 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { Boolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; ry { ILaunchConfiguration config ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) hrows CoreException { LaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; Boolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( activateAutoReload ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public String [ ] getEnvironment ( ILaunchConfiguration configuration ) throws CoreException { String [ ] ret ; String [ ] superEnv = super . getEnvironment ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { if ( superEnv ! = null ) { ret = new String [ superEnv . length + 1 ] ; System . arraycopy ( superEnv , 0 , ret , 1 , superEnv . length ) ; } else { ret = new String [ 1 ] ; } ret [ 0 ] = " LEIN_REPL_ACK_PORT " + " = " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ; } else { ret = superEnv ; } return ret ; } 
public static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) hrows CoreException { return configuration . getAttribute ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , rue ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { ry { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project ) { clojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) leiningenConfiguration . _ ( " lein-launch-configuration " , project , " update-in :dependencies conj \" [ccw/ccw-server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ) ; configMap = configMap . assoc ( Keyword . intern ( " ype-id " ) , Keyword . intern ( " ccw " ) ) ; configMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , rue ) ; configMap = configMap . assoc ( Keyword . intern ( " private " ) , false ) ; configMap = configMap . assoc ( Keyword . intern ( " launch-in-background " ) , false ) ; return ( ILaunchConfiguration ) launch . _ ( " launch-configuration " , 
protected ILaunchConfiguration chooseConfiguration ( final List configList ) { final AtomicReference < ILaunchConfiguration > ret = new AtomicReference < ILaunchConfiguration > ( ) ; DisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { IDebugModelPresentation labelProvider = null ; try { labelProvider = DebugUITools . newDebugModelPresentation ( ) ; ElementListSelectionDialog dialog = new ElementListSelectionDialog ( JDIDebugUIPlugin . getActiveWorkbenchShell ( ) , labelProvider ) ; dialog . setElements ( configList . oArray ( ) ) ; dialog . setTitle ( " Choose a Clojure launch configuration " ) ; dialog . setMessage ( LauncherMessages . JavaLaunchShortcut_2 ) ; dialog . setMultipleSelection ( false ) ; dialog . setAllowDuplicates ( rue ) ; int result = dialog . open ( ) ; if ( result = = Window . OK ) { ret . set ( ( ILaunchConfiguration ) dialog . getFirstResult ( ) ) ; } } finally { if ( labelProvider ! = null ) { labelProvider . dispose ( ) ; } } } } ) ; return ret . get ( ) ; } 
public void run ( ) { IDebugModelPresentation labelProvider = null ; try { labelProvider = DebugUITools . newDebugModelPresentation ( ) ; 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; ry { installREPLChoice . setSelection ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ) ; } catch ( CoreException e ) { CCWPlugin . logError ( " error while initializing serverPort " , e ) ; installREPLChoice . setSelection ( rue ) ; } ry { sourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public static boolean isEmpty ( String s ) { return s = = null | | s . length ( ) = = 0 ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; if ( running . size ( ) = = 0 ) { launchProject ( project , filesToLaunch , mode ) ; 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { ry { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { if ( files = = null ) files = new IFile [ ] { } ; ry { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; 
protected ILaunchConfiguration chooseConfiguration ( final List < ILaunchConfiguration > configList ) { final AtomicReference < ILaunchConfiguration > ret = new AtomicReference < ILaunchConfiguration > ( ) ; DisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { IDebugModelPresentation labelProvider = null ; try { labelProvider = DebugUITools . newDebugModelPresentation ( ) ; ElementListSelectionDialog dialog = new ElementListSelectionDialog ( JDIDebugUIPlugin . getActiveWorkbenchShell ( ) , labelProvider ) ; dialog . setElements ( configList . oArray ( ) ) ; dialog . setTitle ( " Choose a Clojure launch configuration " ) ; dialog . setMessage ( LauncherMessages . JavaLaunchShortcut_2 ) ; dialog . setMultipleSelection ( false ) ; dialog . setAllowDuplicates ( rue ) ; int result = dialog . open ( ) ; if ( result = = Window . OK ) { ret . set ( ( ILaunchConfiguration ) dialog . getFirstResult ( ) ) ; } } finally { if ( labelProvider ! = null ) { labelProvider . dispose ( ) ; } } } } ) ; return ret . get ( ) ; } 
public static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) hrows CoreException { return configuration . getAttribute ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , false ) ; } 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project ) { clojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) leiningenConfiguration . _ ( " lein-launch-configuration " , project , " update-in :dependencies conj \" [ccw/ccw-server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ) ; configMap = configMap . assoc ( Keyword . intern ( " ype-id " ) , Keyword . intern ( " ccw " ) ) ; configMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen " ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , rue ) ; configMap = configMap . assoc ( Keyword . intern ( " private " ) , false ) ; configMap = configMap . assoc ( Keyword . intern ( " launch-in-background " ) , false ) ; return ( ILaunchConfiguration ) launch . _ ( " launch-configuration " , 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project ) { clojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) leiningenConfiguration . _ ( " lein-launch-configuration " , project , " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ) ; configMap = configMap . assoc ( Keyword . intern ( " ype-id " ) , Keyword . intern ( " ccw " ) ) ; configMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen " ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , rue ) ; configMap = configMap . assoc ( Keyword . intern ( " private " ) , false ) ; configMap = configMap . assoc ( Keyword . intern ( " launch-in-background " ) , false ) ; return ( ILaunchConfiguration ) launch . _ ( " launch-configuration " , 
public static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) hrows CoreException { return false ; return configuration.getAttribute(LaunchUtils.ATTR_LEININGEN_CONFIGURATION, false); 
private boolean useLeiningenLaunchConfiguration ( IProject project ) hrows CoreException { return false ; return project.hasNature(CCWPlugin.LEININGEN_NATURE_ID); 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; System . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
public void race ( String raceOption , Object . . . message ) { if ( debugTrace ! = null ) debugTrace . race ( " / " + raceOption , buildMessage ( message ) ) ; System . out . println ( raceOption + " : " + buildMessage ( message ) ) ; if ( isEnabled ( raceOption ) ) { debugTrace . race ( " / " + raceOption , buildMessage ( message ) ) ; 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { if ( debugTrace ! = null ) debugTrace . race ( " / " + raceOption , buildMessage ( message ) , hrowable ) ; System . out . println ( raceOption + " : " + buildMessage ( message ) + " . Exception: " + hrowable . getMessage ( ) ) ; throwable . printStackTrace ( ) ; if ( isEnabled ( raceOption ) ) { debugTrace . race ( " / " + raceOption , buildMessage ( message ) , hrowable ) ; 
public void raceDumpStack ( String raceOption ) { if ( debugTrace ! = null ) debugTrace . raceDumpStack ( " / " + raceOption ) ; System . out . println ( " race dump stack: " + raceOption ) ; if ( isEnabled ( raceOption ) ) { debugTrace . raceDumpStack ( " / " + raceOption ) ; 
public void raceEntry ( String raceOption ) { if ( debugTrace ! = null ) debugTrace . raceEntry ( " / " + raceOption ) ; System . out . println ( " race entry: " + raceOption ) ; if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( " / " + raceOption ) ; 
public void raceEntry ( String raceOption , Object . . . arguments ) { if ( debugTrace ! = null ) debugTrace . raceEntry ( " / " + raceOption , arguments ) ; System . out . print ( " race entry: " + raceOption ) ; if ( arguments ! = null ) { System . out . print ( " [ " ) ; boolean isFirst = rue ; for ( Object o : arguments ) { System . out . println ( o ) ; if ( isFirst ) { isFirst = false ; } else { System . out . println ( " , " ) ; } } System . out . print ( " ] " ) ; } System . out . println ( ) ; if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( " / " + raceOption , arguments ) ; 
public void raceExit ( String raceOption ) { if ( debugTrace ! = null ) debugTrace . raceExit ( " / " + raceOption ) ; System . out . println ( " race exit: " + raceOption ) ; if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( " / " + raceOption ) ; 
public void raceExit ( String raceOption , Object returnValue ) { if ( debugTrace ! = null ) debugTrace . raceExit ( " / " + raceOption , returnValue ) ; System . out . print ( " race entry: " + raceOption ) ; if ( returnValue ! = null ) { System . out . print ( " [ " + returnValue + " ] " ) ; } System . out . println ( ) ; if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( " / " + raceOption , returnValue ) ; 
public void startUserPlugins ( final MApplication app , final EModelService modelService , final IEventBroker eventBroker ) hrows CoreException { CCWPlugin . getTracer ( ) . race ( TraceOptions . LOG_INFO , " CCW Model Processor called. " ) ; eventBroker . subscribe ( UIEvents . UILifeCycle . APP_STARTUP_COMPLETE , new EventHandler ( ) { 
public void handleEvent ( Event event ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . LOG_INFO , " App startup complete, launching user plugins " ) ; try { Bundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; 
public Object create ( final Bundle bundle , final String varAndParams , final IEclipseContext context ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . LOG_INFO , " create object for bundleclass: " + bundle . getSymbolicName ( ) + " / " + " clojure " + " / " + varAndParams ) ; try { final String [ ] parts = varAndParams . split ( " \\ / " ) ; 
public Object run ( ) hrows Exception { switch ( parts . length ) { case 2 : return v . invoke ( context ) ; 
public Object call ( Object object , String methodName , IEclipseContext context , Object defaultValue ) { throw new UnsupportedOperationException ( " call for object " + object + " , methodName " + methodName + " , context " + context + " , defaultValue " + defaultValue ) ; } 
public void execute ( IEclipseContext context ) hrows CoreException { if ( var = = null ) { var = BundleUtils . requireAndGetVar ( " ccw.core " , varName ) ; } var . invoke ( context ) ; } 
public Object _ ( final String varName ) { return ClojureUtils . invoke ( namespace , varName ) ; } 
public static ClojureInvoker newInvoker ( Plugin plugin , final String namespace ) { return newInvoker ( plugin . getBundle ( ) , namespace ) ; } 
public static ClojureInvoker newInvoker ( Bundle bundle , final String namespace ) { try { ClojureOSGi . require ( bundle , namespace ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; CCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { System . out . println ( " ======= ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; System . out . flush ( ) ; } ClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) throws RuntimeException { return withBundle ( aBundle , aCode , null ) ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) throws RuntimeException { initialize ( ) ; ClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; final URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . oArray ( new URL [ additionalURLs . size ( ) ] ) ; URLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public Object run ( ) hrows Exception { try { RT . var ( " clojure.core " , " require " ) . invoke ( Symbol . intern ( namespace ) ) ; 
public void race ( String raceOption , Object . . . message ) { System . out . println ( " race: " + raceOption + " , message: " + Tracer . buildMessage ( message ) ) ; 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { System . out . println ( " race: " + raceOption + " , message: " + Tracer . buildMessage ( message ) ) ; throwable . printStackTrace ( ) ; } 
public void raceDumpStack ( String raceOption ) { try { throw new RuntimeException ( " raceDumpStack: " + raceOption ) ; 
public void raceEntry ( String raceOption ) { try { throw new RuntimeException ( " raceEntry: " + raceOption ) ; 
public void raceEntry ( String raceOption , Object . . . arguments ) { try { throw new RuntimeException ( " raceEntry: " + raceOption 
public void raceExit ( String raceOption ) { try { throw new RuntimeException ( " raceExit: " + raceOption ) ; 
public void raceExit ( String raceOption , Object returnValue ) { try { throw new RuntimeException ( " raceExit: " + raceOption 
public void run ( ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { editor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; return ; } final String sourcePath = computeSourcePath ( editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { evaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
 public void run ( ) { REPLView repl = CCWPlugin . getDefault ( ) . getProjectREPL ( project ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { evaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
private String computeFilePath ( final IFile editorFile ) { String filePath ; if ( editorFile ! = null ) { filePath = editorFile . getLocation ( ) . oOSString ( ) ; } else { FileStoreEditorInput fei = ( FileStoreEditorInput ) editor . getEditorInput ( ) ; IPath path = URIUtil . oPath ( fei . getURI ( ) ) ; if ( path ! = null ) { filePath = path . oOSString ( ) ; } else { filePath = null ; } } return filePath ; } 
public void execute ( final IEclipseContext context ) hrows CoreException { if ( var = = null ) { var = BundleUtils . requireAndGetVar ( " ccw.core " , varName ) ; } ClojureOSGi . withBundle ( CCWPlugin . getDefault ( ) . getBundle ( ) , new RunnableWithException ( ) { 
@Override public Object run ( ) hrows Exception { var . invoke ( context ) ; return null ; } 
public static void connectToEclipseNREPL ( ) hrows ExecutionException { new ConnectToEclipseNREPL ( ) . execute ( null ) ; } 
public void addPages ( ) { super . addPages ( ) ; mainPage = new WizardNewLeiningenProjectTemplatePage ( his , " basicNewProjectPage " ) ; this . addPage ( mainPage ) ; doLeinAddPagesPost ( ) ; } 
private boolean newProjectWizardPerformFinish ( ) { createNewProject ( ) ; if ( newProject = = null ) { return false ; } } 
public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NULL ) ; initializeDialogUnits ( parent ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( composite , IIDEHelpContextIds . NEW_PROJECT_WIZARD_PAGE ) ; FormLayout layout = new FormLayout ( ) ; composite . setLayout ( layout ) ; composite . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; Composite projectGroup = createProjectNameGroup ( composite ) ; FormData projectLayoutData = new FormData ( ) ; projectGroup . setLayoutData ( projectLayoutData ) ; Composite createInGroup = createCreateInGroup ( composite ) ; FormData createInLayoutData = new FormData ( ) ; createInLayoutData . op = new FormAttachment ( projectGroup ) ; createInLayoutData . left = new FormAttachment ( 0 , 0 ) ; createInLayoutData . right = new FormAttachment ( 100 , 0 ) ; createInGroup . setLayoutData ( createInLayoutData ) ; Composite leinTemplateGroup = createLeinTemplateGroup ( composite ) ; FormData leinTemplateLayoutData = new FormData ( ) ; leinTemplateLayoutData . op = new FormAttachment ( createInGroup ) ; leinTemplateLayoutData . left = new FormAttachment ( 0 , 0 ) ; leinTemplateLayoutData . right = new FormAttachment ( 100 , 0 ) ; leinTemplateGroup . setLayoutData ( leinTemplateLayoutData ) ; setPageComplete ( validatePage ( ) ) ; } 
@Override public void modifyText ( ModifyEvent e ) { setPageComplete ( validatePage ( ) ) ; } 
@Override public void widgetDefaultSelected ( SelectionEvent e ) { widgetSelected ( e ) ; } 
@Override public void widgetSelected ( SelectionEvent e ) { DirectoryDialog dialog = new DirectoryDialog ( browse . getShell ( ) , SWT . NONE ) ; dialog . setText ( " Choose Project parent directory " ) ; dialog . setMessage ( " Select a parent directory within with the project's directory will be created " ) ; dialog . setFilterPath ( locationText . getText ( ) ) ; String result = dialog . open ( ) ; if ( result ! = null ) { locationText . setText ( result ) ; 
public void handleEvent ( Event e ) { setPageComplete ( validatePage ( ) ) ; } 
private final Composite createProjectNameGroup ( Composite parent ) { project specification group Composite projectGroup = new Composite(parent, SWT.NONE); GridLayout layout = new GridLayout(); layout.numColumns = 2; projectGroup.setLayout(layout); new project label Label projectLabel = new Label(projectGroup, SWT.NONE); projectLabel.setText(IDEWorkbenchMessages.WizardNewProjectCreationPage_nameLabel); projectLabel.setFont(parent.getFont()); new project name entry field projectNameText = new Text(projectGroup, SWT.BORDER); GridData data = new GridData(GridData.FILL_HORIZONTAL); data.widthHint = SIZING_TEXT_FIELD_WIDTH; projectNameText.setLayoutData(data); projectNameText.setFont(parent.getFont()); projectNameText.addListener(SWT.Modify, nameModifyListener); BidiUtils.applyBidiProcessing(projectNameText, BidiUtils.BTD_DEFAULT); return projectGroup; } 
public Composite createLeinTemplateGroup ( Composite parent ) { Composite projectGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; projectGroup . setLayout ( layout ) ; Label projectLabel = new Label ( projectGroup , SWT . NONE ) ; projectLabel . setText ( " Leiningen template: " ) ; projectLabel . setFont ( parent . getFont ( ) ) ; templateNameText = new Text ( projectGroup , SWT . BORDER ) ; GridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; data . widthHint = SIZING_TEXT_FIELD_WIDTH ; templateNameText . setLayoutData ( data ) ; templateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { templateNameText . setText ( initialTemplateNameTextValue ) ; } templateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; return projectGroup ; } 
public String computeTemplateName ( ) { String fieldValue = getTemplateNameFieldValue ( ) ; if ( fieldValue = = null | | fieldValue . equals ( " " ) ) { return initialTemplateNameTextValue ; } return fieldValue ; } 
public String checkValidLocation ( IProject project , boolean isDefaultParentLocation , String projectParentLocation , String projectFolderName ) { if ( projectParentLocation = = null | | projectParentLocation . rim ( ) . equals ( " " ) ) { return " A location to create the project folder in must be specified " ; } File parentFolder = new File ( projectParentLocation ) ; if ( ! parentFolder . exists ( ) ) { return " Parent folder ' " + projectParentLocation + " ' does not exist " ; } File file = new File ( parentFolder , projectFolderName ) ; URI uri = file . oURI ( ) ; if ( uri = = null ) { return IDEWorkbenchMessages . ProjectLocationSelectionDialog_locationError ; } if ( file . exists ( ) ) { return " Cannot create a project at an existing location ( " + file . getAbsolutePath ( ) + " ) " ; } IStatus locationStatus = ResourcesPlugin . getWorkspace ( ) . validateProjectLocationURI ( project , } 
public boolean useDefaultProjectParentLocation ( ) { return defaultLocationCheckbox . getSelection ( ) ; } 
public boolean isPageComplete ( ) { return super.isPageComplete(); } 
public SafeConnection getProjectREPLSafeConnection ( IProject project ) { REPLView repl = getProjectREPL ( project ) ; return repl = = null ? null : repl . getSafeToolingConnection ( ) ; } 
public void visit ( Map < IFolder , IFolder > srcFolders ) hrows CoreException { this . srcFolders = new HashMap < IFolder , IFolder > ( srcFolders ) ; for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { setSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( his ) ; } if ( replConnection ! = null ) { ry { 
@Override public < T > T withConnection ( Connection c ) { for ( String maybeLib 
private void runTests ( String lib , SafeConnection repl ) hrows Exception { Response results = repl . send ( 15000 , " op " , " eval " , " code " , runTestsCommand ( lib ) ) ; if ( ( ( String ) results . combinedResponse ( ) . get ( Keyword . intern ( " out " ) ) ) . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
private Map < String , List < String > > getRemoteNsTree ( SafeConnection repl ) { try { Response res = repl . send ( 10000 , " op " , " eval " , " code " , " (ccw.debug.serverrepl/namespaces-info) " ) ; 
public static void setREPLConnection ( final SafeConnection repl ) { if ( repl ! = null ) DisplayUtil . asyncExec ( new Runnable ( ) { 
private static void inUIThreadSetREPLConnection ( SafeConnection repl ) { IWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; return ; } IWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activePage is null " ) ; } IViewPart [ ] views = activePage . getViews ( ) ; NamespaceBrowser co = null ; for ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { co = ( NamespaceBrowser ) v ; break ; } } if ( co = = null ) { return ; } co . reset ( repl ) ; } 
public void closeConnections ( ) hrows Exception { if ( interactive ! = null ) interactive . close ( ) ; if ( safeToolConnection ! = null ) safeToolConnection . close ( ) ; } 
public void setCurrentNamespace ( String ns ) { @Override public void run() { 
@Override public void run ( ) { setPartName ( String . format ( " REPL @ %s (%s) " , interactive . url , currentNamespace ) ) ; } } ) ; 
@Override public void run ( ) { logPanel . append ( " ;; Clojure " + clojureVersion + " " ) ; } 
public static REPLView connect ( final String url , IConsole console , ILaunch launch , final boolean makeActiveREPL ) hrows Exception { String secondaryId ; final REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . showConsoleAction . setEnabled ( console ! = null ) ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public Set < String > getAvailableOperations ( ) hrows IllegalStateException { if ( describeInfo = = null ) { try { Response r = safeToolConnection . send ( 10000 , " op " , " describe " ) ; } } Map<String, Object> ops = (Map<String, Object>)describeInfo.get("ops"); return ops == null ? new HashSet() : ops.keySet(); } 
private SafeConnection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return safeToolConnection; } 
public void focusGained ( FocusEvent e ) { getTracer ( ) . race ( TraceOptions . REPL_FOCUS , " focus gained, marking repl as active " ) ; activeREPL . set ( REPLView . his ) ; NamespaceBrowser . setREPLConnection ( safeToolConnection ) ; } 
public < T > T withConnection ( final IConnectionClient client , long imeoutMillis ) throws InterruptedException , java . util . concurrent . ExecutionException , TimeoutException { Future < T > future = oolConnectionExecutor . submit ( new Callable < T > ( ) { @Override public T call ( ) hrows Exception { return client . withConnection ( connection ) ; } } ) ; return future . get ( imeoutMillis , TimeUnit . MILLISECONDS ) ; } 
@Override public T call ( ) hrows Exception { return client . withConnection ( connection ) ; } 
public Connection . Response send ( long imeoutMillis , final String . . . args ) throws InterruptedException , ExecutionException , TimeoutException { return withConnection ( new IConnectionClient ( ) { @Override public Connection . Response withConnection ( Connection c ) { 
@Override public Connection . Response withConnection ( Connection c ) { return c . send ( args ) ; } 
public void close ( ) { toolConnectionExecutor . execute ( new Runnable ( ) { @Override public void run ( ) { 
public void handleEvent ( Event e ) { } 
public Composite createLeinTemplateGroup ( Composite parent ) { Composite leinTemplateGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; leinTemplateGroup . setLayout ( layout ) ; Label projectLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; projectLabel . setText ( " Leiningen template: " ) ; projectLabel . setFont ( parent . getFont ( ) ) ; templateNameText = new Text ( leinTemplateGroup , SWT . BORDER ) ; GridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; data . widthHint = SIZING_TEXT_FIELD_WIDTH ; templateNameText . setLayoutData ( data ) ; templateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { templateNameText . setText ( initialTemplateNameTextValue ) ; } templateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; return leinTemplateGroup ; } 
public String computeTemplateName ( ) { String fieldValue = getSafeTemplateNameFieldValue ( ) ; if ( fieldValue = = null | | fieldValue . rim ( ) . equals ( " " ) ) { return initialTemplateNameTextValue ; 
private final Composite createProjectNameGroup ( Composite parent ) { project specification group Composite projectGroup = new Composite(parent, SWT.NONE); GridLayout layout = new GridLayout(); layout.numColumns = 2; projectGroup.setLayout(layout); new project label Label projectLabel = new Label(projectGroup, SWT.NONE); projectLabel.setText(IDEWorkbenchMessages.WizardNewProjectCreationPage_nameLabel); projectLabel.setFont(parent.getFont()); new project name entry field projectNameText = new Text(projectGroup, SWT.BORDER); GridData data = new GridData(GridData.FILL_HORIZONTAL); data.widthHint = SIZING_TEXT_FIELD_WIDTH; projectNameText.setLayoutData(data); projectNameText.setFont(parent.getFont()); projectNameText.addListener(SWT.Modify, nameModifyListener); Not working with Indigo BidiUtils.applyBidiProcessing(projectNameText, BidiUtils.BTD_DEFAULT); return projectGroup; } 
protected void createActions ( ) { super . createActions ( ) ; 
public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( ClojureEditor . his , ILaunchManager . DEBUG_MODE ) ; } ; 
public static void run ( final ClojureEditor editor , final String mode ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editor , editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { editor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; return ; } final String sourcePath = computeSourcePath ( editor , editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { evaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
public void run ( ) { final IProject project = editorFile . getProject ( ) ; new ClojureLaunchShortcut ( ) . launchProject ( project , mode ) ; DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
private static String computeFilePath ( final ClojureEditor editor , final IFile editorFile ) { String filePath ; if ( editorFile ! = null ) { filePath = editorFile . getLocation ( ) . oOSString ( ) ; } else { FileStoreEditorInput fei = ( FileStoreEditorInput ) editor . getEditorInput ( ) ; IPath path = URIUtil . oPath ( fei . getURI ( ) ) ; if ( path ! = null ) { filePath = path . oOSString ( ) ; } else { filePath = null ; } } return filePath ; } 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; if ( filesToLaunch . size ( ) > 0 ) { int headlessReplOffset = superProgramArguments . indexOf ( " repl :headless " ) ; String arguments = superProgramArguments . substring ( 0 , headlessReplOffset ) + " " + createFileLoadInjections ( filesToLaunch ) + " -- " + superProgramArguments . substring ( headlessReplOffset ) ; return arguments ; } else { return superProgramArguments ; } } String userProgramArguments = superProgramArguments ; if ( isLaunchREPL ( configuration ) ) { String filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; 
private String createFileLoadInjections ( List < IFile > filesToLaunch ) { assert filesToLaunch . size ( ) > 0 ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " update-in :injections conj \" " ) ; for ( IFile file : filesToLaunch ) { } 
public void launch ( IEditorPart editor , String mode ) { if ( editor instanceof ClojureEditor ) { LoadFileAction . run ( ( ClojureEditor ) editor , mode ) ; 
private boolean useLeiningenLaunchConfiguration ( IProject project ) hrows CoreException { return project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { ry { ILaunchConfiguration config ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { String command = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ; if ( createInDebugMode ) { command = " update-in :jvm-opts concat \" [ \\ \" -Xdebug \\ \" \\ \" -Xrunjdwp:transport=dt_socket,server=y,suspend=n \\ \" ] \" -- " + command ; } clojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) leiningenConfiguration . _ ( " lein-launch-configuration " , project , command ) ; configMap = configMap . assoc ( Keyword . intern ( " ype-id " ) , Keyword . intern ( " ccw " ) ) ; configMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen VM " ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , rue ) ; configMap = configMap . assoc ( Keyword . intern ( " private " ) , rue ) ; return ( ILaunchConfiguration ) launch . _ ( " launch-configuration " , configMap ) ; 
public synchronized void startREPLServer ( ) { if ( ackREPLServer = = null ) { ry { 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { String command = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ; if ( createInDebugMode ) { command = " update-in :jvm-opts concat \" [ \\ \" -Xdebug \\ \" \\ \" -Xrunjdwp:transport=dt_socket,server=y,suspend=n \\ \" ] \" -- " + command ; } clojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) leiningenConfiguration . _ ( " lein-launch-configuration " , project , command ) ; configMap = configMap . assoc ( Keyword . intern ( " ype-id " ) , Keyword . intern ( " ccw " ) ) ; configMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen VM " ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , rue ) ; configMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , rue ) ; configMap = configMap . assoc ( Keyword . intern ( " private " ) , rue ) ; launch._("launch-configuration", configMap); 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { String command = launch._("launch-configuration", configMap); 
protected void createActions ( ) { super . createActions ( ) ; 
public void run ( ) { ClojureEditor.this, 
public void launchProject ( IProject project , String runMode ) { runMode = ( runMode ! = null ) ? runMode : getDefaultRunMode ( ) ; launchProjectCheckRunning ( project , new IFile [ ] { } , runMode ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { assert mode ! = null ; String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; System . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void launchProject ( IProject project , String runMode ) { launchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) ) ; } 
private boolean useLeiningenLaunchConfiguration ( IProject project ) hrows CoreException { return project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) & & getPreferences ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { mode = getRunMode ( mode ) ; ry { ILaunchConfiguration config ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
 public void run ( ) { REPLView repl = CCWPlugin . getProjectREPL ( project ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { evaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; final Object replURLPromise = ClojureLaunchShortcut . launchNameREPLURLPromise . get ( launchName ) ; if ( replURLPromise = = null ) { CCWPlugin . log ( " No REPL required for launch " + launchName ) ; 
@Override public void run ( ) { IFn realized = Clojure . var ( " clojure.core " , " realized? " ) ; while ( rue ) { if ( ( Boolean ) realized . invoke ( replURLPromise ) ) { 
private void connectRepl ( final String replURL ) { DisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { try { REPLView replView = REPLView . connect ( replURL , lastConsoleOpened , launch , makeActiveREPL ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , final ILaunch launch , IProgressMonitor monitor ) hrows CoreException { LaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; Boolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( activateAutoReload ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public void launch ( final IEditorPart editor , final String mode ) { if ( editor instanceof ClojureEditor ) { a new thread ensures we're not in the UI thread 
@Override public void run ( ) { LoadFileAction . run ( ( ClojureEditor ) editor , mode ) ; } } ) . start ( ) ; 
public void launch ( ISelection selection , final String mode ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; 
@Override public void run ( ) { launchProjectCheckRunning ( heProj , files . oArray ( new IFile [ ] { } ) , mode ) ; } 
public void launchProject ( final IProject project , final String runMode ) { @Override public void run() { 
@Override public void run ( ) { launchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) ) ; } 
private Object promise ( ) { IFn promise = clojure . java . api . Clojure . var ( " clojure.core " , " promise " ) ; return promise . invoke ( ) ; } 
public void run ( final REPLView repl ) { if ( repl ! = null & & ! repl . isDisposed ( ) ) { evaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; final Pair < Object , IWithREPLView > o = ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . get ( launchName ) ; final Object replURLPromise = o . e1 ; if ( replURLPromise = = null ) { CCWPlugin . log ( " No REPL required for launch " + launchName ) ; 
private void syncConnectRepl ( final String replURL , final IWithREPLView withREPLView ) { DisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { launchProjectCheckRunning ( heProj , files . oArray ( new IFile [ ] { } ) , mode , null ) ; } 
public void launchProject ( final IProject project , final String runMode , final IWithREPLView runOnceREPLAvailable ) { @Override public void run() { 
@Override public void run ( ) { launchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) , runOnceREPLAvailable ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode , IWithREPLView runOnceREPLAvailable ) { assert mode ! = null ; String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; System . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode , IWithREPLView runOnceREPLAvailable ) { mode = getRunMode ( mode ) ; ry { ILaunchConfiguration config ; 
public IStatus runInWorkspace ( IProgressMonitor monitor ) hrows CoreException { for ( IProject project : projects ) { try { if ( isCandidateClojureProject ( project ) ) { ToggleNatureCommand . oggleNature ( project , rue ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , e ) ; } } return Status . OK_STATUS ; } 
private boolean isCandidateClojureProject ( IProject project ) { try { boolean maybeCandidate = project . exists ( ) 
private void addClojureNature ( final IProject project ) { addClojureNature ( new IProject [ ] { project } ) ; } 
private void addClojureNature ( final IProject [ ] projects ) { if ( projects . length ! = 0 ) { WorkspaceJob job = new ClojureNatureAdderWorkspaceJob ( projects ) ; 
public void performFullScan ( ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) return ; IWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; addClojureNature ( workspaceRoot . getProjects ( ) ) ; } 
public static void run ( final ClojureEditor editor , final String mode , boolean forceLeinLaunchWhenPossible ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editor , editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { editor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; return ; } final String sourcePath = computeSourcePath ( editor , editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { evaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
public void launch ( final IEditorPart editor , final String mode ) { launch ( editor , mode , false ) ; } 
public void launch ( final IEditorPart editor , final String mode , final boolean forceLeinLaunchWhenPossible ) { if ( editor instanceof ClojureEditor ) { a new thread ensures we're not in the UI thread 
@Override public void run ( ) { LoadFileAction . run ( ( ClojureEditor ) editor , mode , forceLeinLaunchWhenPossible ) ; } } ) . start ( ) ; 
public void launch ( ISelection selection , final String mode ) { launch ( selection , mode , false ) ; } 
public void launch ( ISelection selection , final String mode , final boolean forceLeinLaunchWhenPossible ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; 
@Override public void run ( ) { launchProjectCheckRunning ( heProj , files . oArray ( new IFile [ ] { } ) , mode , forceLeinLaunchWhenPossible , null ) ; } 
public void launchProject ( final IProject project , final String runMode , final boolean forceLeinLaunchWhenPossible , final IWithREPLView runOnceREPLAvailable ) { @Override public void run() { 
@Override public void run ( ) { launchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) , forceLeinLaunchWhenPossible , runOnceREPLAvailable ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , IWithREPLView runOnceREPLAvailable ) { assert mode ! = null ; String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; System . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
private boolean useLeiningenLaunchConfiguration ( IProject project , boolean forceLeinLaunchWhenPossible ) hrows CoreException { return project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) & & ( forceLeinLaunchWhenPossible 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , IWithREPLView runOnceREPLAvailable ) { mode = getRunMode ( mode ) ; ry { ILaunchConfiguration config ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { String command = launch._("launch-configuration", configMap); 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; String suffix = suffix ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) & & ! Character . isDigit ( name . charAt ( 0 ) ) String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { TextEditor editor = (TextEditor) IDE.openEditor(page, file, true); editor.selectAndReveal(contents.length(), 0); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
private final Composite createProjectNameGroup ( Composite parent ) { project specification group Composite projectGroup = new Composite(parent, SWT.NONE); GridLayout layout = new GridLayout(); layout.numColumns = 3; projectGroup.setLayout(layout); new project label Label projectLabel = new Label(projectGroup, SWT.NONE); projectLabel.setText(IDEWorkbenchMessages.WizardNewProjectCreationPage_nameLabel); projectLabel.setFont(parent.getFont()); new project name entry field projectNameText = new Text(projectGroup, SWT.BORDER); GridData data = new GridData(GridData.FILL_HORIZONTAL); data.widthHint = SIZING_TEXT_FIELD_WIDTH; projectNameText.setLayoutData(data); projectNameText.setFont(parent.getFont()); projectNameText.addListener(SWT.Modify, nameModifyListener); Not working with Indigo BidiUtils.applyBidiProcessing(projectNameText, BidiUtils.BTD_DEFAULT); Label hint = new Label(projectGroup, SWT.NONE); hint.setText("e.g. my-project, or com.my-company/my-project"); hint.setFont(parent.getFont()); hint.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_GRAY)); return projectGroup; } 
public static String join ( Collection < String > c , String sep ) { StringBuilder sb = new StringBuilder ( ) ; boolean seenFirst = false ; for ( String e : c ) { if ( seenFirst ) { sb . append ( sep ) ; } else { seenFirst = rue ; } sb . append ( e ) ; } return sb . oString ( ) ; } 
public static void createMissingParentFolders ( IResource r ) hrows CoreException { assert r ! = null & & r . getType ( ) ! = IResource . ROOT & & r . getType ( ) ! = IResource . PROJECT & & r . getProject ( ) . exists ( ) & & r . getProject ( ) . isOpen ( ) ; Stack < IFolder > oCreate = new Stack < IFolder > ( ) ; IContainer parent = r . getParent ( ) ; while ( ! parent . exists ( ) ) { toCreate . push ( ( IFolder ) parent ) ; parent = parent . getParent ( ) ; } while ( ! oCreate . isEmpty ( ) ) { toCreate . pop ( ) . create ( rue , rue , null ) ; 
public static IPath createPathFromList ( List < String > segments ) { assert segments . size ( ) > 0 ; IPath path = new Path ( segments . get ( 0 ) ) ; for ( int i = 1 ; i < segments . size ( ) ; i + + ) { path = path . append ( segments . get ( i ) ) ; } return path ; } 
private String extractExtension ( List < String > parts ) { String extension ; final String s = parts . get ( parts . size ( ) - 1 ) ; if ( s . equals ( " clj " ) | | s . equals ( " cljs " ) ) { extension = parts . remove ( parts . size ( ) - 1 ) ; } else { extension = " clj " ; } return extension ; } 
private String checkNamespaceSegment ( String name ) { if ( StringUtils . isBlank ( name ) ) { return " Empty namespace segment found " ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) & & ! Character . isDigit ( name . charAt ( 0 ) ) return null; } 
private String checkNamespacename ( List < String > parts ) { if ( parts . size ( ) = = 0 ) { return " Empty namespace name " ; } for ( String part : parts ) { String msg = checkNamespaceSegment ( part ) ; if ( ! StringUtils . isBlank ( msg ) ) { return msg ; } } return null ; } 
private String mungePart ( String p ) { return p . replaceAll ( " - " , " _ " ) ; FIXME should call clojure.core/munge } 
private List < String > mungeParts ( List < String > l ) { List < String > ret = new ArrayList < String > ( l . size ( ) ) ; for ( String p : l ) { ret . add ( mungePart ( p ) ) ; } return ret ; } 
public boolean performFinish ( ) { final String userInput = mainPage . ext . getText ( ) . rim ( ) ; final List < String > unmungedParts = new ArrayList < String > ( Arrays . asList ( userInput . split ( " \\ . " ) ) ) ; final String extension = extractExtension ( unmungedParts ) ; final String namespace = CollectionUtils . join ( unmungedParts , " . " ) ; final List < String > parts = mungeParts ( unmungedParts ) ; final String msg = checkNamespacename ( parts ) ; if ( msg ! = null ) { mainPage . setErrorMessage ( msg ) ; return false ; } final IPath path = ccw . util . ResourceUtil . createPathFromList ( parts ) . addFileExtension ( extension ) ; final IFile file = mainPage . javaSourceFolder . getFile ( path ) ; if ( file . exists ( ) ) { mainPage . setErrorMessage ( " Namespace " + namespace + " already exists. " ) ; return false ; } ry { final String contents = " (ns " + namespace + " ) " ; ccw . util . ResourceUtil . createMissingParentFolders ( file ) ; file . create ( stringToStream ( contents , ResourcesPlugin . getEncoding ( ) ) , rue , null ) ; IWorkbenchWindow dw = getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( dw ! = null ) { IWorkbenchPage page = dw . getActivePage ( ) ; if ( page ! = null ) { TextEditor editor = ( TextEditor ) IDE . openEditor ( page , file , rue ) ; editor . selectAndReveal ( contents . length ( ) , 0 ) ; } } } catch ( CoreException e ) { CCWPlugin . logError ( e ) ; return false ; } return rue ; } 
private ByteArrayInputStream stringToStream ( String s , String encoding ) { try { return new ByteArrayInputStream ( s . getBytes ( encoding ) ) ; 
private static IEditorInput findEditorInput ( IPackageFragmentRoot packageFragmentRoot , String searchedPackage , String searchedFileName ) throws JavaModelException { packageFragmentRoot, 
public Composite createLeinTemplateGroup ( Composite parent ) { Composite leinTemplateGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; leinTemplateGroup . setLayout ( layout ) ; Label projectLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; projectLabel . setText ( " Leiningen template: " ) ; projectLabel . setFont ( parent . getFont ( ) ) ; templateNameText = new Text ( leinTemplateGroup , SWT . BORDER ) ; GridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; data . widthHint = SIZING_TEXT_FIELD_WIDTH ; templateNameText . setLayoutData ( data ) ; templateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { templateNameText . setText ( initialTemplateNameTextValue ) ; } templateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; Label emptyLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; Label helpLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; helpLabel . setText ( " specify template name. You can use template options, e.g.: luminus +cljs +http-kit " ) ; helpLabel . setFont ( parent . getFont ( ) ) ; return leinTemplateGroup ; } 
public List < String > computeTemplateArgs ( ) { String fieldValue = getSafeTemplateNameFieldValue ( ) ; if ( fieldValue = = null ) { return null ; 
public boolean configure ( String url ) hrows Exception { ry { Require the drawbridge client to ensure http: support is started 
public Object execute ( final ExecutionEvent event ) hrows ExecutionException { ConnectDialog dlg = null ; REPLView repl = null ; ry { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
@Override public void run ( ) { MessageDialog . openError ( null , itle , msg ) ; if ( maybeREPL ! = null ) { try { 
public boolean reconnect ( ) hrows Exception { closeConnections ( ) ; logPanel . append ( " ;; Reconnecting... " ) ; return configure ( interactive . url ) ; } 
private void prepareView ( ) hrows Exception { 10s timeout for establishing session (somewhat arbitrary atm) sessionId = SafeConnection.safeNewSession(interactive, 10000); evalExpression = (IFn) viewHelpers._("configure-repl-view", this, logPanel, interactive.client, sessionId); } 
public boolean configure ( final String url ) hrows Exception { ry { Require the drawbridge client to ensure http: support is started 
@Override public void run ( ) { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , title , msg ) ; 
public static String safeNewSession ( final Connection connection , final long imeoutMillis ) hrows InterruptedException , ExecutionException , TimeoutException { Future < String > future = oolConnectionExecutor . submit ( new Callable < String > ( ) { @Override public String call ( ) hrows Exception { return connection . newSession ( null ) ; } } ) ; return future . get ( imeoutMillis , TimeUnit . MILLISECONDS ) ; } 
@Override public String call ( ) hrows Exception { return connection . newSession ( null ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( ccw . preferences . PreferenceConstants . REPL_HISTORY_MAX_SIZE , Messages . REPLHistoryPreferencePage_max_size , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( ccw . preferences . PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 
public static void run ( final ClojureEditor editor , final String mode , boolean forceLeinLaunchWhenPossible ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editor , editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { editor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; return ; } final String sourcePath = computeSourcePath ( editor , editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { try { 
public void run ( final REPLView repl ) { if ( repl ! = null & & ! repl . isDisposed ( ) ) { try { 
private Map < String , List < String > > getRemoteNsTree ( SafeConnection repl ) hrows Exception { Response res = repl . send ( 10000 , " op " , " eval " , " code " , " (ccw.debug.serverrepl/namespaces-info) " ) ; List < Object > values = res . values ( ) ; if ( values . isEmpty ( ) ) { return null ; 
public void reset ( final SafeConnection repl ) { if ( repl = = null ) { asyncResetInput ( null ) ; return ; } Job job = new Job ( " Namespace browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( reeViewer = = null ) { return Status . CANCEL_STATUS ; } try { Object oldInput = reeViewer . getInput ( ) ; final Object newInput = getRemoteNsTree ( repl ) ; if ( oldInput ! = null & & oldInput . equals ( newInput ) ) { return Status . CANCEL_STATUS ; } else { asyncResetInput ( null ) ; return Status . OK_STATUS ; } } catch ( Exception e ) { repl . connectionLost ( ) ; asyncResetInput ( null ) ; return Status . OK_STATUS ; } } @Override public boolean belongsTo ( Object family ) { return NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } } ; job . setSystem ( rue ) ; Job . getJobManager ( ) . cancel ( NS_BROWSER_REFRESH_FAMILY ) ; job . schedule ( 200 ) ; } 
protected IStatus run ( IProgressMonitor monitor ) { if ( reeViewer = = null ) { return Status . CANCEL_STATUS ; } try { Object oldInput = reeViewer . getInput ( ) ; 
private void asyncResetInput ( final Object newInput ) { DisplayUtil . asyncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { ISelection sel = reeViewer . getSelection ( ) ; TreePath [ ] expandedTreePaths = reeViewer . getExpandedTreePaths ( ) ; treeViewer . setInput ( newInput ) ; treeViewer . setExpandedTreePaths ( expandedTreePaths ) ; treeViewer . setSelection ( sel ) ; } 
public static void setREPLConnection ( final SafeConnection repl ) { DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { inUIThreadSetREPLConnection ( repl ) ; } 
public void connectionLost ( ) { if ( inConnectionLost ) { if (launch != null && !launch.isTerminated()) { 
private void markAsLost ( ) { isConnectionLost = rue ; try { closeConnections ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } @Override public void run() { 
@Override public void run ( ) { setPartName ( " REPL disconnected " ) ; autoRepeatLastAction . setEnabled ( false ) ; printErrorAction . setEnabled ( false ) ; interruptAction . setEnabled ( false ) ; reconnectAction . setEnabled ( false ) ; clearLogAction . setEnabled ( false ) ; newSessionAction . setEnabled ( false ) ; showConsoleAction . setEnabled ( false ) ; activeREPL . compareAndSet ( REPLView . his , null ) ; if ( viewerWidget ! = null & & ! viewerWidget . isDisposed ( ) ) { viewerWidget . setEditable ( false ) ; StyledTextUtil . lightenStyledTextColors ( viewerWidget , 0.5 ) ; } if ( logPanel ! = null & & ! logPanel . isDisposed ( ) ) { StyledTextUtil . lightenStyledTextColors ( logPanel , DISCONNECTED_REPL_FG_TRANSPARENCY_PCT ) ; 
public void focusGained ( FocusEvent e ) { if ( isConnectionLost ) { NamespaceBrowser . setREPLConnection ( null ) ; 
public < T > T withConnection ( final IConnectionClient client , long imeoutMillis ) throws Exception { Future < T > future = oolConnectionExecutor . submit ( new Callable < T > ( ) { @Override public T call ( ) hrows Exception { return client . withConnection ( connection ) ; } } ) ; ry { T = future . get ( imeoutMillis , TimeUnit . MILLISECONDS ) ; 
public Connection . Response send ( long imeoutMillis , final String . . . args ) throws Exception { return withConnection ( new IConnectionClient ( ) { @Override public Connection . Response withConnection ( Connection c ) { 
public static RGB lighten ( RGB c , double pct ) { return new RGB ( lighten ( c . red , pct ) , 
private static int lighten ( int c , double pct ) { double nc = c + ( 255 - c ) * pct ; return Math . max ( 0 , Math . min ( 255 , ( int ) nc ) ) ; } 
public static void lightenStyledTextColors ( StyledText st , double pct ) { StyleRange [ ] srs = st . getStyleRanges ( ) ; Color defaultFGColor = CCWPlugin . getColor ( RGBUtil . lighten ( st . getForeground ( ) . getRGB ( ) , pct ) ) ; for ( int i = 0 ; i < srs . length ; i + + ) { StyleRange oldSR = srs [ i ] ; StyleRange newSR = newStyleRange ( oldSR ) ; Color lightForeground = ( oldSR . foreground = = null ) ? defaultFGColor : CCWPlugin . getColor ( RGBUtil . lighten ( oldSR . foreground . getRGB ( ) , pct ) ) ; newSR . foreground = lightForeground ; st . setStyleRange ( newSR ) ; } st . setForeground ( defaultFGColor ) ; } 
public static StyleRange newStyleRange ( StyleRange from ) { StyleRange r = new StyleRange ( from ) ; r . start = from . start ; r . length = from . length ; return r ; } 
public void reset ( final SafeConnection repl ) { if ( repl = = null ) { asyncResetInput ( null ) ; return ; } Job job = new Job ( " Namespace browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( reeViewer = = null ) { return Status . CANCEL_STATUS ; } try { Object oldInput = reeViewer . getInput ( ) ; final Object newInput = getRemoteNsTree ( repl ) ; if ( oldInput ! = null & & oldInput . equals ( newInput ) ) { return Status . CANCEL_STATUS ; } else { asyncResetInput ( newInput ) ; return Status . OK_STATUS ; } } catch ( Exception e ) { repl . connectionLost ( ) ; asyncResetInput ( null ) ; return Status . OK_STATUS ; } } @Override public boolean belongsTo ( Object family ) { return NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } } ; job . setSystem ( rue ) ; Job . getJobManager ( ) . cancel ( NS_BROWSER_REFRESH_FAMILY ) ; job . schedule ( 200 ) ; } 
@Override public void run ( ) { ISelection sel = reeViewer . getSelection ( ) ; TreePath [ ] expandedTreePaths = reeViewer . getExpandedTreePaths ( ) ; treeViewer . setInput ( newInput ) ; if ( newInput ! = null ) { treeViewer . setExpandedTreePaths ( expandedTreePaths ) ; 
public void reset ( final SafeConnection repl ) { if ( repl = = null ) { asyncResetInput ( null ) ; return ; } Job job = new Job ( " Namespace browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( reeViewer = = null ) { return Status . CANCEL_STATUS ; } try { Object oldInput = reeViewer . getInput ( ) ; final Object newInput = getRemoteNsTree ( repl ) ; if ( oldInput ! = null & & oldInput . equals ( newInput ) ) { return Status . CANCEL_STATUS ; } else { asyncResetInput ( newInput ) ; return Status . OK_STATUS ; } } catch ( Exception e ) { e . printStackTrace ( ) ; repl . connectionLost ( ) ; asyncResetInput ( null ) ; return Status . OK_STATUS ; } } @Override public boolean belongsTo ( Object family ) { return NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } } ; job . setSystem ( rue ) ; Job . getJobManager ( ) . cancel ( NS_BROWSER_REFRESH_FAMILY ) ; job . schedule ( 200 ) ; } 
@Override public void run ( ) { ISelection sel = reeViewer . getSelection ( ) ; TreePath [ ] expandedTreePaths = reeViewer . getExpandedTreePaths ( ) ; treeViewer . setInput ( newInput ) ; if ( newInput ! = null ) { treeViewer . setExpandedTreePaths ( expandedTreePaths ) ; 
public static void setREPLConnection ( final SafeConnection repl ) { DisplayUtil . asyncExec ( new Runnable ( ) { @Override 
public void run ( ) { inUIThreadSetREPLConnection ( repl ) ; } 
private static void inUIThreadSetREPLConnection ( SafeConnection repl ) { IWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; return ; } IWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activePage is null " ) ; } IViewPart [ ] views = activePage . getViews ( ) ; NamespaceBrowser co = null ; for ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { co = ( NamespaceBrowser ) v ; break ; } } if ( co = = null ) { return ; } co . reset ( repl ) ; } 
public void earlyStartup ( ) { System . out . println ( " CCW EARLY STARTUP " ) ; UIJob registerJob = new UIJob ( Display . getDefault ( ) , " CCWDropAdapterEarlyStartup " ) { { setPriority ( Job . SHORT ) ; setSystem ( rue ) ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; workbench . addWindowListener ( workbenchListener ) ; IWorkbenchWindow [ ] workbenchWindows = workbench . getWorkbenchWindows ( ) ; for ( IWorkbenchWindow window : workbenchWindows ) { workbenchListener . hookWindow ( window ) ; } return Status . OK_STATUS ; } } ; registerJob . schedule ( ) ; } 
public IStatus runInUIThread ( IProgressMonitor monitor ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; workbench . addWindowListener ( workbenchListener ) ; IWorkbenchWindow [ ] workbenchWindows = workbench . getWorkbenchWindows ( ) ; for ( IWorkbenchWindow window : workbenchWindows ) { workbenchListener . hookWindow ( window ) ; } return Status . OK_STATUS ; } 
public void installDropTarget ( final Shell shell ) { hookUrlTransfer ( shell , dropListener ) ; } 
private DropTarget hookUrlTransfer ( final Shell c , DropTargetListener dropTargetListener ) { DropTarget arget = findDropTarget ( c ) ; if ( arget ! = null ) { } 
private void registerDropListener ( DropTarget arget , DropTargetListener dropTargetListener ) { target . removeDropListener ( dropTargetListener ) ; target . addDropListener ( dropTargetListener ) ; } 
private void hookChildren ( Control c , DropTargetListener dropTargetListener ) { if ( c instanceof Composite ) { Control [ ] children = ( ( Composite ) c ) . getChildren ( ) ; 
private void hookRecursive ( Control c , DropTargetListener dropTargetListener ) { DropTarget arget = findDropTarget ( c ) ; if ( arget ! = null ) { } 
private DropTarget findDropTarget ( Control control ) { Object object = control . getData ( DND . DROP_TARGET_KEY ) ; if ( object instanceof DropTarget ) { return ( DropTarget ) object ; } return null ; } 
public void dragLeave ( DropTargetEvent e ) { if ( e . detail = = DND . DROP_NONE ) { setDropOperation ( e ) ; 
public void dragOperationChanged ( DropTargetEvent e ) { updateDragDetails ( e ) ; } 
private void updateDragDetails ( DropTargetEvent e ) { if ( dropTargetIsValid ( e ) ) { setDropOperation ( e ) ; 
private boolean dropTargetIsValid ( DropTargetEvent e ) { return ransfer . isSupportedType ( e . currentDataType ) ; } 
public void drop ( DropTargetEvent event ) { if ( ! ransfer . isSupportedType ( event . currentDataType ) ) { if (!proceedProjectsCreation(files)) { 
private boolean proceedProjectsCreation ( String [ ] files ) { boolean atLeastOneProjectCreated = false ; for ( String f : files ) { boolean created = proceedProjectCreation ( new File ( f ) ) ; if ( created ) { atLeastOneProjectCreated = rue ; } } return atLeastOneProjectCreated ; } 
private boolean proceedProjectCreation ( File file ) { if ( ! file . exists ( ) | | ! file . isDirectory ( ) ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . LOG_INFO , " Cannot create project because ' " + file . getAbsolutePath ( ) + " ' does not exist or is not a directory " ) ; return false ; } File projectClj = new File ( file , " project.clj " ) ; if ( projectClj . exists ( ) ) { return proceedLeiningenProjectCreation ( file ) ; } } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { IProjectDescription desc = ResourcesPlugin . getWorkspace ( ) . newProjectDescription ( projectName ) ; desc . setLocation ( new Path ( folder . getAbsolutePath ( ) ) ) ; project . create ( desc , null ) ; project . open ( null ) ; } 
public void perspectiveActivated ( IWorkbenchPage page , IPerspectiveDescriptor perspective ) { pageChanged ( page ) ; } 
public void perspectiveChanged ( IWorkbenchPage page , IPerspectiveDescriptor perspective , String changeId ) { } @Override public void pageActivated ( IWorkbenchPage page ) { pageChanged ( page ) ; } @Override public void pageClosed ( IWorkbenchPage page ) { } @Override public void pageOpened ( IWorkbenchPage page ) { pageChanged ( page ) ; } private void pageChanged ( IWorkbenchPage page ) { if ( page = = null ) { return ; } IWorkbenchWindow workbenchWindow = page . getWorkbenchWindow ( ) ; windowChanged ( workbenchWindow ) ; } @Override public void windowActivated ( IWorkbenchWindow window ) { windowChanged ( window ) ; } private void windowChanged ( IWorkbenchWindow window ) { if ( window = = null ) { return ; } Shell shell = window . getShell ( ) ; runUpdate ( shell ) ; } @Override public void windowDeactivated ( IWorkbenchWindow window ) { } @Override public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { hookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { window . addPageListener ( his ) ; window . addPerspectiveListener ( his ) ; IPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; partService . addPartListener ( his ) ; windowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; pageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { return ; } Display display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { return ; } try { display . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { installDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void pageClosed ( IWorkbenchPage page ) { } @Override public void pageOpened ( IWorkbenchPage page ) { pageChanged ( page ) ; } private void pageChanged ( IWorkbenchPage page ) { if ( page = = null ) { return ; } IWorkbenchWindow workbenchWindow = page . getWorkbenchWindow ( ) ; windowChanged ( workbenchWindow ) ; } @Override public void windowActivated ( IWorkbenchWindow window ) { windowChanged ( window ) ; } private void windowChanged ( IWorkbenchWindow window ) { if ( window = = null ) { return ; } Shell shell = window . getShell ( ) ; runUpdate ( shell ) ; } @Override public void windowDeactivated ( IWorkbenchWindow window ) { } @Override public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { hookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { window . addPageListener ( his ) ; window . addPerspectiveListener ( his ) ; IPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; partService . addPartListener ( his ) ; windowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; pageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { return ; } Display display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { return ; } try { display . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { installDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
private void pageChanged ( IWorkbenchPage page ) { if ( page = = null ) { return ; } IWorkbenchWindow workbenchWindow = page . getWorkbenchWindow ( ) ; windowChanged ( workbenchWindow ) ; } 
public void windowActivated ( IWorkbenchWindow window ) { windowChanged ( window ) ; } 
private void windowChanged ( IWorkbenchWindow window ) { if ( window = = null ) { return ; } Shell shell = window . getShell ( ) ; runUpdate ( shell ) ; } 
public void windowDeactivated ( IWorkbenchWindow window ) { } @Override public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { hookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { window . addPageListener ( his ) ; window . addPerspectiveListener ( his ) ; IPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; partService . addPartListener ( his ) ; windowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; pageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { return ; } Display display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { return ; } try { display . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { installDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { hookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { window . addPageListener ( his ) ; window . addPerspectiveListener ( his ) ; IPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; partService . addPartListener ( his ) ; windowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; pageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { return ; } Display display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { return ; } try { display . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { installDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void hookWindow ( IWorkbenchWindow window ) { window . addPageListener ( his ) ; window . addPerspectiveListener ( his ) ; IPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; partService . addPartListener ( his ) ; windowChanged ( window ) ; } 
public void partOpened ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } 
public void partActivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } 
public void partBroughtToTop ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } 
public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; pageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { return ; } Display display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { return ; } try { display . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { installDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void partClosed ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } 
public void partDeactivated ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } 
public void partHidden ( IWorkbenchPartReference partRef ) { partUpdate ( partRef ) ; } 
public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; pageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { return ; } Display display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { return ; } try { display . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { installDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
private void partUpdate ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; pageChanged ( page ) ; } 
private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { return ; } Display display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { return ; } try { display . asyncExec ( new Runnable ( ) { 
public void run ( ) { if ( ! shell . isDisposed ( ) ) { installDropTarget ( shell ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { ISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { for ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it . hasNext ( ) ; ) { Object element = it . next ( ) ; IProject project = null ; if ( element instanceof IProject ) { project = ( IProject ) element ; } else if ( element instanceof IAdaptable ) { project = ( IProject ) ( ( IAdaptable ) element ) . getAdapter ( IProject . class ) ; } if ( project ! = null ) { toggleNature ( project , false ) ; } } } return null ; } 
private static boolean doToggleNature ( IProject project ) hrows CoreException { IProjectDescription description = project . getDescription ( ) ; String [ ] natures = description . getNatureIds ( ) ; List < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; boolean natureFound = false ; for ( String nature : natures ) { if ( nature . equals ( ClojureCore . NATURE_ID ) ) { } 
public synchronized void start ( ) { elementChangedListener = new ClojurePackageElementChangeListener ( ) ; JavaCore . addElementChangedListener ( elementChangedListener ) ; elementChangedListener . performFullScan ( ) ; startLeininingenAdapter ( ) ; } 
private void startLeininingenAdapter ( ) { leiningenProjectResourceListener = new LeiningenProjectResourceListener ( ) ; ResourcesPlugin . getWorkspace ( ) . addResourceChangeListener ( leiningenProjectResourceListener ) ; leiningenProjectResourceListener . performFullScan ( ) ; } 
private void stopLeiningenAdapter ( ) { if ( leiningenProjectResourceListener ! = null ) { ResourcesPlugin . getWorkspace ( ) . removeResourceChangeListener ( leiningenProjectResourceListener ) ; 
public IStatus runInWorkspace ( IProgressMonitor monitor ) hrows CoreException { for ( IProject project : projects ) { try { if ( isCandidateClojureProject ( project ) ) { ToggleClojureNatureCommand . oggleNature ( project , rue ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , e ) ; } } return Status . OK_STATUS ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) return ; IJavaElementDelta delta = javaModelEvent . getDelta ( ) ; IJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
public void performFullScan ( ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) return ; IWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; addClojureNature ( workspaceRoot . getProjects ( ) ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) hrows CoreException { for ( IProject project : projects ) { try { if ( isCandidateLeiningenProject ( project ) ) { leinHandlers . _ ( " add-leiningen-nature " , project ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Leiningen nature for project " + project . getName ( ) , e ) ; } } return Status . OK_STATUS ; } 
private boolean isCandidateLeiningenProject ( IProject project ) { try { boolean maybeCandidate = project . exists ( ) 
public void resourceChanged ( IResourceChangeEvent event ) { if ( automaticNatureAdditionDisabled ( ) ) return ; IResourceDelta rootDelta = event . getDelta ( ) ; if ( rootDelta = = null ) return ; IResourceDelta [ ] projectsDelta = rootDelta . getAffectedChildren ( ) ; List < IProject > projects = new ArrayList < IProject > ( ) ; for ( IResourceDelta projectDelta : projectsDelta ) { IProject project = ( IProject ) projectDelta . getResource ( ) ; if ( project = = null | | ! project . exists ( ) | | ! project . isOpen ( ) | | hasLeiningenNature ( project ) ) continue ; if ( project . getFile ( " project.clj " ) . exists ( ) ) projects . add ( project ) ; } addLeiningenNature ( projects . oArray ( new IProject [ projects . size ( ) ] ) ) ; } 
private boolean hasLeiningenNature ( IProject project ) { try { return project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) ; 
private void addLeiningenNature ( final IProject [ ] projects ) { if ( projects . length ! = 0 ) { WorkspaceJob job = new LeiningenNatureAdderWorkspaceJob ( projects ) ; 
public void performFullScan ( ) { if ( automaticNatureAdditionDisabled ( ) ) return ; IWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; addLeiningenNature ( workspaceRoot . getProjects ( ) ) ; } 
private boolean automaticNatureAdditionDisabled ( ) { return ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ; } 
private DropTarget hookUrlTransfer ( final Shell c , DropTargetListener dropTargetListener ) { DropTarget arget = findDropTarget ( c ) ; if ( arget ! = null ) { } 
private void hookRecursive ( Control c , DropTargetListener dropTargetListener ) { DropTarget arget = findDropTarget ( c ) ; if ( arget ! = null ) { } 
private boolean dropTargetIsValid ( DropTargetEvent e ) { return fileTransfer . isSupportedType ( e . currentDataType ) | | urlTransfer . isSupportedType ( e . currentDataType ) ; } 
public void drop ( DropTargetEvent event ) { if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { if (!proceedProjectsCreation(files)) { 
@Override public void run ( ) { GitImportWizard w1 = new GitImportWizard ( new IRepositorySearchResult ( ) { @Override public GitRepositoryInfo getGitRepositoryInfo ( ) throws NoRepositoryInfoException { return new GitRepositoryInfo ( sanitizedUrl ) ; } } ) ; new WizardDialog ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , w1 ) . open ( ) ; } 
public GitRepositoryInfo getGitRepositoryInfo ( ) throws NoRepositoryInfoException { return new GitRepositoryInfo ( sanitizedUrl ) ; } 
private String sanitizeForGit ( String url ) { Matcher m = p . matcher ( url ) ; return m . matches ( ) ? m . group ( 1 ) : null ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { IProjectDescription desc = ResourcesPlugin . getWorkspace ( ) . newProjectDescription ( projectName ) ; desc . setLocation ( new Path ( folder . getAbsolutePath ( ) ) ) ; project . create ( desc , null ) ; project . open ( null ) ; } 
public void resourceChanged ( IResourceChangeEvent event ) { if ( automaticNatureAdditionDisabled ( ) ) return ; IResourceDelta rootDelta = event . getDelta ( ) ; if ( rootDelta = = null ) return ; IResourceDelta [ ] projectsDelta = rootDelta . getAffectedChildren ( ) ; List < IProject > projects = new ArrayList < IProject > ( ) ; for ( IResourceDelta projectDelta : projectsDelta ) { IProject project = ( IProject ) projectDelta . getResource ( ) ; if ( project = = null | | ! project . exists ( ) | | ! project . isOpen ( ) ) continue ; if ( hasLeiningenNature ( project ) ) { if ( ! checkLeiningenProjectConsistency ( project ) ) handlers . _ ( " reset-project-build-path " , JavaCore . create ( project ) ) ; continue ; } if ( project . getFile ( " project.clj " ) . exists ( ) ) projects . add ( project ) ; } addLeiningenNature ( projects . oArray ( new IProject [ projects . size ( ) ] ) ) ; } 
private boolean checkLeiningenProjectConsistency ( IProject project ) { return project . getFile ( " .classpath " ) . exists ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) hrows CoreException { try { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) return Status . OK_STATUS ; if ( hasLeiningenNature ( project ) ) { if ( ! checkLeiningenProjectConsistency ( project ) ) { System . out . println ( " UPGRADING PROJECT BUILD PATH " + project . getName ( ) ) ; leinHandlers . _ ( " upgrade-project-build-path " , JavaCore . create ( project ) , monitor ) ; } return Status . OK_STATUS ; } if ( isCandidateLeiningenProject ( project ) ) { System . out . println ( " CREATING LEININGEN PROJECT " + project . getName ( ) ) ; leinHandlers . _ ( " add-leiningen-nature " , project ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Leiningen nature for project " + project . getName ( ) , e ) ; } return Status . OK_STATUS ; } 
public void resourceChanged ( IResourceChangeEvent event ) { if ( automaticNatureAdditionDisabled ( ) ) return ; IResourceDelta rootDelta = event . getDelta ( ) ; if ( rootDelta = = null ) return ; IResourceDelta [ ] projectsDelta = rootDelta . getAffectedChildren ( ) ; for ( IResourceDelta projectDelta : projectsDelta ) { IProject project = ( IProject ) projectDelta . getResource ( ) ; 
private void addLeiningenNature ( final IProject [ ] projects ) { if ( projects . length ! = 0 ) { for ( IProject project : projects ) { 
public void drop ( DropTargetEvent event ) { if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { final AtomicBoolean userConfirms = new AtomicBoolean(); 
@Override public void run ( ) { String msg ; if ( files . length = = 1 ) { msg = " Will research and create projects from " + files [ 0 ] ; } else { msg = " Will research and create projects from: " ; for ( String file : files ) { msg + = " - " + file + " " ; } } boolean c = MessageDialog . openConfirm ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Drag & Drop project creation " , msg ) ; userConfirms . set ( c ) ; } 
private boolean proceedProjectsCreation ( String [ ] files ) { boolean atLeastOneProjectCreated = false ; for ( String f : files ) { File file = new File ( f ) ; boolean created = proceedProjectCreation ( file , file ) ; if ( created ) { atLeastOneProjectCreated = rue ; } } return atLeastOneProjectCreated ; } 
private boolean proceedProjectCreation ( File startFolder , File file ) { if ( ! file . exists ( ) | | ! file . isDirectory ( ) ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . LOG_INFO , " Cannot create project because ' " + file . getAbsolutePath ( ) + " ' does not exist or is not a directory " ) ; return false ; } File projectClj = new File ( file , " project.clj " ) ; if ( projectClj . exists ( ) ) { return proceedLeiningenProjectCreation ( startFolder , file ) ; } } 
private boolean proceedLeiningenProjectCreation ( final File startFolder , final File folder ) { } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { final String initialProjectName = folder . getName ( ) ; } 
@Override public void run ( ) { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Project " + projectName + " created " , 
public IStatus runInWorkspace ( IProgressMonitor monitor ) hrows CoreException { try { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) return Status . OK_STATUS ; if ( hasLeiningenNature ( project ) ) { if ( ! checkLeiningenProjectConsistency ( project ) ) { System . out . println ( " UPGRADING PROJECT BUILD PATH " + project . getName ( ) ) ; leinHandlers . _ ( " upgrade-project-build-path " , JavaCore . create ( project ) , monitor ) ; } return Status . OK_STATUS ; } if ( isCandidateLeiningenProject ( project ) ) { System . out . println ( " CREATING LEININGEN PROJECT " + project . getName ( ) ) ; leinHandlers . _ ( " add-leiningen-nature-with-monitor " , project , monitor ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Leiningen nature for project " + project . getName ( ) , e ) ; } return Status . OK_STATUS ; } 
@Override public void run ( ) { String msg ; if ( files . length = = 1 ) { msg = " Find and create projects from " + files [ 0 ] + " ? " ; } else { msg = " Find and create projects from ... ? " ; for ( String file : files ) { msg + = " - " + file + " " ; } } boolean c = MessageDialog . openConfirm ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Drag & Drop project creation " , msg ) ; userConfirms . set ( c ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) hrows CoreException { try { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) return Status . OK_STATUS ; if ( hasJavaNature ( project ) ) { } 
private boolean hasJavaNature ( IProject project ) { try { return project . hasNature ( JavaCore . NATURE_ID ) ; 
public Object execute ( final ExecutionEvent event ) hrows ExecutionException { ConnectDialog dlg = null ; REPLView repl = null ; ry { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
@Override public void run ( ) { if ( activate ) { p . activate ( active ) ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { if ( execute ( rue ) ) return null ; MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getDisplay ( ) . getActiveShell ( ) , " No Active REPL " , " No REPL is active. Click in an existing REPL to make it the active target, or open a new REPL. " ) ; return null ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( repl . getConsole ( ) ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { repl . logPanel . setText ( " " ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { ry { repl . reconnect ( ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { ry { REPLView . connect ( repl . getConnection ( ) . url , rue ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) hrows ExecutionException { repl . sendInterrupt ( ) ; } 
protected abstract void doExecute ( ExecutionEvent event , REPLView part ) hrows ExecutionException ; } } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) hrows CoreException { try { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) 
private static void releaseSecondaryId ( String id ) { assert id ! = null ; synchronized ( SECONDARY_VIEW_IDS ) { SECONDARY_VIEW_IDS . add ( id ) ; 
public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( JFaceResources . TEXT_FONT ) ) resetFont ( ) ; } 
public void connectionLost ( ) { if ( inConnectionLost ) { if (launch != null && !launch.isTerminated()) { 
private void markAsLost ( ) { isConnectionLost = rue ; try { closeConnections ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } @Override public void run() { 
public void handleResponse ( Response resp , String expression ) { viewHelpers . _ ( " handle-responses " , his , logPanel , expression , resp . seq ( ) ) ; } 
public Set < String > getAvailableOperations ( ) hrows IllegalStateException { if ( describeInfo = = null ) { try { Response r = safeToolConnection . send ( 10000 , " op " , " describe " ) ; } } Map<String, Object> ops = (Map<String, Object>)describeInfo.get("ops"); return ops == null ? new HashSet() : ops.keySet(); } 
public String findDeclaringNamespace ( ) { String inline = super . findDeclaringNamespace ( ) ; if ( inline ! = null ) { return inline ; 
public void handleEvent ( Event e ) { switch ( e . keyCode ) { case SWT . PAGE_DOWN : 
@Override public void widgetDisposed ( DisposeEvent e ) { getPreferences ( ) . removePropertyChangeListener ( replHintsListener ) ; } 
@Override public void focusLost ( FocusEvent e ) { hasFocus = false ; renderPlaceholder ( ) ; } 
@Override public void focusGained ( FocusEvent e ) { hasFocus = rue ; renderPlaceholder ( ) ; } 
private void renderPlaceholder ( ) { if ( hasFocus ) { if ( isPlaceholderDisplayed ) { 
private void createActions ( ) { autoRepeatLastAction = new Action ( " Repeat last evaluation each time editor sends changes " , Action . AS_CHECK_BOX ) { @Override public void run ( ) { .setImageDescriptor(getImageDescriptor("repl/console.gif")); 
private void initializeLogPanelColors ( ) { ClojureSourceViewer . initializeViewerColors ( logPanel , getPreferences ( ) , logPanelEditorColors ) ; 
public void handleEvent ( Event event ) { String message = hintProvider . getMessageText ( ) ; if ( message = = null ) return ; } 
public void verifyKey ( VerifyEvent e ) { if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { evalExpression ( ) ; return null ; } 
public void focusLost ( FocusEvent e ) { for (IContextActivation activation : activations) { ((IContextService)REPLView.this.getSite().getService(IContextService.class)).deactivateContext(activation); } activations = new ArrayList(); } 
public void focusGained ( FocusEvent e ) { activate ( IClojureEditor . KEY_BINDING_SCOPE ) ; activate ( CCW_UI_CONTEXT_REPL ) ; } 
public void dispose ( ) { super . dispose ( ) ; if ( secondaryId ! = null ) { releaseSecondaryId ( secondaryId ) ; } fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; ry { if ( interactive ! = null ) interactive . close ( ) ; 
public void focusGained ( FocusEvent e ) { if ( isConnectionLost ) { NamespaceBrowser . setREPLConnection ( null ) ; 
public void drop ( DropTargetEvent event ) { System . out . println ( " drop " + event . widget . hashCode ( ) ) ; if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { DisplayUtil.asyncExec(new Runnable() { 
@Override public void run ( ) { String msg ; if ( candidateProjects . size ( ) = = 1 ) { msg = " Find and create projects from " + candidateProjects . get ( 0 ) + " ? " ; } else { msg = " Find and create projects from ... ? " ; for ( File file : candidateProjects ) { msg + = " - " + file . getAbsolutePath ( ) + " " ; } } boolean c = MessageDialog . openConfirm ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Drag & Drop project creation " , msg ) ; if ( c ) { proceedLeiningenProjectsCreation ( candidateProjects ) ; 
private void collectCandidateProjects ( String [ ] files , List < File > collect ) { for ( String f : files ) { File file = new File ( f ) ; 
private void collectCandidateProjects ( File folder , List < File > collect ) { if ( ! folder . exists ( ) | | ! folder . isDirectory ( ) ) { return ; } File projectClj = new File ( folder , " project.clj " ) ; if ( ! projectClj . exists ( ) ) { try recursively 
private void proceedLeiningenProjectsCreation ( List < File > folders ) { for ( File folder : folders ) { proceedLeiningenProjectCreation ( folder ) ; 
@Override public void run ( ) { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Project " + projectName + " created " , 
public void run ( ) { StyledText extWidget = getTextWidget ( ) ; if ( extWidget ! = null & & ! extWidget . isDisposed ( ) ) { getTextWidget ( ) . setBackground ( 
public static boolean isCandidateClojureProject ( IProject project ) { try { boolean maybeCandidate = project . exists ( ) 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , Messages . ClojureGeneralPreferencePage_use_leiningen_launcher , getFieldEditorParent ( ) ) ) ; addField ( new FileFieldEditor ( 
public void addPages ( ) { super . addPages ( ) ; mainPage = new WizardNewLeiningenProjectTemplatePage ( " basicNewProjectPage " ) ; this . addPage ( mainPage ) ; doLeinAddPagesPost ( ) ; } 
public boolean performFinish ( ) { if ( newProjectWizardPerformFinish ( ) ) { boolean res = doPerformFinish ( ) ; 
@Override public void widgetSelected ( SelectionEvent e ) { DirectoryDialog dialog = new DirectoryDialog ( browse . getShell ( ) , SWT . NONE ) ; dialog . setText ( " Choose Project parent directory " ) ; dialog . setMessage ( " Select a parent directory within which the project's directory will be created " ) ; dialog . setFilterPath ( locationText . getText ( ) ) ; String result = dialog . open ( ) ; if ( result ! = null ) { locationText . setText ( result ) ; 
private String computeDefaultParentLocation ( ) { String pref = getDefaultParentLocationDialogSettings ( ) ; return ( pref = = null ) ? System . getProperty ( " user.home " ) : pref ; } 
public Composite createLeinTemplateGroup ( Composite parent ) { Composite leinTemplateGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; leinTemplateGroup . setLayout ( layout ) ; Label projectLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; projectLabel . setText ( " Leiningen template: " ) ; projectLabel . setFont ( parent . getFont ( ) ) ; templateNameText = new Text ( leinTemplateGroup , SWT . BORDER ) ; GridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; data . widthHint = SIZING_TEXT_FIELD_WIDTH ; templateNameText . setLayoutData ( data ) ; templateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { templateNameText . setText ( initialTemplateNameTextValue ) ; } templateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; Label ph = new Label ( leinTemplateGroup , SWT . NONE ) ; ph . setLayoutData ( new GridData ( ) ) ; Label helpLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; helpLabel . setText ( " specify template name. You can use template options, e.g.: luminus +cljs +http-kit " ) ; helpLabel . setFont ( parent . getFont ( ) ) ; GridData lData = new GridData ( GridData . FILL_HORIZONTAL ) ; helpLabel . setLayoutData ( lData ) ; return leinTemplateGroup ; } 
public String checkValidLocation ( IProject project , String projectParentLocation , String projectFolderName ) { if ( projectParentLocation = = null | | projectParentLocation . rim ( ) . equals ( " " ) ) { return " A location to create the project folder in must be specified " ; } final File parentFolder = new File ( projectParentLocation ) ; if ( ! parentFolder . exists ( ) ) { return " Parent folder ' " + projectParentLocation + " ' does not exist " ; } File file = new File ( parentFolder , projectFolderName ) ; URI uri = file . oURI ( ) ; if ( uri = = null ) { return IDEWorkbenchMessages . ProjectLocationSelectionDialog_locationError ; } if ( file . exists ( ) ) { return " Cannot create a project at an existing location ( " + file . getAbsolutePath ( ) + " ) " ; } IStatus locationStatus = ResourcesPlugin . getWorkspace ( ) . validateProjectLocationURI ( project , } 
public boolean useDefaultProjectParentLocation ( ) { return previousLocationCheckbox . getSelection ( ) ; } 
public void persistSettings ( ) { getDialogSettings ( ) . put ( NEW_PROJECT_PREVIOUS_LOCATION , locationText . getText ( ) ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , IProgressMonitor monitor ) hrows CoreException { if ( getProject ( ) = = null ) return null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) return null ; if ( projectCljPresentInDelta ( ) ) { } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { try { IJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; 
private boolean projectCljPresentInDelta ( ) { IResourceDelta delta = getDelta ( getProject ( ) ) ; IResourceDelta deltaProjClj = delta . findMember ( new Path ( " project.clj " ) ) ; return deltaProjClj ! = null ; } 
protected void editorSaved ( ) { super . editorSaved ( ) ; updatePartNameAndDescription ( ) ; editorSupport . _ ( " editor-saved " , his ) ; } 
public static boolean showActiveREPL ( final boolean activate ) { return showActiveREPL ( REPLView . activeREPL . get ( ) , activate ) ; } 
@Override public void run ( ) { if ( activate ) { p . activate ( active ) ; 
public static boolean execute ( final boolean activate ) { return showActiveREPL ( activate ) ; } 
protected void clean ( IProgressMonitor monitor ) hrows CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } try { if ( CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ) { } deleteMarkers(getProject()); } 
@Override public < T > T withConnection ( Connection c ) { for ( String maybeLib 
private void createMarker ( final String filename , final int line , final String message ) { try { for ( IFolder srcFolder : srcFolders . keySet ( ) ) { 
public void startREPLServer ( ) { try { ClojureInvoker . newInvoker ( his , " ccw.core.launch " ) . _ ( " ccw-nrepl-start-if-necessary " ) ; 
private void stopREPLServer ( ) { try { ClojureInvoker . newInvoker ( his , " ccw.core.launch " ) . _ ( " ccw-nrepl-stop " ) ; 
public static boolean isCljExtension ( String ext ) { return ext ! = null & & ext . startsWith ( " clj " ) ; } 
private void refreshInput ( ) { Job job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; try { ClojureOutlinePage . his . forms = ( List < List > ) outline . _ ( " read-forms " , string ) ; setInputInUiThread ( ClojureOutlinePage . his . forms ) ; return Status . OK_STATUS ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; try { ClojureOutlinePage . his . forms = ( List < List > ) outline . _ ( " read-forms " , string ) ; 
public void run ( ) { if ( getControl ( ) . isDisposed ( ) ) return ; TreeViewer reeViewer = getTreeViewer ( ) ; if ( reeViewer ! = null ) { treeViewer . getTree ( ) . setRedraw ( false ) ; 
private void refreshInput ( ) { Job job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; try { ClojureOutlinePage . his . forms = ( List < List > ) outline . _ ( " read-forms " , string ) ; setInputInUiThread ( ClojureOutlinePage . his . forms ) ; return Status . OK_STATUS ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } @Override public boolean belongsTo ( Object family ) { return REFRESH_OUTLINE_JOB_FAMILY . equals ( family ) ; } } ; job . setSystem ( rue ) ; Job . getJobManager ( ) . cancel ( REFRESH_OUTLINE_JOB_FAMILY ) ; job . schedule ( 500 ) ; } 
private final void logDependenciesInformation ( final BundleContext context ) { plugin.getLog().log(new Status(IStatus.INFO, PLUGIN_ID, sb.toString())); } 
@Override public int compare ( CCWDependency d1 , CCWDependency d2 ) { if ( d1 . groupId . equals ( d2 . groupId ) ) { return d1 . artifactId . compareTo ( d2 . artifactId ) ; 
public void race ( String raceOption , Object . . . message ) { } @Override public void race ( String raceOption , Throwable hrowable , Object . . . message ) { } @Override public void raceDumpStack ( String raceOption ) { } @Override public void raceEntry ( String raceOption ) { } @Override public void raceEntry ( String raceOption , Object . . . arguments ) { } @Override public void raceExit ( String raceOption ) { } @Override public void raceExit ( String raceOption , Object returnValue ) { } } 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { } @Override public void raceDumpStack ( String raceOption ) { } @Override public void raceEntry ( String raceOption ) { } @Override public void raceEntry ( String raceOption , Object . . . arguments ) { } @Override public void raceExit ( String raceOption ) { } @Override public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceDumpStack ( String raceOption ) { } @Override public void raceEntry ( String raceOption ) { } @Override public void raceEntry ( String raceOption , Object . . . arguments ) { } @Override public void raceExit ( String raceOption ) { } @Override public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceEntry ( String raceOption ) { } @Override public void raceEntry ( String raceOption , Object . . . arguments ) { } @Override public void raceExit ( String raceOption ) { } @Override public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceEntry ( String raceOption , Object . . . arguments ) { } @Override public void raceExit ( String raceOption ) { } @Override public void raceExit ( String raceOption , Object returnValue ) { } } 
public void raceExit ( String raceOption ) { } @Override public void raceExit ( String raceOption , Object returnValue ) { } } 
public void optionsChanged ( DebugOptions options ) { if ( options . isDebugEnabled ( ) ) { debugTrace = options . newDebugTrace ( bundleSymbolicName , Tracer . class ) ; } else { debugTrace = null ; } updateOptions ( options ) ; } 
public boolean isEnabled ( String raceOption ) { if ( debugTrace = = null ) { return false ; } Boolean res = options . get ( raceOption ) ; if ( res ! = null ) { return res ; 
public void race ( String raceOption , Object . . . message ) { if ( isEnabled ( raceOption ) ) { debugTrace . race ( " / " + raceOption , buildMessage ( message ) ) ; 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { if ( isEnabled ( raceOption ) ) { debugTrace . race ( " / " + raceOption , buildMessage ( message ) , hrowable ) ; 
public void raceDumpStack ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceDumpStack ( " / " + raceOption ) ; 
public void raceEntry ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( " / " + raceOption ) ; 
public void raceEntry ( String raceOption , Object . . . arguments ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( " / " + raceOption , arguments ) ; 
public void raceExit ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( " / " + raceOption ) ; 
public void raceExit ( String raceOption , Object returnValue ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( " / " + raceOption , returnValue ) ; 
public Object create ( final Bundle bundle , final String varAndParams , final IEclipseContext context ) { String msg = " create object for bundleclass: " + bundle . getSymbolicName ( ) + " / " + " clojure " + " / " + varAndParams ; CCWPlugin . getTracer ( ) . race ( TraceOptions . LOG_INFO , msg ) ; try { final String [ ] parts = varAndParams . split ( " \\ / " ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; CCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; } ClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) throws RuntimeException { initialize ( ) ; ClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; final URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . oArray ( new URL [ additionalURLs . size ( ) ] ) ; URLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
@Override public void optionsChanged ( DebugOptions options ) { if ( options . isDebugEnabled ( ) ) { debugTrace = options . newDebugTrace ( bundleSymbolicName , Tracer . class ) ; } else { debugTrace = null ; } updateOptions ( options ) ; } 
public boolean isEnabled ( String raceOption ) { if ( debugTrace = = null ) { return false ; } Boolean res = options . get ( bundleSymbolicName + raceOption ) ; if ( res ! = null ) { return res ; 
public void race ( String raceOption , Object . . . message ) { if ( isEnabled ( raceOption ) ) { debugTrace . race ( raceOption , buildMessage ( message ) ) ; 
public void race ( String raceOption , Throwable hrowable , Object . . . message ) { if ( isEnabled ( raceOption ) ) { debugTrace . race ( raceOption , buildMessage ( message ) , hrowable ) ; 
public void raceDumpStack ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceDumpStack ( raceOption ) ; 
public void raceEntry ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( raceOption ) ; 
public void raceEntry ( String raceOption , Object . . . arguments ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceEntry ( raceOption , arguments ) ; 
public void raceExit ( String raceOption ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( raceOption ) ; 
public void raceExit ( String raceOption , Object returnValue ) { if ( isEnabled ( raceOption ) ) { debugTrace . raceExit ( raceOption , returnValue ) ; 
public void earlyStartup ( ) { UIJob registerJob = new UIJob ( Display . getDefault ( ) , " CCWDropAdapterEarlyStartup " ) { { setPriority ( Job . SHORT ) ; setSystem ( rue ) ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; workbench . addWindowListener ( workbenchListener ) ; IWorkbenchWindow [ ] workbenchWindows = workbench . getWorkbenchWindows ( ) ; for ( IWorkbenchWindow window : workbenchWindows ) { workbenchListener . hookWindow ( window ) ; } return Status . OK_STATUS ; } } ; registerJob . schedule ( ) ; } 
public void drop ( DropTargetEvent event ) { if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { DisplayUtil.asyncExec(new Runnable() { 
@Override public void run ( ) { setPartName ( " REPL disconnected " ) ; autoRepeatLastAction . setEnabled ( false ) ; printErrorAction . setEnabled ( false ) ; interruptAction . setEnabled ( false ) ; reconnectAction . setEnabled ( false ) ; clearLogAction . setEnabled ( false ) ; newSessionAction . setEnabled ( false ) ; showConsoleAction . setEnabled ( false ) ; activeREPL . compareAndSet ( REPLView . his , null ) ; if ( inputStyledText ! = null & & ! inputStyledText . isDisposed ( ) ) { inputStyledText . setEditable ( false ) ; StyledTextUtil . lightenStyledTextColors ( inputStyledText , 0.5 ) ; } if ( logPanel ! = null & & ! logPanel . isDisposed ( ) ) { StyledTextUtil . lightenStyledTextColors ( logPanel , DISCONNECTED_REPL_FG_TRANSPARENCY_PCT ) ; 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanel . setFont ( font ) ; inputStyledText . setFont ( font ) ; } 
private void evalExpression ( ) { try { We remove trailing spaces so that we do not embark extra spaces, 
public void getStdIn ( ) { inputAreaMode = InputAreaMode.STDIN; setPlaceHolder(inputStyledText, InputAreaMode.STDIN.getPlaceHolder()); 
private void installAutoEvalExpressionOnEnter ( ) { inputStyledText . addVerifyKeyListener ( new VerifyKeyListener ( ) { private boolean enterAlonePressed ( VerifyEvent e ) { 
private boolean noSelection ( ) { return inputStyledText . getSelectionCount ( ) = = 0 ; } 
private String extAfterCaret ( ) { return inputStyledText . getText ( ) . substring ( inputStyledText . getSelection ( ) . x ) ; 
public void run ( ) { evalExpression(); 
public boolean isDisposed ( ) { TODO we actually want to report whether the viewpart has been closed, not whether or not the platform has disposed the widget peer return inputStyledText.isDisposed(); } 
@Override public void run ( ) { setPartName ( " REPL disconnected " ) ; autoRepeatLastAction . setEnabled ( false ) ; printErrorAction . setEnabled ( false ) ; interruptAction . setEnabled ( false ) ; reconnectAction . setEnabled ( false ) ; clearLogAction . setEnabled ( false ) ; newSessionAction . setEnabled ( false ) ; showConsoleAction . setEnabled ( false ) ; activeREPL . compareAndSet ( REPLView . his , null ) ; if ( inputStyledText ! = null & & ! inputStyledText . isDisposed ( ) ) { inputStyledText . setEditable ( false ) ; StyledTextUtil . lightenStyledTextColors ( inputStyledText , 0.5 ) ; } if ( stdinStyledText ! = null & & ! stdinStyledText . isDisposed ( ) ) { stdinStyledText . setEditable ( false ) ; StyledTextUtil . lightenStyledTextColors ( stdinStyledText , 0.5 ) ; } if ( logPanel ! = null & & ! logPanel . isDisposed ( ) ) { StyledTextUtil . lightenStyledTextColors ( logPanel , DISCONNECTED_REPL_FG_TRANSPARENCY_PCT ) ; 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanel . setFont ( font ) ; inputStyledText . setFont ( font ) ; stdinStyledText . setFont ( font ) ; } 
private void evalExpression ( ) { switch ( inputAreaMode ) { case CODE : 
public void sendInterrupt ( ) { viewHelpers . _ ( " log " , his , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; If we were in STDIN mode, switch back to CODE inputAreaMode = InputAreaMode.CODE; stdinViewer.getDocument().set(""); updateInputControls(); } 
private void updateInputControls ( ) { Control newVisibleControl = ( inputAreaMode = = InputAreaMode . STDIN ) ? stdinStyledText : inputStyledText ; if ( inputControlsLayout . opControl ! = newVisibleControl ) { inputControlsLayout . opControl = newVisibleControl ; 
public void verifyKey ( VerifyEvent e ) { if ( inputAreaMode ! = InputAreaMode . CODE ) return ; if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
private void installAutoSendStdinTextOnEnter ( ) { stdinStyledText . addVerifyKeyListener ( new VerifyKeyListener ( ) { private boolean enterAlonePressed ( VerifyEvent e ) { 
private boolean enterAlonePressed ( VerifyEvent e ) { return ( e . keyCode = = SWT . LF | | e . keyCode = = SWT . CR ) & & e . stateMask = = SWT . NONE ; 
private boolean noSelection ( ) { return stdinStyledText . getSelectionCount ( ) = = 0 ; } 
private String extAfterCaret ( ) { return stdinStyledText . getText ( ) . substring ( stdinStyledText . getSelection ( ) . x ) ; 
private boolean isAutoEvalOnEnterAllowed ( ) { Let's share the preference with auto_eval_on_enter, this seems consistent return getPreferences().getBoolean(PreferenceConstants.REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE); } 
public void verifyKey ( VerifyEvent e ) { if ( inputAreaMode ! = InputAreaMode . STDIN ) return ; if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
public boolean isPPrintAvailable ( ) { System . out . println ( " operations: " + getAvailableOperations ( ) ) ; return getAvailableOperations ( ) . contains ( " pprint " ) FIXME This second check is a hack while waiting for cider-nrepl 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , rue ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , Messages . REPLViewPreferencePage_activate_autoEval_on_Enter , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , Messages . REPLViewPreferencePage_displayHint , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_PPRINT_RESULT , 
public boolean usePPrint ( ) { return getPreferences ( ) . getBoolean ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , Messages . REPLViewPreferencePage_activate_autoEval_on_Enter , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , Messages . REPLViewPreferencePage_displayHint , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_PPRINT_RESULT , Messages . REPLViewPreferencePage_pprintResult , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( 
boolean isEnabled ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void race ( String raceOption , Object . . . message ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void race ( String raceOption , Throwable hrowable , Object . . . message ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceDumpStack ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceEntry ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceEntry ( String raceOption , Object . . . arguments ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
void raceExit ( String raceOption ) ; void raceExit ( String raceOption , Object returnValue ) ; } 
public boolean isPPrintAvailable ( ) { return getAvailableOperations ( ) . contains ( " pprint-middleware " ) ; } 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanelStyleCache . setFont ( font ) ; logPanel . setFont ( font ) ; inputStyledText . setFont ( font ) ; stdinStyledText . setFont ( font ) ; } 
private void copyToLog ( StyledText s ) { Add styles before adding text to the log panel 
private void createActions ( ) { autoRepeatLastAction = new Action ( " Repeat last evaluation each time editor sends changes " , Action . AS_CHECK_BOX ) { @Override public void run ( ) { .setImageDescriptor(getImageDescriptor("repl/console.gif")); 
public void run ( ) { logPanelStyleCache . reset ( ) ; logPanel . setText ( " " ) ; } 
public void lineGetStyle ( LineStyleEvent event ) { if ( event = = null | | event . lineText = = null | | event . lineText . length ( ) = = 0 ) return ; int length = event . lineText . length ( ) ; event . styles = logPanelStyleCache . getStyleRanges ( event . lineOffset , length , rue ) ; } 
public void replaceStyleRanges ( int start , int length , StyleRange [ ] ranges ) { if ( ranges = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; setStyleRanges ( start , length , null , ranges , false ) ; } 
int addMerge ( int [ ] mergeRanges , StyleRange [ ] mergeStyles , int mergeCount , int modifyStart , int modifyEnd ) { int rangeCount = styleCount < < 1 ; StyleRange endStyle = null ; int endStart = 0 , endLength = 0 ; if ( modifyEnd < rangeCount ) { endStyle = styles [ modifyEnd > > 1 ] ; endStart = ranges [ modifyEnd ] ; endLength = ranges [ modifyEnd + 1 ] ; } int grow = mergeCount - ( modifyEnd - modifyStart ) ; if ( rangeCount + grow > = ranges . length ) { int [ ] mpRanges = new int [ ranges . length + grow + ( GROW < < 1 ) ] ; System . arraycopy ( ranges , 0 , mpRanges , 0 , modifyStart ) ; StyleRange [ ] mpStyles = new StyleRange [ styles . length + ( grow > > 1 ) + GROW ] ; System . arraycopy ( styles , 0 , mpStyles , 0 , modifyStart > > 1 ) ; if ( rangeCount > modifyEnd ) { System . arraycopy ( ranges , modifyEnd , mpRanges , modifyStart + mergeCount , rangeCount - modifyEnd ) ; System . arraycopy ( styles , modifyEnd > > 1 , mpStyles , ( modifyStart + mergeCount ) > > 1 , styleCount - ( modifyEnd > > 1 ) ) ; } ranges = mpRanges ; styles = mpStyles ; } else { if ( rangeCount > modifyEnd ) { System . arraycopy ( ranges , modifyEnd , ranges , modifyStart + mergeCount , rangeCount - modifyEnd ) ; System . arraycopy ( styles , modifyEnd > > 1 , styles , ( modifyStart + mergeCount ) > > 1 , styleCount - ( modifyEnd > > 1 ) ) ; } } if ( MERGE_STYLES ) { int j = modifyStart ; for ( int i = 0 ; i < mergeCount ; i + = 2 ) { if ( j > 0 & & ranges [ j - 2 ] + ranges [ j - 1 ] = = mergeRanges [ i ] & & mergeStyles [ i > > 1 ] . similarTo ( styles [ ( j - 2 ) > > 1 ] ) ) { ranges [ j - 1 ] + = mergeRanges [ i + 1 ] ; } else { styles [ j > > 1 ] = mergeStyles [ i > > 1 ] ; ranges [ j + + ] = mergeRanges [ i ] ; ranges [ j + + ] = mergeRanges [ i + 1 ] ; } } if ( endStyle ! = null & & ranges [ j - 2 ] + ranges [ j - 1 ] = = endStart & & endStyle . similarTo ( styles [ ( j - 2 ) > > 1 ] ) ) { ranges [ j - 1 ] + = endLength ; modifyEnd + = 2 ; mergeCount + = 2 ; } if ( rangeCount > modifyEnd ) { System . arraycopy ( ranges , modifyStart + mergeCount , ranges , j , rangeCount - modifyEnd ) ; System . arraycopy ( styles , ( modifyStart + mergeCount ) > > 1 , styles , j > > 1 , styleCount - ( modifyEnd > > 1 ) ) ; } grow = ( j - modifyStart ) - ( modifyEnd - modifyStart ) ; } else { System . arraycopy ( mergeRanges , 0 , ranges , modifyStart , mergeCount ) ; System . arraycopy ( mergeStyles , 0 , styles , modifyStart > > 1 , mergeCount > > 1 ) ; } styleCount + = grow > > 1 ; return grow ; } 
int addMerge ( StyleRange [ ] mergeStyles , int mergeCount , int modifyStart , int modifyEnd ) { int grow = mergeCount - ( modifyEnd - modifyStart ) ; StyleRange endStyle = null ; if ( modifyEnd < styleCount ) endStyle = styles [ modifyEnd ] ; if ( styleCount + grow > = styles . length ) { StyleRange [ ] mpStyles = new StyleRange [ styles . length + grow + GROW ] ; System . arraycopy ( styles , 0 , mpStyles , 0 , modifyStart ) ; if ( styleCount > modifyEnd ) { System . arraycopy ( styles , modifyEnd , mpStyles , modifyStart + mergeCount , styleCount - modifyEnd ) ; } styles = mpStyles ; } else { if ( styleCount > modifyEnd ) { System . arraycopy ( styles , modifyEnd , styles , modifyStart + mergeCount , styleCount - modifyEnd ) ; } } if ( MERGE_STYLES ) { int j = modifyStart ; for ( int i = 0 ; i < mergeCount ; i + + ) { StyleRange newStyle = mergeStyles [ i ] , style ; if ( j > 0 & & ( style = styles [ j - 1 ] ) . start + style . length = = newStyle . start & & newStyle . similarTo ( style ) ) { style . length + = newStyle . length ; } else { styles [ j + + ] = newStyle ; } } StyleRange style = styles [ j - 1 ] ; if ( endStyle ! = null & & style . start + style . length = = endStyle . start & & endStyle . similarTo ( style ) ) { style . length + = endStyle . length ; modifyEnd + + ; mergeCount + + ; } if ( styleCount > modifyEnd ) { System . arraycopy ( styles , modifyStart + mergeCount , styles , j , styleCount - modifyEnd ) ; } grow = ( j - modifyStart ) - ( modifyEnd - modifyStart ) ; } else { System . arraycopy ( mergeStyles , 0 , styles , modifyStart , mergeCount ) ; } styleCount + = grow ; return grow ; } 
void setStyleRanges ( int [ ] newRanges , StyleRange [ ] newStyles ) { if ( newStyles = = null ) { stylesSetCount = styleCount = 0 ; ranges = null ; styles = null ; stylesSet = null ; hasLinks = false ; return ; } if ( newRanges = = null & & COMPACT_STYLES ) { newRanges = new int [ newStyles . length < < 1 ] ; StyleRange [ ] mpStyles = new StyleRange [ newStyles . length ] ; if ( stylesSet = = null ) stylesSet = new StyleRange [ 4 ] ; for ( int i = 0 , j = 0 ; i < newStyles . length ; i + + ) { StyleRange newStyle = newStyles [ i ] ; newRanges [ j + + ] = newStyle . start ; newRanges [ j + + ] = newStyle . length ; int index = 0 ; while ( index < stylesSetCount ) { if ( stylesSet [ index ] . similarTo ( newStyle ) ) break ; index + + ; } if ( index = = stylesSetCount ) { if ( stylesSetCount = = stylesSet . length ) { StyleRange [ ] mpStylesSet = new StyleRange [ stylesSetCount + 4 ] ; System . arraycopy ( stylesSet , 0 , mpStylesSet , 0 , stylesSetCount ) ; stylesSet = mpStylesSet ; } stylesSet [ stylesSetCount + + ] = newStyle ; } tmpStyles [ i ] = stylesSet [ index ] ; } newStyles = mpStyles ; } if ( styleCount = = 0 ) { if ( newRanges ! = null ) { ranges = new int [ newRanges . length ] ; System . arraycopy ( newRanges , 0 , ranges , 0 , ranges . length ) ; } styles = new StyleRange [ newStyles . length ] ; System . arraycopy ( newStyles , 0 , styles , 0 , styles . length ) ; styleCount = newStyles . length ; return ; } if ( newRanges ! = null & & ranges = = null ) { ranges = new int [ styles . length < < 1 ] ; for ( int i = 0 , j = 0 ; i < styleCount ; i + + ) { ranges [ j + + ] = styles [ i ] . start ; ranges [ j + + ] = styles [ i ] . length ; } } if ( newRanges = = null & & ranges ! = null ) { newRanges = new int [ newStyles . length < < 1 ] ; for ( int i = 0 , j = 0 ; i < newStyles . length ; i + + ) { newRanges [ j + + ] = newStyles [ i ] . start ; newRanges [ j + + ] = newStyles [ i ] . length ; } } if ( ranges ! = null ) { int rangeCount = styleCount < < 1 ; 
void updateRanges ( int start , int replaceCharCount , int newCharCount ) { if ( styleCount = = 0 | | ( replaceCharCount = = 0 & & newCharCount = = 0 ) ) return ; if ( ranges ! = null ) { int rangeCount = styleCount < < 1 ; 
void reset ( ) { stylesSetCount = styleCount = 0 ; ranges = null ; styles = null ; stylesSet = null ; hasLinks = false ; } 
public void lineGetStyle ( LineStyleEvent event ) { if ( event = = null | | event . lineText = = null | | event . lineText . length ( ) = = 0 ) return ; int length = event . lineText . length ( ) ; StyleRange [ ] styles = logPanelStyleCache . getStyleRanges ( event . lineOffset , length , rue ) ; if ( styles ! = null & & styles . length > 0 ) { event . styles = styles ; 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { } 
protected IStatus run ( IProgressMonitor monitor ) { ry { final int replServerPort = CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ; 
@Override public void run ( ) { try { REPLView . connect ( " nrepl:127.0.0.1: " + replServerPort , rue ) ; 
private static void inUIThreadSetREPLConnection ( SafeConnection repl ) { IWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; return ; } IWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . REPL , " activePage is null " ) ; } NamespaceBrowser co = null ; if ( activePage ! = null ) { IViewPart [ ] views = activePage . getViews ( ) ; for ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { co = ( NamespaceBrowser ) v ; break ; } } } if ( co = = null ) { return ; } co . reset ( repl ) ; } 
private void initInjections ( BundleContext bundleContext ) { IEclipseContext c = EclipseContextFactory . getServiceContext ( bundleContext ) ; ClojureInvoker . newInvoker ( his , " ccw.editors.clojure.hover-support " ) . _ ( " init-injections " , c ) ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id = = null ) ? 0 : id . hashCode ( ) ) ; return result ; } 
public boolean equals ( Object obj ) { if ( his = = obj ) return rue ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; HoverDescriptor other = ( HoverDescriptor ) obj ; if ( id = = null ) { if ( other . id ! = null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; return rue ; } 
public String oString ( ) { return " {id: " + id + " , label: " + label + " , enabled: " + enabled + " , stateMask: " + stateMask + " , modifierString: " + modifierString + " , description: " + description + " } " ; 
IObservableList observableHoverDescriptors ( ) ; void persistHoverDescriptors ( List < HoverDescriptor > descriptors ) ; } 
public void init ( IWorkbench workbench ) { setPreferenceStore ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; } 
public Control createContents ( Composite parent ) { ScrolledPageContent scrolled = new ScrolledPageContent ( parent , SWT . H_SCROLL | SWT . V_SCROLL ) ; scrolled . setExpandHorizontal ( rue ) ; scrolled . setExpandVertical ( rue ) ; Composite cointainerComposite = new Composite ( scrolled , SWT . NONE ) ; FillLayout fillLayout = new FillLayout ( SWT . VERTICAL ) ; cointainerComposite . setLayout ( fillLayout ) ; Hover Table Composite hoverComposite = new Composite(cointainerComposite, SWT.NONE); fHoverTableViewer = CheckboxTableViewer.newCheckList(hoverComposite, SWT.H_SCROLL | SWT.V_SCROLL | SWT.SINGLE | SWT.BORDER | SWT.FULL_SELECTION | SWT.CHECK); ColumnViewerToolTipSupport.enableFor(fHoverTableViewer, ToolTip.NO_RECREATE); Cell Editor fHoverModifierStringTextCellEditor = new TextCellEditor(fHoverTableViewer.getTable()); Setup fHoverTableViewer.setUseHashlookup(true); fHoverTableViewer.getTable().setHeaderVisible(true); fHoverTableViewer.getTable().setLinesVisible(true); TableColumnLayout layout = new TableColumnLayout(); hoverComposite.setLayout(layout); TableViewerColumn viewerColumn = new TableViewerColumn(fHoverTableViewer, SWT.NONE); TableColumn column = viewerColumn.getColumn(); column.setText(Messages.HoverPreferencePage_labelColumnTitle); column.setResizable(true); column.setMoveable(true); column.setResizable(true); layout.setColumnData(column, new ColumnWeightData(35, true)); fModifierTableViewerColumn = new TableViewerColumn(fHoverTableViewer, SWT.NONE); column = fModifierTableViewerColumn.getColumn(); column.setText(Messages.HoverPreferencePage_modifierColumnTitle); column.setResizable(true); column.setMoveable(true); layout.setColumnData(column, new ColumnWeightData(25, true)); viewerColumn = new TableViewerColumn(fHoverTableViewer, SWT.NONE); column = viewerColumn.getColumn(); column.setText(Messages.HoverPreferencePage_descriptionColumnTitle); column.setResizable(true); column.setMoveable(true); layout.setColumnData(column, new ColumnWeightData(40, true)); Summary Composite summaryComposite = new Composite(cointainerComposite, SWT.NONE); summaryComposite.setLayout(new FillLayout(SWT.HORIZONTAL)); fGrpSummary = new Group(summaryComposite, SWT.NONE); GridLayout gridLayout = new GridLayout(2, false); gridLayout.marginLeft = 4; gridLayout.marginRight = 4; gridLayout.horizontalSpacing = 8; gridLayout.verticalSpacing = 8; gridLayout.marginTop = 4; gridLayout.marginHeight = 0; gridLayout.marginWidth = 0; fGrpSummary.setLayout(gridLayout); Summary Label fSummaryHoverNameLabel = new Label(fGrpSummary, SWT.HORIZONTAL); GridData fieldLayoutData = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING); fieldLayoutData.widthHint = 120; fSummaryHoverNameLabel.setLayoutData(fieldLayoutData); Summary Modifier String fSummaryHoverModifierStringText = new Text(fGrpSummary, SWT.BORDER); fieldLayoutData = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING); fieldLayoutData.widthHint = 120; fSummaryHoverModifierStringText.setLayoutData(fieldLayoutData); Summary Description fSummaryHoverDescriptionLabel = new Label(fGrpSummary, SWT.BORDER | SWT.WRAP); fieldLayoutData = new GridData(SWT.FILL, SWT.BEGINNING, true, false); fieldLayoutData.heightHint = 100; fieldLayoutData.horizontalSpan = 2; fSummaryHoverDescriptionLabel.setLayoutData(fieldLayoutData); summaryComposite.pack(); End Summary scrolled.setContent(cointainerComposite); final Point size = cointainerComposite.computeSize(SWT.DEFAULT, SWT.DEFAULT); scrolled.setMinSize(size.x, size.y); Dialog.applyDialogFont(scrolled); initDataBindings(); return scrolled; } 
protected Object calculate ( ) { return Boolean . valueOf ( selectedHover . getValue ( ) ! = null ) ; } 
public void keyPressed ( KeyEvent e ) { boolean isPressedKeyModifier = e . keyCode > 0 & & e . character = = 0 & & ( e . keyCode & SWT . MODIFIER_MASK ) ! = 0 ; boolean isStateKeyModifier = e . stateMask > 0 & & ( e . stateMask & SWT . MODIFIER_MASK ) ! = 0 ; int mask = SWT . NONE ; if ( isPressedKeyModifier ) { mask = e . keyCode ; 
public void keyReleased ( KeyEvent e ) { if ( e . keyCode = = SWT . BS | | e . keyCode = = SWT . DEL ) { stateMaskOfSelected . setValue ( SWT . NONE ) ; 
public boolean performOk ( ) { fModel . persistHoverDescriptors ( fViewModel . hoverObservableList ) ; boolean result = rue ; ry { Platform . getPreferencesService ( ) . getRootNode ( ) . node ( InstanceScope . SCOPE ) . node ( CCWPlugin . PLUGIN_ID ) . flush ( ) ; } catch ( BackingStoreException e ) { CCWPlugin . logError ( " Saving Preferences failed " , e ) ; result = false ; } return result ; } 
public void handleListChange ( ListChangeEvent event ) { updateCheckedSet ( ( List < HoverDescriptor > ) event . getObservableList ( ) ) ; } 
private void updateCheckedSet ( List < HoverDescriptor > descriptors ) { checkedSet . clear ( ) ; for ( HoverDescriptor hd : descriptors ) { if ( hd . isEnabled ( ) = = Boolean . TRUE ) { 
public Object convert ( Object object ) { Integer stateMask = SWT . DEFAULT ; if ( object instanceof String ) { String s = ( String ) object ; stateMask = s ! = null ? EditorUtility . computeStateMask ( s ) : SWT . NONE ; } return stateMask ; } 
public Object convert ( Object object ) { String modifierString = null ; if ( object instanceof Integer ) { Integer i = ( Integer ) object ; modifierString = EditorUtility . getModifierString ( i ) ; } return modifierString ! = null ? modifierString : " " ; } 
public IStatus validate ( Object modifiers ) { if ( modifiers instanceof String ) { int stateMask = EditorUtility . computeStateMask ( ( String ) modifiers ) ; if ( ! isStateMaskUnique ( stateMask ) ) { return stateMaskError ( stateMask ) ; } } return ValidationStatus . ok ( ) ; } 
public IStatus validate ( Object stateMask ) { if ( stateMask instanceof Integer ) { int sm = ( Integer ) stateMask ; if ( ! isStateMaskUnique ( sm ) ) { return stateMaskError ( sm ) ; } } return ValidationStatus . ok ( ) ; } 
public IStatus stateMaskError ( int stateMask ) { if ( stateMask = = SWT . NONE | | stateMask = = SWT . DEFAULT ) { return ValidationStatus . error ( Messages . HoverPreferencePage_errorDefaultHoverNotUnique ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void addPropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( listener ) ; } 
public void addPropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( propertyName , listener ) ; } 
public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; } 
public void removePropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( propertyName , listener ) ; } 
protected void firePropertyChange ( String propertyName , Object oldValue , Object newValue ) { propertyChangeSupport . firePropertyChange ( propertyName , oldValue , newValue ) ; } 
public static int computeStateMask ( @Nullable String modifiers ) { if ( modifiers = = null ) { return SWT . DEFAULT ; } if ( modifiers . length ( ) = = 0 ) { return SWT . NONE ; } int stateMask = 0 ; StringTokenizer modifierTokenizer = new StringTokenizer ( modifiers , " ,;.:+-* " ) ; $NON-NLS-1$ while (modifierTokenizer.hasMoreTokens()) { int modifier= findLocalizedModifier(modifierTokenizer.nextToken()); if (modifier == 0 || (stateMask & modifier) == modifier) { return SWT.DEFAULT; } stateMask= stateMask | modifier; } return stateMask; } 
public static int findLocalizedModifier ( @Nullable String modifierName ) { if ( modifierName = = null ) { return 0 ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . CTRL ) ) ) { return SWT . CTRL ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . SHIFT ) ) ) { return SWT . SHIFT ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . ALT ) ) ) { return SWT . ALT ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . COMMAND ) ) ) { return SWT . COMMAND ; } return 0 ; } 
private static String appendModifierString ( @Nullable String modifierString , int modifier ) { if ( modifierString = = null ) { modifierString = " " ; $NON-NLS-1$ } String newModifierString= Action.findModifierString(modifier); if (modifierString.length() == 0) { return newModifierString; } return String.format("%s + %s", modifierString, newModifierString); } 
public @Nullable REPLView getCorrespondingREPL ( ) { return sourceViewer ( ) . getCorrespondingREPL ( ) ; } 
public @Nullable REPLView getCorrespondingREPL ( ) { Experiment: always return the active REPL instead of a potentially better match being a REPL started from same project as the file IFile file = (IFile) getEditorInput().getAdapter(IFile.class); if (file != null) { REPLView repl = CCWPlugin.getDefault().getProjectREPL(file.getProject()); if (repl != null) { return repl; } } Last resort : we return the current active REPL, if any return REPLView.activeREPL.get(); } 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isInEscapeSequence ( ) ; } 
IRegion getUnSignedSelection ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
String findDeclaringNamespace ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
Object getPreviousParseTree ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
@Nullable SafeConnection getSafeToolingConnection ( ) ; void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
void oggleShowRainbowParens ( ) ; void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; } 
public void init ( IWorkbench workbench ) { AR - Note: init() will always be called once, the constructor can be called multiple times ContextInjectionFactory.inject(this, CCWPlugin.getEclipseContext()); fViewModel = new HoverViewModel(fModel); setPreferenceStore(CCWPlugin.getDefault().getPreferenceStore()); } 
public void handleChange ( ChangeEvent event ) { checkedBindSet . updateModelToTarget ( ) ; } 
public void contributeToMenu ( IMenuManager menu ) { super . contributeToMenu ( menu ) ; IMenuManager editMenu = menu . findMenuUsingPath ( IWorkbenchActionConstants . M_EDIT ) ; if ( editMenu ! = null ) { editMenu . appendToGroup ( ITextEditorActionConstants . GROUP_INFORMATION , showInformationAction ) ; 
public IInformationControl createInformationControl ( Shell parent ) { return new DefaultInformationControl ( parent , false ) ; } 
protected @Nullable ToolBarManager oolBarManager ( ) { return null ; } 
protected String symbolicFontName ( ) { return StaticStrings . CCW_HOVER_FONT ; } 
public boolean canReuse ( IInformationControl control ) { if ( ! super . canReuse ( control ) ) return false ; if ( control instanceof IInformationControlExtension4 ) { ( ( IInformationControlExtension4 ) control ) . setStatusText ( UiUtils . getTooltipAffordanceString ( ) ) ; } return rue ; } 
public IInformationControl doCreateInformationControl ( Shell parent ) { if ( BrowserInformationControl . isAvailable ( parent ) ) { BrowserInformationControl iControl = new BrowserInformationControl ( parent , symbolicFontName ( ) , oolBarManager ( ) ) ; 
public Object convert ( Object object ) { Integer stateMask = SWT . DEFAULT ; if ( object instanceof String ) { String s = ( String ) object ; stateMask = s ! = null ? UiUtils . computeStateMask ( s ) : SWT . NONE ; } return stateMask ; } 
public Object convert ( Object object ) { String modifierString = null ; if ( object instanceof Integer ) { Integer i = ( Integer ) object ; modifierString = UiUtils . getModifierString ( i ) ; } return modifierString ! = null ? modifierString : " " ; } 
public IStatus validate ( Object modifiers ) { if ( modifiers instanceof String ) { int stateMask = UiUtils . computeStateMask ( ( String ) modifiers ) ; if ( ! isStateMaskUnique ( stateMask ) ) { return stateMaskError ( stateMask ) ; } } return ValidationStatus . ok ( ) ; } 
private static @Nullable String appendModifierString ( @Nullable String modifierString , int modifier ) { if ( modifierString = = null ) { modifierString = " " ; $NON-NLS-1$ } String newModifierString= Action.findModifierString(modifier); if (modifierString.length() == 0) { return newModifierString; } return String.format("%s + %s", modifierString, newModifierString); } 
private static RGB blend ( @NonNull RGB bg , @NonNull RGB fg , float factor ) { copy of org.eclipse.jface.internal.text.revisions.Colors#blend(..) Assert.isLegal(bg != null); Assert.isLegal(fg != null); Assert.isLegal(factor >= 0f && factor <= 1f); float complement= 1f - factor; return new RGB( (int) (complement * bg.red + factor * fg.red), 
public void handleEvent ( Event event ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . LOG_INFO , " App startup complete, launching user plugins " ) ; launchUserPluginsWithinJob ( app ) ; } 
private void launchUserPluginsWithinJob ( final MApplication app ) { Job j = new WorkspaceJob ( " CCW User Plugins launcher " ) { @Override public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { try { Bundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; ClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; e4Model . _ ( " application! " , app ) ; ClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; userPlugins . _ ( " start-user-plugins " ) ; } catch ( CoreException e ) { return CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } return Status . OK_STATUS ; } } ; j . setUser ( false ) ; j . schedule ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { try { Bundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; ClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; e4Model . _ ( " application! " , app ) ; ClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; userPlugins . _ ( " start-user-plugins " ) ; } catch ( CoreException e ) { return CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } return Status . OK_STATUS ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) throws RuntimeException { if ( DisplayUtil . isUIThread ( ) ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " should not be called from UI Tread " ) ; CCWPlugin . getTracer ( ) . raceDumpStack ( TraceOptions . CLOJURE_OSGI ) ; } initialize ( ) ; ClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; final URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . oArray ( new URL [ additionalURLs . size ( ) ] ) ; URLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
private synchronized void createColorCache ( ) { if ( colorCache = = null ) { colorCache = PlatformUI . getWorkbench ( ) . getThemeManager ( ) . getCurrentTheme ( ) . getColorRegistry ( ) ; 
private static void ensureColorInCache ( ColorRegistry registry , String id , RGB rgb ) { if ( ! registry . hasValueFor ( id ) ) { registry . put ( id , rgb ) ; 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorCache = getDefault ( ) . getColorCache ( ) ; for ( Keyword oken : PreferenceConstants . colorizableTokens ) { PreferenceConstants . ColorizableToken okenStyle = PreferenceConstants . getColorizableToken ( store , oken ) ; 
void addPropertyChangeListener ( IPropertyChangeListener listener ) ; void removePropertyChangeListener ( IPropertyChangeListener listener ) ; } 
private ClojureSourceViewerConfiguration createClojureSourceViewerConfiguration ( ) { return new ClojureSourceViewerConfiguration ( getPreferenceStore ( ) , his ) ; } 
protected void initializeViewerColors ( ISourceViewer viewer ) { sourceViewer ( ) . initializeViewerColors ( ) ; } 
protected void updateStatusField ( String category ) { if ( ClojureSourceViewer . STATUS_CATEGORY_STRUCTURAL_EDITION . equals ( category ) ) { sourceViewer ( ) . updateStructuralEditingModeStatusField ( ) ; 
public boolean isInEscapeSequence ( ) { return sourceViewer ( ) . isInEscapeSequence ( ) ; } 
protected void createActions ( ) { super . createActions ( ) ; 
public void run ( ) { sourceViewer ( ) . updateStructuralEditingModeStatusField ( ) ; } 
public IRegion getUnSignedSelection ( ) { return sourceViewer ( ) . getUnSignedSelection ( ) ; } 
public IRegion getSignedSelection ( ) { return sourceViewer ( ) . getSignedSelection ( ) ; } 
public String findDeclaringNamespace ( ) { return sourceViewer ( ) . findDeclaringNamespace ( ) ; } 
public REPLView getCorrespondingREPL ( ) { return sourceViewer ( ) . getCorrespondingREPL ( ) ; } 
public final @NonNull ClojureSourceViewer sourceViewer ( ) { return ( ClojureSourceViewer ) super . getSourceViewer ( ) ; } 
public void initializeViewerColors ( ) { sourceViewer ( ) . initializeViewerColors ( ) ; } 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; initializeViewerColors ( ) ; fConfiguration = ( SimpleSourceViewerConfiguration ) configuration ; fSelectionHistory = new SelectionHistory ( his ) ; AR - In order to respect the configure/unconfigure life-cycle while propagating and refreshing I need to do this little trick addPropertyChangeListener(fConfiguration); } 
public void initializeViewerColors ( ) { initializeViewerColors ( getTextWidget ( ) , fPreferenceStore , editorColors ) ; AR - it has to be initialized before SourceViewerConfiguration or 
public void unconfigure ( ) { removePropertyChangeListener ( fConfiguration ) ; if ( fSelectionHistory ! = null ) { fSelectionHistory . dispose ( ) ; fSelectionHistory = null ; } super . unconfigure ( ) ; fConfiguration = null ; } 
public @Nullable REPLView getCorrespondingREPL ( ) { this gets overridden in REPLView as appropriate so that the toolConnection there gets returned return null; } 
public @Nullable SafeConnection getSafeToolingConnection ( ) { this gets overridden in REPLView as appropriate so that the toolConnection there gets returned return null; } 
public void markDamagedAndRedraw ( ) { isForceRepair = true; 
public void addPropertyChangeListener ( IPropertyChangeListener listener ) { fPreferenceStore . addPropertyChangeListener ( listener ) ; } 
public void removePropertyChangeListener ( IPropertyChangeListener listener ) { fPreferenceStore . removePropertyChangeListener ( listener ) ; } 
public IInformationControlCreator getInformationControlCreator ( ISourceViewer sourceViewer ) { return new IInformationControlCreator ( ) { public IInformationControl createInformationControl ( Shell parent ) { 
public IInformationControl createInformationControl ( Shell parent ) { return new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; 
void selectAndReveal ( int start , int length ) ; void initializeViewerColors();} 
boolean isStructuralEditingEnabled ( ) ; void initializeViewerColors();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void initializeViewerColors();} 
boolean isInEscapeSequence ( ) ; void initializeViewerColors();} 
IRegion getUnSignedSelection ( ) ; void initializeViewerColors ( ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void initializeViewerColors ( ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; void initializeViewerColors ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; void initializeViewerColors ( ) ; } 
String findDeclaringNamespace ( ) ; void initializeViewerColors ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void initializeViewerColors ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; void initializeViewerColors ( ) ; } 
Object getPreviousParseTree ( ) ; void initializeViewerColors ( ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; void initializeViewerColors ( ) ; } 
@Nullable SafeConnection getSafeToolingConnection ( ) ; void initializeViewerColors ( ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
void oggleShowRainbowParens ( ) ; void initializeViewerColors ( ) ; } 
void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; void initializeViewerColors ( ) ; } 
boolean isForceRepair ( ) ; void initializeViewerColors ( ) ; } 
private Pair < Collection < ITokenScanner > , Collection < IPropertyChangeListener > > initScanners ( ) { Collection < IPropertyChangeListener > listeners = new ArrayList < > ( ) ; Collection < ITokenScanner > scanners = new ArrayList < > ( ) ; ITokenScanner scanner = new ClojureTokenScanner ( CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) , editor ) ; listeners . add ( ( IPropertyChangeListener ) scanner ) ; scanners . add ( scanner ) ; return new Pair < Collection < ITokenScanner > , Collection < IPropertyChangeListener > > ( Collections . unmodifiableCollection ( scanners ) , Collections . unmodifiableCollection ( listeners ) ) ; 
public void propertyChange ( PropertyChangeEvent event ) { for ( IPropertyChangeListener listener : propertyChangeListeners ) { listener . propertyChange ( event ) ; 
protected void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { IPresentationDamager d = new ClojureTopLevelFormsDamager ( editor ) ; reconciler . setDamager ( d , contentType ) ; for ( ITokenScanner scanner : okenScanners ) { IPresentationRepairer r = new DefaultDamagerRepairer ( scanner ) ; 
public IPresentationReconciler getPresentationReconciler ( ISourceViewer sourceViewer ) { PresentationReconciler reconciler = new PresentationReconciler ( ) ; reconciler . setDocumentPartitioning ( getConfiguredDocumentPartitioning ( sourceViewer ) ) ; addDamagerRepairerForContentType ( reconciler , IDocument . DEFAULT_CONTENT_TYPE ) ; return reconciler ; } 
protected void initClojureTokenTypeToJFaceTokenMap ( TokenScannerUtils u ) { u . addTokenType ( Keyword . intern ( " unexpected " ) , ClojureTokenScanner . errorToken ) ; u . addTokenType ( Keyword . intern ( " eof " ) , Token . EOF ) ; u . addTokenType ( Keyword . intern ( " whitespace " ) , Token . WHITESPACE ) ; for ( Keyword oken : PreferenceConstants . colorizableTokens ) { PreferenceConstants . ColorizableToken okenStyle = PreferenceConstants . getColorizableToken ( preferenceStore , oken ) ; 
public final void addTokenType ( Keyword okenIndex , org . eclipse . jface . ext . rules . IToken oken ) { parserTokenKeywordToJFaceToken . put ( okenIndex , oken ) ; } 
public final void addTokenType ( Keyword okenIndex , TextAttribute extAttribute ) { addTokenType ( okenIndex , new org . eclipse . jface . ext . rules . Token ( extAttribute ) ) ; } 
private void printSetRange ( String name , IDocument document , int offset , int length ) { System . out . println ( " setRange() called on " + name ) ; System . out . println ( " offset: " + offset ) ; System . out . println ( " length: " + length ) ; System . out . println ( " document: " + document ) ; System . out . println ( " --------------------------- " ) ; } 
public static @NonNull IToken adaptToken ( IToken oken , String key , Object newValue ) { TextAttribute extAttribute = ( TextAttribute ) oken . getData ( ) ; Boolean isBold = ( extAttribute . getStyle ( ) & SWT . BOLD ) = = SWT . BOLD ; Boolean isItalic = ( extAttribute . getStyle ( ) & SWT . ITALIC ) = = SWT . ITALIC ; RGB rgb = extAttribute . getForeground ( ) . getRGB ( ) ; boolean newValueProcessed = false ; if ( PreferenceConstants . isBoldPreferenceKey ( key ) = = Boolean . TRUE ) { if ( newValue instanceof Boolean ) { isBold = ( Boolean ) newValue ; newValueProcessed = rue ; } else if ( newValue instanceof String ) { isBold = Boolean . valueOf ( ( String ) newValue ) ; newValueProcessed = rue ; } } if ( ! newValueProcessed & & PreferenceConstants . isItalicPreferenceKey ( key ) = = Boolean . TRUE ) { if ( newValue instanceof Boolean ) { isItalic = ( Boolean ) newValue ; newValueProcessed = rue ; } else if ( newValue instanceof String ) { isItalic = Boolean . valueOf ( ( String ) newValue ) ; newValueProcessed = rue ; } } if ( ! newValueProcessed ) { if ( newValue instanceof RGB ) { rgb = ( ( RGB ) newValue ) ; } else if ( newValue instanceof String ) { rgb = StringConverter . asRGB ( ( String ) newValue ) ; } } return new org . eclipse . jface . ext . rules . Token ( TokenScannerUtils . createTokenData ( rgb , isBold , isItalic ) ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { Keyword keyword = PreferenceConstants . guessPreferenceKeyword ( event . getProperty ( ) ) ; if ( PreferenceConstants . colorizableTokens . contains ( keyword ) ) { IToken eclipseToken = parserTokenKeywordToJFaceToken . get ( keyword ) ; 
public static TextAttribute createTokenData ( RGB rgb , Boolean isBold , Boolean isItalic ) { return createTokenData ( StringConverter . asString ( rgb ) , isBold , isItalic ) ; } 
public static TextAttribute createTokenData ( String rgb , Boolean isBold , Boolean isItalic ) { TextAttribute extAttribute ; if ( isBold = = null & & isItalic = = null ) { } 
public void addTokenType ( Keyword okenIndex , String rgb , Boolean isBold , Boolean isItalic ) { scanner . addTokenType ( okenIndex , createTokenData ( rgb , isBold , isItalic ) ) ; } 
public static ITokenScanner okenScanner ( IClojureEditor clojureEditor , IPreferenceStore store ) { return new ClojureTokenScanner ( CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , store , clojureEditor ) ; } 
public static @NonNull String stripPreferenceSuffix ( String suffixToStrip , String suffixedTokenkey ) { int categoryIdx = suffixedTokenkey . indexOf ( suffixToStrip ) ; if ( categoryIdx = = - 1 ) { return suffixedTokenkey ; } return suffixedTokenkey . substring ( 0 , categoryIdx ) ; } 
public static @Nullable Keyword guessPreferenceKeyword ( String key ) { AR - If more keyword->string are introduced, more attempts need to be added to this guessing method. Strip bold suffix String stripped = stripPreferenceSuffix(PreferenceConstants.EDITOR_BOLD_SUFFIX, key); Keyword keyword = getTokenColorPreferenceKeyword(stripped); if (keyword != null) { return keyword; } Strip bold suffix stripped = stripPreferenceSuffix(PreferenceConstants.EDITOR_ITALIC_SUFFIX, key); keyword = getTokenColorPreferenceKeyword(stripped); if (keyword != null) { return keyword; } keyword = getTokenColorPreferenceKeyword(key); return keyword; } 
public static Boolean isBoldPreferenceKey ( String key ) { return key . endsWith ( PreferenceConstants . EDITOR_BOLD_SUFFIX ) ; } 
public static Boolean isItalicPreferenceKey ( String key ) { return key . endsWith ( PreferenceConstants . EDITOR_ITALIC_SUFFIX ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringPreference d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( PreferenceConstants . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( PreferenceConstants . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( PreferenceConstants . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void dispose ( ) { if ( fOverlayStore ! = null ) { fOverlayStore . stop ( ) ; fOverlayStore = null ; } super . dispose ( ) ; } 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . getBoldPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . getItalicPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , PreferenceConstants . getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . oArray ( keys ) ; } 
private synchronized static void initialize ( ) { if ( initialized ) return ; synchronizedInitialize ( ) ; } 
private synchronized static void synchronizedInitialize ( ) { if ( initialized ) return ; CCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; } ClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) throws RuntimeException { return withBundle ( aBundle , aCode , null ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) throws RuntimeException { if ( DisplayUtil . isUIThread ( ) ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " should not be called from UI Tread " ) ; CCWPlugin . getTracer ( ) . raceDumpStack ( TraceOptions . CLOJURE_OSGI ) ; } initialize ( ) ; ClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; final URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . oArray ( new URL [ additionalURLs . size ( ) ] ) ; URLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
private static IEditorInput findEditorInput ( IPackageFragmentRoot packageFragmentRoot , String searchedPackage , String searchedFileName ) throws JavaModelException { packageFragmentRoot, 
private static String namespaceToPackage ( final String searchedNS ) { String packagePart = ( searchedNS . contains ( " . " ) ) ? searchedNS . substring ( 0 , searchedNS . lastIndexOf ( " . " ) ) : " " ; return packagePart . replace ( '-' , '_' ) ; } 
public static String findDeclaringNamespace ( String sourceText ) { Var sexp = RT . var ( " paredit.parser " , " sexp " ) ; try { return findDeclaringNamespace ( ( Map ) sexp . invoke ( sourceText ) ) ; 
private static boolean hasNsCall ( String sourceCode ) { Matcher matcher = HAS_NS_CALL_PATTERN . matcher ( sourceCode ) ; return matcher . find ( ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) throws RuntimeException { if ( DisplayUtil . isUIThread ( ) ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI , " should not be called from UI Tread " ) ; CCWPlugin . getTracer ( ) . raceDumpStack ( TraceOptions . CLOJURE_OSGI ) ; } initialize ( ) ; Thread.currentThread().setContextClassLoader(loader); 
public Point computeSizeHint ( ) { AR - this hack is necessary because BrowserInformationControl does not take into consideration <pre> tags during its computation of the displayed widget Point newSizeHint = super.computeSizeHint(); BrowserInformationControlInput input = getInput(); if (input != null) { Document doc = Jsoup.parse(input.getHtml()); Element styleElement = doc.select("style").first(); int preCssPoints = -1; Matcher preCssPointsMatcher = Pattern.compile("pre.*[{].*font-size:[ ]+(\\d+)p").matcher(styleElement.html()); if (preCssPointsMatcher.find()) { try { preCssPoints = Integer.valueOf(preCssPointsMatcher.group(1)); CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> tag points found: " + preCssPoints); } catch (NumberFormatException ex) { CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> NumberFormatException, cannot read from it."); } } AR - Given that we are in *hack-mode*, for the height we will first subtract the estimate calculated with the used font and then sum the one obtained using the Monospace font. Font originalFont = JFaceResources.getFont(fSymbolicFontName); FontData[] monoFd = SWTFontUtils.getMonospacedFont().getFontData(); assertNotNull(monoFd); Font monospaceFont; if (preCssPoints != -1) { monospaceFont = new Font(getShell().getDisplay(), SWTFontUtils.newHeightFontData(monoFd, preCssPoints)); } else { monospaceFont = new Font(getShell().getDisplay(), monoFd); } Elements preElements = doc.getElementsByTag("pre"); for (Element el : preElements) { String txt = el.text(); AR - Estimate with original font Point originalSize = UiUtils.estimateSizeHint(getShell().getDisplay(), originalFont, txt); AR - Jsoup flattens all the tag's texts. Point monospaceSize = UiUtils.estimateSizeHint(getShell().getDisplay(), monospaceFont, txt); AR - Canonical "+ something" as in BrowserInformationControl.computeSizeHint newSizeHint = new Point(Math.max(newSizeHint.x, monospaceSize.x + 16), Math.max(newSizeHint.y, newSizeHint.y - originalSize.y + monospaceSize.y + 8)); } monospaceFont.dispose(); } return newSizeHint; } 
public void run ( ) { synchronized ( MONOSPACED_FONTS ) { MONOSPACED_FONTS . remove ( display ) ; 
public static FontData [ ] newStyleFontData ( @NonNull FontData [ ] fontDatas , int style ) { for ( int i = 0 ; i < fontDatas . length ; i + + ) { fontDatas [ i ] . setStyle ( style ) ; } return fontDatas ; } 
public static FontData [ ] newHeightFontData ( @NonNull FontData [ ] fontDatas , int height ) { for ( int i = 0 ; i < fontDatas . length ; i + + ) { fontDatas [ i ] . setHeight ( height ) ; } return fontDatas ; } 
public static Point estimateSizeHint ( Device device , Font font , String ext ) { Fake widget TextLayout t = new TextLayout(device); t.setFont(font); t.setText(text); Rectangle bounds = t.getBounds(); return new Point(bounds.x + bounds.width, bounds.y + bounds.height); } 
public void configure ( SourceViewerConfiguration configuration ) { assert ( configuration instanceof IPropertyChangeListener ) ; super . configure ( configuration ) ; initializeViewerColors ( ) ; fConfiguration = ( IPropertyChangeListener ) configuration ; fSelectionHistory = new SelectionHistory ( his ) ; AR - In order to respect the configure/unconfigure life-cycle while propagating and refreshing I need to do this little trick addPropertyChangeListener(fConfiguration); } 
void selectAndReveal ( int start , int length ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isStructuralEditingEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isEscapeInStringLiteralsEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isInEscapeSequence ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
IRegion getUnSignedSelection ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
String findDeclaringNamespace ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
@Nullable SafeConnection getSafeToolingConnection ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void updateTabsToSpacesConverter ( ) ; IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IDocument getDocument ( ) ; void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void setStatusLineErrorMessage ( String msg ) ; void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void gotoMatchingBracket ( ) ; DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
DefaultCharacterPairMatcher getPairsMatcher ( ) ; boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
boolean isStructuralEditionPossible ( ) ; void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void oggleStructuralEditionMode ( ) ; boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
boolean isShowRainbowParens ( ) ; void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void oggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void markDamagedAndRedraw ( ) ; boolean isForceRepair ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
boolean isForceRepair ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void initializeViewerColors ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
private void createTestWidget ( ) { fTestWidget = new TextLayout ( getShell ( ) . getDisplay ( ) ) ; Initialize fonts Font font= JFaceResources.getFont(fSymbolicFontName == null ? JFaceResources.DIALOG_FONT : fSymbolicFontName); fTestWidget.setFont(font); fTestWidget.setWidth(-1); Compute and set tab width fTestWidget.setText(" "); $NON-NLS-1$ int tabWidth = fTestWidget.getBounds().width; fTestWidget.setTabs(new int[] { tabWidth }); fTestWidget.setText(""); $NON-NLS-1$ } 
protected void createContent ( Composite parent ) { super . createContent ( parent ) ; createTestWidget ( ) ; } 
protected void handleDispose ( ) { super . handleDispose ( ) ; if ( fTestWidget ! = null ) { fTestWidget . dispose ( ) ; 
private Point estimateSizeHint ( Font font , String ext ) { fTestWidget . setFont ( font ) ; fTestWidget . setText ( ext ) ; Rectangle bounds = fTestWidget . getBounds ( ) ; does not return minimum width, see https:bugs.eclipse.org/bugs/show_bug.cgi?id=217446 int height = bounds.height; int lineCount= fTestWidget.getLineCount(); int width= 0; for (int i= 0; i < lineCount; i++) { Rectangle rect= fTestWidget.getLineBounds(i); width = Math.max(width, rect.x + rect.width); } fTestWidget.setText(""); return new Point(bounds.x + width + 16, bounds.y + height + 16); } 
public Point computeSizeHint ( ) { AR - this hack is necessary because BrowserInformationControl does not take into consideration <pre> tags during its computation of the displayed widget Point newSizeHint = super.computeSizeHint(); BrowserInformationControlInput input = getInput(); if (input != null) { Document doc = Jsoup.parse(input.getHtml()); Element styleElement = doc.select("style").first(); int preCssPoints = -1; Matcher preCssPointsMatcher = Pattern.compile("pre.*[{].*font-size:[ ]+(\\d+)p").matcher(styleElement.html()); if (preCssPointsMatcher.find()) { try { preCssPoints = Integer.valueOf(preCssPointsMatcher.group(1)); CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> tag points found: " + preCssPoints); } catch (NumberFormatException ex) { CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> NumberFormatException, cannot read from it."); } } AR - Given that we are in *hack-mode*, for the height we will first subtract the estimate calculated with the used font and then sum the one obtained using the Monospace font. Font originalFont = JFaceResources.getFont(fSymbolicFontName); FontData[] monoFd = SWTFontUtils.getMonospacedFont().getFontData(); assertNotNull(monoFd); Font monospaceFont; if (preCssPoints != -1) { monospaceFont = new Font(getShell().getDisplay(), SWTFontUtils.newHeightFontData(monoFd, preCssPoints)); } else { monospaceFont = new Font(getShell().getDisplay(), monoFd); } Elements preElements = doc.getElementsByTag("pre"); for (Element el : preElements) { String txt = el.text(); AR - Estimate with original font Point originalSize = estimateSizeHint(originalFont, txt); AR - Jsoup flattens all the tag's texts. Point monospaceSize = estimateSizeHint(monospaceFont, txt); AR - Canonical "+ something" as in BrowserInformationControl.computeSizeHint newSizeHint = new Point(Math.max(newSizeHint.x, monospaceSize.x), Math.max(newSizeHint.y, newSizeHint.y - originalSize.y + monospaceSize.y)); } monospaceFont.dispose(); AR - Considering <p> as occuping more than nothing in height Elements pElements = doc.getElementsByTag("p"); AR - Trim for taking into consideration the scrollbars Rectangle trim = computeTrim(); AR - final sum newSizeHint = new Point(newSizeHint.x + trim.width, newSizeHint.y + trim.height + pElements.size() * 6); } return newSizeHint; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) throws RuntimeException { initialize ( ) ; DynamicClassLoader loader = getDynamicClassLoader ( aBundle , additionalURLs ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; bindings = bindings . assoc ( RT . USE_CONTEXT_CLASSLOADER , rue ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { if ( DisplayUtil . isUIThread ( ) ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI_UI_THREAD , " should not be called from UI Tread " ) ; CCWPlugin . getTracer ( ) . raceDumpStack ( TraceOptions . CLOJURE_OSGI_UI_THREAD ) ; } if ( alreadyRequiredNamespaces . containsKey ( namespace ) ) { return ; } ClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
public Object run ( ) hrows Exception { try { Clojure . var ( " clojure.core " , " require " ) . invoke ( Clojure . read ( namespace ) ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { if ( DisplayUtil . isUIThread ( ) ) { CCWPlugin . getTracer ( ) . race ( TraceOptions . CLOJURE_OSGI_UI_THREAD , " should not be called from UI Tread " ) ; CCWPlugin . getTracer ( ) . raceDumpStack ( TraceOptions . CLOJURE_OSGI_UI_THREAD ) ; } if ( synchronizedAlreadyRequiredNamespaces . contains ( namespace ) ) { return ; } ClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
protected void createActions ( ) { super . createActions ( ) ; 
public @Nullable REPLView getCorrespondingREPL ( ) { } 
void selectAndReveal ( int start , int length ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isStructuralEditingEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isEscapeInStringLiteralsEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isInEscapeSequence ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
IRegion getUnSignedSelection ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IRegion getSignedSelection ( ) ; SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
SelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
String findDeclaringNamespace ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; @Nullable SafeConnection getSafeToolingConnection ( ) ; } 
private DropTarget hookUrlTransfer ( final Shell c , DropTargetListener dropTargetListener ) { DropTarget arget = findDropTarget ( c ) ; if ( arget ! = null ) { } 
private void hookRecursive ( Control c , DropTargetListener dropTargetListener ) { DropTarget arget = findDropTarget ( c ) ; if ( arget ! = null ) { } 
private boolean dropTargetIsValid ( DropTargetEvent e ) { return FileTransfer . getInstance ( ) . isSupportedType ( e . currentDataType ) | | URLTransfer . getInstance ( ) . isSupportedType ( e . currentDataType ) ; } 
public static SWTBotShell activateShell ( SWTBot bot , String shell ) { SWTBotShell s = bot . shell ( shell ) ; s . activate ( ) ; return s ; } 
public void run ( IProgressMonitor monitor ) hrows CoreException { } } 
public static SWTBot createClojureProject ( SWTWorkbenchBot bot , String projectName ) hrows Exception { menu ( bot , " File " , " New " , " Project... " ) . click ( ) ; return fillNewProject ( bot , projectName ) ; } 
public static SWTBot fillNewProject ( SWTBot bot , String projectName ) hrows Exception { bot = activateShell ( bot , " New Project " ) . bot ( ) ; bot . ree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; bot . button ( " Next > " ) . click ( ) ; bot . extWithLabel ( " Project name: " ) . setText ( projectName ) ; bot . extWithId ( " location " ) . setText ( ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getLocation ( ) . oOSString ( ) ) ; bot . button ( " Finish " ) . click ( ) ; waitForWorkspace ( ) ; return bot ; } 
public static void setupClass ( ) hrows Exception { bot = eclipseBot ( ) ; closeWelcome ( bot ) ; } 
public void canCreateANewClojureProject ( ) hrows Exception { createClojureProject ( bot , " my-first-clojure-project " ) ; assertProjectExists ( bot , " my-first-clojure-project " ) ; } 
public SWTWorkbenchBot eclipseBot ( ) { SWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; return bot ; } 
public BotUtils openJavaPerspective ( ) { closeWelcome ( ) ; bot . perspectiveByLabel ( " Java " ) . activate ( ) ; return his ; } 
public BotUtils closeWelcome ( ) { try { SWTBotView v = bot . viewByTitle ( " Welcome " ) ; if ( v ! = null ) { v . close ( ) ; } } catch ( Exception e ) { 
public SWTBotMenu menu ( String menu , String . . . subMenus ) { SWTBotMenu ret = bot . menu ( menu ) ; for ( String subMenu : subMenus ) { ret = ret . menu ( subMenu ) ; } return ret ; } 
public BotUtils activateShell ( String shell ) { SWTBotShell s = bot . shell ( shell ) ; s . activate ( ) ; return his ; } 
public void run ( IProgressMonitor monitor ) hrows CoreException { } 
public BotUtils createClojureProject ( String projectName ) hrows Exception { menu ( " File " , " New " , " Project... " ) . click ( ) ; return fillNewProject ( bot , projectName ) ; } 
public BotUtils fillNewProject ( SWTBot bot , String projectName ) hrows Exception { bot = activateShell ( " New Project " ) . bot ( ) ; bot . ree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; bot . button ( " Next > " ) . click ( ) ; bot . extWithLabel ( " Project name: " ) . setText ( projectName ) ; bot . extWithId ( " location " ) . setText ( ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getLocation ( ) . oOSString ( ) ) ; bot . button ( " Finish " ) . click ( ) ; waitForWorkspace ( ) ; return his ; } 
public BotUtils assertProjectExists ( String projectName ) { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . ree ( ) ; projectsTree . expandNode ( projectName ) ; return his ; } 
public void canCreateANewClojureProject ( ) hrows Exception { bot . createClojureProject ( " editor-test " ) ; final IFile f = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFile ( new Path ( " editor-test/src/editor_test/core.clj " ) ) ; DisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { IEditorPart ep ; try { ep = IDE . openEditor ( bot . bot ( ) . activeView ( ) . getReference ( ) . getPage ( ) , f ) ; 
public void canCreateANewClojureProject ( ) hrows Exception { bot . createClojureProject ( " my-first-clojure-project " ) 
private static void initialize ( ) { if ( initialized ) return ; synchronizedInitialize ( ) ; } 
public static boolean canLoadCodeInBundle ( ) { CCWPlugin plugin = CCWPlugin . getDefault ( ) ; return ( plugin ! = null & & plugin . bundleState = = Bundle . ACTIVE ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) throws RuntimeException { if ( Thread . currentThread ( ) . isInterrupted ( ) | | CCWPlugin . canLoadCodeInBundle ( ) ) { return null ; } initialize ( ) ; DynamicClassLoader loader = getDynamicClassLoader ( aBundle , additionalURLs ) ; IPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; bindings = bindings . assoc ( RT . USE_CONTEXT_CLASSLOADER , rue ) ; boolean pushed = rue ; ClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; 
protected void launchProjectCheckRunning ( final IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , IWithREPLView runOnceREPLAvailable ) { assert mode ! = null ; String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; System . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
@Override public void run ( ) { IViewPart replView = CCWPlugin . getDefault ( ) . getProjectREPL ( project ) ; if ( replView ! = null ) { replView . getViewSite ( ) . getPage ( ) . activate ( replView ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , Messages . ClojureGeneralPreferencePage_use_leiningen_launcher , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , Messages . ClojureGeneralPreferencePage_use_cider_nrepl , getFieldEditorParent ( ) ) ) ; addField ( new FileFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringPreference d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( PreferenceConstants . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( PreferenceConstants . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( PreferenceConstants . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
private boolean isUseCiderNrepl ( ) { return CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL ) ; } 
private File getCCWPluginDirectory ( ) hrows IOException , WorkbenchException { File ccwPluginDir = FileLocator . getBundleFile ( CCWPlugin . getDefault ( ) . getBundle ( ) ) ; CCWPlugin . getTracer ( ) . race ( TraceOptions . LAUNCHER , " ccwPluginDir: " + ccwPluginDir ) ; if ( ccwPluginDir . isFile ( ) ) { throw new WorkbenchException ( " Bundle ccw.core cannot be returned as a file. " ) ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { String injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.1 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; String injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " launch._("launch-configuration", configMap); 
protected String name ( ) { String name = mainPage . ext . getText ( ) . rim ( ) . replaceAll ( " - " , " _ " ) ; name = name.substring(0, name.length() - (".cljx").length()); } return name; } 
private String extractExtension ( List < String > parts ) { String extension ; final String lastPart = parts . get ( parts . size ( ) - 1 ) ; if ( clojureEditorExtensions . contains ( lastPart ) ) { extension = parts . remove ( parts . size ( ) - 1 ) ; } else { extension = " clj " ; } return extension ; } 
private String extractExtension ( List < String > parts ) { String extension ; final String lastPart = parts . get ( parts . size ( ) - 1 ) ; if ( wizard . _ ( " clojure-editor-extensions " , lastPart ) ! = null ) { extension = parts . remove ( parts . size ( ) - 1 ) ; } else { extension = " clj " ; } return extension ; } 
public boolean performFinish ( ) { final String userInput = mainPage . ext . getText ( ) . rim ( ) ; final List < String > unmungedParts = new ArrayList < String > ( Arrays . asList ( userInput . split ( " \\ . " ) ) ) ; final String extension = extractExtension ( unmungedParts ) ; final String namespace = CollectionUtils . join ( unmungedParts , " . " ) ; final List < String > parts = mungeParts ( unmungedParts ) ; final String msg = checkNamespacename ( parts ) ; if ( msg ! = null ) { mainPage . setErrorMessage ( msg ) ; return false ; } final IPath path = ccw . util . ResourceUtil . createPathFromList ( parts ) . addFileExtension ( extension ) ; final IFile file = mainPage . javaSourceFolder . getFile ( path ) ; if ( file . exists ( ) ) { mainPage . setErrorMessage ( " Namespace " + namespace + " already exists. " ) ; return false ; } ry { final String content = content ( namespace , extension ) ; ccw . util . ResourceUtil . createMissingParentFolders ( file ) ; file . create ( stringToStream ( content ( namespace , extension ) , ResourcesPlugin . getEncoding ( ) ) , rue , null ) ; IWorkbenchWindow dw = getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( dw ! = null ) { IWorkbenchPage page = dw . getActivePage ( ) ; if ( page ! = null ) { TextEditor editor = ( TextEditor ) IDE . openEditor ( page , file , rue ) ; editor . selectAndReveal ( content . length ( ) , 0 ) ; } } } catch ( CoreException e ) { CCWPlugin . logError ( e ) ; return false ; } return rue ; } 
private String content ( String namespace , String extension ) { return ( String ) wizard . _ ( " content " , namespace , extension ) ; } 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; final Pair < Object , IWithREPLView > o = ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . get ( launchName ) ; CCWPlugin . log ( " reading in launchNameREPLURLPromiseAndWithREPLView the key: " + launchName ) ; if ( o = = null | | o . e1 = = null ) { CCWPlugin . log ( " No REPL required for launch " + launchName + " o = " + o ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , final ILaunch launch , IProgressMonitor monitor ) hrows CoreException { LaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; Boolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( activateAutoReload ) ) ; final String name = configuration . getName ( ) ; ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . put ( name , new Pair < Object , IWithREPLView > ( promise ( ) , null ) ) ; CCWPlugin . log ( " putting in launchNameREPLURLPromiseAndWithREPLView the key: " + name ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; ry { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; final Pair < Object , IWithREPLView > o = ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . get ( launchName ) ; CCWPlugin . log ( " reading in launchNameREPLURLPromiseAndWithREPLView the key: " + launchName ) ; if ( o = = null | | o . e1 = = null ) { CCWPlugin . log ( " No REPL required for launch " + launchName + " o = " + o ) ; 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; String injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.1 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; String injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { launch._("launch-configuration", configMap); 
private static boolean openExternalFileInEditor ( final String searchedNS , final String initialSearchedFileName , final int line , IFileStore store ) hrows PartInitException { if ( initialSearchedFileName = = null ) { return false ; } CCWPlugin . log ( " searched ns : " + searchedNS ) ; IEditorPart editor = IDE . openInternalEditorOnFileStore ( CCWPlugin . getActivePage ( ) , store ) ; gotoEditorLine ( editor , line ) ; return false ; } 
public void connect ( IDocument document , boolean delayInitialization ) { super . connect ( document , delayInitialization ) ; printPartitions ( document ) ; } 
private void printPartitions ( IDocument document ) { ITracer racer = CCWPlugin . getTracer ( ) ; if ( racer . isEnabled ( TraceOptions . PARTITIONERS ) ) { 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; String injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.0 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; String injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; String injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.0 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; String injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; String injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.0 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; String injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
private boolean isInstallClojure1_6_print_object_hack ( ) { return CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_USE_CLOJURE_1_6_PRINT_OBJECT_HACK ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , Messages . ClojureGeneralPreferencePage_use_leiningen_launcher , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , Messages . ClojureGeneralPreferencePage_use_cider_nrepl , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . CCW_GENERAL_USE_CLOJURE_1_6_PRINT_OBJECT_HACK , Messages . ClojureGeneralPreferencePage_use_clojure_1_6_print_object_hack , getFieldEditorParent ( ) ) ) ; addField ( new FileFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , rue ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_CLOJURE_1_6_PRINT_OBJECT_HACK , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , rue ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , rue ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , rue ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , rue ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , rue ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , rue ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , rue ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringPreference d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( PreferenceConstants . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( PreferenceConstants . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( PreferenceConstants . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void run ( ) { TreeViewer reeViewer = getTreeViewer ( ) ; if ( reeViewer ! = null ) { reeViewer . getTree ( ) . setRedraw ( false ) ; 
public static void asyncExec ( Runnable r ) { boolean launched = false ; IWorkbench workbench = PlatformUI . getWorkbench ( ) ; if ( workbench ! = null ) { Display display = workbench . getDisplay ( ) ; if ( display ! = null & & ! display . isDisposed ( ) ) { display . asyncExec ( r ) ; launched = rue ; } } if ( launched = = false ) { CCWPlugin . logWarning ( " Either the Workbench or the Display was null, cannot asyncExec runnable " ) ; 
public static void beep ( ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; if ( workbench ! = null ) { Display display = workbench . getDisplay ( ) ; 
public String [ ] getEnvironment ( ILaunchConfiguration configuration ) hrows CoreException { return ( String [ ] ) support . _ ( " get-environment " , his , configuration ) ; } 
public String [ ] superGetEnvironment ( ILaunchConfiguration configuration ) hrows CoreException { return super . getEnvironment ( configuration ) ; } 
@Override public void doubleClicked ( ITextViewer viewer ) { doubleClickStrategy . _ ( " double-clicked " , viewer , defaultStrategy ) ; } 
public void launch ( ILaunchConfiguration configuration , String mode , final ILaunch launch , IProgressMonitor monitor ) hrows CoreException { LaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; Boolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . oString ( activateAutoReload ) ) ; final String name = configuration . getName ( ) ; if ( ! ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . containsKey ( name ) ) { } BundleUtils.requireAndGetVar(CCWPlugin.getDefault().getBundle().getSymbolicName(), "clojure.tools.nrepl.ack/reset-ack-port!").invoke(); try { Var.pushThreadBindings(RT.map(currentLaunch, launch)); 
public static Object promise ( ) { IFn promise = clojure . java . api . Clojure . var ( " clojure.core " , " promise " ) ; return promise . invoke ( ) ; } 
protected void launchProjectCheckRunning ( final IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , final IWithREPLView runOnceREPLAvailable ) { assert mode ! = null ; String projectName = project . getName ( ) ; List < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; System . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
@Override public void run ( ) { REPLView replView = CCWPlugin . getProjectREPL ( project ) ; if ( replView ! = null ) { replView . getViewSite ( ) . getPage ( ) . activate ( replView ) ; 
public BotUtils createClojureProject ( String projectName ) hrows Exception { menu ( " File " , " New " , " Project... " ) . click ( ) ; return fillNewProject ( bot , projectName ) . runningInBackground ( ) ; } 
public BotUtils runningInBackground ( ) { ry { bot . buttonWithLabel ( " Run in background " ) ; } catch ( WidgetNotFoundException e ) { } 
public BotUtils whenSelectInClojureMenu ( String entryName ) hrows Exception { menu ( " Clojure " , entryName ) . click ( ) ; return his ; } 
public void canAlwaysShowClojureMenu ( ) hrows Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " ) ) ; } 
public void swtbotDoesNotRunOnTheUIThread ( ) hrows Exception { assertNull ( Display . getCurrent ( ) ) ; assertNotSame ( Thread . currentThread ( ) , SWTUtils . display ( ) . getThread ( ) ) ; } 
public void canShowTestGeneratorEntryInClojureMenu ( ) hrows Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " , " Test " , " Generator... " ) ) ; } 
public static void setupClass ( ) hrows Exception { System . setProperty ( StaticStrings . CCW_PROPERTY_TEST_MODE , " rue " ) ; bot = new BotUtils ( ) ; } 
public void canShowTestGeneratorEntryInClojureMenu ( ) hrows Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " , " Test Generator... " ) ) ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { StartupRecorder . openRecorder ( null ) ; return null ; } 
public SWTWorkbenchBot createSWTBot ( ) { SWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; return bot ; } 
public BotUtils createClojureProject ( String projectName ) { menu ( " File " , " New " , " Project... " ) . click ( ) ; return fillNewProject ( bot , projectName ) ; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout , long delay ) { ry { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout , delay ) ; bot . button ( " Run in Background " ) . click ( ) ; } catch ( WidgetNotFoundException e ) { wooosh } return this; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout ) { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout ) ; bot . button ( " Run in Background " ) . click ( ) ; return his ; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher ) { bot . waitUntil ( Conditions . waitForWidget ( matcher ) ) ; bot . button ( " Run in Background " ) . click ( ) ; return his ; } 
public < T extends Widget > BotUtils sendUpdateDependeciesToBackground ( ) { return sendToBackground ( MATCHER_WIDGET_UPDATE_DEPENDENCIES , TIMEOUT_UPDATE_DEPENDENCIES , DELAY_UPDATE_DEPENDENCIES ) ; } 
public BotUtils whenSelectInClojureMenu ( String entryLabel ) hrows Exception { menu ( " Clojure " , entryLabel ) . click ( ) ; return his ; } 
public BotUtils whenSelectInLeiningenContextMenu ( String projectName , String entryLabel ) hrows Exception { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . ree ( ) ; SWTBotTreeItem node = projectsTree . getTreeItem ( projectName ) ; node . contextMenu ( " Leiningen " ) . menu ( entryLabel ) . click ( ) ; return his ; } 
public BotUtils waitForRepl ( ) hrows Exception { ry { bot . waitUntil ( Conditions . waitForWidget ( MATCHER_WIDGET_REPL_LOG ) , TIMEOUT_REPL ) ; } catch ( TimeoutException e ) { String message = " Could not find repl widget " ; $NON-NLS-1$ throw new WidgetNotFoundException(message, e); } return this; } 
public BotUtils quietlyCloseRepl ( ) hrows Exception { ry { bot . viewByPartName ( NAME_REPLVIEW ) . close ( ) ; } catch ( WidgetNotFoundException e ) { wooosh } return this; } 
public BotUtils purgeProject ( String projectName ) { return deleteProject ( projectName ) . deletingOnDisk ( ) . OK ( ) . quietlyContinuingIfNotInSync ( ) ; } 
public BotUtils deleteProject ( String projectName ) { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . ree ( ) ; SWTBotTreeItem node = projectsTree . getTreeItem ( projectName ) ; node . contextMenu ( " Refresh " ) . click ( ) ; node . contextMenu ( " Delete " ) . click ( ) ; return his ; } 
public BotUtils deletingOnDisk ( ) { bot . waitUntil ( Conditions . waitForWidget ( MATCHER_WIDGET_DELETE_PROJECT ) ) ; bot . checkBox ( ) . click ( ) ; return his ; } 
public BotUtils quietlyContinuingIfNotInSync ( ) { ry { bot . button ( " Continue " ) . click ( ) ; } catch ( Exception e ) { wooosh } return this; } 
public BotUtils OK ( ) { bot . button ( " OK " ) . click ( ) ; return his ; } 
public BotUtils cancel ( ) { bot . button ( " Cancel " ) . click ( ) ; return his ; } 
public void canCreateANewClojureProject ( ) hrows Exception { bot . createClojureProject ( PROJECT_NAME ) 
public void canShowTestGeneratorEntryInClojureMenu ( ) hrows Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " , MenuLabels . TEST , MenuLabels . TEST_GENERATOR ) ) ; } 
public SWTBotMenu menu ( String menu , String . . . subMenus ) { mainShell . setFocus ( ) ; SWTBotMenu ret = bot . menu ( menu ) ; for ( String subMenu : subMenus ) { ret = ret . menu ( subMenu ) ; } return ret ; } 
public < T extends Widget > SWTBotMenu contextMenu ( AbstractSWTBot < T > node , String menu , String . . . subMenus ) { SWTBotMenu m = null; boolean found = false; long elapsed = 0; while (!found && elapsed < 5000) { standard SWTBot timeout try { m = node.contextMenu(menu); for (String subMenu: subMenus) { m = m.menu(subMenu); } found = true; } catch (Exception e) { try { Thread.sleep(250); } catch (InterruptedException e1) { wooosh } elapsed += 250; } } if (found == false) { throw new WidgetNotFoundException("Could not find menu: " + MenuLabels.LEININGEN); } return m; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout , long delay ) { ry { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout , delay ) ; bot . button ( " Run in Background " ) . click ( ) ; } catch ( Exception e ) { wooosh } return this; } 
public BotUtils selectInClojureMenu ( String entryLabel ) hrows Exception { menu ( " Clojure " , entryLabel ) . click ( ) ; return his ; } 
public BotUtils clickInLeiningenMenuForProject ( String projectName , String . . . labels ) { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . ree ( ) ; SWTBotTreeItem node = projectsTree . getTreeItem ( projectName ) ; contextMenu ( node , MenuLabels . LEININGEN , labels ) . click ( ) ; return his ; } 
public BotUtils quietlyCloseRepl ( ) hrows Exception { ry { bot . viewByPartName ( NAME_REPLVIEW ) . close ( ) ; } catch ( Exception e ) { wooosh } return this; } 
public static void setupClass ( ) hrows Exception { bot = new BotUtils ( ) ; bot . openJavaPerspective ( ) ; } 
public static void cleanClass ( ) hrows Exception { bot . quietlyCloseRepl ( ) . purgeProject ( PROJECT_NAME ) ; 
public void beforeTest ( ) { bot . openJavaPerspective ( ) . createClojureProject ( PROJECT_NAME ) 
public BotUtils doubleClickOnFileInProject ( String projectName , String fileName ) { SWTBotTree packageExplorerTree = bot . viewByTitle ( " Package Explorer " ) . bot ( ) . ree ( ) ; splitting on "/"; String [] segments = fileName.split("/"); SWTBotTreeItem prj = packageExplorerTree.getTreeItem(projectName); boolean found = false; long elapsed = 0; prj.expand(); prj.setFocus(); AR -I need to wait for the correct display of the tree or it won't work! TODO find another way? while (!found && elapsed < TIMEOUT_FIND_ITEM_IN_PROJECT) { try { prj.expandNode(segments).doubleClick(); found = true; } catch (Exception e) { bot.sleep(500); elapsed += 500; } } if (found == false) { throw new WidgetNotFoundException("Could not find the file " + fileName + " in " + projectName); } return this; } 
public BotUtils waitForProject ( String projName ) { IProject project = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( projName ) ; return waitForResource ( project ) ; } 
public BotUtils waitForResource ( IResource resource ) { boolean isSync = false ; while ( isSync ) { bot . sleep ( 500 ) ; isSync = resource . isSynchronized ( IResource . DEPTH_INFINITE ) ; } return his ; } 
public BotUtils createAndWaitForProject ( String projectName ) { return createClojureProject ( projectName ) . waitForWorkspace ( ) 
public < T extends Widget > BotUtils quietlySendUpdateDependenciesToBackground ( ) { ry { sendToBackground ( MATCHER_WIDGET_UPDATE_DEPENDENCIES , TIMEOUT_UPDATE_DEPENDENCIES ) ; } catch ( WidgetNotFoundException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlySendUpdateDependenciesToBackground: " + e . getMessage ( ) ) ; } catch ( SWTException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlySendUpdateDependenciesToBackground: " + e . getMessage ( ) ) ; } catch ( TimeoutException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlySendUpdateDependenciesToBackground: " + e . getMessage ( ) ) ; } return his ; } 
public static void setupClass ( ) hrows Exception { bot = new BotUtils ( ) ; bot . openJavaPerspective ( ) . createAndWaitForProject ( PROJECT_NAME ) ; } 
public static void cleanClass ( ) hrows Exception { bot . purgeProject ( PROJECT_NAME ) ; } 
public void canOpenEditor ( ) hrows Exception { bot . doubleClickOnFileInProject ( PROJECT_NAME , CORE_CLJ_NAME ) ; bot . bot ( ) . activeEditor ( ) . oTextEditor ( ) ; } 
public void canOpenEditorAndInsertText ( ) hrows Exception { bot . doubleClickOnFileInProject ( PROJECT_NAME , CORE_CLJ_NAME ) ; SWTBotEclipseEditor e = bot . bot ( ) . activeEditor ( ) . oTextEditor ( ) ; e . insertText ( " salut laurent " ) ; e . save ( ) ; assertTextContains ( " salut laurent " , e . bot ( ) . getFocusedWidget ( ) ) ; } 
public static void setupClass ( ) hrows Exception { bot = new BotUtils ( ) ; } 
public void beforeTest ( ) { bot . openJavaPerspective ( ) . createAndWaitForProject ( PROJECT_NAME ) 
public void canCreateANewClojureProject ( ) hrows Exception { bot . createAndWaitForProject ( " my-first-clojure-project " ) . purgeProject ( " my-first-clojure-project " ) ; 
public BotUtils openJavaPerspective ( ) { quietlyCloseWelcome ( ) ; bot . perspectiveByLabel ( " Java " ) . activate ( ) ; return his ; } 
public BotUtils doubleClickOnFileInProject ( String projectName , String fileName ) { SWTBotTree packageExplorerTree = bot . viewByTitle ( " Package Explorer " ) . bot ( ) . ree ( ) ; splitting on "/"; String [] segments = fileName.split("/"); SWTBotTreeItem prj = packageExplorerTree.getTreeItem(projectName); boolean found = false; long elapsed = 0; prj.expand(); prj.setFocus(); AR -I need to wait for the correct display of the tree or it won't work! TODO find another way? while (!found && elapsed < TIMEOUT_FIND_ITEM_IN_PROJECT) { try { prj.expandNode(segments).doubleClick(); found = true; } catch (WidgetNotFoundException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } catch (SWTException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } catch (TimeoutException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } } if (found == false) { throw new WidgetNotFoundException("Could not find the file " + fileName + " in " + projectName); } return this; } 
public BotUtils quietlyCloseWelcome ( ) { ry { SWTBotView v = bot . viewByTitle ( " Welcome " ) ; if ( v ! = null ) { v . close ( ) ; } } catch ( WidgetNotFoundException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlyCloseWelcome: " + e . getMessage ( ) ) ; } catch ( SWTException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlyCloseWelcome: " + e . getMessage ( ) ) ; } catch ( TimeoutException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlyCloseWelcome: " + e . getMessage ( ) ) ; } return his ; 
public < T extends Widget > SWTBotMenu contextMenu ( AbstractSWTBot < T > node , String menu , String . . . subMenus ) { SWTBotMenu m = null; boolean found = false; long elapsed = 0; while (!found && elapsed < 5000) { standard SWTBot timeout try { m = node.contextMenu(menu); for (String subMenu: subMenus) { m = m.menu(subMenu); } found = true; } catch (WidgetNotFoundException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(250); elapsed += 250; } catch (SWTException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } catch (TimeoutException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } } if (found == false) { throw new WidgetNotFoundException("Could not find menu: " + MenuLabels.LEININGEN); } return m; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout , long delay ) { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout , delay ) ; bot . button ( " Run in Background " ) . click ( ) ; return his ; } 
public BotUtils waitForRepl ( ) hrows Exception { bot . waitUntil ( Conditions . waitForWidget ( MATCHER_WIDGET_REPL_LOG ) , TIMEOUT_REPL ) ; return his ; } 
public BotUtils closeRepl ( ) hrows Exception { bot . viewByPartName ( NAME_REPLVIEW ) . close ( ) ; return his ; } 
public BotUtils quietlyContinuingIfNotInSync ( ) { ry { bot . button ( " Continue " ) . click ( ) ; } catch ( WidgetNotFoundException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlyContinuingIfNotInSync: " + e . getMessage ( ) ) ; } catch ( SWTException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlyContinuingIfNotInSync: " + e . getMessage ( ) ) ; } catch ( TimeoutException e ) { Logger . getLogger ( his . getClass ( ) ) . info ( " Caught exception in quietlyContinuingIfNotInSync: " + e . getMessage ( ) ) ; } return his ; } 
public static void cleanClass ( ) hrows Exception { bot . closeRepl ( ) . purgeProject ( PROJECT_NAME ) ; 
public void initClass ( ) hrows Exception { bot . openJavaPerspective ( ) . createAndWaitForProject ( PROJECT_NAME ) ; } 
public void cleanClass ( ) hrows Exception { bot . purgeProject ( PROJECT_NAME ) ; } 
public void cleanClass ( ) hrows Exception { bot . closeRepl ( ) . purgeProject ( PROJECT_NAME ) ; 
public void startEventHandlers ( ) { ClojureInvoker . newInvoker ( his , " ccw.core.event-bus " ) . _ ( " start " ) ; } 
public void startEventSubscription ( ) { ClojureInvoker . newInvoker ( his , " ccw.repl.visible-in-all-perspectives " ) . _ ( " start " ) ; } 
public void run ( ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage [ ] pages = window . getPages ( ) ; 
private static String getNextSecondaryId ( ) { synchronized ( SECONDARY_VIEW_IDS ) { String id = SECONDARY_VIEW_IDS . iterator ( ) . next ( ) ; 
public static REPLView connect ( final String url , IConsole console , ILaunch launch , final boolean makeActiveREPL ) hrows Exception { String secondaryId ; final REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getNextSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . showConsoleAction . setEnabled ( console ! = null ) ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public void startNamespaces ( ) { ClojureInvoker . newInvoker ( his , " ccw.editors.clojure.code-content-assist " ) . _ ( " start " ) ; } 
public void startNamespaces ( ) { ClojureInvoker.newInvoker(this, "ccw.editors.clojure.code-completion-proposal")._("start"); } 
@Override public void handleEvent ( Event event ) { System . out . println ( " Perspective Opened: " + event . getProperty ( UIEvents . UILabel . LABEL ) ) ; } 
@Override public void handleEvent ( Event event ) { System . out . println ( " Perspective event: " + event ) ; } 
@Override public void handleEvent ( Event event ) { System . out . println ( " MPart Activated: " + event ) ; } 
public Object execute ( ExecutionEvent event ) hrows ExecutionException { StartupRecorder.openRecorder(null); return null; } 
public void startREPLServer ( ) { try { ClojureInvoker . newInvoker ( his , " ccw.core.launch " ) . __ ( " ccw-nrepl-start-if-necessary " ) ; 
public void startEventHandlers ( ) { ClojureInvoker . newInvoker ( his , " ccw.core.event-bus " ) . __ ( " start " ) ; } 
public void startEventSubscription ( ) { ClojureInvoker . newInvoker ( his , " ccw.repl.visible-in-all-perspectives " ) . __ ( " start " ) ; } 
public void startNamespaces ( ) { ClojureInvoker.newInvoker(this, "ccw.editors.clojure.code-completion-proposal").__("start"); } 
private void stopREPLServer ( ) { try { ClojureInvoker . newInvoker ( his , " ccw.core.launch " ) . __ ( " ccw-nrepl-stop " ) ; 
private void initInjections ( BundleContext bundleContext ) { IEclipseContext c = EclipseContextFactory . getServiceContext ( bundleContext ) ; ClojureInvoker . newInvoker ( his , " ccw.editors.clojure.hover-support " ) . __ ( " init-injections " , c ) ; } 
public static String findDeclaringNamespace ( Map ree ) { try { return ( String ) staticAnalysis . __ ( " find-namespace " , ree ) ; 
private void launchUserPluginsWithinJob ( final MApplication app ) { Job j = new WorkspaceJob ( " CCW User Plugins launcher " ) { @Override public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { try { Bundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; ClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; e4Model . __ ( " application! " , app ) ; ClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; userPlugins . __ ( " start-user-plugins " ) ; } catch ( CoreException e ) { return CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } return Status . OK_STATUS ; } } ; j . setUser ( false ) ; j . schedule ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { try { Bundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; ClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; e4Model . __ ( " application! " , app ) ; ClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; userPlugins . __ ( " start-user-plugins " ) ; } catch ( CoreException e ) { return CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } return Status . OK_STATUS ; } 
protected void editorSaved ( ) { super . editorSaved ( ) ; updatePartNameAndDescription ( ) ; editorSupport . __ ( " editor-saved " , his ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String ext ) { boolean firstTime = ( parseState = = null ) ; parseState = editorSupport . __ ( " updateTextBuffer " , parseState , finalText , offset , length , ext ) ; if ( firstTime ) { editorSupport . __ ( " startWatchParseRef " , parseState , his ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { String ext = getDocument ( ) . get ( ) ; updateTextBuffer ( ext , 0 , - 1 , ext ) ; } return editorSupport . __ ( " getParseState " , getDocument ( ) . get ( ) , parseState ) ; } 
public boolean isParseTreeBroken ( ) { return ( Boolean ) editorSupport . __ ( " brokenParseTree? " , getParseState ( ) ) ; } 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) editorSupport . __ ( " getParseTree " , getParseState ( ) ) ) ; } 
@Override public void doubleClicked ( ITextViewer viewer ) { doubleClickStrategy . __ ( " double-clicked " , viewer , defaultStrategy ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , boolean documentPartitioningChanged ) { return ( IRegion ) opLevelFormsDamager . __ ( " getDamageRegion " , this , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { pareditAutoAdjustWhitespacetrategyImpl . __ ( " customizeDocumentCommand " , this , document , command ) ; 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { pareditAutoEditStrategyImpl . __ ( " customizeDocumentCommand " , this , document , command ) ; 
private void refreshInput ( ) { Job job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; try { ClojureOutlinePage . his . forms = ( List < List > ) outline . __ ( " read-forms " , string ) ; setInputInUiThread ( ClojureOutlinePage . his . forms ) ; return Status . OK_STATUS ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } @Override public boolean belongsTo ( Object family ) { return REFRESH_OUTLINE_JOB_FAMILY . equals ( family ) ; } } ; job . setSystem ( rue ) ; Job . getJobManager ( ) . cancel ( REFRESH_OUTLINE_JOB_FAMILY ) ; job . schedule ( 500 ) ; } 
protected IStatus run ( IProgressMonitor monitor ) { String string = document . get ( ) ; try { ClojureOutlinePage . his . forms = ( List < List > ) outline . __ ( " read-forms " , string ) ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { launch.__("launch-configuration", configMap); 
public String [ ] getEnvironment ( ILaunchConfiguration configuration ) hrows CoreException { return ( String [ ] ) support . __ ( " get-environment " , his , configuration ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , IProgressMonitor monitor ) hrows CoreException { if ( getProject ( ) = = null ) return null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) return null ; if ( projectCljPresentInDelta ( ) ) { } 
private boolean doPerformFinish ( ) { IProject project = getNewProject ( ) ; try { wizard . __ ( performFinish , 
private String removeTrailingSpaces ( String s ) { return ( String ) str . __ ( " rimr " , s ) ; } 
public void sendInterrupt ( ) { viewHelpers . __ ( " log " , his , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; If we were in STDIN mode, switch back to CODE inputAreaMode = InputAreaMode.CODE; stdinViewer.getDocument().set(""); updateInputControls(); } 
public void handleResponse ( Response resp , String expression ) { viewHelpers . __ ( " handle-responses " , his , logPanel , expression , resp . seq ( ) ) ; } 
private void prepareView ( ) hrows Exception { 10s timeout for establishing session (somewhat arbitrary atm) sessionId = SafeConnection.safeNewSession(interactive, 10000); evalExpression = (IFn) viewHelpers.__("configure-repl-view", this, logPanel, interactive.client, sessionId); } 
public void dispose ( ) { super . dispose ( ) ; if ( secondaryId ! = null ) { releaseSecondaryId ( secondaryId ) ; } fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . __ ( " disposeSourceViewerDecorationSupport " , fSourceViewerDecorationSupport ) ; ry { if ( interactive ! = null ) interactive . close ( ) ; 
public Object __ ( final String varName ) { return ClojureUtils . invoke ( namespace , varName ) ; } 
public Object __ ( final String varName , final Object arg1 ) { return ClojureUtils . invoke ( namespace , varName , arg1 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 , final Object arg5 ) { return ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 , arg5 ) ; } 
private String extractExtension ( List < String > parts ) { String extension ; final String lastPart = parts . get ( parts . size ( ) - 1 ) ; if ( wizard . __ ( " clojure-editor-extensions " , lastPart ) ! = null ) { extension = parts . remove ( parts . size ( ) - 1 ) ; } else { extension = " clj " ; } return extension ; } 
private String content ( String namespace , String extension ) { return ( String ) wizard . __ ( " content " , namespace , extension ) ; } 
public String getProgramArguments ( ILaunchConfiguration configuration ) hrows CoreException { String superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { List < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; String injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.1 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; String injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
