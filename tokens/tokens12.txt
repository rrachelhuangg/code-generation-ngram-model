public void start ( BundleContext context ) throws Exception { tsuper . start ( context ) ; tplugin = this ; } 
public void stop ( BundleContext context ) throws Exception { tplugin = null ; tsuper . stop ( context ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) tthrows CoreException { tIResourceDelta delta = getDelta ( getProject ( ) ) ; tincrementalBuild ( delta , monitor ) ; treturn null ; } 
private void incrementalBuild ( IResourceDelta delta , IProgressMonitor monitor ) { tclojure . lang . Compiler compiler = new clojure . lang . Compiler ( ) ; tmonitor . beginTask ( " Evaluating " + delta . getFullPath ( ) . lastSegment ( ) , IProgressMonitor . UNKNOWN ) ; ttry { tObject result = compiler . loadFile ( delta . getFullPath ( ) . toOSString ( ) ) ; 
public boolean performFinish ( ) { tboolean result = super . performFinish ( ) ; if ( result ) { tIProject project = getNewProject ( ) ; ttry { tIProjectDescription description = project . getDescription ( ) ; tString [ ] natures = description . getNatureIds ( ) ; tString [ ] newNatures = new String [ natures . length + 2 ] ; tSystem . arraycopy ( natures , 0 , newNatures , 0 , natures . length ) ; tnewNatures [ natures . length ] = " clojuredev.nature " ; tnewNatures [ natures . length + 1 ] = " org.eclipse.jdt.core.javanature " ; tdescription . setNatureIds ( newNatures ) ; tproject . setDescription ( description , null ) ; } catch ( CoreException e ) { tActivator . getDefault ( ) . getLog ( ) . log ( new Status ( tIStatus . ERROR , Activator . PLUGIN_ID , e . getMessage ( ) , e ) ) ; } } treturn result ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { tString workingDirectory = configuration . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , " " ) ; tlaunch . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , workingDirectory ) ; tSystem . out . println ( " launch!!! " ) ; } 
public void launch ( ISelection selection , String mode ) { }} 
public void launch ( IEditorPart editor , String mode ) { }} 
public void createControl ( Composite parent ) { tComposite comp = SWTFactory . createComposite ( parent , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; ( ( GridLayout ) comp . getLayout ( ) ) . verticalSpacing = 0 ; tcreateProjectEditor ( comp ) ; tcreateVerticalSpacer ( comp , 1 ) ; tcreateFileEditor ( comp , " Clojure File " ) ; tsetControl ( comp ) ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { tconfig . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; tmapResources ( config ) ; } 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { tILaunchConfigurationTab [ ] tabs = new ILaunchConfigurationTab [ ] { } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) tthrows CoreException { tSystem . out . println ( " build: " + kind + " args: " + args ) ; tIResourceDelta delta = getDelta ( getProject ( ) ) ; tincrementalBuild ( delta , monitor ) ; treturn null ; } 
public void launch ( ISelection selection , String mode ) { tSystem . out . println ( " launch: " + selection . toString ( ) ) ; } 
public void launch ( IEditorPart editor , String mode ) { tIEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { tIFile file = ( ( FileEditorInput ) input ) . getFile ( ) ; 
public void run ( ) { tfinal IOConsoleInputStream in = getInputStream ( ) ; tIOConsoleOutputStream ioOut = newOutputStream ( ) ; tIOConsoleOutputStream ioInfo = newOutputStream ( ) ; tIOConsoleOutputStream ioErr = newOutputStream ( ) ; tin . setColor ( INPUT_COLOUR ) ; tioOut . setColor ( OUTPUT_COLOUR ) ; tioInfo . setColor ( INPUT_COLOUR ) ; tioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; tinfo = new PrintStream ( ioInfo ) ; terr = new PrintStream ( ioErr ) ; ttry { *ns* must be thread-bound for in-ns to work 
private Object loadFile ( IFile file ) throws Exception { tString fullPath = file . getLocation ( ) . toFile ( ) . toString ( ) ; tinfo . println ( " (load-file \" " + fullPath + " \" ) " ) ; treturn clojure . lang . Compiler . loadFile ( fullPath ) ; } 
private Object eval ( Object r ) throws Exception { treturn clojure . lang . Compiler . eval ( r ) ; } 
public void consolesAdded ( IConsole [ ] consoles ) { } public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { }} 
public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { 
public void openConsole ( ) { if ( fConsole = = null ) { fConsole = new ClojureConsole ( ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { System . out . println ( " build: " + kind + " args: " + args ) ; IResourceDelta delta = getDelta ( getProject ( ) ) ; incrementalBuild ( delta , monitor ) ; return null ; } 
private static boolean addNature ( IProject project , String natureID ) { IProjectDescription desc ; try { desc = project . getDescription ( ) ; } catch ( CoreException e ) { ClojuredevPlugin . logError ( " Could not get project description " , e ) ; return false ; } String [ ] ids = desc . getNatureIds ( ) ; String [ ] newIDs = new String [ ids . length + 1 ] ; System . arraycopy ( ids , 0 , newIDs , 1 , ids . length ) ; newIDs [ 0 ] = natureID ; desc . setNatureIds ( newIDs ) ; try { project . setDescription ( desc , null ) ; } catch ( CoreException e ) { ClojuredevPlugin . logError ( " Could not set project description " , e ) ; return false ; } return true ; } 
public static boolean addClojureNature ( IProject project ) { return addNature ( project , ClojureNature . NATURE_ID ) ; } 
public static boolean addJavaNature ( IProject project ) { return addNature ( project , JavaCore . NATURE_ID ) ; } 
public void checkClasspath ( ) { IFile classpath = project . getProject ( ) . getFile ( " .classpath " ) ; if ( ! classpath . exists ( ) ) return ; if ( classpathUpdate = = IResource . NULL_STAMP ) { classpathUpdate = classpath . getModificationStamp ( ) ; return ; } if ( classpathUpdate = = classpath . getModificationStamp ( ) ) return ; classpathUpdate = classpath . getModificationStamp ( ) ; resetBuildState(); 
public List < IFolder > sourceFolders ( ) { return sourceFolders ( getJavaProject ( ) ) ; } 
public void notifyBuilt ( Runnable notifyBuilt ) { this . notifyBuilt = notifyBuilt ; } 
public void notifyBuilt ( ) { if ( notifyBuilt ! = null ) notifyBuilt . run ( ) ; 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; } 
public void stop ( BundleContext context ) throws Exception { plugin = null ; super . stop ( context ) ; } 
public static void logError ( String msg ) { plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg ) ) ; } 
public static void logError ( String msg , Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg , e ) ) ; } 
public static void logError ( Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public boolean hasNext ( ) { try { current = LispReader . read ( pushbackReader , false , EOF , false ) ; 
public void remove ( ) { throw new UnsupportedOperationException ( ) ; } 
public void evalString ( String string ) { try { queue . put ( string ) ; 
public void run ( ) { final IOConsoleInputStream in = getInputStream ( ) ; IOConsoleOutputStream ioOut = newOutputStream ( ) ; IOConsoleOutputStream ioInfo = newOutputStream ( ) ; IOConsoleOutputStream ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; try { *ns* must be thread-bound for in-ns to work 
public void run ( ) { for ( ; ; ) { try { 
private Object loadFile ( IFile file ) throws Exception { String fullPath = file . getLocation ( ) . toFile ( ) . toString ( ) ; info . println ( " (load-file \" " + fullPath + " \" ) " ) ; return clojure . lang . Compiler . loadFile ( fullPath ) ; } 
private Object eval ( Object r ) throws Exception { return clojure . lang . Compiler . eval ( r ) ; } 
public void consolesAdded ( IConsole [ ] consoles ) { } public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { fConsole.saveDocument(); fConsole = null; } } } }); } @Override public void openConsole() { if (fConsole == null) { fConsole = new ClojureConsole(); fConsole.initializeDocument(); fConsoleManager.addConsoles(new IConsole[] { fConsole }); } fConsoleManager.showConsoleView(fConsole); }} 
public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { 
public void openConsole ( ) { if ( fConsole = = null ) { fConsole = new ClojureConsole ( ) ; fConsole.initializeDocument(); fConsoleManager.addConsoles(new IConsole[] { fConsole }); } fConsoleManager.showConsoleView(fConsole); } 
public boolean isWordStart ( char c ) { return Character . isJavaIdentifierStart ( c ) ; } 
public boolean isWordPart ( char c ) { return Character . isJavaIdentifierPart ( c ) ; } 
public boolean isWhitespace ( char c ) { return Character . isWhitespace ( c ) ; } 
public IPresentationReconciler getPresentationReconciler ( ISourceViewer sourceViewer ) { PresentationReconciler reconciler = new PresentationReconciler ( ) ; reconciler . setDocumentPartitioning ( getConfiguredDocumentPartitioning ( sourceViewer ) ) ; DefaultDamagerRepairer dr = new DefaultDamagerRepairer ( clojureScanner ) ; reconciler . setDamager ( dr , IDocument . DEFAULT_CONTENT_TYPE ) ; reconciler . setRepairer ( dr , IDocument . DEFAULT_CONTENT_TYPE ) ; return reconciler ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { String workingDirectory = configuration . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , " " ) ; launch . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_WORKING_DIRECTORY , workingDirectory ) ; System . out . println ( " launch!!! " ) ; } 
public void launch ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { IFile file = ( ( FileEditorInput ) input ) . getFile ( ) ; 
public void createControl ( Composite parent ) { Composite comp = SWTFactory . createComposite ( parent , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; ( ( GridLayout ) comp . getLayout ( ) ) . verticalSpacing = 0 ; createProjectEditor ( comp ) ; createVerticalSpacer ( comp , 1 ) ; createFileEditor ( comp , " Clojure File " ) ; setControl ( comp ) ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; mapResources ( config ) ; } 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { ILaunchConfigurationTab [ ] tabs = new ILaunchConfigurationTab [ ] { new JavaMainTab(), new ClojureMainTab(), new JavaArgumentsTab(), new JavaJRETab(), new JavaClasspathTab(), new SourceLookupTab(), new EnvironmentTab(), new CommonTab() }; setTabs(tabs); } 
protected String kind ( boolean toLower ) { if ( toLower ) return adjective ( ) . toLowerCase ( ) + kind ( ) . toLowerCase ( ) ; 
private Group label ( Composite parent , String label ) { Group group = new Group ( parent , SWT . NONE ) ; group . setText ( label ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; group . setLayout ( layout ) ; group . setFont ( parent . getFont ( ) ) ; GridData gd = new GridData ( GridData . FILL_HORIZONTAL ) ; group . setLayoutData ( gd ) ; return group ; } 
private void addToGroup ( Group group , Control control ) { GridData gd = new GridData ( GridData . FILL_HORIZONTAL ) ; control . setLayoutData ( gd ) ; control . setFont ( group . getFont ( ) ) ; } 
public void addPages ( ) { super . addPages ( ) ; mainPage = new Page ( ) ; $NON-NLS-1$ mainPage.setTitle("New Clojure " + kind(false)); mainPage.setDescription("Create new top-level Clojure " + kind(true)); addPage(mainPage); } 
public void init ( IWorkbench workbench , IStructuredSelection currentSelection ) { super . init ( workbench , currentSelection ) ; setWindowTitle ( " New Clojure " + kind ( false ) ) ; setNeedsProgressMonitor ( false ) ; } 
protected void initializeDefaultPageImageDescriptor ( ) { super . initializeDefaultPageImageDescriptor ( ) ; } 
protected String name ( ) { String name = mainPage . text . getText ( ) . trim ( ) ; if ( name . endsWith ( " .clj " ) ) name = name . substring ( 0 , name . length ( ) - ( " .clj " ) . length ( ) ) ; return name ; } 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " in " + name ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( i ) + " ' at index " + i + " in " + name ) ; return false ; } check if file already exists. IFile file; if (mainPage.dest instanceof IProject) { file = ((IProject)mainPage.dest).getFile(name + ".clj"); } else if (mainPage.dest instanceof IFolder) { file = ((IFolder)mainPage.dest).getFile(name + ".clj"); } else { return false; } if (file.exists()) { mainPage.setErrorMessage("File with same name already exists."); return false; } try { String contents = ";; " + name; contents += ""; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { ClojuredevPlugin.logError(e); return false; } return true; } 
public void addPages ( ) { super . addPages ( ) ; getStartingPage ( ) . setDescription ( " Create a new Clojure project. " ) ; getStartingPage ( ) . setTitle ( " Clojure project " ) ; setWindowTitle ( " New Clojure project " ) ; } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { IProject project = getNewProject ( ) ; ScalaCore.getScalaProject(project); ScalaCore.getJavaProject(project); boolean ret = ClojureCore.addJavaNature(project) && ClojureCore.addClojureNature(project); return ret; } new NewSourceFolderCreationWizard(); return false; } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; textTools = new ClojureTextTools ( ) ; } 
public void stop ( BundleContext context ) throws Exception { plugin = null ; textTools = null ; super . stop ( context ) ; } 
public static ClojureTextTools textTools ( ) { return getDefault ( ) . textTools ; } 
public void removeColor ( String colorKey ) { tcolorMap . remove ( colorKey ) ; tfontMap . remove ( colorKey ) ; } 
public Image image ( ImageDescriptor desc ) { if ( ! images . containsKey ( desc ) ) images . put ( desc , desc . createImage ( ) ) ; treturn images . get ( desc ) ; } 
protected IDocument createDocument ( Object element ) throws CoreException { IDocument document = super . createDocument ( element ) ; if ( document ! = null ) { IDocumentPartitioner partitioner = new ClojurePartitioner ( ) ; document . setDocumentPartitioner ( partitioner ) ; partitioner . connect ( document ) ; } else { return null ; } return document ; } 
public IProject iproject ( ) { IEditorInput input0 = getEditorInput ( ) ; if ( input0 instanceof FileEditorInput ) return ( ( FileEditorInput ) input0 ) . getFile ( ) . getProject ( ) ; return null ; } 
public void connect ( IDocument document , boolean delayInitialization ) { super . connect ( document , delayInitialization ) ; printPartitions ( document ) ; } 
public void printPartitions ( IDocument document ) { StringBuffer buffer = new StringBuffer ( ) ; ITypedRegion [ ] partitions = computePartitioning ( 0 , document . getLength ( ) ) ; for ( int i = 0 ; i < partitions . length ; i + + ) { try { buffer . append ( " Partition type: " + partitions [ i ] . getType ( ) + " , offset: " + partitions [ i ] . getOffset ( ) + " , length: " + partitions [ i ] . getLength ( ) ) ; buffer . append ( " " ) ; buffer . append ( " Text: " ) ; buffer . append ( document . get ( partitions [ i ] . getOffset ( ) , partitions [ i ] . getLength ( ) ) ) ; buffer . append ( " n--------------------------- " ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } } System . out . print ( buffer ) ; } 
public IInformationControl createInformationControl ( Shell parent ) { tDefaultInformationControl ret = new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; tret . setBackgroundColor ( parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_WHITE ) ) ; tret . setForegroundColor ( parent . getDisplay ( ) . getSystemColor ( SWT . COLOR_BLACK ) ) ; treturn ret ; } 
public static String indent ( ) { if ( indent = = null ) { tindent = " " ; tfor ( int i = 0 ; i < getTabWidth ( ) ; i + + ) indent + = " " ; } treturn indent ; } 
public boolean isArgBracket ( char character ) { for ( int index = 0 ; index < ARG_BRACKETS . length ; index + + ) { if ( ARG_BRACKETS [ index ] = = character ) return true ; } return false ; } 
public IToken evaluate ( ICharacterScanner scanner ) { int character = scanner . read ( ) ; if ( isArgBracket ( ( char ) character ) ) { do { 
public boolean isWhitespace ( char c ) { return Character . isWhitespace ( c ) ; } 
public TextAttribute createTextAttribute ( String colorKey ) { tboolean bold = getPreferenceStore ( ) . getBoolean ( tcolorKey + ClojureColorConstants . CLOJURE_ISBOLD_APPENDIX ) ; tboolean italics = getPreferenceStore ( ) . getBoolean ( tcolorKey + ClojureColorConstants . CLOJURE_ISITALICS_APPENDIX ) ; tboolean underline = getPreferenceStore ( ) . getBoolean ( tcolorKey + ClojureColorConstants . CLOJURE_ISUNDERLINE_APPENDIX ) ; tboolean strikethrough = getPreferenceStore ( ) . getBoolean ( tcolorKey + ClojureColorConstants . CLOJURE_ISSTRIKETHROUGH_APPENDIX ) ; tint style = SWT . NORMAL ; if ( bold ) style = style | SWT . BOLD ; if ( italics ) style = style | SWT . ITALIC ; if ( underline ) style = style | TextAttribute . UNDERLINE ; if ( strikethrough ) style = style | TextAttribute . STRIKETHROUGH ; treturn new TextAttribute ( getColorProvider ( ) . getColor ( colorKey ) , null , style ) ; } 
public boolean isWordPart ( char character ) { return Character . isJavaIdentifierPart ( character ) ; } 
public boolean isWordStart ( char character ) { return Character . isJavaIdentifierStart ( character ) ; } 
public boolean isParen ( char character ) { for ( int index = 0 ; index < PARENS . length ; index + + ) { if ( PARENS [ index ] = = character ) return true ; } return false ; } 
public IToken evaluate ( ICharacterScanner scanner ) { int character = scanner . read ( ) ; if ( isParen ( ( char ) character ) ) { do { 
public IToken evaluate ( ICharacterScanner scanner ) { if ( scanner . read ( ) ! = '(' ) { scanner . unread ( ) ; return Token . UNDEFINED ; } int depth = 1 ; for ( int c = scanner . read ( ) ; c ! = ICharacterScanner . EOF ; c = scanner . read ( ) ) { if ( c = = '(' ) { depth + + ; } else if ( c = = ')' ) { depth - - ; } if ( depth = = 0 ) { break ; } } return depth = = 0 ? getSuccessToken ( ) : Token . UNDEFINED ; } 
public IToken evaluate ( ICharacterScanner scanner , boolean resume ) { return evaluate ( scanner ) ; } 
public void initializeDefaultPreferences ( ) { tIEclipsePreferences node = new DefaultScope ( ) . getNode ( ClojuredevPlugin . PLUGIN_ID ) ; tnode . put ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , StringConverter . asString ( true ) ) ; tnode . put ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , tStringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; 
public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { setDocumentProvider ( new FileDocumentProvider ( ) ) ; tsetSourceViewerConfiguration ( new ClojureSourceViewerConfiguration ( ) ) ; tsuper . init ( site , input ) ; } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { tsupport . setCharacterPairMatcher ( pairsMatcher ) ; tsupport . setMatchingCharacterPainterPreferenceKeys ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR ) ; tsuper . configureSourceViewerDecorationSupport ( support ) ; } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { tfAnnotationAccess = createAnnotationAccess ( ) ; tfOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; tISourceViewer viewer = new ProjectionViewer ( parent , ruler , getOverviewRuler ( ) , isOverviewRulerVisible ( ) , styles ) ; } 
public void createPartControl ( Composite parent ) { tsuper . createPartControl ( parent ) ; tProjectionViewer viewer = ( ProjectionViewer ) getSourceViewer ( ) ; tfProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public void dispose ( ) { if ( pairsMatcher ! = null ) { tpairsMatcher . dispose ( ) ; tpairsMatcher = null ; } tsuper . dispose ( ) ; } 
public AntlrBasedPartitionScanner create ( ) { treturn new AntlrBasedPartitionScanner ( new ClojureLexer ( ) ) { @Override 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { taddToken ( ClojurePartitionLexer . PARTITION_STRING , CLOJURE_STRING ) ; taddToken ( ClojurePartitionLexer . PARTITION_COMMENT , CLOJURE_COMMENT ) ; taddToken ( ClojurePartitionLexer . PARTITION_CODE , CLOJURE_CODE ) ; } 
private void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { tDefaultDamagerRepairer dr = new DefaultDamagerRepairer ( tokenScanner ) ; treconciler . setDamager ( dr , contentType ) ; treconciler . setRepairer ( dr , contentType ) ; } 
public AntlrBasedTokenScanner create ( final IColorManager colorProvider ) { treturn new AntlrBasedTokenScanner ( new ClojureLexer ( ) ) { @Override 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorProvider ) ; tu . addTokenType ( ClojureLexer . STRING , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . NUMBER , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . CHARACTER , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . NIL , IJavaColorConstants . JAVA_DEFAULT ) ; tu . addTokenType ( ClojureLexer . BOOLEAN , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . SYMBOL , IJavaColorConstants . JAVA_DEFAULT ) ; tu . addBoldToken ( ClojureLexer . SPECIAL_FORM , IJavaColorConstants . JAVA_KEYWORD ) ; tu . addTokenType ( ClojureLexer . T21 , IJavaColorConstants . JAVA_DEFAULT ) ; } 
public String toString ( ) { treturn super . toString ( ) + getClass ( ) . getSimpleName ( ) + " [ " + text + " ] " + offset + " " + length + " " + iToken ; } 
public void customizeDocumentCommand ( IDocument document , DocumentCommand command ) { tSystem . out . println ( " customizeDocumentCommand " + command . offset + " " + command . length + " [ " + command . text + " ] " ) ; if ( command . length = = 0 & & command . text ! = null & & endsWithDelimiter ( document , command . text ) ) { End of line 
private boolean endsWithDelimiter ( IDocument document , String txt ) { tString [ ] delimiters = document . getLegalLineDelimiters ( ) ; if ( delimiters ! = null ) { treturn TextUtilities . endsWith ( delimiters , txt ) > - 1 ; } treturn false ; } 
public final void mT21 ( ) throws RecognitionException { try { int _type = T21 ; 
public final void mT22 ( ) throws RecognitionException { try { int _type = T22 ; 
public final void mT23 ( ) throws RecognitionException { try { int _type = T23 ; 
public final void mT24 ( ) throws RecognitionException { try { int _type = T24 ; 
public final void mT25 ( ) throws RecognitionException { try { int _type = T25 ; 
public final void mT26 ( ) throws RecognitionException { try { int _type = T26 ; 
public final void mT27 ( ) throws RecognitionException { try { int _type = T27 ; 
public final void mT28 ( ) throws RecognitionException { try { int _type = T28 ; 
public final void mT29 ( ) throws RecognitionException { try { int _type = T29 ; 
public final void mT30 ( ) throws RecognitionException { try { int _type = T30 ; 
public final void mT31 ( ) throws RecognitionException { try { int _type = T31 ; 
public final void mSPECIAL_FORM ( ) throws RecognitionException { try { int _type = SPECIAL_FORM ; 
public final void mSTRING ( ) throws RecognitionException { try { int _type = STRING ; 
public final void mNUMBER ( ) throws RecognitionException { try { int _type = NUMBER ; 
public final void mCHARACTER ( ) throws RecognitionException { try { int _type = CHARACTER ; 
public final void mNIL ( ) throws RecognitionException { try { int _type = NIL ; 
public final void mBOOLEAN ( ) throws RecognitionException { try { int _type = BOOLEAN ; 
public final void mSYMBOL ( ) throws RecognitionException { try { int _type = SYMBOL ; 
public final void mNAME ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:73:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:77:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:83:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public final void mKEYWORD ( ) throws RecognitionException { try { int _type = KEYWORD ; 
public final void mSYNTAX_QUOTE ( ) throws RecognitionException { try { int _type = SYNTAX_QUOTE ; 
public final void mUNQUOTE_SPLICING ( ) throws RecognitionException { try { int _type = UNQUOTE_SPLICING ; 
public final void mUNQUOTE ( ) throws RecognitionException { try { int _type = UNQUOTE ; 
public final void mCOMMENT ( ) throws RecognitionException { try { int _type = COMMENT ; 
public final void mSPACE ( ) throws RecognitionException { try { int _type = SPACE ; 
public final void mLAMBDA_ARG ( ) throws RecognitionException { try { int _type = LAMBDA_ARG ; 
public void mTokens ( ) throws RecognitionException { o:/clojure/basic-clojure-grammar/src/Clojure.g:1:8: ( T21 | T22 | T23 | T24 | T25 | T26 | T27 | T28 | T29 | T30 | T31 | SPECIAL_FORM | STRING | NUMBER | CHARACTER | NIL | BOOLEAN | SYMBOL | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt22=25; alt22 = dfa22.predict(input); switch (alt22) { case 1 : 
public final void mPARTITION_STRING ( ) throws RecognitionException { try { int _type = PARTITION_STRING ; 
public final void mPARTITION_COMMENT ( ) throws RecognitionException { try { int _type = PARTITION_COMMENT ; 
public final void mPARTITION_CODE ( ) throws RecognitionException { try { int _type = PARTITION_CODE ; 
public void mTokens ( ) throws RecognitionException { o:/clojure/basic-clojure-grammar/src/ClojurePartition.g:1:8: ( PARTITION_STRING | PARTITION_COMMENT | PARTITION_CODE ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0=='\"') ) { alt6=1; } else if ( (LA6_0==';') ) { alt6=2; } else if ( ((LA6_0>='\u0000' && LA6_0<='!')||(LA6_0>='#' && LA6_0<=':')||(LA6_0>='<' && LA6_0<='\uFFFE')) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("1:1: Tokens : ( PARTITION_STRING | PARTITION_COMMENT | PARTITION_CODE );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : 
public final void addTokenType ( int tokenIndex , org . eclipse . jface . text . rules . Token token ) { if ( initialized ) throw lifeCycleError ( ) ; tantlrTokenTypeToJFaceToken . put ( tokenIndex , token ) ; } 
public final void addTokenType ( int tokenIndex , TextAttribute textAttribute ) { if ( initialized ) throw lifeCycleError ( ) ; taddTokenType ( tokenIndex , new org . eclipse . jface . text . rules . Token ( textAttribute ) ) ; } 
public final void addToken ( int tokenIndex , String tokenData ) { if ( initialized ) throw lifeCycleError ( ) ; taddTokenType ( tokenIndex , new org . eclipse . jface . text . rules . Token ( tokenData ) ) ; } 
private RuntimeException lifeCycleError ( ) { treturn new RuntimeException ( " Object Lifecycle error: method called at an inappropriate time " ) ; } 
public final IToken nextToken ( ) { tint nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = tokensData . size ( ) ) { tClojuredevPlugin . logError ( " nextToken called but no more token ! Returning EOF (Last non EOF token: " + tokensData . get ( currentTokenIndex ) + " ) " ) ; tSystem . err . println ( " nextToken called but no more token ! Returning EOF (Last non EOF token: " + tokensData . get ( currentTokenIndex ) + " ) " ) ; treturn org . eclipse . jface . text . rules . Token . EOF ; return token.iToken; 
private void repositionCurrentTokenAtOffset ( int offset ) { tfor ( int i = tokensData . size ( ) - 1 ; i > = 0 ; i - - ) { tTokenData tokenInfo = tokensData . get ( i ) ; 
private void addTokenInfo ( CommonToken token ) { tassert token ! = null ; tIToken retToken = antlrTokenTypeToJFaceToken . get ( token . getType ( ) ) ; if ( retToken = = null ) { tSystem . err . println ( " addTokenInfo " + token ) ; tretToken = org . eclipse . jface . text . rules . Token . UNDEFINED ; } ttokensData . add ( new TokenData ( token , retToken ) ) ; } 
public void addTokenType ( int tokenIndex , String colorKey ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . getColor ( colorKey ) ) ) ; } 
public void addBoldToken ( int tokenIndex , String colorKey ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . getColor ( colorKey ) , null , SWT . BOLD ) ) ; } 
public void addItalicToken ( int tokenIndex , String colorKey ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . getColor ( colorKey ) , null , SWT . ITALIC ) ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; } 
public void gotoMatchingBracket ( ) { tISourceViewer sourceViewer = getSourceViewer ( ) ; tIDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) treturn ; tIRegion selection = getSignedSelection ( sourceViewer ) ; tint selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { tsetStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; tsourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; treturn ; } } 
protected void initializeKeyBindingScopes ( ) { tsetKeyBindingScopes ( new String [ ] { " clojuredev.ui.clojureEditorScope " } ) ; } 
protected final void markAsPartListener ( RetargetAction action ) { tpartListeners . add ( action ) ; } 
public void init ( IActionBars bars , IWorkbenchPage page ) { tfor ( RetargetAction a : partListeners ) tpage . addPartListener ( a ) ; tsuper . init ( bars , page ) ; } 
public void contributeToMenu ( IMenuManager menu ) { tsuper . contributeToMenu ( menu ) ; tIMenuManager gotoMenu = menu . findMenuUsingPath ( " navigate/goTo " ) ; gotoMenu.add(new Separator("additions2")); $NON-NLS-1$ 
public void dispose ( ) { tfor ( RetargetAction a : partListeners ) tgetPage ( ) . removePartListener ( a ) ; tpartListeners . clear ( ) ; tsetActiveEditor ( null ) ; } 
public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { tsuper . init ( site , input ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; } 
public void gotoPreviousMember ( ) { tISourceViewer sourceViewer = getSourceViewer ( ) ; tIDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) treturn ; tIRegion selection = getSignedSelection ( sourceViewer ) ; tint selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { tsetStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; tsourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; treturn ; } while (nextParenOffset >= 0) { 
private boolean matchChar ( char c , char [ ] charsToMatch ) { tfor ( char ctm : charsToMatch ) if ( c = = ctm ) treturn true ; treturn false ; } 
private void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { tDefaultDamagerRepairer dr = new DefaultDamagerRepairer ( tokenScanner ) ; treconciler . setDamager ( dr , contentType ) ; treconciler . setRepairer ( dr , contentType ) ; } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorProvider ) ; tu . addTokenType ( ClojureLexer . STRING , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . NUMBER , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . CHARACTER , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . NIL , IJavaColorConstants . JAVA_DEFAULT ) ; tu . addTokenType ( ClojureLexer . BOOLEAN , IJavaColorConstants . JAVA_STRING ) ; tu . addTokenType ( ClojureLexer . SYMBOL , IJavaColorConstants . JAVA_DEFAULT ) ; tu . addBoldToken ( ClojureLexer . SPECIAL_FORM , IJavaColorConstants . JAVA_KEYWORD ) ; tu . addTokenType ( ClojureLexer . T23 , IJavaColorConstants . JAVA_DEFAULT ) ; } 
protected IDocument createDocument ( Object element ) throws CoreException { IDocument document = super . createDocument ( element ) ; if ( document ! = null ) { tIDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , tClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; tMap < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; tm . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; tTextUtilities . addDocumentPartitioners ( document , m ) ; } else { return null ; } return document ; } 
public final void mOPEN_PAREN ( ) throws RecognitionException { try { int _type = OPEN_PAREN ; 
public final void mCLOSE_PAREN ( ) throws RecognitionException { try { int _type = CLOSE_PAREN ; 
public final void mNAME ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:86:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:90:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:96:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public void mTokens ( ) throws RecognitionException { o:/clojure/basic-clojure-grammar/src/Clojure.g:1:8: ( T23 | T24 | T25 | T26 | T27 | T28 | T29 | T30 | T31 | OPEN_PAREN | CLOSE_PAREN | SPECIAL_FORM | STRING | NUMBER | CHARACTER | NIL | BOOLEAN | SYMBOL | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt23=25; alt23 = dfa23.predict(input); switch (alt23) { case 1 : 
public final IToken nextToken ( ) { tint nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = tokensData . size ( ) ) { treturn org . eclipse . jface . text . rules . Token . EOF ; } tcurrentTokenIndex = nextIndex ; tTokenData token = tokensData . get ( currentTokenIndex ) ; if ( token ! = null ) { treturn token . iToken ; 
private void addTokenInfo ( CommonToken token ) { tassert token ! = null ; tIToken retToken = antlrTokenTypeToJFaceToken . get ( token . getType ( ) ) ; if ( retToken = = null ) { tretToken = org . eclipse . jface . text . rules . Token . UNDEFINED ; } ttokensData . add ( new TokenData ( token , retToken ) ) ; } 
public void run ( ) { final IOConsoleInputStream in = getInputStream ( ) ; IOConsoleOutputStream ioOut = newOutputStream ( ) ; IOConsoleOutputStream ioInfo = newOutputStream ( ) ; IOConsoleOutputStream ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; try { *ns* must be thread-bound for in-ns to work 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , this ) ; tString id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; taction . setActionDefinitionId ( id ) ; tsetAction ( " ContentAssistProposal " , action ) ; tmarkAsStateDependentAction ( " ContentAssistProposal " , true ) ; } 
private List < String > parse ( String text ) { tClojureLexer lex = new ClojureLexer ( new ANTLRStringStream ( text ) ) ; tCommonTokenStream tokens = new CommonTokenStream ( lex ) ; tClojureParser parser = new ClojureParser ( tokens ) ; try { tSystem . out . println ( " begin parse " ) ; 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { tint wordStart = offset - 1 ; tIDocument doc = viewer . getDocument ( ) ; ttry { 
public IContextInformation [ ] computeContextInformation ( ITextViewer viewer , int offset ) { treturn new IContextInformation [ ] { tnew IContextInformation ( ) { 
public Integer matchingParenForPosition ( Integer position ) { return ( Integer ) parensMatching . get ( position ) ; } 
public final void literal ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:106:8: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) o:/clojure/basic-clojure-grammar/src/Clojure.g: { if ( (input.LA(1)>=STRING && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:171:10: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case 28: { alt5=1; } break; case 29: { alt5=2; } break; case 30: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("171:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:172:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1033); quoteForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:173:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1043); metaForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:174:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1053); derefForm(); _fsp--; } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:175:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1063); syntaxQuoteForm(); _fsp--; } break; case 5 : o:/clojure/basic-clojure-grammar/src/Clojure.g:176:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1073); unquoteSplicingForm(); _fsp--; } break; case 6 : o:/clojure/basic-clojure-grammar/src/Clojure.g:177:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1083); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:180:18: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==31) ) { switch ( input.LA(2) ) { case STRING: { alt6=1; } break; case 28: { alt6=2; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("180:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("180:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:181:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1110); regexForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:182:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1120); varQuoteForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:183:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1132); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1161); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,25,FOLLOW_25_in_vector1184); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,27,FOLLOW_27_in_map1212); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:198:5: ( '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:198:8: '\\'' form { match(input,28,FOLLOW_28_in_quoteForm1245); pushFollow(FOLLOW_form_in_quoteForm1247); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:201:9: ( '^' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:201:13: '^' form { match(input,29,FOLLOW_29_in_metaForm1261); pushFollow(FOLLOW_form_in_metaForm1263); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:204:10: ( '@' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:204:13: '@' form { match(input,30,FOLLOW_30_in_derefForm1280); pushFollow(FOLLOW_form_in_derefForm1282); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:210:5: ( SYNTAX_QUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:211:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1322); pushFollow(FOLLOW_form_in_syntaxQuoteForm1324); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:217:5: ( UNQUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:218:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1364); pushFollow(FOLLOW_form_in_unquoteForm1366); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:224:5: ( UNQUOTE_SPLICING form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:225:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1406); pushFollow(FOLLOW_form_in_unquoteSplicingForm1408); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,27,FOLLOW_27_in_set1434); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:231:10: ( '#' STRING ) o:/clojure/basic-clojure-grammar/src/Clojure.g:231:13: '#' STRING { match(input,31,FOLLOW_31_in_regexForm1447); match(input,STRING,FOLLOW_STRING_in_regexForm1449); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:234:13: ( '#' '^' ( map | SYMBOL | KEYWORD | STRING ) ) o:/clojure/basic-clojure-grammar/src/Clojure.g:235:9: '#' '^' ( map | SYMBOL | KEYWORD | STRING ) { match(input,31,FOLLOW_31_in_metadataForm1473); match(input,29,FOLLOW_29_in_metadataForm1475); o:/clojure/basic-clojure-grammar/src/Clojure.g:235:17: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case 26: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("235:17: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:18: map { pushFollow(FOLLOW_map_in_metadataForm1478); map(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:24: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1482); } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:31: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1484); } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:235:39: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1486); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:238:13: ( '#' '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:239:9: '#' '\\'' form { match(input,31,FOLLOW_31_in_varQuoteForm1507); match(input,28,FOLLOW_28_in_varQuoteForm1509); pushFollow(FOLLOW_form_in_varQuoteForm1511); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:251:5: ( '#' list ) o:/clojure/basic-clojure-grammar/src/Clojure.g:251:7: '#' list { match(input,31,FOLLOW_31_in_lambdaForm1540); pushFollow(FOLLOW_list_in_lambdaForm1542); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public void evalString ( String string ) { tin . appendData ( string ) ; try { 
public void run ( ) { in = getInputStream ( ) ; IOConsoleOutputStream ioOut = newOutputStream ( ) ; IOConsoleOutputStream ioInfo = newOutputStream ( ) ; IOConsoleOutputStream ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; try { *ns* must be thread-bound for in-ns to work 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , this ) ; tString id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; taction . setActionDefinitionId ( id ) ; tsetAction ( " ContentAssistProposal " , action ) ; tmarkAsStateDependentAction ( " ContentAssistProposal " , true ) ; } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) treturn ; tint sourceCaretOffset = getSourceCaretOffset ( ) ; tint previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) tselectAndReveal ( previousMemberOffset , 0 ) ; 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) treturn false ; tIRegion selection = getSignedSelection ( getSourceViewer ( ) ) ; tint selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { tsetStatusLineErrorMessage ( errorMessageIfProblem ) ; tgetSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; treturn false ; } treturn true ; } 
public void selectTopLevelSExpression ( ) { tIRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) tselectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) treturn ; tint sourceCaretOffset = getSourceCaretOffset ( ) ; tint endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) tselectAndReveal ( endOfMemberOffset , 0 ) ; 
public void consolesAdded ( IConsole [ ] consoles ) { } public void consolesRemoved ( IConsole [ ] consoles ) { for ( int i = 0 ; i < consoles . length ; i + + ) { if ( consoles [ i ] = = fConsole ) { fConsole.saveDocument(); fConsole = null; } } } }); } public void openConsole() { if (fConsole == null) { fConsole = new ClojureConsole(); fConsole.initializeDocument(); fConsoleManager.addConsoles(new IConsole[] { fConsole }); } fConsoleManager.showConsoleView(fConsole); }} 
public void evalString ( String string ) { if ( in ! = null ) { tin . appendData ( string ) ; 
public void run ( ) { in = getInputStream ( ) ; ioOut = newOutputStream ( ) ; ioInfo = newOutputStream ( ) ; ioErr = newOutputStream ( ) ; in . setColor ( INPUT_COLOUR ) ; ioOut . setColor ( OUTPUT_COLOUR ) ; ioInfo . setColor ( INPUT_COLOUR ) ; ioErr . setColor ( ERROR_COLOUR ) ; out = new PrintStream ( ioOut ) ; info = new PrintStream ( ioInfo ) ; err = new PrintStream ( ioErr ) ; try { *ns* must be thread-bound for in-ns to work 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { System.out.println("build:" + kind + " args:" + args); IResourceDelta delta = getDelta(getProject()); incrementalBuild(delta, monitor); return null; } 
public static boolean addClojureNature ( IProject project ) { return addNature ( project , ClojureProjectNature . NATURE_ID ) ; } 
public void deconfigure ( ) throws CoreException { Check that we actally have a project if (project == null) { ClojuredevPlugin.logError( "Could not remove Scala builder: project is null", null); return; } closed clojure projects cannot be modified if (!project.isOpen()) { return; } get project description IProjectDescription desc; try { desc = project.getDescription(); } catch (CoreException e) { ClojuredevPlugin.logError("Could not get project description", e); return; } look for clojure builder int index = -1; ICommand[] cmds = desc.getBuildSpec(); for (int i = 0; i < cmds.length; i++) { if (cmds[i].getBuilderName().equals( ClojureBuilder.BUILDER_ID)) { index = i; break; } } builder was not found, so no need to remove it if (index == -1) { return; } builder was found so remove it ArrayList<ICommand> list = new ArrayList<ICommand>(); list.addAll(Arrays.asList(cmds)); list.remove(index); ICommand[] newCmds = (ICommand[]) list .toArray(new ICommand[list.size()]); set back the project description desc.setBuildSpec(newCmds); try { project.setDescription(desc, null); 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; mapResources ( config ) ; try { config . doSave ( ) ; 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { ILaunchConfigurationTab [ ] tabs = new ILaunchConfigurationTab [ ] { new JavaMainTab(), new ClojureMainTab(), new JavaArgumentsTab(), new JavaJRETab(), new JavaClasspathTab(), new SourceLookupTab(), new EnvironmentTab(), new CommonTab() }; setTabs(tabs); } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { IProject project = getNewProject ( ) ; ScalaCore.getScalaProject(project); ScalaCore.getJavaProject(project); boolean ret = ClojureCore.addJavaNature(project) && ClojureCore.addClojureNature(project); IJavaProject javaProject = JavaCore.create(project); return ret && javaProject != null; } return false; } 
public void configure ( ) throws CoreException { IProjectDescription desc = getProjectDescription ( ) ; if ( desc = = null ) { treturn ; } ICommand [ ] spec = desc . getBuildSpec ( ) ; return; } ICommand clojureCommand = desc.newCommand(); clojureCommand.setBuilderName(ClojureBuilder.BUILDER_ID); Add clojure builder before all other builders (thus before Java builder if present) ICommand[] newSpec = new ICommand[spec.length + 1]; newSpec[0] = clojureCommand; System.arraycopy(spec, 0, newSpec, 1, spec.length); desc.setBuildSpec(newSpec); project.setDescription(desc, IResource.FORCE, null); setupClojureProjectClassPath(); } 
private void setupClojureProjectClassPath ( ) throws CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; if ( ! hasClojureLibOnClasspath ( javaProject ) ) { IClasspathEntry [ ] entriesOld = javaProject . getRawClasspath ( ) ; 
private boolean hasClojureLibOnClasspath ( IJavaProject javaProject ) throws JavaModelException { treturn javaProject . findElement ( new Path ( " clojure/lang " ) ) ! = null ; } 
public static void logWarning ( String msg ) { plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg ) ) ; } 
public static void logWarning ( String msg , Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg , e ) ) ; } 
public static void logWarning ( Throwable e ) { plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public void selectionChanged ( IAction action , ISelection selection ) { tthis . selection = selection ; } 
public void run ( IAction action ) { if ( selection instanceof IStructuredSelection ) { tfor ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it 
private void toggleNature ( IProject project ) { tString title = " Change Clojure Nature " ; tString message ; ttry { tboolean added = doToggleNature ( project ) ; tmessage = " Clojure nature successfully " + ( added ? " added " : " removed " ) + " . " ; } catch ( CoreException e ) { tmessage = " Error while trying to toggle clojure nature for project " + project . getName ( ) ; tClojuredevPlugin . logError ( message , e ) ; } tMessageDialog . openInformation ( targetPart . getSite ( ) . getShell ( ) , title , message ) ; } 
private boolean doToggleNature ( IProject project ) throws CoreException { tIProjectDescription description = project . getDescription ( ) ; tString [ ] natures = description . getNatureIds ( ) ; tList < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; tboolean natureFound = false ; tfor ( String nature : natures ) { if ( nature . equals ( ClojureProjectNature . NATURE_ID ) ) { } 
public void dispose ( ) { tfor ( RetargetAction a : partListeners ) tgetPage ( ) . removePartListener ( a ) ; tpartListeners . clear ( ) ; tsetActiveEditor ( null ) ; tsuper . dispose ( ) ; } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { IProject project = getNewProject ( ) ; 
private void setupClojureProjectClassPath ( ) throws CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; File clojureLib = getDefaultClojureLib ( ) ; if ( ! hasClojureLibOnClasspath ( javaProject ) & & clojureLib ! = null ) { IClasspathEntry [ ] entriesOld = javaProject . getRawClasspath ( ) ; 
private void createFileEditor ( final Composite parent , String string ) { Group section = SWTFactory . createGroup ( parent , " Evaluate Clojure source file(s) " , 2 , 1 , GridData . FILL_BOTH ) ; sourceFilesViewer = new TableViewer ( section ) ; sourceFilesViewer . setLabelProvider ( new LabelProvider ( ) ) ; sourceFilesViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; sourceFilesViewer . getTable ( ) . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Composite buttonSection = SWTFactory . createComposite ( section , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; Button chooseButton = new Button ( buttonSection , SWT . PUSH ) ; chooseButton . setText ( " Choose... " ) ; chooseButton . addSelectionListener ( new SelectionAdapter ( ) { 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; List < IFile > sourceFilesInput = ( List < IFile > ) sourceFilesViewer . getInput ( ) ; if ( sourceFilesInput ! = null ) { StringBuilder args = new StringBuilder ( ) ; for ( IFile srcFile : sourceFilesInput ) { if ( args . length ( ) > 0 ) { args . append ( " " ) ; } args . append ( srcFile . getProjectRelativePath ( ) . toString ( ) ) ; } config . setAttribute ( ATTR_PROGRAM_ARGUMENTS , args . toString ( ) ) ; } mapResources ( config ) ; try { config . doSave ( ) ; 
public void launch ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void launch ( ISelection selection , String mode ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; 
protected void launchProject ( IProject project , IFile [ ] files , String mode ) { try { ILaunchConfiguration config = findLaunchConfiguration ( project , files ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) ; if ( files . length = = 1 ) { basename + = " " + files [ 0 ] . getName ( ) ; } String args = LaunchUtils . getProgramArguments ( files ) ; ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , args ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
protected ILaunchConfiguration chooseConfiguration ( List configList ) { IDebugModelPresentation labelProvider = DebugUITools . newDebugModelPresentation ( ) ; ElementListSelectionDialog dialog = new ElementListSelectionDialog ( JDIDebugUIPlugin . getActiveWorkbenchShell ( ) , labelProvider ) ; dialog . setElements ( configList . toArray ( ) ) ; dialog . setTitle ( " Choose a Clojure launch configuration " ) ; dialog . setMessage ( LauncherMessages . JavaLaunchShortcut_2 ) ; dialog . setMultipleSelection ( false ) ; int result = dialog . open ( ) ; labelProvider . dispose ( ) ; if ( result = = Window . OK ) { return ( ILaunchConfiguration ) dialog . getFirstResult ( ) ; } return null ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; List < IFile > sourceFilesInput = ( List < IFile > ) sourceFilesViewer . getInput ( ) ; if ( sourceFilesInput ! = null ) { String args = LaunchUtils . getProgramArguments ( sourceFilesInput ) ; config . setAttribute ( ATTR_PROGRAM_ARGUMENTS , args ) ; } mapResources ( config ) ; try { config . doSave ( ) ; 
private boolean contains ( IResource container , IResource containee ) { treturn container . getFullPath ( ) . isPrefixOf ( containee . getFullPath ( ) ) ; } 
private void createFileEditor ( final Composite parent , String string ) { Group section = SWTFactory . createGroup ( parent , " Evaluate Clojure source file(s) " , 2 , 1 , GridData . FILL_BOTH ) ; sourceFilesViewer = new TableViewer ( section ) ; sourceFilesViewer . setLabelProvider ( new DecoratingLabelProvider ( tnew WorkbenchLabelProvider ( ) , ClojuredevPlugin . getDefault ( ) . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ) ; sourceFilesViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; sourceFilesViewer . getTable ( ) . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Composite buttonSection = SWTFactory . createComposite ( section , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; Button chooseButton = new Button ( buttonSection , SWT . PUSH ) ; chooseButton . setText ( " Choose... " ) ; chooseButton . addSelectionListener ( new SelectionAdapter ( ) { 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; if ( needsSeparator ( userProgramArguments ) ) { tuserProgramArguments = " -- " + userProgramArguments ; } treturn filesToLaunchArguments + userProgramArguments ; } 
private boolean needsSeparator ( String userArgs ) { treturn ! userArgs . contains ( " -- " ) ; } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) ; if ( files . length = = 1 ) { basename + = " " + files [ 0 ] . getName ( ) ; } ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
protected ILaunchConfiguration chooseConfiguration ( List configList ) { IDebugModelPresentation labelProvider = null ; ttry { tlabelProvider = DebugUITools . newDebugModelPresentation ( ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; mapResources ( config ) ; try { config . doSave ( ) ; 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . trim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } try { sourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
static public String getFilesToLaunchAsCommandLineList ( ILaunchConfiguration config ) throws CoreException { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( config ) ; treturn LaunchUtils . getProgramArguments ( filesToLaunch ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { ttry { tURL clientReplBundleUrl = ClojuredevPlugin . getDefault ( ) . getBundle ( ) . getResource ( " clojuredev/clientrepl.clj " ) ; 
public void run ( ) { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " remote call! " , result . toString ( ) ) ; } 
public void removeHandlerListener ( IHandlerListener handlerListener ) { }} 
public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { treturn " -D " + " clojure.remote.server.port " + " = " + Integer . toString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) + super . getVMArguments ( configuration ) ; 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) ; if ( files . length = = 1 ) { basename + = " " + files [ 0 ] . getName ( ) ; } ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
public void createControl ( Composite parent ) { Composite comp = SWTFactory . createComposite ( parent , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; ( ( GridLayout ) comp . getLayout ( ) ) . verticalSpacing = 0 ; createProjectEditor ( comp ) ; createVerticalSpacer ( comp , 1 ) ; createFileEditor ( comp , " Clojure File " ) ; createVerticalSpacer ( comp , 1 ) ; createReplServerControl ( comp ) ; setControl ( comp ) ; } 
private void createReplServerControl ( final Composite parent ) { Group section = SWTFactory . createGroup ( parent , " Repl remote control settings " , 2 , 1 , 0 ) ; SWTFactory . createLabel ( section , " Remote server must listen on port: " , 1 ) ; serverPort = SWTFactory . createSingleText ( section , 0 ) ; serverPort . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { 
public void modifyText ( ModifyEvent e ) { getLaunchConfigurationDialog ( ) . updateButtons ( ) ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . valueOf ( serverPort . getText ( ) ) ) ; mapResources ( config ) ; try { config . doSave ( ) ; 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . trim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } try { serverPort . setText ( Integer . toString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; 
private void setupClojureProjectClassPath ( ) throws CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; if ( ! alreadyHasClojureLibOnClasspath ( javaProject ) ) { File clojureLib = getDefaultClojureLib ( ) ; 
private boolean alreadyHasClojureLibOnClasspath ( IJavaProject javaProject ) throws JavaModelException { treturn javaProject . findElement ( new Path ( " clojure/lang " ) ) ! = null ; } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; loadPluginClojureCode ( ) ; } 
private void loadPluginClojureCode ( ) throws Exception { tURL clientReplBundleUrl = ClojuredevPlugin . getDefault ( ) . getBundle ( ) . getResource ( " clojuredev/debug/clientrepl.clj " ) ; tURL clientReplFileUrl = FileLocator . toFileURL ( clientReplBundleUrl ) ; tString serverRepl = clientReplFileUrl . getFile ( ) ; tCompiler . loadFile ( serverRepl ) ; } 
public static ClojureClient createClojureClientFor ( IProcess process ) { } 
protected void initializeImageRegistry ( ImageRegistry reg ) { reg.put(PUBLIC_FUNCTION, ImageDescriptor.createFromURL(getBundle().getEntry("/icons/jdt/methpub_obj.gif"))); } 
public void run ( ) { MessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " remote call exception! " , e . getMessage ( ) ) ; } 
private void toggleNature ( IProject project ) { tString title = " Change Clojure language support " ; tString message ; ttry { tboolean added = doToggleNature ( project ) ; tmessage = " Clojure language support successfully " + ( added ? " added " : " removed " ) + " . " ; } catch ( CoreException e ) { tmessage = " Error while trying to toggle clojure language support for project " + project . getName ( ) ; tClojuredevPlugin . logError ( message , e ) ; } tMessageDialog . openInformation ( targetPart . getSite ( ) . getShell ( ) , title , message ) ; } 
public void dispose ( ) { if ( contentOutlinePage ! = null ) { tcontentOutlinePage . dispose ( ) ; 
private void createContentOutlinePage ( ) { tcontentOutlinePage = new ClojureNSOutlinePage ( new IClojureClientProvider ( ) { private final ClojureClient cc ; 
public Object invoke ( String string ) { ttry { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; } 
public void createControl ( Composite parent ) { tsuper . createControl ( parent ) ; tgetTreeViewer ( ) . setContentProvider ( new ContentProvider ( ) ) ; tgetTreeViewer ( ) . setLabelProvider ( new LabelProvider ( ) ) ; tgetTreeViewer ( ) . setSorter ( new NSSorter ( ) ) ; tObject remoteTree = getRemoteNsTree ( ) ; tgetTreeViewer ( ) . setInput ( remoteTree ) ; } 
public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { tthis . input = ( Map < String , List < String > > ) newInput ; } 
public boolean hasChildren ( Object parentElement ) { if ( parentElement instanceof Map ) { treturn ! ( ( Map ) parentElement ) . isEmpty ( ) ; 
public void addSelectionChangedListener ( ISelectionChangedListener listener ) { getSelectionProvider ( ) . addSelectionChangedListener ( listener ) ; } 
protected IPage createDefaultPage ( PageBook book ) { MessagePage page = new MessagePage ( ) ; initPage ( page ) ; page . createControl ( book ) ; page . setMessage ( defaultText ) ; return page ; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( getPageBook ( ) , CONTENT_OUTLINE_VIEW_HELP_CONTEXT_ID ) ; 
protected PageRec doCreatePage ( IWorkbenchPart part ) { } page.createControl(getPageBook()); return new PageRec(part, page); } There is no content outline return null; } 
protected void doDestroyPage ( IWorkbenchPart part , PageRec rec ) { IContentOutlinePage page = ( IContentOutlinePage ) rec . page ; page . dispose ( ) ; rec . dispose ( ) ; } 
protected boolean isImportant ( IWorkbenchPart part ) { treturn true ; We only care about editors 
public void partBroughtToTop ( IWorkbenchPart part ) { partActivated ( part ) ; } 
public void removeSelectionChangedListener ( ISelectionChangedListener listener ) { getSelectionProvider ( ) . removeSelectionChangedListener ( listener ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { getSelectionProvider ( ) . selectionChanged ( event ) ; } 
protected void showPageRec ( PageRec pageRec ) { IPageSite pageSite = getPageSite ( pageRec . page ) ; ISelectionProvider provider = pageSite . getSelectionProvider ( ) ; if ( provider = = null & & ( pageRec . page instanceof IContentOutlinePage ) ) { } super.showPageRec(pageRec); } 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( contentOutlinePage ! = null ) { contentOutlinePage . refresh ( ) ; 
public void run ( ) { getTreeViewer ( ) . setInput ( getRemoteNsTree ( ) ) ; getTreeViewer ( ) . refresh ( ) ; } 
protected PageRec doCreatePage ( IWorkbenchPart part ) { } page.createControl(getPageBook()); return new PageRec(part, page); } There is no content outline return null; } 
public void activated ( ) { if ( contentOutlinePage ! = null ) { tcontentOutlinePage . refresh ( ) ; 
public boolean equals ( Object a , Object b ) { if ( a = = b ) { treturn true ; } if ( ( a = = null & & b ! = null ) | | ( b = = null & & a ! = null ) ) { treturn false ; } if ( a instanceof AMapEntry & & b instanceof AMapEntry ) { treturn ( ( AMapEntry ) a ) . getKey ( ) . equals ( ( ( AMapEntry ) b ) . getKey ( ) ) ; 
public int hashCode ( Object element ) { if ( element = = null ) { treturn 0 ; } if ( element instanceof AMapEntry ) { treturn ( ( AMapEntry ) element ) . getKey ( ) . hashCode ( ) ; 
public void run ( ) { trefreshTreeViewer ( newInput ) ; } 
private void refreshTreeViewer ( Object newInput ) { tISelection sel = getTreeViewer ( ) . getSelection ( ) ; tTreePath [ ] expandedTreePaths = getTreeViewer ( ) . getExpandedTreePaths ( ) ; getTreeViewer ( ) . setInput ( newInput ) ; getTreeViewer ( ) . setExpandedTreePaths ( expandedTreePaths ) ; getTreeViewer ( ) . setSelection ( sel ) ; } 
protected boolean isImportant ( IWorkbenchPart part ) { treturn ( part instanceof IEditorPart | | part instanceof IConsoleView ) ; return true; 
public void modifyText ( ModifyEvent e ) { tupdateLaunchConfigurationDialog ( ) ; } 
private void loadPluginClojureCode ( ) throws Exception { tURL clientReplBundleUrl = ClojuredevPlugin . getDefault ( ) . getBundle ( ) . getResource ( " clojuredev/debug/clientrepl.clj " ) ; tURL clientReplFileUrl = FileLocator . toFileURL ( clientReplBundleUrl ) ; tString clientRepl = clientReplFileUrl . getFile ( ) ; tCompiler . loadFile ( clientRepl ) ; } 
public Object invokeLocal ( String localCode ) { ttry { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
public Object invokeStr ( String string ) { ttry { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
protected void initializeImageRegistry ( ImageRegistry reg ) { reg.put(PUBLIC_FUNCTION, ImageDescriptor.createFromURL(getBundle().getEntry("/icons/jdt/methpub_obj.gif"))); reg.put(PRIVATE_FUNCTION, ImageDescriptor.createFromURL(getBundle().getEntry("/icons/jdt/methpri_obj.gif"))); } 
public boolean equals ( Object a , Object b ) { if ( a = = b ) { treturn true ; } if ( ( a = = null & & b ! = null ) | | ( b = = null & & a ! = null ) ) { treturn false ; } if ( a instanceof Map & & b instanceof Map & & ( ( Map ) a ) . get ( KEYWORD_NAME ) ! = null & & ( ( Map ) b ) . get ( KEYWORD_NAME ) ! = null ) { 
public int hashCode ( Object element ) { if ( element = = null ) { treturn 0 ; } if ( element instanceof Map & & ( ( Map ) element ) . get ( KEYWORD_NAME ) ! = null ) { treturn ( ( Map ) element ) . get ( KEYWORD_NAME ) . hashCode ( ) ; 
public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { tthis . input = newInput ; } 
public boolean hasChildren ( Object parentElement ) { if ( Map . class . isInstance ( parentElement ) ) { return ( ( Map ) parentElement ) . get ( KEYWORD_CHILDREN ) ! = null ; 
public void update ( ViewerCell cell ) { cell . setText ( getText ( cell . getElement ( ) ) ) ; cell . setImage ( getImage ( cell . getElement ( ) ) ) ; 
public void modifyText ( ModifyEvent e ) { tpatternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . trim ( ) ) ) { if ( pattern ! = null ) { 
public void widgetSelected ( SelectionEvent e ) { tsearchInName = ( ( Button ) e . getSource ( ) ) . getSelection ( ) ; ttreeViewer . refresh ( false ) ; } 
public void widgetSelected ( SelectionEvent e ) { tsearchInDoc = ( ( Button ) e . getSource ( ) ) . getSelection ( ) ; ttreeViewer . refresh ( false ) ; } 
public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( patternString = = null | | patternString . trim ( ) . equals ( " " ) ) { treturn true ; } tMap parent = ( Map ) parentElement ; tMap elem = ( Map ) element ; if ( " var " . equals ( elem . get ( KEYWORD_TYPE ) ) ) { tString name = ( String ) elem . get ( KEYWORD_NAME ) ; 
private void refreshTreeViewer ( Object newInput ) { tISelection sel = treeViewer . getSelection ( ) ; tTreePath [ ] expandedTreePaths = treeViewer . getExpandedTreePaths ( ) ; ttreeViewer . setInput ( newInput ) ; ttreeViewer . setExpandedTreePaths ( expandedTreePaths ) ; ttreeViewer . setSelection ( sel ) ; } 
public void addSelectionChangedListener ( ISelectionChangedListener listener ) { selectionChangedListeners . add ( listener ) ; } 
protected void fireSelectionChanged ( ISelection selection ) { create an event final SelectionChangedEvent event = new SelectionChangedEvent(this, selection); fire the event Object[] listeners = selectionChangedListeners.getListeners(); for (int i = 0; i < listeners.length; ++i) { final ISelectionChangedListener l = (ISelectionChangedListener) listeners[i]; 
public void run ( ) { l . selectionChanged ( event ) ; } 
public void init ( IPageSite pageSite ) { super . init ( pageSite ) ; pageSite . setSelectionProvider ( this ) ; } 
public void removeSelectionChangedListener ( ISelectionChangedListener listener ) { selectionChangedListeners . remove ( listener ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { fireSelectionChanged ( event . getSelection ( ) ) ; } 
public String remoteLoad ( String remoteCode ) { treturn ( String ) invokeClojureVarWith ( remoteLoad , remoteCode ) ; } 
public Object remoteLoadRead ( String remoteCode ) { treturn invokeClojureVarWith ( remoteLoadRead , remoteCode ) ; } 
public String localLoad ( String localCode ) { treturn ( String ) invokeClojureVarWith ( localLoad , localCode ) ; } 
public Object localLoadRead ( String localCode ) { treturn invokeClojureVarWith ( localLoadRead , localCode ) ; } 
private Object invokeClojureVarWith ( Var varToInvoke , String code ) { ttry { Var . pushThreadBindings ( RT . map ( starPort , port ) ) ; 
public void run ( ) { tfinal String text = editor . getCurrentOrNextTopLevelSExpression ( ) ; if ( text = = null ) treturn ; IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; 
public void run ( ) { tMessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
 public void run ( ) { tMessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
public void run ( ) { tfinal String text = editor . getCurrentOrNextTopLevelSExpression ( ) ; if ( text = = null ) treturn ; tIOConsole console = ClojureClient . findActiveReplConsole ( ) ; if ( console = = null ) treturn ; tIOConsoleOutputStream os = null ; tIOConsoleInputStream is = console . getInputStream ( ) ; ttry { tos = console . newOutputStream ( ) ; 
public void run ( ) { tMessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
public static void asyncExec ( Runnable r ) { tPlatformUI . getWorkbench ( ) . getDisplay ( ) . asyncExec ( r ) ; } 
public static void safeClose ( Closeable toClose ) { if ( toClose ! = null ) { ttry { 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateRegionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_REGION ) ; tsetAction ( EvaluateRegionAction . ID , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , this ) ; tString id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; taction . setActionDefinitionId ( id ) ; tsetAction ( " ContentAssistProposal " , action ) ; tmarkAsStateDependentAction ( " ContentAssistProposal " , true ) ; } 
protected final void evaluateText ( final String text ) { if ( text = = null ) treturn ; tIOConsole console = ClojureClient . findActiveReplConsole ( ) ; if ( console = = null ) treturn ; tIOConsoleOutputStream os = null ; tIOConsoleInputStream is = console . getInputStream ( ) ; ttry { tos = console . newOutputStream ( ) ; 
public void run ( ) { tevaluateText ( editor . getCurrentOrNextTopLevelSExpression ( ) ) ; } 
public void doubleClick ( DoubleClickEvent event ) { tIStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) treturn ; tMap node = ( Map ) sel . getFirstElement ( ) ; if ( " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) { tString ns = ( String ) node . get ( KEYWORD_NS ) ; 
public void run ( ) { tMessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " source code " , " project name found: " + projectName ) ; 
public final IToken nextToken ( ) { tint nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = tokensData . size ( ) ) { treturn org . eclipse . jface . text . rules . Token . EOF ; } tcurrentTokenIndex = nextIndex ; tTokenData token = tokensData . get ( currentTokenIndex ) ; if ( token ! = null ) { if ( token . text . equals ( " ( " ) ) { 
private void setupClojureProjectClassPath ( ) throws CoreException { ClojureProject clojureProject = ClojureCore . getClojureProject ( project ) ; IJavaProject javaProject = clojureProject . getJavaProject ( ) ; if ( ! alreadyHasClojureLibOnClasspath ( javaProject ) ) { tint numOfEntriesToAdd = 0 ; 
public void doubleClick ( DoubleClickEvent event ) { tIStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) treturn ; tMap node = ( Map ) sel . getFirstElement ( ) ; tSystem . out . println ( node ) ; if ( " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) { tString ns = ( String ) node . get ( KEYWORD_NS ) ; 
protected boolean isImportant ( IWorkbenchPart part ) { treturn ; return true; 
public final IToken nextToken ( ) { tint nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = tokensData . size ( ) ) { treturn org . eclipse . jface . text . rules . Token . EOF ; } tcurrentTokenIndex = nextIndex ; tTokenData token = tokensData . get ( currentTokenIndex ) ; if ( token ! = null ) { tIToken result ; 
private void repositionCurrentTokenAtOffset ( int offset ) { tcurrentParenLevel = 0 ; tint size = tokensData . size ( ) ; tfor ( int i = 0 ; i < size ; i + + ) { tTokenData tokenInfo = tokensData . get ( i ) ; 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; 
public void stop ( BundleContext context ) throws Exception { tdisposeParenRainbowColors ( ) ; plugin = null ; super . stop ( context ) ; } 
private void initializeParenRainbowColors ( ) { allColors = new Color [ ] { new Color ( Display . getDefault ( ) , 0x00 , 0xCC , 0x00 ) , 
private void disposeParenRainbowColors ( ) { if ( allColors ! = null ) { tfor ( Color c : allColors ) { 
private static IToken newParenTokenWith ( Color color ) { treturn new org . eclipse . jface . text . rules . Token ( new TextAttribute ( color ) ) ; } 
public void doubleClick ( DoubleClickEvent event ) { tIStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) treturn ; tMap node = ( Map ) sel . getFirstElement ( ) ; if ( ! " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) treturn ; tString searchedNS = ( ( String ) node . get ( KEYWORD_NS ) ) ; tString searchedFileName = ( String ) node . get ( KEYWORD_FILE ) ; tint line = ( node . get ( KEYWORD_LINE ) = = null ) ? - 1 : Integer . valueOf ( ( String ) node . get ( KEYWORD_LINE ) ) ; ttry { tfinal String projectName = ( ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( ) ) . getProcess ( ) . getLaunch ( ) . getLaunchConfiguration ( ) . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , ( String ) null ) ; 
private void gotoEditorLine ( IEditorPart editor , int line ) { if ( ITextEditor . class . isInstance ( editor ) ) { tITextEditor textEditor = ( ITextEditor ) editor ; 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { ttry { tString projectName = ( ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( ) ) . getProcess ( ) . getLaunch ( ) . getLaunchConfiguration ( ) . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_PROJECT_NAME , ( String ) null ) ; 
public static void gotoEditorLine ( IEditorPart editor , int line ) { if ( ITextEditor . class . isInstance ( editor ) ) { tITextEditor textEditor = ( ITextEditor ) editor ; 
public void doubleClick ( DoubleClickEvent event ) { tIStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) treturn ; tMap node = ( Map ) sel . getFirstElement ( ) ; if ( ! " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) treturn ; tString searchedNS = ( ( String ) node . get ( KEYWORD_NS ) ) ; tString searchedFileName = ( String ) node . get ( KEYWORD_FILE ) ; tint line = ( node . get ( KEYWORD_LINE ) = = null ) ? - 1 : Integer . valueOf ( ( String ) node . get ( KEYWORD_LINE ) ) ; tSystem . out . println ( " trying to open file " + searchedNS + " " + searchedFileName + " " + line ) ; tClojureCore . openInEditor ( searchedNS , searchedFileName , line ) ; } 
public void run ( ) { tString selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . trim ( ) . equals ( " " ) ) { tselectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } tevaluateText ( selectedText ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , this ) ; tString id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; taction . setActionDefinitionId ( id ) ; tsetAction ( " ContentAssistProposal " , action ) ; tmarkAsStateDependentAction ( " ContentAssistProposal " , true ) ; } 
protected final void loadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString absoluteFilePath = editorFile . getLocation ( ) . toOSString ( ) ; tString text = " (load-file \" " + absoluteFilePath . replaceAll ( " \\ \\ " , " \\ \\ \\ \\ " ) . replaceAll ( " \" " , " \\ \\ \" " ) + " \" ) " ; tevaluateText ( text ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , " ContentAssistProposal. " , this ) ; tString id = ITextEditorActionDefinitionIds . CONTENT_ASSIST_PROPOSALS ; taction . setActionDefinitionId ( id ) ; tsetAction ( " ContentAssistProposal " , action ) ; tmarkAsStateDependentAction ( " ContentAssistProposal " , true ) ; } 
public void run ( ) { tString title = " File Compiler and loader " ; tString message = " The editor has pending changes. Clicking OK will save the changes and compile+load the file. " ; if ( ! canProceed ( editor , title , message ) ) treturn ; tcompileLoadFile ( ) ; } 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tString text = " (binding [*compile-path* \" classes \" ] (compile ' " + lib + " )) " ; tevaluateText ( text ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
protected boolean canProceed ( IEditorPart editor , String title , String message ) { if ( editor . isDirty ( ) ) { tboolean saveAndCompileLoad = MessageDialog . openConfirm ( editor . getSite ( ) . getShell ( ) , title , message ) ; 
public void run ( ) { tString title = " File Loader " ; tString message = " The editor has pending changes. Clicking OK will save the changes and load the file. " ; if ( ! canProceed ( editor , title , message ) ) treturn ; tloadFile ( ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { tclojureFiles . add ( file ) ; } } treturn true ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . toString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; super . launch ( configuration , mode , launch , monitor ) ; } 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . trim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } try { serverPort . setText ( Integer . toString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; } catch ( CoreException e ) { tClojuredevPlugin . logError ( " error while initializing serverPort " , e ) ; tserverPort . setText ( " " ) ; } try { tsourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . valueOf ( serverPort . getText ( ) ) ) ; mapResources ( config ) ; } 
public void createTabs ( ILaunchConfigurationDialog dialog , String mode ) { ILaunchConfigurationTab [ ] tabs = new ILaunchConfigurationTab [ ] { new JavaMainTab(), new ClojureMainTab(), new JavaArgumentsTab(), new JavaJRETab(), new JavaClasspathTab(), new SourceLookupTab(), new EnvironmentTab(), new CommonTab() }; setTabs(tabs); } 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { ttry { torg . eclipse . debug . ui . console . IConsole console = ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( ) ; 
public void activated ( ) { if ( clojureClient ! = null ) { tContentOutline . setClojureClient ( clojureClient ) ; } tSystem . out . println ( " activated " ) ; } 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { tContentOutline . setClojureClient ( clojureClient ) ; 
public void init ( IViewSite site ) throws PartInitException { tsuper . init ( site ) ; tsite . setSelectionProvider ( this ) ; } 
public boolean equals ( Object a , Object b ) { if ( a = = b ) { treturn true ; } if ( ( a = = null & & b ! = null ) | | ( b = = null & & a ! = null ) ) { treturn false ; } if ( a instanceof Map & & b instanceof Map & & ( ( Map ) a ) . get ( KEYWORD_NAME ) ! = null & & ( ( Map ) b ) . get ( KEYWORD_NAME ) ! = null ) { 
public int hashCode ( Object element ) { if ( element = = null ) { treturn 0 ; } if ( element instanceof Map & & ( ( Map ) element ) . get ( KEYWORD_NAME ) ! = null ) { treturn ( ( Map ) element ) . get ( KEYWORD_NAME ) . hashCode ( ) ; 
public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( patternString = = null | | patternString . trim ( ) . equals ( " " ) ) { treturn true ; } tMap parent = ( Map ) parentElement ; tMap elem = ( Map ) element ; if ( " var " . equals ( elem . get ( KEYWORD_TYPE ) ) ) { tString name = ( String ) elem . get ( KEYWORD_NAME ) ; 
public void doubleClick ( DoubleClickEvent event ) { tIStructuredSelection sel = ( IStructuredSelection ) event . getSelection ( ) ; if ( sel . size ( ) = = 0 ) treturn ; tMap node = ( Map ) sel . getFirstElement ( ) ; if ( ! " var " . equals ( node . get ( KEYWORD_TYPE ) ) ) treturn ; tString searchedNS = ( ( String ) node . get ( KEYWORD_NS ) ) ; tString searchedFileName = ( String ) node . get ( KEYWORD_FILE ) ; tint line = ( node . get ( KEYWORD_LINE ) = = null ) ? - 1 : Integer . valueOf ( ( String ) node . get ( KEYWORD_LINE ) ) ; tClojureCore . openInEditor ( searchedNS , searchedFileName , line ) ; } 
public boolean hasChildren ( Object parentElement ) { if ( Map . class . isInstance ( parentElement ) ) { treturn ( ( Map ) parentElement ) . get ( KEYWORD_CHILDREN ) ! = null ; 
public void update ( ViewerCell cell ) { tcell . setText ( getText ( cell . getElement ( ) ) ) ; tcell . setImage ( getImage ( cell . getElement ( ) ) ) ; 
public boolean belongsTo ( Object family ) { treturn NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } 
public void run ( ) { tSystem . out . println ( " delayed refresh start " ) ; ttreeViewer . refresh ( updateLabels ) ; tSystem . out . println ( " delayed refresh stop " ) ; } 
private void inUIResetInput ( Object newInput ) { tSystem . out . println ( " refresh start " ) ; tISelection sel = treeViewer . getSelection ( ) ; tTreePath [ ] expandedTreePaths = treeViewer . getExpandedTreePaths ( ) ; ttreeViewer . setInput ( newInput ) ; ttreeViewer . setExpandedTreePaths ( expandedTreePaths ) ; ttreeViewer . setSelection ( sel ) ; tSystem . out . println ( " refresh stop " ) ; } 
public void addSelectionChangedListener ( ISelectionChangedListener listener ) { tselectionChangedListeners . add ( listener ) ; } 
protected void fireSelectionChanged ( ISelection selection ) { final ISelectionChangedListener l = (ISelectionChangedListener) listeners[i]; 
public void removeSelectionChangedListener ( ISelectionChangedListener listener ) { tselectionChangedListeners . remove ( listener ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { tfireSelectionChanged ( event . getSelection ( ) ) ; } 
public void addLaunch ( ILaunch launch ) { if ( ! launch . isTerminated ( ) ) { tlaunches . add ( launch ) ; 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { tSystem . out . println ( " full build required! " ) ; fullBuild(monitor); Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { tclojureFiles . add ( file ) ; tSystem . out . println ( " found clojure file: " + file ) ; tIPath maybeLibPath = file . getFullPath ( ) . removeFirstSegments ( currentSrcFolder . getFullPath ( ) . segmentCount ( ) ) . removeFileExtension ( ) ; tString maybeLibName = maybeLibPath . toString ( ) . replace ( '/' , '.' ) ; tclojureLibs . add ( maybeLibName ) ; tSystem . out . println ( " found clojure maybe lib: " + maybeLibName ) ; tfile . touch ( null ) ; } } treturn true ; } 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tevaluateText ( compileLibCommand ( lib ) ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static String compileLibCommand ( String libName ) { treturn " (binding [*compile-path* \" classes \" ] (compile ' " + libName + " )) " ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . toString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; super . launch ( configuration , mode , launch , monitor ) ; if ( ! launch . isTerminated ( ) ) { tClojuredevPlugin . getDefault ( ) . addLaunch ( launch ) ; 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; startLaunchListener ( ) ; } 
public void stop ( BundleContext context ) throws Exception { tdisposeParenRainbowColors ( ) ; tstopLaunchListener ( ) ; plugin = null ; super . stop ( context ) ; } 
private void updateLaunchList ( ILaunch launch ) { if ( findClojurePort ( launch ) ! = - 1 ) { tlaunches . add ( launch ) ; 
private int findClojurePort ( ILaunch launch ) { tString portAttr = launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN ) ; if ( portAttr ! = null ) { treturn Integer . valueOf ( portAttr ) ; 
private void startLaunchListener ( ) { tstopLaunchListener ( ) ; tDebugPlugin . getDefault ( ) . getLaunchManager ( ) . addLaunchListener ( launchListener ) ; } 
private void stopLaunchListener ( ) { tDebugPlugin . getDefault ( ) . getLaunchManager ( ) . removeLaunchListener ( launchListener ) ; tlaunches . clear ( ) ; } 
public void resourceChanged ( IResourceChangeEvent event ) { } public boolean isClassesFolderChange ( ) { treturn false ; } } } 
public void activated ( ) { if ( clojureClient ! = null ) { tNamespaceBrowser . setClojureClient ( clojureClient ) ; } tSystem . out . println ( " activated " ) ; } 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { tNamespaceBrowser . setClojureClient ( clojureClient ) ; 
public String remoteLoad ( String remoteCode ) { treturn invokeClojureVarWith ( remoteLoad , remoteCode ) . toString ( ) ; } 
public String localLoad ( String localCode ) { treturn invokeClojureVarWith ( localLoad , localCode ) . toString ( ) ; } 
public void connect ( IDocument document , boolean delayInitialization ) { super . connect ( document , delayInitialization ) ; printPartitions(document); 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . toString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; super . launch ( configuration , mode , launch , monitor ) ; } 
private void inUIResetInput ( Object newInput ) { tISelection sel = treeViewer . getSelection ( ) ; tTreePath [ ] expandedTreePaths = treeViewer . getExpandedTreePaths ( ) ; ttreeViewer . setInput ( newInput ) ; ttreeViewer . setExpandedTreePaths ( expandedTreePaths ) ; ttreeViewer . setSelection ( sel ) ; } 
public String remoteLoad ( String remoteCode ) { tObject result = invokeClojureVarWith ( remoteLoad , remoteCode ) ; treturn ( result = = null ) ? null : result . toString ( ) ; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { tSystem . out . println ( " full build required! " ) ; tfullBuild ( monitor ) ; Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
protected IProject [ ] build ( int kind , Map args , IProgressMonitor monitor ) throws CoreException { if ( onlyClassesFolderRelatedDelta ( ) ) { treturn null ; } tfullBuild ( monitor ) ; Commented out to not break svn if(kind == FULL_BUILD){ fullBuild(monitor); } else { IResourceDelta delta = getDelta(getProject()); if(delta == null){ fullBuild(monitor); } else { fullBuild(monitor); incrementalBuild(delta, monitor); } } return null; } 
private static boolean tryNonJavaResources ( Object [ ] nonJavaResources , String searchedFileName , int line ) throws PartInitException { tfor ( Object nonJavaResource : nonJavaResources ) { tString nonJavaResourceName = null ; if ( IFile . class . isInstance ( nonJavaResource ) ) { tnonJavaResourceName = ( ( IFile ) nonJavaResource ) . getName ( ) ; } else if ( IJarEntryResource . class . isInstance ( nonJavaResource ) ) { tnonJavaResourceName = ( ( IJarEntryResource ) nonJavaResource ) . getName ( ) ; } tSystem . out . println ( " nje' " + searchedFileName + " ' ' " + nonJavaResourceName + " ' " ) ; if ( searchedFileName . equals ( nonJavaResourceName ) ) { tIEditorPart editor = EditorUtility . openInEditor ( nonJavaResource ) ; tgotoEditorLine ( editor , line ) ; treturn true ; } } treturn false ; } 
private static boolean tryNonJavaResources ( Object [ ] nonJavaResources , String searchedFileName , int line ) throws PartInitException { tfor ( Object nonJavaResource : nonJavaResources ) { tString nonJavaResourceName = null ; if ( IFile . class . isInstance ( nonJavaResource ) ) { tnonJavaResourceName = ( ( IFile ) nonJavaResource ) . getName ( ) ; } else if ( IJarEntryResource . class . isInstance ( nonJavaResource ) ) { tnonJavaResourceName = ( ( IJarEntryResource ) nonJavaResource ) . getName ( ) ; } if ( searchedFileName . equals ( nonJavaResourceName ) ) { tIEditorPart editor = EditorUtility . openInEditor ( nonJavaResource ) ; tgotoEditorLine ( editor , line ) ; treturn true ; } } treturn false ; } 
protected void fullBuild ( IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = ClojuredevPlugin . getDefault ( ) . getProjectClojureClient ( getProject ( ) ) ; if ( clojureClient = = null ) { treturn ; } deleteMarkers ( ) ; ArrayList < IFolder > srcFolders = getSrcFolders ( ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( srcFolders ) ; getClassesFolder ( ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public void visit ( ArrayList < IFolder > srcFolders ) throws CoreException { for ( IFolder srcFolder : srcFolders ) { tsetSrcFolder ( srcFolder ) ; 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { tclojureFiles . add ( file ) ; tfile . touch ( null ) ; tIPath maybeLibPath = file . getFullPath ( ) . removeFirstSegments ( currentSrcFolder . getFullPath ( ) . segmentCount ( ) ) . removeFileExtension ( ) ; tString maybeLibName = maybeLibPath . toString ( ) . replace ( '/' , '.' ) ; tclojureLibs . add ( maybeLibName ) ; if ( clojureClient ! = null ) { tMap result = ( Map ) clojureClient . remoteLoadRead ( CompileLibAction . compileLibCommand ( maybeLibName ) ) ; tSystem . out . println ( " compile result: " + result ) ; if ( result ! = null ) { } 
private void createMarker ( final String filename , final int line , final String message ) { ttry { tSystem . out . println ( " (trying to) create a marker for " + filename ) ; 
protected void fullBuild ( IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = ClojuredevPlugin . getDefault ( ) . getProjectClojureClient ( getProject ( ) ) ; if ( clojureClient = = null ) { treturn ; } deleteMarkers ( ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( ) ) ; getClassesFolder ( ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public void visit ( Map < IFolder , IFolder > srcFolders ) throws CoreException { for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { tsetSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( this ) ; } if ( clojureClient ! = null ) { tfor ( String maybeLib 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
private void createParentIfNecessary ( IContainer folder ) throws CoreException { if ( folder . exists ( ) | | folder . getType ( ) = = IFolder . PROJECT ) treturn ; tcreateParentIfNecessary ( folder . getParent ( ) ) ; ( ( IFolder ) folder ) . create ( true , true , null ) ; } 
public boolean test ( Object receiver , String property , Object [ ] args , Object expectedValue ) { assert IProject . class . isInstance ( receiver ) ; assert " hasClojureNature " . equals ( property ) ; IProject project = ( IProject ) receiver ; try { return project . hasNature ( ClojureProjectNature . NATURE_ID ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
private List < String > parse ( String text ) { tClojureLexer lex = new ClojureLexer ( new ANTLRStringStream ( text ) ) ; tCommonTokenStream tokens = new CommonTokenStream ( lex ) ; tClojureParser parser = new ClojureParser ( tokens ) ; try { tSystem . out . println ( " begin parse " ) ; 
private boolean invalidSymbolCharacter ( char c ) { if ( Character . isWhitespace ( c ) ) treturn true ; tchar [ ] invalidChars = { '(' , ')' , '[' , ']' , '{' , '}' , '\'' , '@' , '~' , '^' , '`' , '#' , '"' } ; tfor ( int i = 0 ; i < invalidChars . length ; i + + ) { if ( invalidChars [ i ] = = c ) treturn true ; } treturn false ; } 
private List < List > dynamicComplete ( String namespace , String prefix ) { if ( namespace = = null | | prefix = = null ) treturn Collections . emptyList ( ) ; tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) treturn Collections . emptyList ( ) ; tMap result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" ) " ) ; if ( result = = null ) treturn Collections . emptyList ( ) ; if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicComplete ( String namespace , String prefix ) { if ( namespace = = null ) { terrorMessage = ERROR_MESSAGE_NO_NAMESPACE_FOUND ; treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { terrorMessage = ERROR_MESSAGE_NULL_PREFIX ; treturn Collections . emptyList ( ) ; } tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { terrorMessage = ERROR_MESSAGE_NO_REPL_FOUND ; treturn Collections . emptyList ( ) ; } tMap result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" ) " ) ; if ( result = = null ) { terrorMessage = null ; treturn Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public IInformationControl createInformationControl ( Shell parent ) { tDefaultInformationControl ret = new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; Display display = parent . getDisplay ( ) ; tret . setBackgroundColor ( display . getSystemColor ( SWT . COLOR_DARK_BLUE ) ) ; tret . setForegroundColor ( display . getSystemColor ( SWT . COLOR_WHITE ) ) ; treturn ret ; } 
private List < List > dynamicComplete ( String namespace , String prefix , boolean findOnlyPublic ) { if ( namespace = = null ) { terrorMessage = ERROR_MESSAGE_NO_NAMESPACE_FOUND ; treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { terrorMessage = ERROR_MESSAGE_NULL_PREFIX ; treturn Collections . emptyList ( ) ; } tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { terrorMessage = ERROR_MESSAGE_NO_REPL_FOUND ; treturn Collections . emptyList ( ) ; } tMap result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) ; if ( result = = null ) { terrorMessage = null ; treturn Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public IInformationControl createInformationControl ( Shell parent ) { treturn new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; } 
public final void mNAME ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:89:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:93:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:99:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public STAttrMap put ( String attrName , Object value ) { super . put ( attrName , value ) ; return this ; } 
public STAttrMap put ( String attrName , int value ) { super . put ( attrName , new Integer ( value ) ) ; return this ; } 
public final file_return file ( ) throws RecognitionException { file_return retval = new file_return ( ) ; retval . start = input . LT ( 1 ) ; try { break loop1; } } while (true); } retval.stop = input.LT(-1); } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return retval; } 
public static void main ( String [ ] args ) throws Exception { System.out.println("begin parse"); 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { terrorMessage = " " ; tassistant . setStatusMessage ( " " ) ; ttry { if ( ! computePrefix ( viewer , offset ) ) { 
public void beginReporting ( ) { tsuper . beginReporting ( ) ; tSystem . out . println ( " begin reporting " ) ; tcounter = 0 ; } 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { tcounter + + ; (IMethod) match.getElement(), 
public void endReporting ( ) { tsuper . endReporting ( ) ; tSystem . out . println ( " end reporting : count= " + counter ) ; } 
public void apply ( IDocument document ) { tgetCompletionProposal ( ) . apply ( document ) ; } 
private List < List > dynamicComplete ( String namespace , String prefix , boolean findOnlyPublic ) { if ( namespace = = null ) { if (result.get("response") == null) { 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . toArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
public void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; 
private Composite createComposite ( Composite parent , int numColumns ) { noDefaultAndApplyButton ( ) ; Composite composite = new Composite ( parent , SWT . NULL ) ; GridLayout GridLayout layout = new GridLayout(); layout.numColumns = numColumns; composite.setLayout(layout); GridData GridData data = new GridData(GridData.FILL); data.horizontalIndent = 0; data.verticalAlignment = GridData.FILL; data.horizontalAlignment = GridData.FILL; composite.setLayoutData(data); return composite; } 
protected Control createContents ( Composite parent ) { Composite composite = createScrolledComposite ( parent ) ; String description = Messages . ClojurePreferencePage_description ; Text text = new Text ( composite , SWT . READ_ONLY ) ; some themes on GTK have different background colors for Text and Labels text.setBackground(composite.getBackground()); text.setText(description); setSize(composite); return composite; } 
private Composite createScrolledComposite ( Composite parent ) { create scrollbars for this parent when needed final ScrolledComposite sc1 = new ScrolledComposite(parent, SWT.H_SCROLL | SWT.V_SCROLL); sc1.setLayoutData(new GridData(GridData.FILL_BOTH)); Composite composite = createComposite(sc1, 1); sc1.setContent(composite); not calling setSize for composite will result in a blank composite, so calling it here initially setSize actually needs to be called after all controls are created, so scrolledComposite has correct minSize setSize(composite); return composite; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; } 
public static int findClojurePort ( ILaunch launch ) { tString portAttr = launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN ) ; if ( portAttr ! = null ) { treturn Integer . valueOf ( portAttr ) ; 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public static final void evaluateText ( final String text ) { tevaluateText ( ClojureClient . findActiveReplConsole ( ) , text ) ; } 
public static final void evaluateText ( IOConsole console , final String text ) { tevaluateText ( console , text , true ) ; } 
public static final void evaluateText ( IOConsole console , final String text , boolean verboseMode ) { if ( text = = null ) treturn ; if ( console = = null ) treturn ; tIOConsoleOutputStream os = null ; tIOConsoleInputStream is = console . getInputStream ( ) ; ttry { if ( verboseMode ) { 
public void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_swith_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; } 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration ) ; } 
private void setupClojureProjectClassPath ( ) throws CoreException { addClassesDirectory(javaProject); 
private void addClojureLibOnClasspath ( IJavaProject javaProject ) throws CoreException { taddLibOnClasspath ( javaProject , getDefaultClojureLib ( ) ) ; } 
private void addLibOnClasspath ( IJavaProject javaProject , File lib ) throws CoreException { if ( lib = = null ) tthrow new CoreException ( Status . CANCEL_STATUS ) ; taddLibOnClasspath ( javaProject , Path . fromOSString ( lib . getAbsolutePath ( ) ) ) ; } 
private void addClojureContribLibOnClasspath ( IJavaProject javaProject ) throws CoreException { taddLibOnClasspath ( javaProject , getDefaultClojureContribLib ( ) ) ; } 
private void addClassesDirectory ( IJavaProject javaProject ) throws CoreException { IFolder classesFolder = javaProject . getProject ( ) . getFolder ( " classes " ) ; if ( ! classesFolder . exists ( ) ) { tclassesFolder . create ( true , true , null ) ; } addLibOnClasspath ( javaProject , classesFolder . getFullPath ( ) ) ; } 
private boolean alreadyHasClojureLibOnClasspath ( IJavaProject javaProject ) throws JavaModelException { treturn javaProject . findElement ( new Path ( " clojure/lang " ) ) ! = null ; } 
private boolean alreadyHasClojureContribLibOnClasspath ( IJavaProject javaProject ) throws JavaModelException { treturn javaProject . findElement ( new Path ( " clojure/contrib " ) ) ! = null ; } 
private boolean alreadyHasClassesDirectory ( IJavaProject javaProject ) throws JavaModelException { treturn javaProject . findPackageFragmentRoot ( javaProject . getProject ( ) . getFolder ( " classes " ) . getFullPath ( ) ) ! = null ; } 
public void createPartControl ( Composite theParent ) { tcontrol = new Composite ( theParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; tgl . numColumns = 4 ; tcontrol . setLayout ( gl ) ; tLabel l = new Label ( control , SWT . NONE ) ; tl . setText ( " Find : " ) ; tl . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; tGridData gd = new GridData ( ) ; tgd . verticalAlignment = SWT . CENTER ; tl . setLayoutData ( gd ) ; tfilterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; tfilterText . setTextLimit ( 10 ) ; tfilterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; tgd = new GridData ( ) ; tgd . horizontalAlignment = SWT . FILL ; tgd . verticalAlignment = SWT . CENTER ; tfilterText . setLayoutData ( gd ) ; tfilterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { tpatternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . trim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; startLaunchListener ( ) ; } 
private void createColorRegistry ( ) { if ( colorRegistry = = null ) { tcolorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; 
public void stop ( BundleContext context ) throws Exception { tdisposeParenRainbowColors ( ) ; tstopLaunchListener ( ) ; corresponding method on the ColorRegistry instance! plugin = null; super.stop(context); } 
public static Object loadString ( String localCode ) { treturn invokeLocalClojureVarWith ( loadString , localCode ) ; } 
private static Object invokeLocalClojureVarWith ( Var varToInvoke , String code ) { ttry { return varToInvoke . invoke ( code ) ; 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { tRGB literal = new RGB ( 188 , 143 , 143 ) ; tRGB black = new RGB ( 0 , 0 , 0 ) ; tRGB gray = new RGB ( 128 , 128 , 128 ) ; tRGB greeen = new RGB ( 34 , 139 , 34 ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . STRING , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . NUMBER , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . CHARACTER , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . NIL , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . BOOLEAN , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . OPEN_PAREN , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . CLOSE_PAREN , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SPECIAL_FORM , new RGB ( 160 , 32 , 240 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SYMBOL , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . FUNCTION , new RGB ( 218 , 112 , 214 ) ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . GLOBAL_VAR , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . MACRO , new RGB ( 160 , 32 , 240 ) ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . SPECIAL_FORM , new RGB ( 160 , 32 , 240 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . KEYWORD , new RGB ( 218 , 112 , 214 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SYNTAX_QUOTE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE_SPLICING , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . COMMENT , new RGB ( 178 , 34 , 34 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SPACE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . LAMBDA_ARG , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . METADATA_TYPEHINT , greeen ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . T24 , black ) ; } 
public AntlrBasedTokenScanner create ( final ColorRegistry colorProvider , IScanContext scanContext ) { treturn new AntlrBasedTokenScanner ( new ClojureLexer ( ) , scanContext ) { @Override 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorProvider ) ; tu . addTokenType ( ClojureLexer . STRING ) ; tu . addTokenType ( ClojureLexer . NUMBER ) ; tu . addTokenType ( ClojureLexer . CHARACTER ) ; tu . addTokenType ( ClojureLexer . NIL ) ; tu . addTokenType ( ClojureLexer . BOOLEAN ) ; tu . addTokenType ( ClojureLexer . SYMBOL ) ; tu . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; tu . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; tu . addTokenType ( IScanContext . SymbolType . MACRO ) ; tu . addTokenType ( IScanContext . SymbolType . SPECIAL_FORM ) ; tu . addTokenType ( ClojureLexer . SPECIAL_FORM ) ; tu . addTokenType ( ClojureLexer . METADATA_TYPEHINT ) ; } 
public final void mT32 ( ) throws RecognitionException { try { int _type = T32 ; 
public final void mMETADATA_TYPEHINT ( ) throws RecognitionException { try { int _type = METADATA_TYPEHINT ; 
public final void mNAME ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:85:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:89:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:95:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | '#' ) 
public void mTokens ( ) throws RecognitionException { o:/clojure/basic-clojure-grammar/src/Clojure.g:1:8: ( T24 | T25 | T26 | T27 | T28 | T29 | T30 | T31 | T32 | OPEN_PAREN | CLOSE_PAREN | SPECIAL_FORM | STRING | NUMBER | CHARACTER | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt23=26; alt23 = dfa23.predict(input); switch (alt23) { case 1 : 
public final void literal ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:102:8: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) o:/clojure/basic-clojure-grammar/src/Clojure.g: { if ( (input.LA(1)>=STRING && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:162:10: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case 29: { alt5=1; } break; case 30: { alt5=2; } break; case 31: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("162:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:163:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1035); quoteForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:164:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1045); metaForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:165:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1055); derefForm(); _fsp--; } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:166:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1065); syntaxQuoteForm(); _fsp--; } break; case 5 : o:/clojure/basic-clojure-grammar/src/Clojure.g:167:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1075); unquoteSplicingForm(); _fsp--; } break; case 6 : o:/clojure/basic-clojure-grammar/src/Clojure.g:168:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1085); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:171:18: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==32) ) { switch ( input.LA(2) ) { case STRING: { alt6=1; } break; case 29: { alt6=2; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("171:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("171:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:172:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1112); regexForm(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:173:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1122); varQuoteForm(); _fsp--; } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:174:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1134); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1163); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,26,FOLLOW_26_in_vector1186); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,28,FOLLOW_28_in_map1214); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:189:5: ( '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:189:8: '\\'' form { match(input,29,FOLLOW_29_in_quoteForm1247); pushFollow(FOLLOW_form_in_quoteForm1249); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:192:9: ( '^' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:192:13: '^' form { match(input,30,FOLLOW_30_in_metaForm1263); pushFollow(FOLLOW_form_in_metaForm1265); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:195:10: ( '@' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:195:13: '@' form { match(input,31,FOLLOW_31_in_derefForm1282); pushFollow(FOLLOW_form_in_derefForm1284); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:201:5: ( SYNTAX_QUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:202:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1324); pushFollow(FOLLOW_form_in_syntaxQuoteForm1326); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:208:5: ( UNQUOTE form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:209:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1366); pushFollow(FOLLOW_form_in_unquoteForm1368); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:215:5: ( UNQUOTE_SPLICING form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:216:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1408); pushFollow(FOLLOW_form_in_unquoteSplicingForm1410); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,28,FOLLOW_28_in_set1436); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:222:10: ( '#' STRING ) o:/clojure/basic-clojure-grammar/src/Clojure.g:222:13: '#' STRING { match(input,32,FOLLOW_32_in_regexForm1449); match(input,STRING,FOLLOW_STRING_in_regexForm1451); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:225:13: ( '#' '^' ( map | SYMBOL | KEYWORD | STRING ) ) o:/clojure/basic-clojure-grammar/src/Clojure.g:226:9: '#' '^' ( map | SYMBOL | KEYWORD | STRING ) { match(input,32,FOLLOW_32_in_metadataForm1475); match(input,30,FOLLOW_30_in_metadataForm1477); o:/clojure/basic-clojure-grammar/src/Clojure.g:226:17: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case 27: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("226:17: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:18: map { pushFollow(FOLLOW_map_in_metadataForm1480); map(); _fsp--; } break; case 2 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:24: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1484); } break; case 3 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:31: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1486); } break; case 4 : o:/clojure/basic-clojure-grammar/src/Clojure.g:226:39: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1488); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { o:/clojure/basic-clojure-grammar/src/Clojure.g:229:13: ( '#' '\\'' form ) o:/clojure/basic-clojure-grammar/src/Clojure.g:230:9: '#' '\\'' form { match(input,32,FOLLOW_32_in_varQuoteForm1509); match(input,29,FOLLOW_29_in_varQuoteForm1511); pushFollow(FOLLOW_form_in_varQuoteForm1513); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { o:/clojure/basic-clojure-grammar/src/Clojure.g:240:5: ( '#' list ) o:/clojure/basic-clojure-grammar/src/Clojure.g:240:7: '#' list { match(input,32,FOLLOW_32_in_lambdaForm1540); pushFollow(FOLLOW_list_in_lambdaForm1542); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void addTokenType ( Object tokenIndex , org . eclipse . jface . text . rules . Token token ) { if ( initialized ) throw lifeCycleError ( ) ; tantlrTokenTypeToJFaceToken . put ( tokenIndex , token ) ; } 
public final void addTokenType ( Object tokenIndex , TextAttribute textAttribute ) { if ( initialized ) throw lifeCycleError ( ) ; taddTokenType ( tokenIndex , new org . eclipse . jface . text . rules . Token ( textAttribute ) ) ; } 
private IToken guessEclipseTokenForSymbol ( CommonToken symbolToken ) { tString symbol = symbolToken . getText ( ) ; tIScanContext . SymbolType symbolType = context . getSymbolType ( symbol ) ; if ( symbolType = = null ) { treturn null ; 
public void addTokenType ( Object tokenIndex , String colorKey ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . get ( colorKey ) ) ) ; } 
public void addTokenType ( Object tokenIndex ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . get ( AntlrBasedClojureEditor . ID + " _ " + tokenIndex ) ) ) ; } 
public void addBoldToken ( Object tokenIndex , String colorKey ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . get ( colorKey ) , null , SWT . BOLD ) ) ; } 
public void addBoldToken ( Object tokenIndex ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( tcolorProvider . get ( AntlrBasedClojureEditor . ID + " _ " + tokenIndex ) , null , SWT . BOLD ) ) ; 
public void addItalicToken ( Object tokenIndex , String colorKey ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . get ( colorKey ) , null , SWT . ITALIC ) ) ; } 
public void addItalicToken ( Object tokenIndex ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( tcolorProvider . get ( AntlrBasedClojureEditor . ID + " _ " + tokenIndex ) , null , SWT . ITALIC ) ) ; 
public static String compileLibCommand ( String libName ) { treturn " (clojure.core/binding [clojure.core/*compile-path* \" classes \" ] (clojure.core/compile ' " + libName + " )) " ; } 
protected final void loadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString absoluteFilePath = editorFile . getLocation ( ) . toOSString ( ) ; tString text = " (clojure.core/load-file \" " + absoluteFilePath . replaceAll ( " \\ \\ " , " \\ \\ \\ \\ " ) . replaceAll ( " \" " , " \\ \\ \" " ) + " \" ) " ; tevaluateText ( text ) ; } 
private boolean isJavaIdentifier ( String s ) { tassert s ! = null & & s . length ( ) > 0 ; if ( ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { treturn false ; } tfor ( int i = 1 ; i < s . length ( ) ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { treturn false ; } } treturn true ; } 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { tRGB literal = new RGB ( 188 , 143 , 143 ) ; tRGB black = new RGB ( 0 , 0 , 0 ) ; tRGB gray = new RGB ( 128 , 128 , 128 ) ; tRGB green = new RGB ( 34 , 139 , 34 ) ; tRGB specialForm = new RGB ( 160 , 32 , 240 ) ; tRGB function = new RGB ( 218 , 112 , 214 ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . STRING , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . NUMBER , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . CHARACTER , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . NIL , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . BOOLEAN , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . OPEN_PAREN , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . CLOSE_PAREN , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SPECIAL_FORM , specialForm ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SYMBOL , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . FUNCTION , function ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . GLOBAL_VAR , green ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . MACRO , specialForm ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . SPECIAL_FORM , specialForm ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_CLASS , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_STATIC_METHOD , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_INSTANCE_METHOD , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . KEYWORD , new RGB ( 218 , 112 , 214 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SYNTAX_QUOTE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE_SPLICING , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . COMMENT , new RGB ( 178 , 34 , 34 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SPACE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . LAMBDA_ARG , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . METADATA_TYPEHINT , green ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . T24 , black ) ; } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorProvider ) ; tu . addTokenType ( ClojureLexer . STRING ) ; tu . addTokenType ( ClojureLexer . NUMBER ) ; tu . addTokenType ( ClojureLexer . CHARACTER ) ; tu . addTokenType ( ClojureLexer . NIL ) ; tu . addTokenType ( ClojureLexer . BOOLEAN ) ; tu . addTokenType ( ClojureLexer . SYMBOL ) ; tu . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; tu . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; tu . addTokenType ( IScanContext . SymbolType . MACRO ) ; } 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { tcounter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { tSystem . out . println ( " too much results (> " + MAX_JAVA_SEARCH_RESULT_NUMBER + " ), throwing exception " ) ; tthrow new CoreException ( Status . OK_STATUS ) ; } tproposals . add ( new LazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { treturn " -D " + " clojure.remote.server.port " + " = " + Integer . toString ( configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) + " " + super . getVMArguments ( configuration ) ; 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; tRGB literal = new RGB ( 188 , 143 , 143 ) ; tRGB black = new RGB ( 0 , 0 , 0 ) ; tRGB gray = new RGB ( 128 , 128 , 128 ) ; tRGB green = new RGB ( 34 , 139 , 34 ) ; tRGB specialForm = new RGB ( 160 , 32 , 240 ) ; tRGB function = PreferenceConverter . getColor ( store , clojuredev . preferences . PreferenceConstants . EDITOR_FUNCTION_COLOR ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . STRING , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . NUMBER , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . CHARACTER , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . NIL , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . BOOLEAN , literal ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . OPEN_PAREN , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . CLOSE_PAREN , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SPECIAL_FORM , specialForm ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SYMBOL , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . FUNCTION , function ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . GLOBAL_VAR , green ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . MACRO , specialForm ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . SPECIAL_FORM , specialForm ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_CLASS , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_STATIC_METHOD , black ) ; tcolorRegistry . put ( ID + " _ " + IScanContext . SymbolType . JAVA_INSTANCE_METHOD , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . KEYWORD , new RGB ( 218 , 112 , 214 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SYNTAX_QUOTE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE_SPLICING , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . UNQUOTE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . COMMENT , new RGB ( 178 , 34 , 34 ) ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . SPACE , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . LAMBDA_ARG , black ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . METADATA_TYPEHINT , green ) ; tcolorRegistry . put ( ID + " _ " + ClojureLexer . T24 , black ) ; } 
public void dispose ( Display display ) { Map < RGB , Color > colorTable = fDisplayTable . get ( display ) ; if ( colorTable ! = null ) { Iterator < Color > e = colorTable . values ( ) . iterator ( ) ; 
public void run ( ) { dispose ( display ) ; } 
public void dispose ( ) { if ( ! fAutoDisposeOnDisplayDispose ) dispose ( Display . getCurrent ( ) ) ; 
public void bindColor ( String key , RGB rgb ) { Object value = fKeyTable . get ( key ) ; if ( value ! = null ) throw new UnsupportedOperationException ( ) ; fKeyTable . put ( key , rgb ) ; } 
public void createFieldEditors ( ) { addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_FUNCTION_COLOR , StringConverter . asString ( new RGB ( 218 , 112 , 214 ) ) ) ; 
public Control createContents ( Composite parent ) { initializeDialogUnits ( parent ) ; ScrolledPageContent scrolled = new ScrolledPageContent ( parent , SWT . H_SCROLL | SWT . V_SCROLL ) ; scrolled . setExpandHorizontal ( true ) ; scrolled . setExpandVertical ( true ) ; Control control = createSyntaxPage ( scrolled ) ; scrolled . setContent ( control ) ; final Point size = control . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ; scrolled . setMinSize ( size . x , size . y ) ; return scrolled ; } 
protected int convertWidthInCharsToPixels ( int chars ) { test for failure to initialize for backward compatibility if (fFontMetrics == null) return 0; return Dialog.convertWidthInCharsToPixels(fFontMetrics, chars); } 
protected int convertHeightInCharsToPixels ( int chars ) { test for failure to initialize for backward compatibility if (fFontMetrics == null) return 0; return Dialog.convertHeightInCharsToPixels(fFontMetrics, chars); } 
public void performDefaults ( ) { super . performDefaults ( ) ; handleSyntaxColorListSelection ( ) ; 
public void dispose ( ) { fColorManager . dispose ( ) ; super . dispose ( ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fBoldCheckBox . setEnabled ( false ) ; fItalicCheckBox . setEnabled ( false ) ; fStrikethroughCheckBox . setEnabled ( false ) ; fUnderlineCheckBox . setEnabled ( false ) ; return ; } RGB rgb = PreferenceConverter . getColor ( getPreferenceStore ( ) , item . getColorKey ( ) ) ; fSyntaxForegroundColorEditor . setColorValue ( rgb ) ; 
public void widgetSelected ( SelectionEvent e ) { PreferencesUtil . createPreferenceDialogOn ( parent . getShell ( ) , e . text , null , null ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { handleSyntaxColorListSelection ( ) ; } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; PreferenceConverter . setValue ( getPreferenceStore ( ) , item . getColorKey ( ) , fSyntaxForegroundColorEditor . getColorValue ( ) ) ; } 
private void addFiller ( Composite composite , int horizontalSpan ) { PixelConverter pixelConverter = new PixelConverter ( composite ) ; Label filler = new Label ( composite , SWT . LEFT ) ; GridData gd = new GridData ( GridData . HORIZONTAL_ALIGN_FILL ) ; gd . horizontalSpan = horizontalSpan ; gd . heightHint = pixelConverter . convertHeightInCharsToPixels ( 1 ) / 2 ; filler . setLayoutData ( gd ) ; } 
private Preferences createTemporaryCorePreferenceStore ( ) { Preferences result = new Preferences ( ) ; result . setValue ( COMPILER_TASK_TAGS , " TASK,TODO " ) ; $NON-NLS-1$ return result; } 
private String loadPreviewContentFromFile ( String filename ) { String line ; String separator = System . getProperty ( " line.separator " ) ; $NON-NLS-1$ StringBuffer buffer= new StringBuffer(512); BufferedReader reader= null; try { reader= new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(filename))); while ((line= reader.readLine()) != null) { buffer.append(line); buffer.append(separator); } } catch (IOException io) { JavaPlugin.log(io); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) {} } } return buffer.toString(); } 
protected void initializeDialogUnits ( Control testControl ) { Compute and store a font metric GC gc = new GC(testControl); gc.setFont(JFaceResources.getDialogFont()); fFontMetrics = gc.getFontMetrics(); gc.dispose(); } 
public void init ( IWorkbench workbench ) { TODO Auto-generated method stub }} 
public void createPartControl ( Composite theParent ) { tcontrol = new Composite ( theParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; tgl . numColumns = 4 ; tcontrol . setLayout ( gl ) ; tLabel l = new Label ( control , SWT . NONE ) ; tl . setText ( " Find : " ) ; tl . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; tGridData gd = new GridData ( ) ; tgd . verticalAlignment = SWT . CENTER ; tl . setLayoutData ( gd ) ; tfilterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; tfilterText . setTextLimit ( 10 ) ; tfilterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; tgd = new GridData ( ) ; tgd . horizontalAlignment = SWT . FILL ; tgd . verticalAlignment = SWT . CENTER ; tfilterText . setLayoutData ( gd ) ; tfilterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { tpatternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . trim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
private static String rawDocStringToHtml ( String docString ) { treturn docString . replaceAll ( " " , " <br/> " ) ; } 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { terrorMessage = " " ; tassistant . setStatusMessage ( " " ) ; tfinal PrefixInfo prefixInfo ; ttry { tprefixInfo = computePrefix ( viewer , offset ) ; 
private List < ICompletionProposal > computeClojureProposals ( PrefixInfo prefixInfo ) { tfinal List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; tfinal String nsPart ; tfinal String symbolPrefix ; tboolean fullyQualified = false ; if ( prefixInfo . prefix . indexOf ( '/' ) > 0 ) { String [ ] parts = prefixInfo . prefix . split ( " / " , 2 ) ; nsPart = parts [ 0 ] ; symbolPrefix = parts [ 1 ] ; fullyQualified = true ; } else { nsPart = editor . getDeclaringNamespace ( ) ; symbolPrefix = prefixInfo . prefix ; } tfinal List < List > dynamicSymbols = dynamicComplete ( nsPart , symbolPrefix , fullyQualified ) ; } 
public void beginReporting ( ) { tsuper . beginReporting ( ) ; tSystem . out . println ( " begin reporting " ) ; tcounter = 0 ; } 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { tcounter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { tSystem . out . println ( " too much results (> " + MAX_JAVA_SEARCH_RESULT_NUMBER + " ), throwing exception " ) ; tthrow new CoreException ( Status . OK_STATUS ) ; } tproposals . add ( new LazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public void endReporting ( ) { tsuper . endReporting ( ) ; tSystem . out . println ( " end reporting : count= " + counter ) ; } 
private List < List > dynamicComplete ( String namespace , String prefix , boolean findOnlyPublic ) { if ( namespace = = null ) { treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { treturn Collections . emptyList ( ) ; } tMap result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) ; if ( result = = null ) { treturn Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { tfAnnotationAccess = createAnnotationAccess ( ) ; tfOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; } 
public void createPartControl ( Composite parent ) { tsuper . createPartControl ( parent ) ; tClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; tfProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; } 
public static void registerEditorColors ( ColorRegistry colorRegistry ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { viewer . invalidateTextPresentation ( ) ; } 
public void widgetDisposed ( DisposeEvent e ) { preferenceStore . removePropertyChangeListener ( propertyChangeListener ) ; JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_FUNCTION_COLOR , StringConverter . asString ( new RGB ( 218 , 112 , 214 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_LITERAL_COLOR , StringConverter . asString ( new RGB ( 188 , 143 , 143 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR , StringConverter . asString ( new RGB ( 160 , 32 , 240 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_COMMENT_COLOR , StringConverter . asString ( new RGB ( 178 , 34 , 34 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR , StringConverter . asString ( new RGB ( 34 , 139 , 34 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_KEYWORD_COLOR , StringConverter . asString ( new RGB ( 218 , 112 , 214 ) ) ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR , StringConverter . asString ( new RGB ( 34 , 139 , 34 ) ) ) ; 
public void performDefaults ( ) { super . performDefaults ( ) ; handleSyntaxColorListSelection ( ) ; fPreviewViewer . invalidateTextPresentation ( ) ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { getPreferenceStore ( ) , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; new ClojureSourcePreviewerUpdater ( fPreviewViewer , configuration , store ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; installSemanticHighlighting(); return fPreviewViewer.getControl(); } 
private void createColorRegistry ( ) { if ( colorRegistry = = null ) { tDisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { tcolorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; tAntlrBasedClojureEditor . registerEditorColors ( colorRegistry ) ; } } ) ; 
private void initializeParenRainbowColors ( ) { tDisplayUtil . syncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { allColors = new Color [ ] { new Color ( Display . getDefault ( ) , 0x00 , 0xCC , 0x00 ) , 
private void disposeParenRainbowColors ( ) { if ( allColors ! = null ) { tDisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { tfor ( Color c : allColors ) { if ( c ! = null & & ! c . isDisposed ( ) ) { 
public void init ( IPageBookViewPage page , IConsole console ) { tassert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; tassert TextConsole . class . isInstance ( console ) ; tthis . console = ( IOConsole ) console ; torg . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; tint clojureVMPort = LaunchUtils . getLaunchServerReplPort ( processConsole . getProcess ( ) . getLaunch ( ) ) ; if ( clojureVMPort ! = - 1 ) { tclojureClient = new ClojureClient ( clojureVMPort ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { tint port = LaunchUtils . getLaunchServerReplPort ( launch ) ; launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , tInteger . toString ( port ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; if ( port = = - 1 ) { ttry { tlaunch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT , tFile . createTempFile ( LaunchUtils . SERVER_FILE_PORT_PREFIX , LaunchUtils . SERVER_FILE_PORT_SUFFFIX ) . getAbsolutePath ( ) ) ; } catch ( IOException e ) { tthrow new CoreException ( Status . CANCEL_STATUS ) ; } } this.launch = launch; super.launch(configuration, mode, launch, monitor); } 
public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { tint port = LaunchUtils . getLaunchServerReplPort ( launch ) ; tStringBuilder sb = new StringBuilder ( ) ; tsb . append ( " -D " + " clojure.remote.server.port " + " = " + Integer . toString ( port ) ) ; if ( port = = - 1 ) { tsb . append ( " -D " + LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT + " = " + launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT ) ) ; } tsb . append ( " " + super . getVMArguments ( configuration ) ) ; treturn sb . toString ( ) ; } 
static private int tryFindPort ( ILaunch launch ) { tFileReader fr = null ; tBufferedReader br = null ; ttry { tString filename = launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT ) ; if ( filename ! = null ) { tFile f = new File ( filename ) ; tfr = new FileReader ( f ) ; tbr = new BufferedReader ( fr ) ; treturn Integer . valueOf ( br . readLine ( ) ) ; } } catch ( IOException e ) { return -1; } 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
private void createColorRegistry ( ) { if ( colorRegistry = = null ) { tDisplayUtil . asyncExec ( new Runnable ( ) { 
private void initializeParenRainbowColors ( ) { tDisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
private void disposeParenRainbowColors ( ) { if ( allColors ! = null ) { tDisplayUtil . asyncExec ( new Runnable ( ) { 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
public void run ( ) { tresult [ 0 ] = ClojuredevPlugin . getDefault ( ) . getAllColors ( ) [ index ] ; } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; loadPluginClojureCode ( ) ; startLaunchListener ( ) ; } 
private synchronized void createColorRegistry ( ) { if ( colorRegistry = = null ) { tDisplayUtil . syncExec ( new Runnable ( ) { 
public void init ( IPageBookViewPage page , IConsole console ) { tassert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; tassert TextConsole . class . isInstance ( console ) ; tthis . console = ( IOConsole ) console ; 
public void activated ( ) { if ( clojureClient = = null ) { tbindConsoleToClojureEnvironment ( ) ; if ( clojureClient ! = null ) { tSystem . out . println ( " activated " ) ; } } if ( clojureClient ! = null ) { tNamespaceBrowser . setClojureClient ( clojureClient ) ; 
private synchronized void bindConsoleToClojureEnvironment ( ) { if ( clojureClient = = null ) { torg . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; 
public void createPartControl ( Composite theParent ) { tcontrol = new Composite ( theParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; tgl . numColumns = 4 ; tcontrol . setLayout ( gl ) ; tLabel l = new Label ( control , SWT . NONE ) ; tl . setText ( " Find : " ) ; tl . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; tGridData gd = new GridData ( ) ; tgd . verticalAlignment = SWT . CENTER ; tl . setLayoutData ( gd ) ; tfilterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; tfilterText . setTextLimit ( 10 ) ; tfilterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; tgd = new GridData ( ) ; tgd . horizontalAlignment = SWT . FILL ; tgd . verticalAlignment = SWT . CENTER ; tfilterText . setLayoutData ( gd ) ; tfilterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { tpatternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . trim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
private static void inUIThreadSetClojureClient ( ClojureClient clojureClient ) { tIViewPart [ ] views = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getViews ( ) ; tNamespaceBrowser co = null ; tfor ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { tco = ( NamespaceBrowser ) v ; tbreak ; } } if ( co = = null ) { treturn ; } tco . clojureClient = clojureClient ; tco . resetInput ( ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { initializeViewerColors ( ) ; } 
protected void initializeViewerColors ( ) { if ( fPreferenceStore ! = null ) { registerEditorColors ( ) ; 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( this ) ; initializeViewerColors ( ) ; } fIsConfigured = true ; } 
public void unconfigure ( ) { if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( this ) ; super . unconfigure ( ) ; fIsConfigured = false ; } 
private void registerEditorColors ( ) { ColorRegistry colorRegistry = ClojuredevPlugin . getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? RGB black = new RGB(0,0,0); RGB gray = new RGB(128,128,128); RGB literal = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_LITERAL_COLOR); RGB specialForm = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR); RGB function = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_FUNCTION_COLOR); RGB comment = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_COMMENT_COLOR); RGB globalVar = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR); RGB keyword = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_KEYWORD_COLOR); RGB metadataTypehint = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, function); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVar); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keyword); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, comment); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehint); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
public void performDefaults ( ) { super . performDefaults ( ) ; handleSyntaxColorListSelection ( ) ; fOverlayStore . loadDefaults ( ) ; fPreviewViewer . invalidateTextPresentation ( ) ; } 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; ClojuredevPlugin . getDefault ( ) . savePluginPreferences ( ) ; return true ; } 
public void dispose ( ) { fColorManager . dispose ( ) ; if ( fOverlayStore ! = null ) { fOverlayStore . stop ( ) ; fOverlayStore = null ; } super . dispose ( ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fBoldCheckBox . setEnabled ( false ) ; fItalicCheckBox . setEnabled ( false ) ; fStrikethroughCheckBox . setEnabled ( false ) ; fUnderlineCheckBox . setEnabled ( false ) ; return ; } TODO: RGB rgb= PreferenceConverter.getColor(getPreferenceStore(), item.getColorKey()); RGB rgb= PreferenceConverter.getColor(fOverlayStore, item.getColorKey()); fSyntaxForegroundColorEditor.setColorValue(rgb); fSyntaxForegroundColorEditor.getButton().setEnabled(true); fColorEditorLabel.setEnabled(true); fBoldCheckBox.setEnabled(true); fItalicCheckBox.setEnabled(true); fStrikethroughCheckBox.setEnabled(true); fUnderlineCheckBox.setEnabled(true); fEnableCheckbox.setEnabled(false); fEnableCheckbox.setSelection(true); } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; TODO: remove this ? PreferenceConverter.setValue(getPreferenceStore(), item.getColorKey(), fSyntaxForegroundColorEditor.getColorValue()); PreferenceConverter.setValue(fOverlayStore, item.getColorKey(), fSyntaxForegroundColorEditor.getColorValue()); } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; new ClojureSourcePreviewerUpdater ( fPreviewViewer , configuration , store ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public void init ( IWorkbench workbench ) { TODO Auto-generated method stub } private OverlayPreferenceStore.OverlayKey[] createOverlayStoreKeys() { ArrayList<OverlayPreferenceStore.OverlayKey> overlayKeys= new ArrayList<OverlayPreferenceStore.OverlayKey>(); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_FUNCTION_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_LITERAL_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_COMMENT_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_KEYWORD_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR)); OverlayPreferenceStore.OverlayKey[] keys= new OverlayPreferenceStore.OverlayKey[overlayKeys.size()]; return overlayKeys.toArray(keys); }} 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_FUNCTION_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_LITERAL_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_COMMENT_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_KEYWORD_COLOR ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR ) ) ; OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . toArray ( keys ) ; } 
public void init ( IWorkbench workbench ) { TODO Auto-generated method stub } private OverlayPreferenceStore.OverlayKey[] createOverlayStoreKeys() { ArrayList<OverlayPreferenceStore.OverlayKey> overlayKeys= new ArrayList<OverlayPreferenceStore.OverlayKey>(); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_FUNCTION_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_LITERAL_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_COMMENT_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_KEYWORD_COLOR)); overlayKeys.add(new OverlayPreferenceStore.OverlayKey(OverlayPreferenceStore.STRING, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR)); OverlayPreferenceStore.OverlayKey[] keys= new OverlayPreferenceStore.OverlayKey[overlayKeys.size()]; return overlayKeys.toArray(keys); }} 
public void registerEditorColors ( ) { ColorRegistry colorRegistry = ClojuredevPlugin . getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? RGB black = new RGB(0,0,0); RGB gray = new RGB(128,128,128); RGB literal = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_LITERAL_COLOR); RGB specialForm = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR); RGB function = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_FUNCTION_COLOR); RGB comment = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_COMMENT_COLOR); RGB globalVar = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR); RGB keyword = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_KEYWORD_COLOR); RGB metadataTypehint = PreferenceConverter.getColor(fPreferenceStore, clojuredev.preferences.PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, function); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVar); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keyword); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, comment); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehint); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
public void initTokenScanner ( ) { tokenScanner = new ClojureTokenScannerFactory ( ) . create ( ClojuredevPlugin . getDefault ( ) . getColorRegistry ( ) , ClojuredevPlugin . getDefault ( ) . getDefaultScanContext ( ) ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { viewer . unconfigure ( ) ; viewer . registerEditorColors ( ) ; configuration . initTokenScanner ( ) ; viewer . configure ( configuration ) ; viewer . invalidateTextPresentation ( ) ; } 
public static void registerEditorColors ( IPreferenceStore store ) { ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? RGB black = new RGB(0,0,0); RGB gray = new RGB(128,128,128); RGB literal = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_LITERAL_COLOR); RGB specialForm = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR); RGB function = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_FUNCTION_COLOR); RGB comment = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_COMMENT_COLOR); RGB globalVar = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR); RGB keyword = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_KEYWORD_COLOR); RGB metadataTypehint = PreferenceConverter.getColor(store, clojuredev.preferences.PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literal); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, function); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVar); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialForm); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keyword); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, comment); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehint); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { tfAnnotationAccess = createAnnotationAccess ( ) ; tfOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { if ( fConfiguration ! = null ) { ClojureSourceViewerConfiguration tmp = fConfiguration ; 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( this ) ; } if ( configuration instanceof ClojureSourceViewerConfiguration ) fConfiguration = ( ClojureSourceViewerConfiguration ) configuration ; fIsConfigured = true ; } 
public void unconfigure ( ) { if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( this ) ; super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojuredevPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public void run ( ) { tcolorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; } } ) ; 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
public boolean isDefaultEnabled ( ) { return defaultEnabled ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = ClojuredevPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( clojuredev . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; ClojuredevPlugin . getDefault ( ) . savePluginPreferences ( ) ; return true ; } 
public void dispose ( ) { fColorManager . dispose ( ) ; if ( fOverlayStore ! = null ) { fOverlayStore . stop ( ) ; fOverlayStore = null ; } super . dispose ( ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fEnableCheckbox . setEnabled ( true ) ; boolean enable = fOverlayStore . getBoolean ( item . getEnableKey ( ) ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; / * TODO depend on enable if text attributes are actually used 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; boolean enable = fEnableCheckbox . getSelection ( ) ; fOverlayStore . setValue ( item . getEnableKey ( ) , enable ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; / * TODO re - enable once text attributes are used 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojuredevPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
private String loadPreviewContentFromFile ( String filename ) { String line ; String separator = System . getProperty ( " line.separator " ) ; $NON-NLS-1$ StringBuffer buffer= new StringBuffer(512); BufferedReader reader= null; try { reader= new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(filename))); while ((line= reader.readLine()) != null) { buffer.append(line); buffer.append(separator); } } catch (IOException io) { JavaPlugin.log(io); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) {} } } return buffer.toString(); } 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . toArray ( keys ) ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojuredevPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public static void asyncExec ( Runnable r ) { tDisplay display = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; if ( ! display . isDisposed ( ) ) { tdisplay . asyncExec ( r ) ; 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T24, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T25, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T26, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T27, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T28, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T29, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T30, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T31, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.T32, black);'#'=30 $NON-NLS-1$ } 
private synchronized void createFontRegistry ( ) { if ( fontRegistry = = null ) { tDisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { tfontRegistry = new FontRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; } 
public void stop ( BundleContext context ) throws Exception { tdisposeParenRainbowColors ( ) ; tstopLaunchListener ( ) ; We also don't remove fonts when deregistered plugin = null; super.stop(context); } 
protected void initializeImageRegistry ( ImageRegistry reg ) { treg . put ( NS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/package_obj.gif " ) ) ) ; treg . put ( PUBLIC_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpub_obj.gif " ) ) ) ; reg . put ( PRIVATE_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpri_obj.gif " ) ) ) ; reg . put ( CLASS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/class_obj.gif " ) ) ) ; } 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , int offset ) { terrorMessage = " " ; tassistant . setStatusMessage ( " " ) ; tfinal PrefixInfo prefixInfo ; ttry { tprefixInfo = computePrefix ( viewer , offset ) ; 
private List < ICompletionProposal > computeClojureFullyQualifiedSymbolsProposals ( PrefixInfo prefixInfo ) { tfinal List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; tfinal List < List > dynamicSymbols = dynamicComplete ( prefixInfo . nsPart , tprefixInfo . symbolPrefix , editor , prefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureSymbolsProposals ( PrefixInfo prefixInfo ) { tfinal List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; tfinal List < List > dynamicSymbols = dynamicComplete ( prefixInfo . nsPart , tprefixInfo . symbolPrefix , editor , prefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureNamespacesProposals ( PrefixInfo prefixInfo ) { tfinal List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; tfinal List < List > dynamicSymbols = dynamicNamespaceComplete ( prefixInfo . prefix ) ; } 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { tcounter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { tSystem . out . println ( " too much results (> " + MAX_JAVA_SEARCH_RESULT_NUMBER + " ), throwing exception " ) ; tthrow new CoreException ( Status . OK_STATUS ) ; } tproposals . add ( new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . METHOD } ; } public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } public String [ ] patternStr ( PrefixInfo prefixInfo ) { 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { treturn new String [ ] { prefixInfo . nsPart + " . " + prefixInfo . symbolPrefix } ; } 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , AntlrBasedClojureEditor editor , SearchMatch match ) { treturn new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . TYPE , IJavaSearchConstants . TYPE } ; } public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_CAMELCASE_MATCH } ; } public String [ ] patternStr ( PrefixInfo prefixInfo ) { 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { treturn new String [ ] { prefixInfo . prefix , prefixInfo . prefix + " * " } ; } 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , AntlrBasedClojureEditor editor , SearchMatch match ) { treturn new ClassLazyCompletionProposal ( ( IType ) match . getElement ( ) , 
public int [ ] searchFor ( ) { return new int [ ] { IJavaSearchConstants . PACKAGE } ; } public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_PATTERN_MATCH } ; } 
public int [ ] matchRule ( ) { return new int [ ] { SearchPattern . R_PATTERN_MATCH } ; } public String [ ] patternStr ( PrefixInfo prefixInfo ) { 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { treturn new String [ ] { prefixInfo . prefix + " * " } ; } 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , AntlrBasedClojureEditor editor , SearchMatch match ) { treturn new PackageLazyCompletionProposal ( ( IPackageFragment ) match . getElement ( ) , 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { tproposals . add ( searchType . lazyCompletionProposal ( prefixInfo , editor , match ) ) ; } 
public void applyStyles ( TextStyle textStyle ) { ttextStyle . font = ClojuredevPlugin . getDefault ( ) . getJavaSymbolFont ( ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , AntlrBasedClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { treturn Collections . emptyList ( ) ; } tMap result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) ; if ( result = = null ) { treturn Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { treturn Collections . emptyList ( ) ; } tMap result = ( Map ) clojureClient . remoteLoadRead ( " (clojuredev.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; if ( result = = null ) { treturn Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public static void main ( String [ ] args ) throws Exception { }} 
public void createPartControl ( Composite theParent ) { tcontrol = new Composite ( theParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; tgl . numColumns = 4 ; tcontrol . setLayout ( gl ) ; tLabel l = new Label ( control , SWT . NONE ) ; tl . setText ( " Find : " ) ; tl . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of symbols " ) ; tGridData gd = new GridData ( ) ; tgd . verticalAlignment = SWT . CENTER ; tl . setLayoutData ( gd ) ; tfilterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; tfilterText . setTextLimit ( 10 ) ; tfilterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; tgd = new GridData ( ) ; tgd . horizontalAlignment = SWT . FILL ; tgd . verticalAlignment = SWT . CENTER ; tgd . grabExcessHorizontalSpace = true ; tfilterText . setLayoutData ( gd ) ; tfilterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { tpatternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . trim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, black);'&'=20 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, gray);'['=23 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, gray);']'=24 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, gray);'{'=25 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, gray);'}'=26 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, black);'\''=27 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, black);'^'=28 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, black);'@'=29 $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, black);'#'=30 $NON-NLS-1$ } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorProvider ) ; tu . addTokenType ( ClojureLexer . STRING ) ; tu . addTokenType ( ClojureLexer . NUMBER ) ; tu . addTokenType ( ClojureLexer . CHARACTER ) ; tu . addTokenType ( ClojureLexer . NIL ) ; tu . addTokenType ( ClojureLexer . BOOLEAN ) ; tu . addTokenType ( ClojureLexer . SYMBOL ) ; tu . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; tu . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; tu . addTokenType ( IScanContext . SymbolType . MACRO ) ; } 
public final void mAMPERSAND ( ) throws RecognitionException { try { int _type = AMPERSAND ; 
public final void mLEFT_SQUARE_BRACKET ( ) throws RecognitionException { try { int _type = LEFT_SQUARE_BRACKET ; 
public final void mRIGHT_SQUARE_BRACKET ( ) throws RecognitionException { try { int _type = RIGHT_SQUARE_BRACKET ; 
public final void mLEFT_CURLY_BRACKET ( ) throws RecognitionException { try { int _type = LEFT_CURLY_BRACKET ; 
public final void mRIGHT_CURLY_BRACKET ( ) throws RecognitionException { try { int _type = RIGHT_CURLY_BRACKET ; 
public final void mBACKSLASH ( ) throws RecognitionException { try { int _type = BACKSLASH ; 
public final void mCIRCUMFLEX ( ) throws RecognitionException { try { int _type = CIRCUMFLEX ; 
public final void mCOMMERCIAL_AT ( ) throws RecognitionException { try { int _type = COMMERCIAL_AT ; 
public final void mNUMBER_SIGN ( ) throws RecognitionException { try { int _type = NUMBER_SIGN ; 
public final void mAPOSTROPHE ( ) throws RecognitionException { try { int _type = APOSTROPHE ; 
public final void mHEXDIGIT ( ) throws RecognitionException { try { int _type = HEXDIGIT ; 
public final void mNAME ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:108:5: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:112:12: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:118:12: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public void mTokens ( ) throws RecognitionException { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:1:8: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt23=28; alt23 = dfa23.predict(input); switch (alt23) { case 1 : 
public final void literal ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:125:8: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g: { if ( (input.LA(1)>=STRING && input.LA(1)<=NUMBER)||(input.LA(1)>=CHARACTER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:185:10: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("185:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:186:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1245); quoteForm(); _fsp--; } break; case 2 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:187:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1255); metaForm(); _fsp--; } break; case 3 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:188:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1265); derefForm(); _fsp--; } break; case 4 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:189:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1275); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:190:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1285); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:191:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1295); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:194:18: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==NUMBER_SIGN) ) { switch ( input.LA(2) ) { case APOSTROPHE: { alt6=2; } break; case STRING: { alt6=1; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("194:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("194:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:195:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1322); regexForm(); _fsp--; } break; case 2 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:196:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1332); varQuoteForm(); _fsp--; } break; case 3 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:197:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1344); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1373); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1397); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1425); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:212:5: ( APOSTROPHE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:212:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1458); pushFollow(FOLLOW_form_in_quoteForm1460); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:215:9: ( CIRCUMFLEX form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:215:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1474); pushFollow(FOLLOW_form_in_metaForm1476); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:218:10: ( COMMERCIAL_AT form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:218:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1493); pushFollow(FOLLOW_form_in_derefForm1495); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:224:5: ( SYNTAX_QUOTE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:225:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1535); pushFollow(FOLLOW_form_in_syntaxQuoteForm1537); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:231:5: ( UNQUOTE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:232:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1577); pushFollow(FOLLOW_form_in_unquoteForm1579); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:238:5: ( UNQUOTE_SPLICING form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:239:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1619); pushFollow(FOLLOW_form_in_unquoteSplicingForm1621); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1647); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:245:10: ( NUMBER_SIGN STRING ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:245:13: NUMBER_SIGN STRING { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_regexForm1660); match(input,STRING,FOLLOW_STRING_in_regexForm1662); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:248:13: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1686); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1688); /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("249:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:33: map { pushFollow(FOLLOW_map_in_metadataForm1691); map(); _fsp--; } break; case 2 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1695); } break; case 3 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1697); } break; case 4 : /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:249:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1699); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:252:13: ( NUMBER_SIGN APOSTROPHE form ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:253:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1720); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1722); pushFollow(FOLLOW_form_in_varQuoteForm1724); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:263:5: ( NUMBER_SIGN list ) /home/stm/JAVA/ws-clojure-dev-git/clojure-antlr-grammar/src/Clojure.g:263:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1751); pushFollow(FOLLOW_list_in_lambdaForm1753); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, black); $NON-NLS-1$ } 
private void updateLaunchList ( ILaunch launch ) { if ( isClojureEnabledLaunch ( launch ) ) { tlaunches . add ( launch ) ; 
public static boolean isClojureEnabledLaunch ( ILaunch launch ) { treturn ( launch . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN ) ! = null ) ; } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . MAIN_CLASSNAME_FOR_REPL ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
private void createReplServerControl ( final Composite parent ) { Group section = SWTFactory . createGroup ( parent , " Repl settings " , 2 , 1 , 0 ) ; installREPLChoice = SWTFactory . createCheckButton ( tsection , " Install a REPL (see tooltip for detail) " , null , true , 2 ) ; installREPLChoice . setToolTipText ( " If checked, the main class will be clojure.contrib.repl_ln, all files listed will be loaded " + " with the -i option. n If unchecked, the main class will be clojure.main, all files listed but the last will be loaded " + " with the -i option, and the last file will be loaded as a script. " ) ; SWTFactory . createLabel ( section , " Remote server must listen on port: " , 1 ) ; serverPort = SWTFactory . createSingleText ( section , 0 ) ; installREPLChoice . addSelectionListener ( new SelectionListener ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { } public void widgetSelected ( SelectionEvent e ) { tserverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; tupdateLaunchConfigurationDialog ( ) ; } } ) ; serverPort . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { 
public void widgetSelected ( SelectionEvent e ) { tserverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; tupdateLaunchConfigurationDialog ( ) ; } 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . trim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } try { tinstallREPLChoice . setSelection ( config . getAttribute ( tLaunchUtils . ATTR_CLOJURE_INSTALL_REPL , true ) ) ; serverPort . setText ( Integer . toString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; serverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; } catch ( CoreException e ) { tClojuredevPlugin . logError ( " error while initializing serverPort " , e ) ; tinstallREPLChoice . setSelection ( true ) ; tserverPort . setEnabled ( true ) ; tserverPort . setText ( " " ) ; } try { tsourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; tconfig . setAttribute ( ATTR_MAIN_TYPE_NAME , tinstallREPLChoice . getSelection ( ) ? LaunchUtils . MAIN_CLASSNAME_FOR_REPL : LaunchUtils . MAIN_CLASSNAME ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_INSTALL_REPL , installREPLChoice . getSelection ( ) ) ; config . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , Integer . valueOf ( serverPort . getText ( ) ) ) ; mapResources ( config ) ; } 
private static String fileArg ( IFile file ) { treturn " \" " + file . getLocation ( ) . toString ( ) + " \" " ; } 
static public String getFilesToLaunchAsCommandLineList ( ILaunchConfiguration config , boolean lastFileAsScript ) throws CoreException { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( config ) ; treturn LaunchUtils . getProgramArguments ( filesToLaunch , lastFileAsScript ) ; 
public static boolean isEmpty ( String s ) { treturn s = = null | | s . length ( ) = = 0 ; 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " in " + name ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( i ) + " ' at index " + i + " in " + name ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { ClojuredevPlugin.logError(e); return false; } return true; } 
private void loadPluginClojureCode ( ) throws Exception { tURL clientReplBundleUrl = CCWPlugin . getDefault ( ) . getBundle ( ) . getResource ( " ccw/debug/clientrepl.clj " ) ; tURL clientReplFileUrl = FileLocator . toFileURL ( clientReplBundleUrl ) ; tString clientRepl = clientReplFileUrl . getFile ( ) ; tCompiler . loadFile ( clientRepl ) ; } 
private static boolean addNature ( IProject project , String natureID ) { IProjectDescription desc ; try { desc = project . getDescription ( ) ; } catch ( CoreException e ) { CCWPlugin . logError ( " Could not get project description " , e ) ; return false ; } String [ ] ids = desc . getNatureIds ( ) ; String [ ] newIDs = new String [ ids . length + 1 ] ; System . arraycopy ( ids , 0 , newIDs , 1 , ids . length ) ; newIDs [ 0 ] = natureID ; desc . setNatureIds ( newIDs ) ; try { project . setDescription ( desc , null ) ; } catch ( CoreException e ) { CCWPlugin . logError ( " Could not set project description " , e ) ; return false ; } return true ; } 
public void configure ( ) throws CoreException { IProjectDescription desc = getProjectDescription ( ) ; if ( desc = = null ) { treturn ; } ICommand [ ] spec = desc . getBuildSpec ( ) ; return; } ICommand clojureCommand = desc.newCommand(); clojureCommand.setBuilderName(ClojureBuilder.BUILDER_ID); Add clojure builder before all other builders (thus before Java builder if present) ICommand[] newSpec = new ICommand[spec.length + 1]; newSpec[0] = clojureCommand; System.arraycopy(spec, 0, newSpec, 1, spec.length); desc.setBuildSpec(newSpec); project.setDescription(desc, IResource.FORCE, null); setupClojureProjectClassPath(); } 
private void toggleNature ( IProject project ) { tString title = " Change Clojure language support " ; tString message ; ttry { tboolean added = doToggleNature ( project ) ; tmessage = " Clojure language support successfully " + ( added ? " added " : " removed " ) + " . " ; } catch ( CoreException e ) { tmessage = " Error while trying to toggle clojure language support for project " + project . getName ( ) ; tCCWPlugin . logError ( message , e ) ; } tMessageDialog . openInformation ( targetPart . getSite ( ) . getShell ( ) , title , message ) ; } 
protected void fullBuild ( IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = CCWPlugin . getDefault ( ) . getProjectClojureClient ( getProject ( ) ) ; if ( clojureClient = = null ) { treturn ; } deleteMarkers ( ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( ) ) ; getClassesFolder ( ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . toArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
protected void initializeKeyBindingScopes ( ) { tsetKeyBindingScopes ( new String [ ] { " ccw.ui.clojureEditorScope " } ) ; } 
public void applyStyles ( TextStyle textStyle ) { ttextStyle . font = CCWPlugin . getDefault ( ) . getJavaSymbolFont ( ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , AntlrBasedClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { treturn Collections . emptyList ( ) ; } tMap result = ( Map ) clojureClient . remoteLoadRead ( " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) ; if ( result = = null ) { treturn Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tClojureClient clojureClient = editor . getCorrespondingClojureClient ( ) ; if ( clojureClient = = null ) { treturn Collections . emptyList ( ) ; } tMap result = ( Map ) clojureClient . remoteLoadRead ( " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; if ( result = = null ) { treturn Collections . emptyList ( ) ; } if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public void initTokenScanner ( ) { tokenScanner = new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) ) ; } 
private void createFileEditor ( final Composite parent , String string ) { Group section = SWTFactory . createGroup ( parent , " Evaluate Clojure source file(s) " , 2 , 1 , GridData . FILL_BOTH ) ; sourceFilesViewer = new TableViewer ( section ) ; sourceFilesViewer . setLabelProvider ( new DecoratingLabelProvider ( tnew WorkbenchLabelProvider ( ) , CCWPlugin . getDefault ( ) . getWorkbench ( ) . getDecoratorManager ( ) . getLabelDecorator ( ) ) ) ; sourceFilesViewer . setContentProvider ( new ArrayContentProvider ( ) ) ; sourceFilesViewer . getTable ( ) . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; Composite buttonSection = SWTFactory . createComposite ( section , parent . getFont ( ) , 1 , 1 , GridData . FILL_BOTH ) ; Button chooseButton = new Button ( buttonSection , SWT . PUSH ) ; chooseButton . setText ( " Choose... " ) ; chooseButton . addSelectionListener ( new SelectionAdapter ( ) { 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . trim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } try { tinstallREPLChoice . setSelection ( config . getAttribute ( tLaunchUtils . ATTR_CLOJURE_INSTALL_REPL , true ) ) ; serverPort . setText ( Integer . toString ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ) ) ; serverPort . setEnabled ( installREPLChoice . getSelection ( ) ) ; } catch ( CoreException e ) { tCCWPlugin . logError ( " error while initializing serverPort " , e ) ; tinstallREPLChoice . setSelection ( true ) ; tserverPort . setEnabled ( true ) ; tserverPort . setText ( " " ) ; } try { tsourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; CCWPlugin . getDefault ( ) . savePluginPreferences ( ) ; return true ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; CCWPlugin . registerEditorColors ( store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " in " + name ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid Clojure resource character ' " + name . charAt ( i ) + " ' at index " + i + " in " + name ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
public boolean canToggleLineBreakpoints ( IWorkbenchPart part , tISelection selection ) { if ( part instanceof ITextEditor ) { tITextEditor editor = ( ITextEditor ) part ; tIResource resource = ( IResource ) editor . getEditorInput ( ) . getAdapter ( IResource . class ) ; treturn ( resource ! = null & & resource . getFileExtension ( ) . equals ( " clj " ) ) ; } treturn false ; } 
public boolean canToggleMethodBreakpoints ( IWorkbenchPart part , tISelection selection ) { treturn false ; } 
public boolean canToggleWatchpoints ( IWorkbenchPart part , tISelection selection ) { treturn false ; } 
public void toggleLineBreakpoints ( IWorkbenchPart part , ISelection selection ) tthrows CoreException { if ( part instanceof ITextEditor ) { tITextEditor editor = ( ITextEditor ) part ; 
public void toggleMethodBreakpoints ( IWorkbenchPart part , tISelection selection ) throws CoreException { } public void toggleWatchpoints ( IWorkbenchPart part , ISelection selection ) tthrows CoreException { } } 
public void toggleWatchpoints ( IWorkbenchPart part , ISelection selection ) tthrows CoreException { } } 
public void selectionChanged ( SelectionChangedEvent event ) { tISelection selection = event . getSelection ( ) ; tselectInEditor ( selection ) ; } 
private void refreshInput ( ) { tJob job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; tLineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( tnew StringReader ( string ) ) ; tObject EOF = new Object ( ) ; tArrayList < Object > input = new ArrayList < Object > ( ) ; tObject result = null ; twhile ( true ) { ttry { tresult = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) { tbreak ; } tinput . add ( result ) ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; tLineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( tnew StringReader ( string ) ) ; tObject EOF = new Object ( ) ; tArrayList < Object > input = new ArrayList < Object > ( ) ; tObject result = null ; twhile ( true ) { ttry { tresult = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) { tbreak ; } tinput . add ( result ) ; } catch ( ReaderException e ) { } 
public boolean belongsTo ( Object family ) { treturn REFRESH_OUTLINE_JOB_FAMILY . equals ( family ) ; } 
public void run ( ) { tTreeViewer treeViewer = getTreeViewer ( ) ; if ( treeViewer ! = null ) { ttreeViewer . getTree ( ) . setRedraw ( false ) ; 
private void selectInEditor ( ISelection selection ) { tIStructuredSelection sel = ( IStructuredSelection ) selection ; if ( sel . size ( ) = = 0 ) treturn ; tObj obj = ( Obj ) sel . getFirstElement ( ) ; tIMapEntry line = obj . meta ( ) . entryAt ( KEYWORD_LINE ) ; if ( line ! = null & & line . val ( ) instanceof Number ) { tClojureCore 
private static String safeToString ( Object value ) { treturn value = = null ? " N/A " : value . toString ( ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { tISelection selection = event . getSelection ( ) ; if ( selection instanceof TextSelection ) { tTextSelection textSelection = ( TextSelection ) selection ; 
public void selectionChanged ( SelectionChangedEvent event ) { tISelection selection = event . getSelection ( ) ; if ( isActivePart ( ) ) { tselectInEditor ( selection ) ; 
protected StructuredSelection findClosest ( int toFind ) { tObject selected = null ; tfor ( Object o : input ) { if ( o instanceof Obj ) { tObj obj = ( Obj ) o ; tint lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 & & lineNr < = toFind ) { tselected = obj ; } } } if ( selected ! = null ) { treturn new StructuredSelection ( selected ) ; } treturn StructuredSelection . EMPTY ; } 
private void refreshInput ( ) { tJob job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; tLineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( tnew StringReader ( string ) ) ; tObject EOF = new Object ( ) ; tArrayList < Object > input = new ArrayList < Object > ( ) ; tObject result = null ; twhile ( true ) { ttry { tresult = LispReader . read ( pushbackReader , false , EOF , tfalse ) ; if ( result = = EOF ) { tbreak ; } tinput . add ( result ) ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; tLineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( tnew StringReader ( string ) ) ; tObject EOF = new Object ( ) ; tArrayList < Object > input = new ArrayList < Object > ( ) ; tObject result = null ; twhile ( true ) { ttry { tresult = LispReader . read ( pushbackReader , false , EOF , tfalse ) ; if ( result = = EOF ) { tbreak ; } tinput . add ( result ) ; } catch ( ReaderException e ) { } 
private void selectInEditor ( ISelection selection ) { tIStructuredSelection sel = ( IStructuredSelection ) selection ; if ( sel . size ( ) = = 0 ) treturn ; tObj obj = ( Obj ) sel . getFirstElement ( ) ; tint lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 ) { tClojureCore . gotoEditorLine ( editor , lineNr ) ; 
protected boolean isActivePart ( ) { tIWorkbenchPart part = getSite ( ) . getPage ( ) . getActivePart ( ) ; treturn part ! = null & & " org.eclipse.ui.views.ContentOutline " . equals ( part . getSite ( ) . getId ( ) ) ; } 
public void dispose ( ) { ttry { if ( document ! = null ) document . removeDocumentListener ( documentChangedListener ) ; } catch ( Throwable ) { } ttry { tfinal TreeViewer viewer = getTreeViewer ( ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( this ) ; if ( viewer ! = null ) viewer . removeSelectionChangedListener ( treeSelectionChangedListener ) ; } catch ( Throwable ) { } ttry { tIPostSelectionProvider selectionProvider = ( IPostSelectionProvider ) editor . getSelectionProvider ( ) ; if ( selectionProvider ! = null ) selectionProvider . removePostSelectionChangedListener ( editorSelectionChangedListener ) ; } catch ( Throwable ) { } tsuper . dispose ( ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { tISelection selection = event . getSelection ( ) ; tselectInOutline ( selection ) ; 
public void selectionChanged ( SelectionChangedEvent event ) { tISelection selection = event . getSelection ( ) ; if ( isActivePart ( ) ) { only when this is the active part, i.e. is user initiated 
protected StructuredSelection findClosest ( int toFind ) { tObject selected = null ; tfor ( Object o : input ) { if ( o instanceof Obj ) { tObj obj = ( Obj ) o ; tint lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 & & lineNr < = toFind ) { tselected = obj ; } } } if ( selected ! = null ) { treturn new StructuredSelection ( selected ) ; } treturn StructuredSelection . EMPTY ; } 
private String safeToString ( Object value ) { treturn value = = null ? NOT_AVAILABLE : value . toString ( ) ; } 
protected boolean isActivePart ( ) { tIWorkbenchPart part = getSite ( ) . getPage ( ) . getActivePart ( ) ; treturn part ! = null & & OUTLINE_VIEW_ID . equals ( part . getSite ( ) . getId ( ) ) ; } 
public void dispose ( ) { ttry { if ( document ! = null ) tdocument . removeDocumentListener ( documentChangedListener ) ; } catch ( Throwable ) { } ttry { tfinal TreeViewer viewer = getTreeViewer ( ) ; if ( viewer ! = null ) tviewer . removeSelectionChangedListener ( this ) ; if ( viewer ! = null ) tviewer . removeSelectionChangedListener ( treeSelectionChangedListener ) ; } catch ( Throwable ) { } ttry { tIPostSelectionProvider selectionProvider = ( IPostSelectionProvider ) editor . getSelectionProvider ( ) ; if ( selectionProvider ! = null ) tselectionProvider . removePostSelectionChangedListener ( editorSelectionChangedListener ) ; } catch ( Throwable ) { } tsuper . dispose ( ) ; } 
private void selectInOutline ( ISelection selection ) { tTreeViewer viewer = getTreeViewer ( ) ; tlastSelection = selection ; if ( viewer ! = null & & selection instanceof TextSelection ) { tTextSelection textSelection = ( TextSelection ) selection ; 
public static boolean addClojureNature ( IProject project ) { return addNature ( project , NATURE_ID ) ; } 
public boolean test ( Object receiver , String property , Object [ ] args , Object expectedValue ) { assert IProject . class . isInstance ( receiver ) ; assert " hasClojureNature " . equals ( property ) ; IProject project = ( IProject ) receiver ; try { return project . hasNature ( ClojureCore . NATURE_ID ) ; 
private boolean doToggleNature ( IProject project ) throws CoreException { tIProjectDescription description = project . getDescription ( ) ; tString [ ] natures = description . getNatureIds ( ) ; tList < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; tboolean natureFound = false ; tfor ( String nature : natures ) { if ( nature . equals ( ClojureCore . NATURE_ID ) ) { } 
public ISourceContainer [ ] computeSourceContainers ( tILaunchConfiguration configuration , IProgressMonitor monitor ) tthrows CoreException { tISourceContainer [ ] superResult = super . computeSourceContainers ( configuration , monitor ) ; tISourceContainer [ ] result = new ISourceContainer [ superResult . length + 1 ] ; tSystem . arraycopy ( superResult , 0 , result , 1 , superResult . length ) ; tresult [ 0 ] = getSrcFolderAsISourceContainer ( configuration ) ; treturn result ; } 
private ISourceContainer getSrcFolderAsISourceContainer ( ILaunchConfiguration configuration ) throws CoreException { tString projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { tthrow new CoreException ( new Status ( IStatus . ERROR , ClojurePlugin . ID , " Clojure SourcePathComputerDelegate unable to correctly set the clojure sources in the class because the considered launch configuration does not have an associated project " ) ) ; 
public Object [ ] findSourceElements ( String name ) throws CoreException { treturn delegatee . findSourceElements ( name ) ; } 
public ISourceContainer [ ] getSourceContainers ( ) throws CoreException { treturn delegatee . getSourceContainers ( ) ; } 
public void init ( ISourceLookupDirector director ) { tdelegatee . init ( director ) ; } 
public void initializeParticipants ( ) { taddParticipants ( new ISourceLookupParticipant [ ] { new ClojureSourceLookupParticipant ( ) , new JavaSourceLookupParticipant ( ) } ) ; } 
public boolean supportsSourceContainerType ( ISourceContainerType type ) { treturn ! fFilteredTypes . contains ( type . getId ( ) ) ; } 
public String getSourceName ( Object object ) throws CoreException { tJavaSourceLookupParticipant javaParticipant = findSiblingJavaParticipant ( ) ; if ( javaParticipant = = null ) { treturn null ; 
public void init ( ISourceLookupDirector director ) { tsuper . init ( director ) ; tdelegateContainers = new HashMap < ISourceContainer , ISourceContainer > ( ) ; } 
public void dispose ( ) { tthis . cachedSiblingJavaParticipant = null ; tdisposeAndClearDelegateContainers ( delegateContainers ) ; tdelegateContainers = null ; tsuper . dispose ( ) ; } 
private void disposeAndClearDelegateContainers ( Map < ISourceContainer , ISourceContainer > delegateContainers ) { if ( delegateContainers ! = null ) { tfor ( ISourceContainer sc : delegateContainers . values ( ) ) { tsc . dispose ( ) ; } } tdelegateContainers . clear ( ) ; } 
public ISourceContainer [ ] computeSourceContainers ( tILaunchConfiguration configuration , IProgressMonitor monitor ) tthrows CoreException { tISourceContainer [ ] superResult = super . computeSourceContainers ( configuration , monitor ) ; tList < ISourceContainer > result = new ArrayList < ISourceContainer > ( superResult . length * 2 ) ; tresult . addAll ( getSrcFoldersAsISourceContainers ( configuration ) ) ; tfor ( ISourceContainer sourceContainer : superResult ) { if ( sourceContainer instanceof PackageFragmentRootSourceContainer ) { tPackageFragmentRootSourceContainer sc = ( PackageFragmentRootSourceContainer ) sourceContainer ; } 
private List < ISourceContainer > getSrcFoldersAsISourceContainers ( ILaunchConfiguration configuration ) throws CoreException { tString projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { tthrow new CoreException ( new Status ( IStatus . ERROR , ClojurePlugin . ID , " Clojure SourcePathComputerDelegate unable to correctly set the clojure sources in the class because the considered launch configuration does not have an associated project " ) ) ; 
private IWorkbenchPage internalGetActivePage ( ) { tIWorkbenchWindow window = getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window = = null ) treturn null ; treturn window . getActivePage ( ) ; } 
public boolean canToggleLineBreakpoints ( IWorkbenchPart part , tISelection selection ) { if ( part instanceof IEditorPart ) { tIEditorPart editor = ( IEditorPart ) part ; treturn isCljFile ( editor ) ; } treturn false ; } 
public void toggleLineBreakpoints ( IWorkbenchPart part , ISelection selection ) tthrows CoreException { tTextSelection textSelection = ( TextSelection ) selection ; tint lineNumber = textSelection . getStartLine ( ) ; tIBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( ) ; if ( part instanceof IEditorPart ) { tIEditorPart editor = ( IEditorPart ) part ; 
private List < ISourceContainer > getSrcFoldersAsISourceContainers ( ILaunchConfiguration configuration ) throws CoreException { tString projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { tthrow new CoreException ( new Status ( IStatus . ERROR , CCWPlugin . PLUGIN_ID , " Clojure SourcePathComputerDelegate unable to correctly set the clojure sources in the class because the considered launch configuration does not have an associated project " ) ) ; 
public void resourceChanged ( IResourceChangeEvent e ) { tIResourceDelta delta = e . getDelta ( ) ; if ( delta ! = null ) { tIResourceDelta child = delta . findMember ( ResourcesPlugin 
public static void addAttribute ( Map attributes , IStorage storage ) { tattributes . put ( STORAGE_ID , storageId ( storage ) ) ; } 
public static void associate ( IMarker marker , IStorage storage ) { ttry { tmarker . setAttribute ( STORAGE_ID , storageId ( storage ) ) ; 
protected void deleteMarkers ( IMarker [ ] markers ) throws CoreException { tResourcesPlugin . getWorkspace ( ) . deleteMarkers ( markers ) ; } 
protected boolean isAcceptable ( IMarker marker ) { ttry { treturn marker . getAttribute ( STORAGE_ID ) . equals ( storageId ( fStorage ) ) ; 
private static String storageId ( IStorage storage ) { treturn storage . getFullPath ( ) . toPortableString ( ) ; } 
protected void listenToMarkerChanges ( boolean listen ) { if ( listen ) tResourcesPlugin . getWorkspace ( ) . addResourceChangeListener ( resourceChangeListener ) ; 
protected IMarker [ ] retrieveMarkers ( ) throws CoreException { tIMarker [ ] allMarkers = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . findMarkers ( null , true , IResource . DEPTH_ZERO ) ; tArrayList < IMarker > markers = new ArrayList < IMarker > ( ) ; tfor ( IMarker marker : allMarkers ) if ( isAcceptable ( marker ) ) tmarkers . add ( marker ) ; treturn markers . toArray ( new IMarker [ 0 ] ) ; } 
protected boolean isAcceptable ( IMarker marker ) { ttry { treturn storageId ( fStorage ) . equals ( marker . getAttribute ( STORAGE_ID ) ) ; 
public final void mEscapeSequence ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:78:9: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UnicodeEscape | OctalEscape ) 
public final void mUnicodeEscape ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:86:9: ( '\\\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT ) 
public final void mOctalEscape ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:92:9: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ) 
public final void mNAME ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:131:9: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:136:9: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:142:9: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public void mTokens ( ) throws RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt25=28; alt25 = dfa25.predict(input); switch (alt25) { case 1 : 
public final void literal ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:149:9: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g: { if ( input.LA(1)==STRING||(input.LA(1)>=NUMBER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:209:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("208:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:209:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1421); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:210:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1431); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:211:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1441); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:212:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1451); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1461); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1471); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:9: ( regexForm | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==NUMBER_SIGN) ) { switch ( input.LA(2) ) { case STRING: { alt6=1; } break; case APOSTROPHE: { alt6=2; } break; case OPEN_PAREN: { alt6=3; } break; default: NoViableAltException nvae = new NoViableAltException("217:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 1, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("217:1: dispatchMacroForm : ( regexForm | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:9: regexForm { pushFollow(FOLLOW_regexForm_in_dispatchMacroForm1498); regexForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:219:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1508); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:220:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1520); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1549); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1573); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1601); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:235:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:235:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1634); pushFollow(FOLLOW_form_in_quoteForm1636); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:238:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:238:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1650); pushFollow(FOLLOW_form_in_metaForm1652); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:241:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:241:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1669); pushFollow(FOLLOW_form_in_derefForm1671); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:248:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:248:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1711); pushFollow(FOLLOW_form_in_syntaxQuoteForm1713); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:255:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:255:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1753); pushFollow(FOLLOW_form_in_unquoteForm1755); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:262:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:262:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1795); pushFollow(FOLLOW_form_in_unquoteSplicingForm1797); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1823); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void regexForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:268:13: ( NUMBER_SIGN STRING ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:268:13: NUMBER_SIGN STRING { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_regexForm1836); match(input,STRING,FOLLOW_STRING_in_regexForm1838); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1862); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1864); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("272:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:33: map { pushFollow(FOLLOW_map_in_metadataForm1867); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1871); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1873); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:272:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1875); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:276:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:276:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1896); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1898); pushFollow(FOLLOW_form_in_varQuoteForm1900); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:286:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:286:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1927); pushFollow(FOLLOW_list_in_lambdaForm1929); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; TODO: define separate preferences for the tokens that use black and gray? final RGB black = new RGB(0,0,0); final RGB gray = new RGB(128,128,128); final RGB literalColor = getElementColor(store, PreferenceConstants.EDITOR_LITERAL_COLOR, black); final RGB specialFormColor = getElementColor(store, PreferenceConstants.EDITOR_SPECIAL_FORM_COLOR, black); final RGB functionColor = getElementColor(store, PreferenceConstants.EDITOR_FUNCTION_COLOR, black); final RGB commentColor = getElementColor(store, PreferenceConstants.EDITOR_COMMENT_COLOR, black); final RGB globalVarColor = getElementColor(store, PreferenceConstants.EDITOR_GLOBAL_VAR_COLOR, black); final RGB keywordColor = getElementColor(store, PreferenceConstants.EDITOR_KEYWORD_COLOR, black); final RGB metadataTypehintColor = getElementColor(store, PreferenceConstants.EDITOR_METADATA_TYPEHINT_COLOR, black); final RGB macroColor = getElementColor(store, PreferenceConstants.EDITOR_MACRO_COLOR, black); colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.STRING, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.REGEX_LITERAL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, gray); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, black); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, black); $NON-NLS-1$ } 
protected void initAntlrTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorProvider ) ; tu . addTokenType ( ClojureLexer . STRING ) ; tu . addTokenType ( ClojureLexer . REGEX_LITERAL ) ; tu . addTokenType ( ClojureLexer . NUMBER ) ; tu . addTokenType ( ClojureLexer . CHARACTER ) ; tu . addTokenType ( ClojureLexer . NIL ) ; tu . addTokenType ( ClojureLexer . BOOLEAN ) ; tu . addTokenType ( ClojureLexer . SYMBOL ) ; tu . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; tu . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; tu . addTokenType ( IScanContext . SymbolType . MACRO ) ; } 
public final void mREGEX_LITERAL ( ) throws RecognitionException { try { int _type = REGEX_LITERAL ; 
public final void mEscapeSequence ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:82:9: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UnicodeEscape | OctalEscape ) 
public final void mUnicodeEscape ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:90:9: ( '\\\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT ) 
public final void mOctalEscape ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:96:9: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ) 
public final void mNAME ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:135:9: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:140:9: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:146:9: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public void mTokens ( ) throws RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | REGEX_LITERAL | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt27=29; alt27 = dfa27.predict(input); switch (alt27) { case 1 : 
public final void literal ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:153:9: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g: { if ( input.LA(1)==STRING||(input.LA(1)>=NUMBER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("212:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1483); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1493); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1503); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1513); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1523); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1533); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1560); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1570); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1582); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1611); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1635); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1663); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1696); pushFollow(FOLLOW_form_in_quoteForm1698); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1712); pushFollow(FOLLOW_form_in_metaForm1714); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1731); pushFollow(FOLLOW_form_in_derefForm1733); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1773); pushFollow(FOLLOW_form_in_syntaxQuoteForm1775); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1815); pushFollow(FOLLOW_form_in_unquoteForm1817); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1857); pushFollow(FOLLOW_form_in_unquoteSplicingForm1859); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1885); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1905); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1907); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("273:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:33: map { pushFollow(FOLLOW_map_in_metadataForm1910); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1914); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1916); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1918); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1939); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1941); pushFollow(FOLLOW_form_in_varQuoteForm1943); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1970); pushFollow(FOLLOW_list_in_lambdaForm1972); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public static IProject getProject ( ILaunchConfiguration configuration ) throws CoreException { tString projectName = configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ; if ( projectName = = null ) { treturn null ; 
private static String fileArg ( IProject project , IFile file ) { tString FILE_ARG_ERROR_PREFIX = " When trying to create clojure.main " + " file arg to launch, was " + " unable to " ; tIPath filePath = file . getLocation ( ) ; tIJavaProject javaProject = ClojureCore . getJavaProject ( project ) ; ttry { tIPackageFragmentRoot filePFR = findPackageFragmentRoot ( javaProject , filePath ) ; 
private static IPackageFragmentRoot findPackageFragmentRoot ( IJavaProject javaProject , IPath filePath ) throws JavaModelException { if ( filePath . isEmpty ( ) ) { treturn null ; 
static public String getFilesToLaunchAsCommandLineList ( ILaunchConfiguration config , boolean lastFileAsScript ) throws CoreException { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( config ) ; treturn LaunchUtils . getProgramArguments ( getProject ( config ) , filesToLaunch , lastFileAsScript ) ; 
public void init ( IPageBookViewPage page , IConsole console ) { tassert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; tassert TextConsole . class . isInstance ( console ) ; tthis . console = ( IOConsole ) console ; tthis . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { tinitNamespaceBrowser ( ) ; } } ) ; tinitializationThread . start ( ) ; } 
private synchronized void initNamespaceBrowser ( ) { if ( clojureClient = = null ) { tbindConsoleToClojureEnvironment ( ) ; } if ( clojureClient ! = null ) { tSystem . out . println ( " activated " ) ; 
private void bindConsoleToClojureEnvironment ( ) { torg . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; tboolean stop = false ; tint selfTimeout = 60000 ; if (Thread.interrupted()) { 
public void dispose ( ) { if ( initializationThread . isAlive ( ) ) { tinitializationThread . interrupt ( ) ; 
public IPresentationReconciler getPresentationReconciler ( tISourceViewer sourceViewer ) { tPresentationReconciler reconciler = new PresentationReconciler ( ) ; treconciler . setDocumentPartitioning ( getConfiguredDocumentPartitioning ( sourceViewer ) ) ; taddDamagerRepairerForContentType ( reconciler , tIDocument . DEFAULT_CONTENT_TYPE ) ; treturn reconciler ; } 
private void addDamagerRepairerForContentType ( tPresentationReconciler reconciler , String contentType ) { tDefaultDamagerRepairer dr = new DefaultDamagerRepairer ( tokenScanner ) { @Override public IRegion getDamageRegion ( ITypedRegion partition , tDocumentEvent e , boolean documentPartitioningChanged ) { treturn partition ; } } ; treconciler . setDamager ( dr , contentType ) ; treconciler . setRepairer ( dr , contentType ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , tDocumentEvent e , boolean documentPartitioningChanged ) { treturn partition ; } 
public IInformationControlCreator getInformationControlCreator ( tISourceViewer sourceViewer ) { treturn new IInformationControlCreator ( ) { public IInformationControl createInformationControl ( Shell parent ) { 
public IInformationControl createInformationControl ( Shell parent ) { treturn new DefaultInformationControl ( parent , tnew HTMLTextPresenter ( ) ) ; 
public void initTokenScanner ( ) { ttokenScanner = new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) 
public IAutoEditStrategy [ ] getAutoEditStrategies ( tISourceViewer sourceViewer , final String contentType ) { treturn new IAutoEditStrategy [ ] { new IAutoEditStrategy ( ) { 
public void customizeDocumentCommand ( IDocument document , tDocumentCommand command ) { if ( command . doit ) { if ( command . length = = 0 ) { 
public void init ( IPageBookViewPage page , IConsole console ) { tassert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; tassert TextConsole . class . isInstance ( console ) ; tthis . console = ( IOConsole ) console ; tthis . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { tinitNamespaceBrowser ( ) ; } } ) ; tinitializationThread . start ( ) ; } 
public void activated ( ) { tactivateContext ( " ccw.ui.clojureEditorScope " ) ; } 
private static IContextService contextService ( ) { treturn ( IContextService ) PlatformUI . getWorkbench ( ) . getAdapter ( tIContextService . class ) ; 
private void activateContext ( String contextId ) { tcontextActivation = contextService ( ) . activateContext ( contextId ) ; } 
private void deactivateContext ( ) { if ( contextActivation ! = null ) { tcontextService ( ) . deactivateContext ( contextActivation ) ; 
public void connect ( TextConsole console ) { }} 
public void disconnect ( ) { }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { tNamespaceBrowser . setClojureClient ( clojureClient ) ; 
public IAutoEditStrategy [ ] getAutoEditStrategies ( tISourceViewer sourceViewer , final String contentType ) { treturn new IAutoEditStrategy [ ] { tnew PareditAutoEditStrategy ( ) 
private String safeToString ( Object value ) { ttry { treturn value = = null ? NOT_AVAILABLE : value . toString ( ) ; 
public IToken evaluate ( ICharacterScanner scanner , boolean resume ) { if ( resume = = true ) { tthrow new IllegalArgumentException ( " unhandled case when resume = true " ) ; 
public IToken evaluate ( ICharacterScanner scanner ) { tint firstChar = scanner . read ( ) ; if ( ( char ) firstChar ! = '\\' ) { tscanner . unread ( ) ; 
public IAutoEditStrategy [ ] getAutoEditStrategies ( tISourceViewer sourceViewer , final String contentType ) { treturn new IAutoEditStrategy [ ] { tnew PareditAutoEditStrategy ( fPreferenceStore ) 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . ACTIVATE_PAREDIT , Messages . ClojurePreferencePage_activate_paredit , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( ccw . preferences . PreferenceConstants . ACTIVATE_PAREDIT , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new FormatAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; } 
public void run ( ) { tIDocument document = editor . getDocument ( ) ; tString original = document . get ( ) ; tString formatted = new ClojureFormat ( ) . formatCode ( original ) ; if ( ! formatted . equals ( original ) ) { tdocument . set ( formatted ) ; 
public void run ( ) { IDocument original = editor . getDocument ( ) ; String originalContents = original . get ( ) ; String formatted = new ClojureFormat ( ) . formatCode ( originalContents ) ; if ( ! formatted . equals ( originalContents ) ) { replaceWithIndented ( original , new Document ( formatted ) ) ; 
private ReplaceEdit replacementLine ( IDocument original , int i , String formattedLine ) throws BadLocationException { return new ReplaceEdit ( original . getLineOffset ( i ) , original . getLineLength ( i ) , formattedLine ) ; } 
private String getLine ( IDocument document , int lineNumber ) throws BadLocationException { return document . get ( document . getLineOffset ( lineNumber ) , document . getLineLength ( lineNumber ) ) ; } 
public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { super . init ( site , input ) ; } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { support . setCharacterPairMatcher ( pairsMatcher ) ; support . setMatchingCharacterPainterPreferenceKeys ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR ) ; super . configureSourceViewerDecorationSupport ( support ) ; } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; ISourceViewer viewer= new ProjectionViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles); ISourceViewer viewer = new ClojureSourceViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles, getPreferenceStore()); ensure decoration support has been created and configured. getSourceViewerDecorationSupport(viewer); return viewer; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; TODO remove the 2 following lines ? fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.error"); $NON-NLS-1$ fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.warning"); $NON-NLS-1$ fProjectionSupport.install(); viewer.doOperation(ClojureSourceViewer.TOGGLE); } 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . toArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) { return ; } int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) { selectAndReveal ( previousMemberOffset , 0 ) ; 
public void selectTopLevelSExpression ( ) { IRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) { selectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) { return ; } int sourceCaretOffset = getSourceCaretOffset ( ) ; int endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) { selectAndReveal ( endOfMemberOffset , 0 ) ; 
private boolean matchChar ( char c , char [ ] charsToMatch ) { for ( char ctm : charsToMatch ) { if ( c = = ctm ) { return true ; } } return false ; } 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { " ccw.ui.clojureEditorScope " } ) ; $NON-NLS-1$ } 
public void dispose ( ) { if ( pairsMatcher ! = null ) { pairsMatcher . dispose ( ) ; pairsMatcher = null ; } super . dispose ( ) ; } 
public final ISourceViewer sourceViewer ( ) { return super . getSourceViewer ( ) ; } 
private void selectToMatchingBracket ( ) { ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getSignedSelection ( sourceViewer ) ; boolean previousSelectionExists = Math . abs ( selection . getLength ( ) ) > 1 ; if ( previousSelectionExists ) { String error = ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ; 
public void showError ( ISourceViewer sourceViewer , String error ) { editor . setStatusLineErrorMessage ( error ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; } 
public int targetOffsetAdjustment ( int anchor ) { return ICharacterPairMatcher . RIGHT = = anchor ? - 1 : 0 ; } 
public int offsetAdjustment ( int sourceCaretOffset , int offset , int length , int anchor ) { switch ( anchor ) { case ICharacterPairMatcher . LEFT : 
public boolean visible ( ISourceViewer sourceViewer , int targetOffset ) { if ( sourceViewer instanceof ITextViewerExtension5 ) { ITextViewerExtension5 extension = ( ITextViewerExtension5 ) sourceViewer ; 
public void run ( ) { IDocument original = editor . getDocument ( ) ; ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getSignedSelection ( sourceViewer ) ; int sourceCaretOffset = selection . getOffset ( ) + selection . getLength ( ) ; String originalContents = original . get ( ) ; String formatted = new ClojureFormat ( ) . formatCode ( originalContents ) ; if ( ! formatted . equals ( originalContents ) ) { original . set ( formatted ) ; 
public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { super . init ( site , input ) ; 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; ISourceViewer viewer= new ProjectionViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles); ISourceViewer viewer = new ClojureSourceViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles, getPreferenceStore()); ensure decoration support has been created and configured. getSourceViewerDecorationSupport(viewer); viewer.getTextWidget().addCaretListener(new SameWordHighlightingCaretListener(this)); return viewer; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void propertyChange ( PropertyChangeEvent event ) { System . out . println ( " propertt change " ) ; if ( fConfiguration ! = null ) { ClojureSourceViewerConfiguration tmp = fConfiguration ; 
public void caretMoved ( CaretEvent event ) { try { IDocument document = editor . getDocument ( ) ; 
private StyleRange createRange ( ITokenScanner tokenScanner ) { StyleRange range = new StyleRange ( ) ; range . background = editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . getSystemColor ( 15 ) ; range . start = tokenScanner . getTokenOffset ( ) ; range . length = tokenScanner . getTokenLength ( ) ; return range ; } 
private IToken tokenAtCaret ( ITokenScanner tokenScanner , int caretOffset ) { IToken token = tokenScanner . nextToken ( ) ; while ( ! token . isEOF ( ) ) { if ( tokenScanner . getTokenOffset ( ) + tokenScanner . getTokenLength ( ) > caretOffset ) return token ; token = tokenScanner . nextToken ( ) ; } return token ; } 
private void startTokenScannerAtTheBeginningOfCurrentLine ( CaretEvent event , IDocument document , ITokenScanner tokenScanner ) throws BadLocationException { int lineOfOffset = document . getLineOfOffset ( event . caretOffset ) ; int lineOffset = document . getLineOffset ( lineOfOffset ) ; int lineLength = document . getLineLength ( lineOfOffset ) ; tokenScanner . setRange ( document , lineOffset , lineLength ) ; } 
public IAutoEditStrategy [ ] getAutoEditStrategies ( tISourceViewer sourceViewer , final String contentType ) { treturn new IAutoEditStrategy [ ] { tnew PareditAutoEditStrategy ( editor , fPreferenceStore ) 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { super . run ( ) ; String lib = editor . getDeclaringNamespace ( ) ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; String compilationResult = clojure . remoteLoad ( CompileLibAction . compileLibCommand ( lib ) ) ; refreshCompilationResults ( ) ; if ( compilationResult . contains ( " \" response-type \" 0, " ) ) { runTests ( lib , clojure ) ; 
private void runTests ( String lib , ClojureClient clojure ) { String results = clojure . remoteLoad ( runTestsCommand ( lib ) ) ; if ( results . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
private void refreshCompilationResults ( ) { try { IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; 
public static String runTestsCommand ( String libName ) { return " (clojure.test/run-tests' " + libName + " ) " ; } 
private void selectToMatchingBracket ( ) { ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getUnSignedSelection ( sourceViewer ) ; boolean previousSelectionExists = Math . abs ( selection . getLength ( ) ) > 1 ; { int sourceCaretOffset = selection . getOffset ( ) ; 
public void actualSelection ( ISourceViewer sourceViewer , IRegion selection , int sourceCaretOffset , int offset , int length , int anchor , int targetOffset ) { int distanceBetweenBrackets = sourceCaretOffset - targetOffset + offsetAdjustment ( sourceCaretOffset , offset , length , anchor ) ; sourceViewer . setSelectedRange ( targetOffset + targetOffsetAdjustment ( anchor ) , distanceBetweenBrackets ) ; sourceViewer . revealRange ( targetOffset + targetOffsetAdjustment ( anchor ) , distanceBetweenBrackets ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new SelectToMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( SelectToMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new Action ( ) { public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; 
public void propertyChange ( PropertyChangeEvent event ) { System . out . println ( " property change " ) ; if ( fConfiguration ! = null ) { ClojureSourceViewerConfiguration tmp = fConfiguration ; 
private StyleRange createRange ( ITokenScanner tokenScanner ) { StyleRange range = new StyleRange ( ) ; range . background = new Color ( editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) , 225 , 225 , 225 ) ; range . start = tokenScanner . getTokenOffset ( ) ; range . length = tokenScanner . getTokenLength ( ) ; return range ; } 
private StyleRange createRange ( ITokenScanner tokenScanner ) { StyleRange range = new StyleRange ( ) ; range . background = new Color ( editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) , 225 , 225 , 225 ) ; range . start = tokenScanner . getTokenOffset ( ) ; range . length = tokenScanner . getTokenLength ( ) ; return range ; } 
public void run ( ) { IDocument original = editor . getDocument ( ) ; ISourceViewer sourceViewer = editor . sourceViewer ( ) ; try { String originalContents = original . get ( ) ; 
private void selectToMatchingBracket ( ) { ISourceViewer sourceViewer = editor . sourceViewer ( ) ; IRegion selection = editor . getUnSignedSelection ( sourceViewer ) ; boolean previousSelectionExists = Math . abs ( selection . getLength ( ) ) > 1 ; { int caretOffset = selection . getOffset ( ) ; 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( OutwardExpandingSelectAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new Action ( ) { public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void actualSelection ( IDocument document , ISourceViewer sourceViewer , int sourceCaretOffset , int offset , int length , int anchor , int targetOffset ) { int distanceBetweenBrackets = sourceCaretOffset - targetOffset + offsetAdjustment ( sourceCaretOffset , offset , length , anchor ) ; int adjustedTargetOffset = targetOffset + targetOffsetAdjustment ( anchor ) ; if ( distanceBetweenBrackets < 0 ) { adjustedTargetOffset = adjustedTargetOffset + distanceBetweenBrackets ; distanceBetweenBrackets = Math . abs ( distanceBetweenBrackets ) ; } if ( previousCharacterIsPound ( document , adjustedTargetOffset ) ) { adjustedTargetOffset - - ; distanceBetweenBrackets + + ; } sourceViewer . setSelectedRange ( adjustedTargetOffset , distanceBetweenBrackets ) ; sourceViewer . revealRange ( adjustedTargetOffset , distanceBetweenBrackets ) ; } 
public boolean previousCharacterIsPound ( IDocument document , int adjustedTargetOffset ) { try { String previousCharacter = document . get ( adjustedTargetOffset - 1 , 1 ) ; 
public static String runTestsCommand ( String libName ) { return " (clojure.test/run-tests' " + testLibName ( libName ) + " ) " ; } 
public static String testLibName ( String libName ) { if ( libName . endsWith ( " -test " ) ) { return libName ; } return libName + " -test " ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( OutwardExpandingSelectAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void caretMoved ( CaretEvent event ) { IDocument document = editor . getDocument ( ) ; Tokens tokens = new Tokens ( document , event . caretOffset ) ; tokens . putTokenScannerRangeOnCurrentLine ( ) ; IToken tokenAtCaret = tokens . tokenAtCaret ( ) ; boolean wordIsNotFormatted = tokenAtCaret . getData ( ) = = null ; if ( wordIsNotFormatted ) { StyleRange range = createRange ( tokens ) ; 
private StyleRange createRange ( Tokens tokens ) { return tokens . styleRange ( new Color ( editor . sourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) , 225 , 225 , 225 ) ) ; } 
public static ITokenScanner tokenScanner ( ) { return new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) ) ; } 
public void putTokenScannerRangeOnCurrentLine ( ) { try { int caretLineNumber = document . getLineOfOffset ( caretOffset ) ; 
public int offsetOfNthTokenOnLine ( int line , int tokenCount ) { setTokenScannerRangeOnLine ( line ) ; while ( tokenCount - - > 0 ) { tokenScanner . nextToken ( ) ; } return tokenScanner . getTokenOffset ( ) ; } 
public int caretLine ( ) { try { return document . getLineOfOffset ( caretOffset ) ; 
public int sameStructuralOffset ( Tokens tokens ) { int tokenOffset = tokens . offsetOfTokenUnderCaret ( ) ; int offsetFromBeginningOfToken = tokens . caretOffset ( ) - tokenOffset ; int caretLine = tokens . caretLine ( ) ; int numberOfTokenUnderCaret = tokens . numberOfTokenUnderCaret ( ) ; int offsetOfNthTokenOnLine = offsetOfNthTokenOnLine ( caretLine , numberOfTokenUnderCaret ) ; return offsetOfNthTokenOnLine + offsetFromBeginningOfToken ; } 
public IRegion tokenRegion ( ) { return new Region ( tokenScanner . getTokenOffset ( ) , tokenScanner . getTokenLength ( ) ) ; } 
public StyleRange styleRange ( Color color ) { StyleRange range = new StyleRange ( ) ; range . start = getTokenOffset ( ) ; range . length = getTokenLength ( ) ; range . background = color ; return range ; } 
public String tokenContents ( ) { try { return document . get ( getTokenOffset ( ) , getTokenLength ( ) ) ; 
public void run ( ) { IDocument original = editor . getDocument ( ) ; ISourceViewer sourceViewer = editor . sourceViewer ( ) ; String originalContents = original . get ( ) ; String formatted = new ClojureFormat ( ) . formatCode ( originalContents ) ; if ( ! formatted . equals ( originalContents ) ) { replaceOriginalWithFormatted ( original , sourceViewer , formatted ) ; 
private void replaceOriginalWithFormatted ( IDocument original , ISourceViewer sourceViewer , String formatted ) { IRegion selection = editor . getSignedSelection ( sourceViewer ) ; Tokens tokens = new Tokens ( original , selection ) ; Document formattedDocument = new Document ( formatted ) ; Tokens formattedTokens = new Tokens ( formattedDocument ) ; int targetOffset = formattedTokens . sameStructuralOffset ( tokens ) ; original . set ( formatted ) ; sourceViewer . setSelectedRange ( targetOffset , 0 ) ; sourceViewer . revealRange ( targetOffset , 0 ) ; } 
private static IToken newParenTokenWith ( Color color ) { return new org . eclipse . jface . text . rules . Token ( new TextAttribute ( color ) ) ; } 
public final void addTokenType ( Object tokenIndex , org . eclipse . jface . text . rules . Token token ) { if ( initialized ) { throw lifeCycleError ( ) ; } antlrTokenTypeToJFaceToken . put ( tokenIndex , token ) ; } 
public final void addTokenType ( Object tokenIndex , TextAttribute textAttribute ) { if ( initialized ) { throw lifeCycleError ( ) ; } addTokenType ( tokenIndex , new org . eclipse . jface . text . rules . Token ( textAttribute ) ) ; } 
public final void addToken ( int tokenIndex , String tokenData ) { if ( initialized ) { throw lifeCycleError ( ) ; } addTokenType ( tokenIndex , new org . eclipse . jface . text . rules . Token ( tokenData ) ) ; } 
private RuntimeException lifeCycleError ( ) { return new RuntimeException ( " Object Lifecycle error: method called at an inappropriate time " ) ; } 
public final IToken nextToken ( ) { int nextIndex = currentTokenIndex + 1 ; if ( nextIndex > = tokensData . size ( ) ) { return org . eclipse . jface . text . rules . Token . EOF ; } currentTokenIndex = nextIndex ; TokenData token = tokensData . get ( currentTokenIndex ) ; if ( token ! = null ) { IToken result ; 
private void repositionCurrentTokenAtOffset ( int offset ) { currentParenLevel = 0 ; int size = tokensData . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { TokenData tokenInfo = tokensData . get ( i ) ; 
private IToken guessEclipseTokenForSymbol ( CommonToken symbolToken ) { String symbol = symbolToken . getText ( ) ; IScanContext . SymbolType symbolType = context . getSymbolType ( symbol ) ; if ( symbolType = = null ) { return null ; 
public void actualSelection ( IDocument document , ISourceViewer sourceViewer , int sourceCaretOffset , int offset , int length , int anchor , int targetOffset ) { int distanceBetweenBrackets = sourceCaretOffset - targetOffset + offsetAdjustment ( sourceCaretOffset , offset , length , anchor ) ; int adjustedTargetOffset = targetOffset + targetOffsetAdjustment ( anchor ) ; if ( distanceBetweenBrackets < 0 ) { adjustedTargetOffset = adjustedTargetOffset + distanceBetweenBrackets ; distanceBetweenBrackets = Math . abs ( distanceBetweenBrackets ) ; } if ( previousCharacterIsPound ( document , adjustedTargetOffset ) ) { adjustedTargetOffset - - ; distanceBetweenBrackets + + ; } showSelection ( sourceViewer , adjustedTargetOffset , distanceBetweenBrackets ) ; } 
public void showSelection ( ISourceViewer sourceViewer , int offset , int length ) { sourceViewer . setSelectedRange ( offset , length ) ; sourceViewer . revealRange ( offset , length ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TO_MATCHING_BRACKET ) ; setAction ( OutwardExpandingSelectAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new NavigationToDefinitionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . NAVIGATE_TO_DEFINITION ) ; setAction ( NavigationToDefinitionAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { int caretOffset = editor . sourceViewer ( ) . getTextWidget ( ) . getCaretOffset ( ) ; Tokens tokens = new Tokens ( editor . getDocument ( ) , caretOffset ) ; String tokenContents = tokens . tokenContents ( ) ; String [ ] split = tokenContents . split ( " / " ) ; String lastPart = split [ split . length - 1 ] ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; PersistentArrayMap result2 = ( PersistentArrayMap ) clojure . remoteLoadRead ( " (ccw.debug.serverrepl/find-symbol \" " + lastPart + " \" ) " ) ; System . out . println ( " searching for " + tokenContents + " --> " + result2 ) ; PersistentArrayMap result = ( PersistentArrayMap ) result2 . get ( " response " ) ; String file = ( String ) result . get ( Keyword . intern ( null , " file " ) ) ; String ns = ( String ) result . get ( Keyword . intern ( null , " ns " ) ) ; Integer line = Integer . valueOf ( ( String ) result . get ( Keyword . intern ( null , " line " ) ) ) ; ClojureCore . openInEditor ( ns , file , line ) ; } 
public String tokenContents ( ) { tokenAtCaret ( ) ; try { return document . get ( getTokenOffset ( ) , getTokenLength ( ) ) ; 
private synchronized void initNamespaceBrowser ( ) { if ( clojureClient = = null ) { tbindConsoleToClojureEnvironment ( ) ; } if ( clojureClient ! = null ) { taddPatternMatchListener ( this . console ) ; 
public int sameStructuralOffset ( Tokens tokens ) { if ( tokens . caretOffset = = 0 ) { return 0 ; } int tokenOffset = tokens . offsetOfTokenUnderCaret ( ) ; int offsetFromBeginningOfToken = tokens . caretOffset ( ) - tokenOffset ; int caretLine = tokens . caretLine ( ) ; int numberOfTokenUnderCaret = tokens . numberOfTokenUnderCaret ( ) ; int offsetOfNthTokenOnLine = offsetOfNthTokenOnLine ( caretLine , numberOfTokenUnderCaret ) ; return offsetOfNthTokenOnLine + offsetFromBeginningOfToken ; } 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; this . console = ( IOConsole ) console ; this . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { initNamespaceBrowser ( ) ; } } ) ; initializationThread . start ( ) ; System . err . println ( " hai4uuuu " + this ) ; } 
public void run ( ) { initNamespaceBrowser ( ) ; } 
public void activated ( ) { activateContext ( " ccw.ui.clojureEditorScope " ) ; $NON-NLS-1$ } 
private static IContextService contextService ( ) { return ( IContextService ) PlatformUI . getWorkbench ( ) . getAdapter ( IContextService . class ) ; } 
private void activateContext ( String contextId ) { System . err . println ( " contextActivation: " + contextActivation ) ; contextActivation = contextService ( ) . activateContext ( contextId ) ; System . out . println ( " started: " + contextActivation ) ; if ( contextActivation = = null ) throw new IllegalStateException ( " fuck " ) ; 
private void deactivateContext ( ) { System . out . println ( " deactivating... " + contextActivation ) ; System.out.println("act: " + contextService().getActiveContextIds()); System.out.println("wat: " + contextService().getContext("ccw.ui.clojureEditorScope")); if (contextActivation != null) { System.out.println("act1: " + 
private synchronized void initNamespaceBrowser ( ) { if ( clojureClient = = null ) { bindConsoleToClojureEnvironment ( ) ; } if ( clojureClient ! = null ) { addPatternMatchListener ( this . console ) ; 
private void bindConsoleToClojureEnvironment ( ) { org . eclipse . debug . ui . console . IConsole processConsole = ( org . eclipse . debug . ui . console . IConsole ) console ; boolean stop = false ; int selfTimeout = 60000 ; 60 seconds while (!stop && selfTimeout > 0) { if (Thread.interrupted()) { 
public void dispose ( ) { deactivateContext ( ) ; if ( initializationThread . isAlive ( ) ) { initializationThread . interrupt ( ) ; 
public void connect ( TextConsole console ) { Nothing } public void disconnect() { Nothing } public void matchFound(PatternMatchEvent event) { if (clojureClient != null) { NamespaceBrowser.setClojureClient(clojureClient); } } }); }} 
public void disconnect ( ) { Nothing } public void matchFound(PatternMatchEvent event) { if (clojureClient != null) { NamespaceBrowser.setClojureClient(clojureClient); } } }); }} 
public void matchFound ( PatternMatchEvent event ) { if ( clojureClient ! = null ) { NamespaceBrowser . setClojureClient ( clojureClient ) ; 
public void init ( IPageBookViewPage page , IConsole console ) { assert org . eclipse . debug . ui . console . IConsole . class . isInstance ( console ) ; assert TextConsole . class . isInstance ( console ) ; this . console = ( IOConsole ) console ; this . initializationThread = new Thread ( new Runnable ( ) { public void run ( ) { initNamespaceBrowser ( ) ; } } ) ; initializationThread . start ( ) ; } 
private void activateContext ( String contextId ) { contextActivation = contextService ( ) . activateContext ( contextId ) ; if ( contextActivation = = null ) { throw new IllegalStateException ( " fuck " ) ; 
private void deactivateContext ( ) { if ( contextActivation ! = null ) { contextService ( ) . deactivateContext ( contextActivation ) ; 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new OpenDeclarationAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; .getDefault().getColorRegistry())); return viewer; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new OpenDeclarationAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
private void initColorRegistry ( ) { if ( ! colorRegistry . hasValueFor ( FAILED_TESTS_COLOR_KEY ) ) { tcolorRegistry . put ( FAILED_TESTS_COLOR_KEY , new RGB ( 0xff , 0xff , 0xcf ) ) ; } if ( ! colorRegistry . hasValueFor ( PASSED_TESTS_COLOR_KEY ) ) { tcolorRegistry . put ( PASSED_TESTS_COLOR_KEY , new RGB ( 0xcf , 0xff , 0xcf ) ) ; 
private void initColorRegistry ( ) { if ( ! colorRegistry . hasValueFor ( COLOR_KEY ) ) { tcolorRegistry . put ( COLOR_KEY , new RGB ( 225 , 225 , 225 ) ) ; } if ( ! colorRegistry . hasValueFor ( OTHER_MATCHES_COLOR_KEY ) ) { tcolorRegistry . put ( OTHER_MATCHES_COLOR_KEY , new RGB ( 255 , 255 , 180 ) ) ; 
private StyleRange createRange ( Tokens tokens ) { return tokens . styleRange ( colorRegistry . get ( COLOR_KEY ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new OpenDeclarationAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; 
public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( sourceViewer ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } #26314 int sourceCaretOffset = selection.getOffset() + selection.getLength(); From JavaEditor, but I don't understand what it does so I maintain it commented out if (isSurroundedByBrackets(document, sourceCaretOffset)) sourceCaretOffset -= selection.getLength(); IRegion region = pairsMatcher.match(document, sourceCaretOffset); if (region == null) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_noMatchingBracket); sourceViewer.getTextWidget().getDisplay().beep(); return; } int offset = region.getOffset(); int length = region.getLength(); if (length < 1) return; int anchor = pairsMatcher.getAnchor(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 int targetOffset = (ICharacterPairMatcher.RIGHT == anchor) ? offset + 1 : offset + length; boolean visible = false; if (sourceViewer instanceof ITextViewerExtension5) { ITextViewerExtension5 extension = (ITextViewerExtension5) sourceViewer; visible = (extension.modelOffset2WidgetOffset(targetOffset) > -1); } else { IRegion visibleRegion = sourceViewer.getVisibleRegion(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 visible = (targetOffset >= visibleRegion.getOffset() && targetOffset <= visibleRegion.getOffset() + visibleRegion.getLength()); } if (!visible) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_bracketOutsideSelectedElement); sourceViewer.getTextWidget().getDisplay().beep(); return; } if (selection.getLength() < 0) targetOffset -= selection.getLength(); sourceViewer.setSelectedRange(targetOffset, selection.getLength()); sourceViewer.revealRange(targetOffset, selection.getLength()); } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) selectAndReveal ( previousMemberOffset , 0 ) ; 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) return false ; IRegion selection = getSignedSelection ( getSourceViewer ( ) ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { setStatusLineErrorMessage ( errorMessageIfProblem ) ; getSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return false ; } return true ; } 
public void selectTopLevelSExpression ( ) { IRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) selectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public final ISourceViewer sourceViewer ( ) { return super . getSourceViewer ( ) ; } 
protected ISourceViewer createSourceViewer ( Composite parent , IVerticalRuler ruler , int styles ) { fAnnotationAccess = createAnnotationAccess ( ) ; fOverviewRuler = createOverviewRuler ( getSharedColors ( ) ) ; ISourceViewer viewer= new ProjectionViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles); ISourceViewer viewer= new ClojureSourceViewer(parent, ruler, getOverviewRuler(), isOverviewRulerVisible(), styles, getPreferenceStore()); ensure decoration support has been created and configured. getSourceViewerDecorationSupport(viewer); return viewer; } 
public void createPartControl ( Composite parent ) { super . createPartControl ( parent ) ; ClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; fProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; TODO remove the 2 following lines ? fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.error"); $NON-NLS-1$ fProjectionSupport.addSummarizableAnnotationType("org.eclipse.ui.workbench.texteditor.warning"); $NON-NLS-1$ fProjectionSupport.install(); viewer.doOperation(ClojureSourceViewer.TOGGLE); } 
private IPreferenceStore createCombinedPreferenceStore ( ) { List < IPreferenceStore > stores = new LinkedList < IPreferenceStore > ( ) ; stores . add ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; stores . add ( EditorsUI . getPreferenceStore ( ) ) ; stores . add ( PlatformUI . getPreferenceStore ( ) ) ; return new ChainedPreferenceStore ( stores . toArray ( new IPreferenceStore [ stores . size ( ) ] ) ) ; } 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); action = new OutwardExpandingSelectionAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.OUTWARD_EXPANDING_SELECTION); setAction(OutwardExpandingSelectionAction.ID, action); action = new RunTestsAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.RUN_TESTS); setAction(RunTestsAction.RUN_TESTS_ID, action); action = new FormatAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.FORMAT_CODE); setAction(FormatAction.ID, action); action = new OpenDeclarationAction(this); action.setActionDefinitionId(IClojureEditorActionDefinitionIds.OPEN_DECLARATION); setAction(OpenDeclarationAction.ID, action); action = new Action() { @Override public void run() { new ClojureLaunchShortcut().launch(AntlrBasedClojureEditor.this, ILaunchManager.RUN_MODE); }; }; action.setActionDefinitionId(IClojureEditorActionDefinitionIds.LAUNCH_REPL); setAction("ClojureLaunchAction", action); 
public void gotoMatchingBracket ( ) { ISourceViewer sourceViewer = getSourceViewer ( ) ; IDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) return ; IRegion selection = getSignedSelection ( sourceViewer ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { setStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ; sourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return ; } #26314 int sourceCaretOffset= selection.getOffset() + selection.getLength(); From JavaEditor, but I don't understand what it does so I maintain it commented out if (isSurroundedByBrackets(document, sourceCaretOffset)) sourceCaretOffset -= selection.getLength(); IRegion region= pairsMatcher.match(document, sourceCaretOffset); if (region == null) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_noMatchingBracket); sourceViewer.getTextWidget().getDisplay().beep(); return; } int offset= region.getOffset(); int length= region.getLength(); if (length < 1) return; int anchor= pairsMatcher.getAnchor(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 int targetOffset= (ICharacterPairMatcher.RIGHT == anchor) ? offset + 1: offset + length; boolean visible= false; if (sourceViewer instanceof ITextViewerExtension5) { ITextViewerExtension5 extension= (ITextViewerExtension5) sourceViewer; visible= (extension.modelOffset2WidgetOffset(targetOffset) > -1); } else { IRegion visibleRegion= sourceViewer.getVisibleRegion(); http:dev.eclipse.org/bugs/show_bug.cgi?id=34195 visible= (targetOffset >= visibleRegion.getOffset() && targetOffset <= visibleRegion.getOffset() + visibleRegion.getLength()); } if (!visible) { setStatusLineErrorMessage(ClojureEditorMessages.GotoMatchingBracket_error_bracketOutsideSelectedElement); sourceViewer.getTextWidget().getDisplay().beep(); return; } if (selection.getLength() < 0) targetOffset -= selection.getLength(); sourceViewer.setSelectedRange(targetOffset, selection.getLength()); sourceViewer.revealRange(targetOffset, selection.getLength()); } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) selectAndReveal ( previousMemberOffset , 0 ) ; 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) return false ; IRegion selection = getSignedSelection ( getSourceViewer ( ) ) ; int selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { setStatusLineErrorMessage ( errorMessageIfProblem ) ; getSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; return false ; } return true ; } 
public void selectTopLevelSExpression ( ) { IRegion r = getTopLevelSExpression ( ) ; if ( r ! = null ) selectAndReveal ( r . getOffset ( ) , r . getLength ( ) ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracket_error_invalidSelection ) ) return ; int sourceCaretOffset = getSourceCaretOffset ( ) ; int endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) selectAndReveal ( endOfMemberOffset , 0 ) ; 
private boolean matchChar ( char c , char [ ] charsToMatch ) { for ( char ctm : charsToMatch ) if ( c = = ctm ) return true ; return false ; } 
protected void initializeKeyBindingScopes ( ) { setKeyBindingScopes ( new String [ ] { " ccw.ui.clojureEditorScope " } ) ; $NON-NLS-1$ } 
public boolean previousCharacterIsPound ( IDocument document , int adjustedTargetOffset ) { try { if ( adjustedTargetOffset = = 0 ) { 
protected void createActions ( ) { super . createActions ( ) ; Action action = new GotoMatchingBracketAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; setAction ( GotoMatchingBracketAction . ID , action ) ; action = new OutwardExpandingSelectionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; setAction ( OutwardExpandingSelectionAction . ID , action ) ; action = new GotoNextMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; setAction ( GotoNextMemberAction . ID , action ) ; action = new GotoPreviousMemberAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; setAction ( GotoPreviousMemberAction . ID , action ) ; action = new SelectTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; setAction ( SelectTopLevelSExpressionAction . ID , action ) ; action = new EvaluateTopLevelSExpressionAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; setAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; action = new LoadFileAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; setAction ( LoadFileAction . ID , action ) ; action = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; setAction ( RunTestsAction . RUN_TESTS_ID , action ) ; action = new CompileLibAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; setAction ( CompileLibAction . ID , action ) ; action = new FormatAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; setAction ( FormatAction . ID , action ) ; action = new reload_clojure ( ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RELOAD_CLOJURE ) ; setAction ( " reload_clojure " , action ) ; action = new OpenDeclarationAction ( this ) ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; setAction ( OpenDeclarationAction . ID , action ) ; action = new Action ( ) { @Override public void run ( ) { new ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; action . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; setAction ( " ClojureLaunchAction " , action ) ; action = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; $NON-NLS-1$ String id = ITextEditorActionDefinitionIds.CONTENT_ASSIST_PROPOSALS; action.setActionDefinitionId(id); setAction(CONTENT_ASSIST_PROPOSAL, action); markAsStateDependentAction(CONTENT_ASSIST_PROPOSAL, true); } 
private static void activateReplAndShowConsole ( IWorkbenchPage page , IViewPart v , IConsole console ) { IConsoleView cv = ( IConsoleView ) v ; page . activate ( cv ) ; cv . display ( console ) ; } 
public void createPartControl ( Composite theParent ) { tcontrol = new Composite ( theParent , SWT . NONE ) ; GridLayout gl = new GridLayout ( ) ; tgl . numColumns = 2 ; tcontrol . setLayout ( gl ) ; tLabel l = new Label ( control , SWT . NONE ) ; tl . setText ( " Find : " ) ; tl . setToolTipText ( " Enter an expression on which the browser will filter, based on name and doc string of vars " ) ; tGridData gd = new GridData ( ) ; tgd . verticalAlignment = SWT . CENTER ; tl . setLayoutData ( gd ) ; tfilterText = new Text ( control , SWT . FILL | SWT . BORDER ) ; tfilterText . setTextLimit ( 10 ) ; tfilterText . setToolTipText ( " Enter here a word to search. It can be a regexp. e.g. \" -map$ \" (without double quotes) for matching strings ending with -map " ) ; tgd = new GridData ( ) ; tgd . horizontalAlignment = SWT . FILL ; tgd . verticalAlignment = SWT . CENTER ; tgd . grabExcessHorizontalSpace = true ; tfilterText . setLayoutData ( gd ) ; tfilterText . addModifyListener ( new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { tpatternString = ( ( Text ) e . getSource ( ) ) . getText ( ) ; if ( " " . equals ( patternString . trim ( ) ) ) { if ( pattern ! = null ) { public void doubleClick(DoubleClickEvent event) { 
public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( patternString = = null | | patternString . trim ( ) . equals ( " " ) ) { treturn true ; 
private boolean recursiveElemMatches ( Object element ) { if ( elemMatches ( element ) ) { treturn true ; 
private boolean elemMatches ( Object element ) { tMap elem = ( Map ) element ; tString name = ( String ) elem . get ( KEYWORD_NAME ) ; tboolean nameMatches = name ! = null & & pattern . matcher ( name ) . find ( ) ; tString doc = ( String ) elem . get ( ClojureDocUtils . KEYWORD_DOC ) ; tboolean docMatches = doc ! = null & & pattern . matcher ( doc ) . find ( ) ; treturn nameMatches | | docMatches ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new OutwardExpandingSelectionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; tsetAction ( OutwardExpandingSelectionAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; taction = new FormatAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . FORMAT_CODE ) ; tsetAction ( FormatAction . ID , action ) ; taction = new OpenDeclarationAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; tsetAction ( OpenDeclarationAction . ID , action ) ; taction = new Action ( ) { @Override public void run ( ) { tnew ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; tsetAction ( " ClojureLaunchAction " , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; } 
public void run ( ) { tnew ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; 
protected boolean isTabsToSpacesConversionEnabled ( ) { treturn false ; } 
public IAutoEditStrategy [ ] getAutoEditStrategies ( tISourceViewer sourceViewer , final String contentType ) { treturn new IAutoEditStrategy [ ] { tnew PareditAutoEditStrategy ( editor , fPreferenceStore ) } ; 
public void run ( ) { tSystem . out . println ( " wrap round action enabled " ) ; editor.selectTopLevelSExpression(); 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new OutwardExpandingSelectionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; tsetAction ( OutwardExpandingSelectionAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; taction = new OpenDeclarationAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; tsetAction ( OpenDeclarationAction . ID , action ) ; taction = new Action ( ) { @Override public void run ( ) { tnew ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; tsetAction ( " ClojureLaunchAction " , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new OutwardExpandingSelectionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OUTWARD_EXPANDING_SELECTION ) ; tsetAction ( taction = new OpenDeclarationAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; tsetAction ( OpenDeclarationAction . ID , action ) ; taction = new Action ( ) { @Override public void run ( ) { tnew ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; tsetAction ( " ClojureLaunchAction " , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new ExpandSelectionUpAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EXPAND_SELECTION_UP ) ; tsetAction ( taction = new OpenDeclarationAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . OPEN_DECLARATION ) ; tsetAction ( OpenDeclarationAction . ID , action ) ; taction = new Action ( ) { @Override public void run ( ) { tnew ClojureLaunchShortcut ( ) . launch ( AntlrBasedClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; } ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LAUNCH_REPL ) ; tsetAction ( " ClojureLaunchAction " , action ) ; taction = new ContentAssistAction ( ClojureEditorMessages . getBundleForConstructedKeys ( ) , CONTENT_ASSIST_PROPOSAL + " . " , this ) ; } 
public void gotoMatchingBracket ( ) { tISourceViewer sourceViewer = getSourceViewer ( ) ; tIDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) treturn ; tIRegion selection = getSignedSelection ( sourceViewer ) ; tint selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { tsetStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ; tsourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; treturn ; } } 
public void gotoPreviousMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ) treturn ; tint sourceCaretOffset = getSourceCaretOffset ( ) ; tint previousMemberOffset = getBeginningOfCurrentOrPrecedingTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( previousMemberOffset > = 0 ) tselectAndReveal ( previousMemberOffset , 0 ) ; 
public void gotoEndOfMember ( ) { if ( ! checkSelectionAndWarnUserIfProblem ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ) treturn ; tint sourceCaretOffset = getSourceCaretOffset ( ) ; tint endOfMemberOffset = getEndOfCurrentOrNextTopLevelSExpressionFor ( sourceCaretOffset ) ; if ( endOfMemberOffset > = 0 ) tselectAndReveal ( endOfMemberOffset , 0 ) ; 
public static void registerEditorColors ( IPreferenceStore store , RGB foregroundColor ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; final RGB literalColor = getElementColor ( store , PreferenceConstants . EDITOR_LITERAL_COLOR , foregroundColor ) ; final RGB specialFormColor = getElementColor ( store , PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR , foregroundColor ) ; final RGB functionColor = getElementColor ( store , PreferenceConstants . EDITOR_FUNCTION_COLOR , foregroundColor ) ; final RGB commentColor = getElementColor ( store , PreferenceConstants . EDITOR_COMMENT_COLOR , foregroundColor ) ; final RGB globalVarColor = getElementColor ( store , PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR , foregroundColor ) ; final RGB keywordColor = getElementColor ( store , PreferenceConstants . EDITOR_KEYWORD_COLOR , foregroundColor ) ; final RGB metadataTypehintColor = getElementColor ( store , PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR , foregroundColor ) ; final RGB macroColor = getElementColor ( store , PreferenceConstants . EDITOR_MACRO_COLOR , foregroundColor ) ; colorRegistry . put ( AntlrBasedClojureEditor . ID + " _ " + ClojureLexer . STRING , literalColor ) ; $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.REGEX_LITERAL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CHARACTER, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NIL, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BOOLEAN, literalColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.OPEN_PAREN, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CLOSE_PAREN, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYMBOL, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.KEYWORD, keywordColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SYNTAX_QUOTE, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE_SPLICING, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.UNQUOTE, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMENT, commentColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.SPACE, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LAMBDA_ARG, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.METADATA_TYPEHINT, metadataTypehintColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.AMPERSAND, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_SQUARE_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_SQUARE_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.LEFT_CURLY_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.RIGHT_CURLY_BRACKET, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.BACKSLASH, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.CIRCUMFLEX, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.COMMERCIAL_AT, foregroundColor); $NON-NLS-1$ colorRegistry.put(AntlrBasedClojureEditor.ID + "_" + ClojureLexer.NUMBER_SIGN, foregroundColor); $NON-NLS-1$ } 
public void createPartControl ( Composite parent ) { tsuper . createPartControl ( parent ) ; tClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; tfProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( this ) ; initializeViewerColors ( ) ; } if ( configuration instanceof ClojureSourceViewerConfiguration ) fConfiguration = ( ClojureSourceViewerConfiguration ) configuration ; fIsConfigured = true ; } 
static public Color createColor ( IPreferenceStore store , String key , Display display ) { RGB rgb = null ; if ( store . contains ( key ) ) { if ( store . isDefault ( key ) ) rgb = PreferenceConverter . getDefaultColor ( store , key ) ; else rgb = PreferenceConverter . getColor ( store , key ) ; if ( rgb ! = null ) return new Color ( display , rgb ) ; } return null ; } 
public void initializeViewerColors ( ) { if ( fPreferenceStore ! = null ) { tStyledText styledText = getTextWidget ( ) ; 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { tfForegroundColor . dispose ( ) ; tfForegroundColor = null ; } if ( fBackgroundColor ! = null ) { tfBackgroundColor . dispose ( ) ; tfBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { tfSelectionForegroundColor . dispose ( ) ; tfSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { tfSelectionBackgroundColor . dispose ( ) ; tfSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( this ) ; super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public void propertyChange ( PropertyChangeEvent event ) { tOverlayKey key = findOverlayKey ( event . getProperty ( ) ) ; if ( key ! = null ) tpropagateProperty ( fParent , key , fStore ) ; 
private OverlayKey findOverlayKey ( String key ) { tfor ( int i = 0 ; i < fOverlayKeys . length ; i + + ) { if ( fOverlayKeys [ i ] . fKey . equals ( key ) ) treturn fOverlayKeys [ i ] ; } treturn null ; } 
private void propagateProperty ( IPreferenceStore orgin , OverlayKey key , IPreferenceStore target ) { if ( orgin . isDefault ( key . fKey ) ) { if ( ! target . isDefault ( key . fKey ) ) ttarget . setToDefault ( key . fKey ) ; treturn ; } tTypeDescriptor d = key . fDescriptor ; if ( BOOLEAN = = d ) { 
public void propagate ( ) { tfor ( int i = 0 ; i < fOverlayKeys . length ; i + + ) tpropagateProperty ( fStore , fOverlayKeys [ i ] , fParent ) ; 
private void loadProperty ( IPreferenceStore orgin , OverlayKey key , IPreferenceStore target , boolean forceInitialization ) { tTypeDescriptor d = key . fDescriptor ; if ( BOOLEAN = = d ) { 
public void load ( ) { tfor ( int i = 0 ; i < fOverlayKeys . length ; i + + ) tloadProperty ( fParent , fOverlayKeys [ i ] , fStore , true ) ; tfLoaded = true ; 
public void loadDefaults ( ) { tfor ( int i = 0 ; i < fOverlayKeys . length ; i + + ) tsetToDefault ( fOverlayKeys [ i ] . fKey ) ; 
public void start ( ) { if ( fPropertyListener = = null ) { tfPropertyListener = new PropertyListener ( ) ; 
public void stop ( ) { if ( fPropertyListener ! = null ) { tfParent . removePropertyChangeListener ( fPropertyListener ) ; 
public void addPropertyChangeListener ( IPropertyChangeListener listener ) { tfStore . addPropertyChangeListener ( listener ) ; } 
public void removePropertyChangeListener ( IPropertyChangeListener listener ) { tfStore . removePropertyChangeListener ( listener ) ; } 
public void firePropertyChangeEvent ( String name , Object oldValue , Object newValue ) { tfStore . firePropertyChangeEvent ( name , oldValue , newValue ) ; } 
public void putValue ( String name , String value ) { if ( covers ( name ) ) tfStore . putValue ( name , value ) ; 
public void addKeys ( OverlayKey [ ] keys ) { tAssert . isTrue ( ! fLoaded ) ; tAssert . isNotNull ( keys ) ; tint overlayKeysLength = fOverlayKeys . length ; tOverlayKey [ ] result = new OverlayKey [ keys . length + overlayKeysLength ] ; tfor ( int i = 0 , length = overlayKeysLength ; i < length ; i + + ) tresult [ i ] = fOverlayKeys [ i ] ; tfor ( int i = 0 , length = keys . length ; i < length ; i + + ) tresult [ overlayKeysLength + i ] = keys [ i ] ; tfOverlayKeys = result ; if ( fLoaded ) tload ( ) ; 
public boolean performOk ( ) { fOverlayStore . propagate ( ) ; boolean result = true ; try { tPlatform . getPreferencesService ( ) . getRootNode ( ) . node ( InstanceScope . SCOPE ) . node ( CCWPlugin . PLUGIN_ID ) . flush ( ) ; } catch ( BackingStoreException e ) { tCCWPlugin . logError ( " Saving Preferences failed " , e ) ; tresult = false ; } return result ; } 
private Control createPreviewer ( Composite parent ) { IPreferenceStore generalTextStore = EditorsUI . getPreferenceStore ( ) ; IPreferenceStore store = new ChainedPreferenceStore ( new IPreferenceStore [ ] { fOverlayStore , generalTextStore } ) ; fPreviewViewer = new ClojureSourceViewer ( parent , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL | SWT . BORDER , store ) ; ClojureSourceViewerConfiguration configuration = new ClojureSourceViewerConfiguration ( store , null ) ; fPreviewViewer . configure ( configuration ) ; fPreviewViewer . initializeViewerColors ( ) ; Font font = JFaceResources . getFont ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_TEXT_FONT ) ; fPreviewViewer . getTextWidget ( ) . setFont ( font ) ; fPreviewViewer . setEditable ( false ) ; IDocument document = new Document ( PREVIEW_SOURCE ) ; IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; fPreviewViewer . setDocument ( document ) ; return fPreviewViewer . getControl ( ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "ExpandSelectionRightAction", action); 
public void dispose ( ) { if ( pairsMatcher ! = null ) { tpairsMatcher . dispose ( ) ; tpairsMatcher = null ; } if ( fSelectionHistory ! = null ) { tfSelectionHistory . dispose ( ) ; tfSelectionHistory = null ; } tsuper . dispose ( ) ; } 
public void selectionChanged ( SelectionChangedEvent event ) { if ( fSelectionChangeListenerCounter = = 0 ) tflush ( ) ; 
public void remember ( ISourceRange range ) { tSystem . out . println ( " asked to remember range: " + range ) ; tfHistory . add ( range ) ; tfHistoryAction . update ( ) ; } 
public void flush ( ) { if ( fHistory . isEmpty ( ) ) treturn ; tfHistory . clear ( ) ; tfHistoryAction . update ( ) ; } 
public void dispose ( ) { tfEditor . getSelectionProvider ( ) . removeSelectionChangedListener ( fSelectionListener ) ; } 
public void run ( ) { tISourceRange old = fHistory . getLast ( ) ; if ( old ! = null ) { tSystem . out . println ( " Action: restoring last selection " ) ; 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "RaiseSelectionAction", action);} 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SplitSexprAction", action);} 
private static IPackageFragmentRoot findPackageFragmentRoot ( IJavaProject javaProject , IPath filePath ) throws JavaModelException { if ( filePath . isEmpty ( ) | | filePath . isRoot ( ) ) { treturn null ; 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "JoinSexprAction", action);} 
protected void initializeImageRegistry ( ImageRegistry reg ) { treg . put ( NS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/package_obj.gif " ) ) ) ; treg . put ( PUBLIC_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpub_obj.gif " ) ) ) ; reg . put ( PRIVATE_FUNCTION , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/methpri_obj.gif " ) ) ) ; reg . put ( CLASS , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/class_obj.gif " ) ) ) ; reg . put ( SORT , ImageDescriptor . createFromURL ( getBundle ( ) . getEntry ( " /icons/jdt/alphab_sort_co.gif " ) ) ) ; } 
private void registerToolbarActions ( ) { tIActionBars actionBars = getSite ( ) . getActionBars ( ) ; tIToolBarManager toolBarManager = actionBars . getToolBarManager ( ) ; ttoolBarManager . add ( new LexicalSortingAction ( ) ) ; } 
public void run ( ) { if ( on ) { ttreeViewer . setComparator ( fComparator ) ; 
public void mTokens ( ) throws RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | REGEX_LITERAL | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt28=29; alt28 = dfa28.predict(input); switch (alt28) { case 1 : 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("212:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:213:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1492); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1502); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1512); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1522); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1532); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1542); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("221:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:222:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1569); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1579); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1591); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1620); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1644); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1672); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:239:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1705); pushFollow(FOLLOW_form_in_quoteForm1707); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:242:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1721); pushFollow(FOLLOW_form_in_metaForm1723); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:245:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1740); pushFollow(FOLLOW_form_in_derefForm1742); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:252:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1782); pushFollow(FOLLOW_form_in_syntaxQuoteForm1784); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:259:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1824); pushFollow(FOLLOW_form_in_unquoteForm1826); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:266:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1866); pushFollow(FOLLOW_form_in_unquoteSplicingForm1868); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1894); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1914); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1916); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("273:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:33: map { pushFollow(FOLLOW_map_in_metadataForm1919); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1923); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1925); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:273:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1927); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:277:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1948); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1950); pushFollow(FOLLOW_form_in_varQuoteForm1952); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:287:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1979); pushFollow(FOLLOW_list_in_lambdaForm1981); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public boolean useStrictStructuralEditing ( ) { treturn useStrictStructuralEditing ; } 
public void init ( IEditorSite site , IEditorInput input ) throws PartInitException { tsuper . init ( site , input ) ; tuseStrictStructuralEditing = getPreferenceStore ( ) . getBoolean ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
protected void updateStatusField ( String category ) { if ( ! STATUS_CATEGORY_STRUCTURAL_EDITING_POSSIBLE . equals ( category ) ) { tsuper . updateStatusField ( category ) ; treturn ; } if ( category = = null ) treturn ; tIStatusField field = getStatusField ( category ) ; if ( field ! = null ) { / * 
public void contributeToStatusLine ( IStatusLineManager statusLineManager ) { tsuper . contributeToStatusLine ( statusLineManager ) ; tstatusLineManager . add ( structuralEditionStatusField ) ; } 
public void toggleStructuralEditionMode ( ) { tuseStrictStructuralEditing = ! useStrictStructuralEditing ; tupdateStatusField ( STATUS_CATEGORY_STRUCTURAL_EDITION ) ; } 
protected void updateStatusField ( String category ) { if ( ! STATUS_CATEGORY_STRUCTURAL_EDITION . equals ( category ) ) { tsuper . updateStatusField ( category ) ; treturn ; } if ( category = = null ) treturn ; tIStatusField field = getStatusField ( category ) ; tIStatusFieldExtension extField = ( IStatusFieldExtension ) field ; if ( field ! = null ) { / * 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SwitchStructuralEditionModeAction", action);} 
public void toggleStructuralEditionMode ( ) { tuseStrictStructuralEditing = ! useStrictStructuralEditing ; tupdateStatusField ( STATUS_CATEGORY_STRUCTURAL_EDITION ) ; tupdateTabsToSpacesConversion ( ) ; } 
public void updateTabsToSpacesConversion ( ) { if ( useStrictStructuralEditing ) { tuninstallTabsToSpacesConverter ( ) ; 
protected boolean isTabsToSpacesConversionEnabled ( ) { treturn ! useStrictStructuralEditing ; } 
private boolean checkJavaPrefixLength ( PrefixInfo prefixInfo ) { if ( prefixInfo . prefix . length ( ) < JAVA_PREFIX_MIN_LENGTH ) { tCCWPlugin . logWarning ( " completion proposal asked for a prefix whose length " 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tIFile file = ( IFile ) resource ; tString extension = file . getFileExtension ( ) ; if ( extension ! = null & & extension . equals ( CLOJURE_EXTENSION ) ) { } 
public void initializeFrom ( ILaunchConfiguration configuration ) { } 
private void addSourceFoldersToModel ( ClasspathModel model ) { tILaunchConfiguration conf = getCurrentLaunchConfiguration ( ) ; tIJavaElement javaElement = getContext ( ) ; tIJavaProject javaProject = javaElement . getJavaProject ( ) ; tIProject project = javaProject . getProject ( ) ; tIRuntimeClasspathEntry entry = JavaRuntime . newArchiveRuntimeClasspathEntry ( project . getFolder ( " src " ) ) ; } 
public String [ ] getClasspath ( ILaunchConfiguration configuration ) throws CoreException { List < String > classpath = new ArrayList < String > ( Arrays . asList ( super . getClasspath ( configuration ) ) ) ; ClojureProject clojureProject = ClojureCore . getClojureProject ( LaunchUtils . getProject ( configuration ) ) ; for ( IFolder f : clojureProject . sourceFolders ( ) ) { String sourcePath = f . getLocation ( ) . toOSString ( ) ; while ( classpath . contains ( sourcePath ) ) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } return classpath.toArray(new String[classpath.size()]); } 
private static boolean isWorkspaceRelativeLibrarySourceAttachment ( IClasspathEntry cpe ) { treturn ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . exists ( cpe . getSourceAttachmentPath ( ) ) ; } 
public static IPath toOSAbsoluteIPath ( IPath path ) { if ( ClojureCore . isWorkspaceRelativeIPath ( path ) ) { tboolean isFolder = path . getFileExtension ( ) = = null ; if ( isFolder ) { tpath = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFolder ( path ) . getLocation ( ) ; } else { tpath = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFile ( path ) . getLocation ( ) ; } } treturn path ; } 
public static boolean isWorkspaceRelativeIPath ( IPath path ) { treturn ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . exists ( path ) ; } 
public void visit ( Map < IFolder , IFolder > srcFolders ) throws CoreException { tthis . srcFolders = new HashMap < IFolder , IFolder > ( srcFolders ) ; for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { tsetSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( this ) ; } if ( clojureClient ! = null ) { tfor ( String maybeLib 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SwitchStructuralEditionModeAction", action);} 
protected void handlePreferenceStoreChanged ( PropertyChangeEvent event ) { ttry { tISourceViewer sourceViewer = getSourceViewer ( ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public void createPartControl ( Composite parent ) { tsuper . createPartControl ( parent ) ; tClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; tfProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
private void installEscListenerForStructuralEditingEscape ( ) { tthis . getSourceViewer ( ) . getTextWidget ( ) . addKeyListener ( tnew KeyListener ( ) { 
public void keyPressed ( KeyEvent e ) { if ( e . character = = SWT . ESC ) { tinEscapeSequence = true ; 
public void keyReleased ( KeyEvent e ) { if ( inEscapeSequence & & ! ( e . character = = SWT . ESC ) ) { tinEscapeSequence = false ; 
protected void updateTabsToSpacesConverter ( ) { if ( isTabsToSpacesConversionEnabled ( ) ) { tinstallTabsToSpacesConverter ( ) ; 
protected boolean isTabsToSpacesConversionEnabled ( ) { if ( getPreferenceStore ( ) . getBoolean ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE ) & & ! isInEscapeSequence ( ) ) { 
public static void fullBuild ( IProject project , IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = CCWPlugin . getDefault ( ) . getProjectClojureClient ( project ) ; if ( clojureClient = = null ) { treturn ; } deleteMarkers ( project ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( project ) ) ; getClassesFolder ( project ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
private void activateContext ( String contextId ) { contextActivation = contextService ( ) . activateContext ( contextId ) ; if ( contextActivation = = null ) { throw new IllegalStateException ( " " ) ; 
public static Object invoke ( String ns , String name , Object . . . args ) throws Exception { tloadString ( " (clojure.core/require ' " + ns + " ) " ) ; tVar var = RT . var ( ns , name ) ; tswitch ( args . length ) { tcase 0 : 
public String getMainTypeName ( ILaunchConfiguration configuration ) tthrows CoreException { tIJavaProject jProj = ClojureCore . getJavaProject ( LaunchUtils . getProject ( configuration ) ) ; ttry { if ( ( Boolean ) ClojureClient . invoke ( " ccw.ClojureProjectNature " , " has-clojure-contrib-on-classpath? " , jProj ) ) { 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , LaunchUtils . DEFAULT_SERVER_PORT ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; tconfig . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; Overriden at launch time, set here just to make JavaMainTab happy config.setAttribute(LaunchUtils.ATTR_CLOJURE_INSTALL_REPL, installREPLChoice.getSelection()); config.setAttribute(LaunchUtils.ATTR_CLOJURE_SERVER_LISTEN, Integer.valueOf(serverPort.getText())); mapResources(config); } 
public void documentChanged ( DocumentEvent event ) { tupdateParseRef ( event . getDocument ( ) . get ( ) ) ; } 
private void updateParseRef ( String text ) { tparseRef = EditorSupport . updateParseRef ( text , parseRef ) ; tSystem . out . println ( " cached the parser! " ) ; } 
protected void doSetInput ( IEditorInput input ) throws CoreException { tIEditorInput oldEditorInput = getEditorInput ( ) ; if ( oldEditorInput ! = null ) { tIDocument oldDocument = getDocumentProvider ( ) . getDocument ( oldEditorInput ) ; if ( oldDocument ! = null ) { toldDocument . removeDocumentListener ( parseTreeConstructorDocumentListener ) ; } } tsuper . doSetInput ( input ) ; tIDocument document = getDocumentProvider ( ) . getDocument ( getEditorInput ( ) ) ; tdocument . addDocumentListener ( parseTreeConstructorDocumentListener ) ; tupdateParseRef ( document . get ( ) ) ; } 
private void updateParseRef ( String text ) { tparseRef = EditorSupport . updateParseRef ( text , parseRef ) ; } 
private boolean onlyProjectTouched ( ) { IResourceDelta delta = getDelta ( getProject ( ) ) ; return delta . getResource ( ) . equals ( getProject ( ) ) & & delta . getAffectedChildren ( ) . length = = 0 ; } 
public static IOConsole findActiveReplConsole ( ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; if ( page ! = null ) { tIConsoleView v ; ttry { tv = ( IConsoleView ) page . showView ( " org.eclipse.ui.console.ConsoleView " ) ; } catch ( PartInitException e ) { te . printStackTrace ( ) ; } IConsole[] consoles = ConsolePlugin.getDefault().getConsoleManager().getConsoles(); for (IConsole console : consoles) { if (console instanceof org.eclipse.debug.ui.console.IConsole) { org.eclipse.debug.ui.console.IConsole processConsole = (org.eclipse.debug.ui.console.IConsole) console; int port = LaunchUtils.getLaunchServerReplPort(processConsole.getProcess().getLaunch()); if (port != -1) { if (!page.isPartVisible(v)) { activateReplAndShowConsole(page, v, console); } assert IOConsole.class.isInstance(processConsole); return (IOConsole) processConsole; } } } } } return null; } 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { ttry { torg . eclipse . debug . ui . console . IConsole console = ( org . eclipse . debug . ui . console . IConsole ) ClojureClient . findActiveReplConsole ( false , null ) ; 
public static IOConsole findActiveReplConsole ( boolean createOneIfNoneFound , IProject project ) { tIOConsole ioc = findActiveReplConsole ( ) ; if ( ioc ! = null ) { tSystem . out . println ( " active console found " ) ; 
public final void evaluateText ( final String text ) { tEvaluateTextAction . evaluateText ( text , project ) ; } 
public static final void evaluateText ( final String text , IProject project ) { tSystem . out . println ( " before findActiveReplConsole() " ) ; tIOConsole console = ClojureClient . findActiveReplConsole ( true , project ) ; tSystem . out . println ( " after findActiveReplConsole() " ) ; tevaluateText ( console , text ) ; } 
public void launch ( IEditorPart editor , String mode ) { tlaunchEditorPart ( editor , mode ) ; } 
public ILaunch launchEditorPart ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void launch ( ISelection selection , String mode ) { tlaunchSelection ( selection , mode ) ; } 
public ILaunch launchSelection ( ISelection selection , String mode ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; List < IFile > files = new ArrayList < IFile > ( ) ; IProject proj = null ; for ( Object o : strSel . toList ( ) ) { IFile f = ( IFile ) Platform . getAdapterManager ( ) . getAdapter ( o , IFile . class ) ; if ( f ! = null ) { files . add ( f ) ; if ( proj = = null ) { proj = f . getProject ( ) ; } continue ; } IProject p = ( IProject ) Platform . getAdapterManager ( ) . getAdapter ( o , IProject . class ) ; if ( p ! = null & & strSel . size ( ) = = 1 ) { return launchProject ( p , new IFile [ ] { } , mode ) ; } } if ( proj ! = null & & ! files . isEmpty ( ) ) { return launchProject ( proj , files . toArray ( new IFile [ ] { } ) , mode ) ; } } return null ; } 
public ILaunch launchProject ( IProject project , String mode ) { tStructuredSelection sel = new StructuredSelection ( project ) ; treturn launchSelection ( sel , mode ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] files , String mode ) { try { ILaunchConfiguration config = findLaunchConfiguration ( project , files ) ; 
public static IOConsole findActiveReplConsole ( boolean createOneIfNoneFound , IProject project , boolean activateAutoReload ) { tIOConsole ioc = findActiveReplConsole ( ) ; if ( ioc ! = null ) { tSystem . out . println ( " active console found " ) ; 
public static final void evaluateText ( final String text , IProject project ) { tSystem . out . println ( " before findActiveReplConsole() " ) ; tIOConsole console = ClojureClient . findActiveReplConsole ( true , project , false ) ; tSystem . out . println ( " after findActiveReplConsole() " ) ; tevaluateText ( console , text ) ; } 
public void launch ( IEditorPart editor , String mode ) { tlaunchEditorPart ( editor , mode , null ) ; } 
public ILaunch launchEditorPart ( IEditorPart editor , String mode , Boolean activateAutoReload ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void launch ( ISelection selection , String mode ) { tlaunchSelection ( selection , mode , null ) ; } 
public ILaunch launchSelection ( ISelection selection , String mode , Boolean activateAutoReload ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; List < IFile > files = new ArrayList < IFile > ( ) ; IProject proj = null ; for ( Object o : strSel . toList ( ) ) { IFile f = ( IFile ) Platform . getAdapterManager ( ) . getAdapter ( o , IFile . class ) ; if ( f ! = null ) { files . add ( f ) ; if ( proj = = null ) { proj = f . getProject ( ) ; } continue ; } IProject p = ( IProject ) Platform . getAdapterManager ( ) . getAdapter ( o , IProject . class ) ; if ( p ! = null & & strSel . size ( ) = = 1 ) { return launchProject ( p , new IFile [ ] { } , mode , activateAutoReload ) ; } } if ( proj ! = null & & ! files . isEmpty ( ) ) { return launchProject ( proj , files . toArray ( new IFile [ ] { } ) , mode , activateAutoReload ) ; } } return null ; } 
public ILaunch launchProject ( IProject project , String mode , Boolean activateAutoReload ) { tStructuredSelection sel = new StructuredSelection ( project ) ; treturn launchSelection ( sel , mode , activateAutoReload ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] files , String mode , Boolean activateAutoReload ) { tactivateAutoReload = activateAutoReload = = null ? files . length = = 0 : activateAutoReload ; try { ILaunchConfiguration config = findLaunchConfiguration ( project , files ) ; 
public static boolean isAutoReloadEnabled ( ILaunch launch ) { treturn ( Boolean . parseBoolean ( launch . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED ) ) ) ; } 
public static void fullBuild ( IProject project , IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { monitor = new NullProgressMonitor ( ) ; } ClojureClient clojureClient = CCWPlugin . getDefault ( ) . getProjectClojureClient ( project ) ; if ( clojureClient = = null | | ! clojureClient . isAutoReloadEnabled ( ) ) { treturn ; } deleteMarkers ( project ) ; ClojureVisitor visitor = new ClojureVisitor ( clojureClient ) ; visitor . visit ( getSrcFolders ( project ) ) ; getClassesFolder ( project ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; } 
public static ClojureClient create ( ILaunch launch ) { int clojureVMPort = LaunchUtils . getLaunchServerReplPort ( launch ) ; if ( clojureVMPort ! = - 1 ) { treturn new ClojureClient ( clojureVMPort , CCWPlugin . isAutoReloadEnabled ( launch ) ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { tint port = LaunchUtils . getLaunchServerReplPort ( launch ) ; launch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_LISTEN , tInteger . toString ( port ) ) ; launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; if ( port = = - 1 ) { ttry { tlaunch . setAttribute ( LaunchUtils . ATTR_CLOJURE_SERVER_FILE_PORT , tFile . createTempFile ( LaunchUtils . SERVER_FILE_PORT_PREFIX , LaunchUtils . SERVER_FILE_PORT_SUFFFIX ) . getAbsolutePath ( ) ) ; } catch ( IOException e ) { tthrow new CoreException ( Status . CANCEL_STATUS ) ; } } launch.setAttribute(LaunchUtils.ATTR_IS_AUTO_RELOAD_ENABLED, Boolean.toString(configuration.getAttribute(LaunchUtils.ATTR_IS_AUTO_RELOAD_ENABLED, false))); this.launch = launch; super.launch(configuration, mode, launch, monitor); } 
public static IOConsole findActiveReplConsole ( long imeoutMillisec ) { tlong imeoutTime = System . currentTimeMillis ( ) + imeoutMillisec ; tIOConsole console = null ; twhile ( System . currentTimeMillis ( ) < imeoutTime ) { tconsole = findActiveReplConsole ( ) ; if ( console ! = null ) { tbreak ; } else { ttry { tThread . sleep ( 50 ) ; } catch ( InterruptedException e ) { return console; } 
public static final void evaluateText ( final String text , IProject project ) { tSystem . out . println ( " before findActiveReplConsole() " ) ; tSystem . out . println ( " Will evaluate text' " + text + " ' " ) ; tIOConsole console = ClojureClient . findActiveReplConsole ( true , project , false ) ; tSystem . out . println ( " after findActiveReplConsole() " ) ; tevaluateText ( console , text ) ; } 
public IHyperlink [ ] detectHyperlinks ( ITextViewer textViewer , tIRegion region , boolean canShowMultipleHyperlinks ) { tSystem . out . println ( " asked for hyperlink detection in clojure code ! " ) ; tSystem . out . println ( " region: " + region ) ; ttry { tSystem . out . println ( " text: " + textViewer . getDocument ( ) . get ( region . getOffset ( ) , region . getLength ( ) ) ) ; } catch ( BadLocationException e ) { } 
public void run ( ) { TODO factorize with ClojureHyperlinkDetector int caretOffset = editor.getUnSignedSelection(editor.sourceViewer()).getOffset(); Tokens tokens = new Tokens(editor.getDocument(), caretOffset); tokens.tokenAtCaret(); String tokenContents = tokens.tokenContents(); run(tokenContents, editor); } 
public static void run ( String tokenContents , AntlrBasedClojureEditor editor ) { List < String > split = Arrays . asList ( tokenContents . split ( " / " ) ) ; String symbol = tokenContents ; String declaringNamespace = editor . getDeclaringNamespace ( ) ; String namespace = null ; if ( split . size ( ) = = 2 ) { symbol = split . get ( 1 ) ; namespace = split . get ( 0 ) ; } String command = String . format ( " (ccw.debug.serverrepl/find-symbol \" %s \" \" %s \" \" %s \" ) " , symbol , declaringNamespace , namespace ) ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; if ( clojure = = null ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . You_need_a_running_repl ) ; return ; } PersistentArrayMap result2 = ( PersistentArrayMap ) clojure . remoteLoadRead ( command ) ; List < String > result = ( List < String > ) result2 . get ( " response " ) ; if ( result = = null | | result . isEmpty ( ) | | result2 . get ( " response-type " ) . equals ( - 1 ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Cannot_find_declaration ) ; return ; } String file = result . get ( 0 ) ; Integer line = Integer . valueOf ( result . get ( 1 ) ) ; String ns = result . get ( 3 ) ; ClojureCore . openInEditor ( ns , file , line ) ; } 
public void run ( ) { int caretOffset = editor . getUnSignedSelection ( editor . sourceViewer ( ) ) . getOffset ( ) ; TODO factorize with ClojureHyperlinkDetector concerning the retrieval of the symbol ... Tokens tokens = new Tokens(editor.getDocument(), caretOffset); tokens.tokenAtCaret(); String tokenContents = tokens.tokenContents(); Map<String, Object> decl = findDecl(tokenContents, editor); String file = (String) decl.get("file"); Integer line = (Integer) decl.get("line"); String ns = (String) decl.get("ns"); ClojureCore.openInEditor(ns, file, line); } 
public static Map < String , Object > findDecl ( String tokenContents , AntlrBasedClojureEditor editor ) { List < String > split = Arrays . asList ( tokenContents . split ( " / " ) ) ; String symbol = tokenContents ; String declaringNamespace = editor . getDeclaringNamespace ( ) ; String namespace = null ; if ( split . size ( ) = = 2 ) { symbol = split . get ( 1 ) ; namespace = split . get ( 0 ) ; } String command = String . format ( " (ccw.debug.serverrepl/find-symbol \" %s \" \" %s \" \" %s \" ) " , symbol , declaringNamespace , namespace ) ; ClojureClient clojure = ClojureClient . newClientForActiveRepl ( ) ; if ( clojure = = null ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . You_need_a_running_repl ) ; return null ; } PersistentArrayMap result2 = ( PersistentArrayMap ) clojure . remoteLoadRead ( command ) ; List < String > result = ( List < String > ) result2 . get ( " response " ) ; if ( result = = null | | result . isEmpty ( ) | | result2 . get ( " response-type " ) . equals ( - 1 ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Cannot_find_declaration ) ; return null ; } Map < String , Object > r = new HashMap < String , Object > ( 3 ) ; r . put ( " file " , result . get ( 0 ) ) ; r . put ( " line " , ( Integer ) Integer . valueOf ( result . get ( 1 ) ) ) ; r . put ( " ns " , result . get ( 3 ) ) ; return r ; } 
public static IOConsole findActiveReplConsole ( boolean createOneIfNoneFound , IProject project , boolean activateAutoReload ) { tIOConsole ioc = findActiveReplConsole ( ) ; if ( ioc ! = null ) { treturn ioc ; 
public static final void evaluateText ( final String text , IProject project ) { tIOConsole console = ClojureClient . findActiveReplConsole ( true , project , false ) ; tevaluateText ( console , text ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; tAction action = new GotoMatchingBracketAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_MATCHING_BRACKET ) ; tsetAction ( GotoMatchingBracketAction . ID , action ) ; taction = new GotoNextMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_NEXT_MEMBER ) ; tsetAction ( GotoNextMemberAction . ID , action ) ; taction = new GotoPreviousMemberAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . GOTO_PREVIOUS_MEMBER ) ; tsetAction ( GotoPreviousMemberAction . ID , action ) ; taction = new SelectTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . SELECT_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( SelectTopLevelSExpressionAction . ID , action ) ; taction = new EvaluateTopLevelSExpressionAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION ) ; tsetAction ( EvaluateTopLevelSExpressionAction . ID , action ) ; taction = new LoadFileAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . LOAD_FILE ) ; tsetAction ( LoadFileAction . ID , action ) ; taction = new CompileLibAction ( this ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . COMPILE_LIB ) ; tsetAction ( CompileLibAction . ID , action ) ; taction = new RunTestsAction ( this , CCWPlugin . getDefault ( ) . getColorRegistry ( ) ) ; taction . setActionDefinitionId ( IClojureEditorActionDefinitionIds . RUN_TESTS ) ; tsetAction ( RunTestsAction . RUN_TESTS_ID , action ) ; "SwitchStructuralEditionModeAction", action);} 
public String getMainTypeName ( ILaunchConfiguration configuration ) tthrows CoreException { tIJavaProject jProj = ClojureCore . getJavaProject ( LaunchUtils . getProject ( configuration ) ) ; ttry { if ( ( Boolean ) ClojureClient . invoke ( " ccw.ClojureProjectNature " , " has-path-on-classpath? " , jProj , " clojure/contrib/repl_ln.class " ) ) { 
public void run ( ) { tString title = " File Compiler and loader " ; tString message = " The editor has pending changes. Clicking OK will save the changes and compile+load the file. " ; if ( ! EvaluateTextUtil . canProceed ( editor , title , message ) ) treturn ; tcompileLoadFile ( ) ; } 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tIOConsole console = ClojureClient . findActiveReplConsole ( true , editor . getProject ( ) , false ) ; tEvaluateTextUtil . evaluateText ( console , compileLibCommand ( lib ) , true ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static boolean canProceed ( IEditorPart editor , String title , String message ) { if ( editor . isDirty ( ) ) { tboolean saveAndCompileLoad = MessageDialog . openConfirm ( editor . getSite ( ) . getShell ( ) , title , message ) ; 
public void run ( ) { tString selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . trim ( ) . equals ( " " ) ) { tselectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } tIOConsole console = ClojureClient . findActiveReplConsole ( true , editor . getProject ( ) , false ) ; tEvaluateTextUtil . evaluateText ( console , selectedText , true ) ; } 
public void run ( ) { tString title = " File Loader " ; tString message = " The editor has pending changes. Clicking OK will save the changes and load the file. " ; if ( ! EvaluateTextUtil . canProceed ( editor , title , message ) ) treturn ; tloadFile ( ) ; } 
protected final void loadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString absoluteFilePath = editorFile . getLocation ( ) . toOSString ( ) ; tString text = " (clojure.core/load-file \" " + absoluteFilePath . replaceAll ( " \\ \\ " , " \\ \\ \\ \\ " ) . replaceAll ( " \" " , " \\ \\ \" " ) + " \" ) " ; tIOConsole console = ClojureClient . findActiveReplConsole ( true , editor . getProject ( ) , false ) ; tEvaluateTextUtil . evaluateText ( console , text , true ) ; } 
public void run ( ) { tString selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . trim ( ) . equals ( " " ) ) { tselectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } tIOConsole console = ClojureClient . findActiveReplConsole ( false , editor . getProject ( ) , false ) ; if ( console ! = null ) { tEvaluateTextUtil . evaluateText ( console , selectedText , true ) ; 
public void run ( ) { tString selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . trim ( ) . equals ( " " ) ) { tselectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } tIOConsole console = ClojureClient . findActiveReplConsole ( true , editor . getProject ( ) , false ) ; if ( console ! = null ) { tEvaluateTextUtil . evaluateText ( console , selectedText , true ) ; 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; startClojureCode ( context ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; startLaunchListener ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.RaiseSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
public void start ( BundleContext context ) throws Exception { tsuper . start ( context ) ; tplugin = this ; tstartClojureCode ( context ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplAntLogger " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplCreateProjectPage " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplCreationOperation " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.support.examples.labrepl.wizards.LabreplCreationWizard " ) ; } 
public final void mEscapeSequence ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:82:11: ( '\\\\' . ) 
public final void mUnicodeEscape ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:91:9: ( '\\\\' 'u' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT ) 
public final void mOctalEscape ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:97:9: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ) 
public final void mNAME ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:136:9: ( SYMBOL_HEAD ( SYMBOL_REST )* ( ':' ( SYMBOL_REST )+ )* ) 
public final void mSYMBOL_HEAD ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:141:9: ( 'a' .. 'z' | 'A' .. 'Z' | '*' | '+' | '!' | '-' | '_' | '?' | '>' | '<' | '=' | '$' ) 
public final void mSYMBOL_REST ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:147:9: ( SYMBOL_HEAD | '0' .. '9' | '.' | NUMBER_SIGN ) 
public final void literal ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:154:9: ( STRING | NUMBER | CHARACTER | NIL | BOOLEAN | KEYWORD ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g: { if ( input.LA(1)==STRING||(input.LA(1)>=NUMBER && input.LA(1)<=BOOLEAN)||input.LA(1)==KEYWORD ) { input.consume(); errorRecovery=false; } else { MismatchedSetException mse = new MismatchedSetException(null,input); recoverFromMismatchedSet(input,mse,FOLLOW_set_in_literal0); throw mse; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("213:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1461); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1471); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1481); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1491); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1501); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:219:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1511); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1538); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1548); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:225:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1560); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1589); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1613); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1641); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1674); pushFollow(FOLLOW_form_in_quoteForm1676); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1690); pushFollow(FOLLOW_form_in_metaForm1692); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1709); pushFollow(FOLLOW_form_in_derefForm1711); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1751); pushFollow(FOLLOW_form_in_syntaxQuoteForm1753); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1793); pushFollow(FOLLOW_form_in_unquoteForm1795); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1835); pushFollow(FOLLOW_form_in_unquoteSplicingForm1837); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1863); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1883); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1885); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("274:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:33: map { pushFollow(FOLLOW_map_in_metadataForm1888); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1892); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1894); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1896); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1917); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1919); pushFollow(FOLLOW_form_in_varQuoteForm1921); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1948); pushFollow(FOLLOW_list_in_lambdaForm1950); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public void mTokens ( ) throws RecognitionException { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:1:10: ( OPEN_PAREN | CLOSE_PAREN | AMPERSAND | LEFT_SQUARE_BRACKET | RIGHT_SQUARE_BRACKET | LEFT_CURLY_BRACKET | RIGHT_CURLY_BRACKET | BACKSLASH | CIRCUMFLEX | COMMERCIAL_AT | NUMBER_SIGN | APOSTROPHE | SPECIAL_FORM | STRING | REGEX_LITERAL | NUMBER | CHARACTER | HEXDIGIT | NIL | BOOLEAN | SYMBOL | METADATA_TYPEHINT | KEYWORD | SYNTAX_QUOTE | UNQUOTE_SPLICING | UNQUOTE | COMMENT | SPACE | LAMBDA_ARG ) int alt31=29; alt31 = dfa31.predict(input); switch (alt31) { case 1 : 
public final void file ( ) throws RecognitionException { try { break loop1; } } while (true); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void macroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm ) int alt5=6; switch ( input.LA(1) ) { case APOSTROPHE: { alt5=1; } break; case CIRCUMFLEX: { alt5=2; } break; case COMMERCIAL_AT: { alt5=3; } break; case SYNTAX_QUOTE: { alt5=4; } break; case UNQUOTE_SPLICING: { alt5=5; } break; case UNQUOTE: { alt5=6; } break; default: NoViableAltException nvae = new NoViableAltException("213:1: macroForm : ( quoteForm | metaForm | derefForm | syntaxQuoteForm | {...}? unquoteSplicingForm | {...}? unquoteForm );", 5, 0, input); throw nvae; } switch (alt5) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:214:9: quoteForm { pushFollow(FOLLOW_quoteForm_in_macroForm1475); quoteForm(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:215:9: metaForm { pushFollow(FOLLOW_metaForm_in_macroForm1485); metaForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:216:9: derefForm { pushFollow(FOLLOW_derefForm_in_macroForm1495); derefForm(); _fsp--; } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:217:9: syntaxQuoteForm { pushFollow(FOLLOW_syntaxQuoteForm_in_macroForm1505); syntaxQuoteForm(); _fsp--; } break; case 5 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:218:7: {...}? unquoteSplicingForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteSplicingForm_in_macroForm1515); unquoteSplicingForm(); _fsp--; } break; case 6 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:219:7: {...}? unquoteForm { if ( !( this.syntaxQuoteDepth > 0 ) ) { throw new FailedPredicateException(input, "macroForm", " this.syntaxQuoteDepth > 0 "); } pushFollow(FOLLOW_unquoteForm_in_macroForm1525); unquoteForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void dispatchMacroForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm ) int alt6=3; int LA6_0 = input.LA(1); if ( (LA6_0==REGEX_LITERAL) ) { alt6=1; } else if ( (LA6_0==NUMBER_SIGN) ) { int LA6_2 = input.LA(2); if ( (LA6_2==APOSTROPHE) ) { alt6=2; } else if ( (LA6_2==OPEN_PAREN) ) { alt6=3; } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 2, input); throw nvae; } } else { NoViableAltException nvae = new NoViableAltException("222:1: dispatchMacroForm : ( REGEX_LITERAL | varQuoteForm | {...}? lambdaForm );", 6, 0, input); throw nvae; } switch (alt6) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:223:9: REGEX_LITERAL { match(input,REGEX_LITERAL,FOLLOW_REGEX_LITERAL_in_dispatchMacroForm1552); } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:224:9: varQuoteForm { pushFollow(FOLLOW_varQuoteForm_in_dispatchMacroForm1562); varQuoteForm(); _fsp--; } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:225:9: {...}? lambdaForm { if ( !(!this.inLambda) ) { throw new FailedPredicateException(input, "dispatchMacroForm", "!this.inLambda"); } pushFollow(FOLLOW_lambdaForm_in_dispatchMacroForm1574); lambdaForm(); _fsp--; } break; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void list ( ) throws RecognitionException { Token o = null ; Token c = null ; try { break loop7; } } while (true); c=(Token)input.LT(1); match(input,CLOSE_PAREN,FOLLOW_CLOSE_PAREN_in_list1603); parensMatching.put(Integer.valueOf(o.getTokenIndex()), Integer.valueOf(c.getTokenIndex())); parensMatching.put(Integer.valueOf(c.getTokenIndex()), Integer.valueOf(o.getTokenIndex())); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void vector ( ) throws RecognitionException { try { break loop8; } } while (true); match(input,RIGHT_SQUARE_BRACKET,FOLLOW_RIGHT_SQUARE_BRACKET_in_vector1627); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void map ( ) throws RecognitionException { try { break loop9; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_map1655); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void quoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: ( APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:240:8: APOSTROPHE form { match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_quoteForm1688); pushFollow(FOLLOW_form_in_quoteForm1690); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metaForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: ( CIRCUMFLEX form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:243:13: CIRCUMFLEX form { match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metaForm1704); pushFollow(FOLLOW_form_in_metaForm1706); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void derefForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: ( COMMERCIAL_AT form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:246:13: COMMERCIAL_AT form { match(input,COMMERCIAL_AT,FOLLOW_COMMERCIAL_AT_in_derefForm1723); pushFollow(FOLLOW_form_in_derefForm1725); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void syntaxQuoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth + + ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: ( SYNTAX_QUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:253:9: SYNTAX_QUOTE form { match(input,SYNTAX_QUOTE,FOLLOW_SYNTAX_QUOTE_in_syntaxQuoteForm1765); pushFollow(FOLLOW_form_in_syntaxQuoteForm1767); form(); _fsp--; } this.syntaxQuoteDepth--; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: ( UNQUOTE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:260:9: UNQUOTE form { match(input,UNQUOTE,FOLLOW_UNQUOTE_in_unquoteForm1807); pushFollow(FOLLOW_form_in_unquoteForm1809); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void unquoteSplicingForm ( ) throws RecognitionException { this . syntaxQuoteDepth - - ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: ( UNQUOTE_SPLICING form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:267:9: UNQUOTE_SPLICING form { match(input,UNQUOTE_SPLICING,FOLLOW_UNQUOTE_SPLICING_in_unquoteSplicingForm1849); pushFollow(FOLLOW_form_in_unquoteSplicingForm1851); form(); _fsp--; } this.syntaxQuoteDepth++; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void set ( ) throws RecognitionException { try { break loop10; } } while (true); match(input,RIGHT_CURLY_BRACKET,FOLLOW_RIGHT_CURLY_BRACKET_in_set1877); } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void metadataForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: ( NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:9: NUMBER_SIGN CIRCUMFLEX ( map | SYMBOL | KEYWORD | STRING ) { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_metadataForm1897); match(input,CIRCUMFLEX,FOLLOW_CIRCUMFLEX_in_metadataForm1899); /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:32: ( map | SYMBOL | KEYWORD | STRING ) int alt11=4; switch ( input.LA(1) ) { case LEFT_CURLY_BRACKET: { alt11=1; } break; case SYMBOL: { alt11=2; } break; case KEYWORD: { alt11=3; } break; case STRING: { alt11=4; } break; default: NoViableAltException nvae = new NoViableAltException("274:32: ( map | SYMBOL | KEYWORD | STRING )", 11, 0, input); throw nvae; } switch (alt11) { case 1 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:33: map { pushFollow(FOLLOW_map_in_metadataForm1902); map(); _fsp--; } break; case 2 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:39: SYMBOL { match(input,SYMBOL,FOLLOW_SYMBOL_in_metadataForm1906); } break; case 3 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:46: KEYWORD { match(input,KEYWORD,FOLLOW_KEYWORD_in_metadataForm1908); } break; case 4 : /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:274:54: STRING { match(input,STRING,FOLLOW_STRING_in_metadataForm1910); } break; } } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void varQuoteForm ( ) throws RecognitionException { try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: ( NUMBER_SIGN APOSTROPHE form ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:278:9: NUMBER_SIGN APOSTROPHE form { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_varQuoteForm1931); match(input,APOSTROPHE,FOLLOW_APOSTROPHE_in_varQuoteForm1933); pushFollow(FOLLOW_form_in_varQuoteForm1935); form(); _fsp--; } } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public final void lambdaForm ( ) throws RecognitionException { this . inLambda = true ; try { /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: ( NUMBER_SIGN list ) /home/lpetit/projects/ccw/clojure-antlr-grammar/src/Clojure.g:288:7: NUMBER_SIGN list { match(input,NUMBER_SIGN,FOLLOW_NUMBER_SIGN_in_lambdaForm1962); pushFollow(FOLLOW_list_in_lambdaForm1964); list(); _fsp--; } this.inLambda = false; } catch (RecognitionException re) { reportError(re); recover(input,re); } finally { } return ; } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; loadPluginClojureCode ( ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; } 
private void loadPluginClojureCode ( ) throws Exception { tURL clientReplBundleUrl = CCWPlugin . getDefault ( ) . getBundle ( ) . getResource ( " ccw/debug/clientrepl.clj " ) ; tURL clientReplFileUrl = FileLocator . toFileURL ( clientReplBundleUrl ) ; tString clientRepl = clientReplFileUrl . getFile ( ) ; tCompiler . loadFile ( clientRepl ) ; try { Var . find ( Symbol . intern ( " clojure.core/require " ) ) . invoke ( Symbol . intern ( " cemerick.nrepl " ) ) ; 
public void stop ( BundleContext context ) throws Exception { tdisposeParenRainbowColors ( ) ; We also don't remove fonts when deregistered plugin = null; super.stop(context); } 
public Connection getProjectREPLConnection ( IProject project ) { REPLView repl = getProjectREPL ( project ) ; return repl = = null ? null : repl . getToolingConnection ( ) ; } 
public static void openInEditor ( String searchedNS , String searchedFileName , int line ) { ttry { REPLView replView = REPLView . activeREPL . get ( ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { return REPLView . connect ( ) ; 
public void removeHandlerListener ( IHandlerListener handlerListener ) { } public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } } 
public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } } 
public void visit ( Map < IFolder , IFolder > srcFolders ) throws CoreException { tthis . srcFolders = new HashMap < IFolder , IFolder > ( srcFolders ) ; for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { tsetSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( this ) ; } if ( repl ! = null ) { try { 
private static Object invokeLocalClojureVarWith ( Var varToInvoke , String code ) { try { return varToInvoke . invoke ( code ) ; 
public static Object loadString ( String localCode ) { return invokeLocalClojureVarWith ( loadString , localCode ) ; } 
public boolean isStructuralEditingEnabled ( ) { } 
public void createPartControl ( Composite parent ) { tsuper . createPartControl ( parent ) ; tClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; tfProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public boolean isInEscapeSequence ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . isInEscapeSequence ( ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void gotoMatchingBracket ( ) { tISourceViewer sourceViewer = getSourceViewer ( ) ; tIDocument document = sourceViewer . getDocument ( ) ; if ( document = = null ) treturn ; tIRegion selection = getSignedSelection ( ) ; tint selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { tsetStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ; tsourceViewer . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; treturn ; } } 
private boolean checkSelectionAndWarnUserIfProblem ( String errorMessageIfProblem ) { if ( getDocument ( ) = = null ) treturn false ; tIRegion selection = getSignedSelection ( ) ; tint selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 0 ) { tsetStatusLineErrorMessage ( errorMessageIfProblem ) ; tgetSourceViewer ( ) . getTextWidget ( ) . getDisplay ( ) . beep ( ) ; treturn false ; } treturn true ; } 
public IRegion getUnSignedSelection ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . getUnSignedSelection ( ) ; } 
public IRegion getSignedSelection ( ) { return ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . getSignedSelection ( ) ; } 
public IJavaProject getAssociatedProject ( ) { return JavaCore . create ( ( ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ) . getProject ( ) ) ; } 
public String getDeclaringNamespace ( ) { treturn ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . getDeclaringNamespace ( ) ; } 
public REPLView getCorrespondingREPL ( ) { tIFile file = ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( file ! = null ) treturn CCWPlugin . getDefault ( ) . getProjectREPL ( file . getProject ( ) ) ; 
public void updateTabsToSpacesConverter ( ) { if ( isTabsToSpacesConversionEnabled ( ) ) { tinstallTabsToSpacesConverter ( ) ; 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { treturn new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { treturn new ClassLazyCompletionProposal ( ( IType ) match . getElement ( ) , 
public AbstractLazyCompletionProposal lazyCompletionProposal ( PrefixInfo prefixInfo , IClojureEditor editor , SearchMatch match ) { treturn new PackageLazyCompletionProposal ( ( IPackageFragment ) match . getElement ( ) , 
private static List < List > dynamicComplete ( String namespace , String prefix , IClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tConnection repl = editor . getCorrespondingREPL ( ) . getToolingConnection ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; tMap result = ( Map ) repl . send ( " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) . values ( ) . get ( 0 ) ; if ( result = = null ) return Collections . emptyList ( ) ; if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } Connection repl = editor . getCorrespondingREPL ( ) . getToolingConnection ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; tMap result = ( Map ) repl . send ( " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) . values ( ) . get ( 0 ) ; if ( result = = null ) return Collections . emptyList ( ) ; if ( result . get ( " response-type " ) . equals ( 0 ) ) { if ( result . get ( " response " ) = = null ) { 
public void keyPressed ( KeyEvent e ) { if ( e . character = = SWT . ESC ) { inEscapeSequence = true ; 
public void keyReleased ( KeyEvent e ) { if ( inEscapeSequence & & ! ( e . character = = SWT . ESC ) ) { inEscapeSequence = false ; 
public void inputDocumentChanged ( IDocument oldInput , IDocument newInput ) { if ( newInput ! = null ) { newInput . addDocumentListener ( parseTreeConstructorDocumentListener ) ; 
public void inputDocumentAboutToBeChanged ( IDocument oldInput , IDocument newInput ) { if ( oldInput ! = null ) oldInput . removeDocumentListener ( parseTreeConstructorDocumentListener ) ; 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { tfForegroundColor . dispose ( ) ; tfForegroundColor = null ; } if ( fBackgroundColor ! = null ) { tfBackgroundColor . dispose ( ) ; tfBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { tfSelectionForegroundColor . dispose ( ) ; tfSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { tfSelectionBackgroundColor . dispose ( ) ; tfSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( this ) ; super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public void documentChanged ( DocumentEvent event ) { updateParseRef ( event . getDocument ( ) . get ( ) ) ; } 
private void updateParseRef ( String text ) { parseRef = EditorSupport . updateParseRef ( text , parseRef ) ; } 
public Object getParsed ( ) { if ( parseRef = = null ) { updateParseRef ( getDocument ( ) . get ( ) ) ; } return EditorSupport . getParser ( getDocument ( ) . get ( ) , parseRef ) ; } 
public IRegion getUnSignedSelection ( ) { StyledText text = getTextWidget ( ) ; Point selection = text . getSelectionRange ( ) ; selection . x = widgetOffset2ModelOffset ( selection . x ) ; return new Region ( selection . x , selection . y ) ; } 
public void selectAndReveal ( int start , int length ) { setSelection ( new TextSelection ( start , length ) , true ) ; } 
public REPLView getCorrespondingREPL ( ) { this gets overridden in REPLView as appropriate so that the toolConnection there gets returned return null; } 
public void setStructuralEditingPossible ( boolean possible ) { } public void updateTabsToSpacesConverter ( ) { } } 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . getDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tEvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , true ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static String compileLibCommand ( String libName ) { treturn " (ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \" classes \" ] (clojure.core/compile ' " + libName + " ))) " ; } 
public static final void evaluateText ( final String text , boolean verbose ) { tevaluateText ( REPLView . activeREPL . get ( ) , text , verbose ) ; } 
public static final void evaluateText ( REPLView console , final String text , boolean verbose ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void run ( ) { MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Expression evaluation " , 
public void run ( ) { tString selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . trim ( ) . equals ( " " ) ) { tselectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } tREPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tEvaluateTextUtil . evaluateText ( repl , selectedText , true ) ; 
private void replaceOriginalWithFormatted ( IDocument original , ISourceViewer sourceViewer , String formatted ) { IRegion selection = editor . getSignedSelection ( ) ; Tokens tokens = new Tokens ( original , selection ) ; Document formattedDocument = new Document ( formatted ) ; Tokens formattedTokens = new Tokens ( formattedDocument ) ; int targetOffset = formattedTokens . sameStructuralOffset ( tokens ) ; original . set ( formatted ) ; sourceViewer . setSelectedRange ( targetOffset , 0 ) ; sourceViewer . revealRange ( targetOffset , 0 ) ; } 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isInEscapeSequence ( ) ; @todo -- what does "unsigned"/"signed" mean in this context? public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IJavaProject getAssociatedProject ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public void run ( ) { int caretOffset = editor . getUnSignedSelection ( ) . getOffset ( ) ; Tokens tokens = new Tokens ( editor . getDocument ( ) , caretOffset ) ; tokens . tokenAtCaret ( ) ; String tokenContents = tokens . tokenContents ( ) ; List < String > split = Arrays . asList ( tokenContents . split ( " / " ) ) ; String symbol = tokenContents ; String declaringNamespace = editor . getDeclaringNamespace ( ) ; String namespace = null ; if ( split . size ( ) = = 2 ) { symbol = split . get ( 1 ) ; namespace = split . get ( 0 ) ; } String command = String . format ( " (ccw.debug.serverrepl/find-symbol \" %s \" \" %s \" \" %s \" ) " , symbol , declaringNamespace , namespace ) ; TODO this isn't right, we should be using a REPL specifically for the project where the file is located REPLView replView = REPLView.activeREPL.get(); if (replView == null || replView.isDisposed()) { editor.setStatusLineErrorMessage(ClojureEditorMessages.You_need_a_running_repl); return; } Connection repl = replView.getToolingConnection(); List values = repl.send(command).values(); if (values.isEmpty()) { editor.setStatusLineErrorMessage(ClojureEditorMessages.Cannot_find_declaration); 
public void run ( ) { try { String lib = editor . getDeclaringNamespace ( ) ; 
private void runTests ( String lib , Connection repl ) throws Exception { Response results = repl . send ( runTestsCommand ( lib ) ) ; if ( ( ( String ) results . combinedResponse ( ) . get ( Keyword . intern ( " out " ) ) ) . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
public static IDocument configure ( IDocument document ) { IDocumentPartitioner partitioner = new ClojurePartitioner ( new ClojurePartitionScanner ( ) , ClojurePartitionScanner . CLOJURE_CONTENT_TYPES ) ; Map < String , IDocumentPartitioner > m = new HashMap < String , IDocumentPartitioner > ( ) ; m . put ( ClojurePartitionScanner . CLOJURE_PARTITIONING , partitioner ) ; TextUtilities . addDocumentPartitioners ( document , m ) ; return document ; } 
protected IDocument createDocument ( Object element ) throws CoreException { IDocument document = super . createDocument ( element ) ; if ( document ! = null ) document = configure ( document ) ; return document ; } 
public void consolesRemoved ( IConsole [ ] consoles ) { } public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } } ) ; } private class REPLViewLaunchMonitor extends ProgressMonitorWrapper { private ILaunch launch ; private REPLViewLaunchMonitor ( IProgressMonitor m , ILaunch launch ) { super ( m ) ; this . launch = launch ; } public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " cemerick.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { try { REPLView replView = REPLView . connect ( " localhost " , port ) ; if ( replView ! = null ) { replView . setConsole ( lastConsoleOpened ) ; replView . setLaunch ( launch ) ; } } catch ( Exception e ) { CCWPlugin . logError ( " Could not connect REPL to local launch " , e ) ; } } } ) ; } } @Override public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " cemerick.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; super . launch ( configuration , mode , launch , ( monitor = = null | | ! isLaunchREPL ( configuration ) ) ? monitor : new REPLViewLaunchMonitor ( monitor , launch ) ) ; } finally { Var . popThreadBindings ( ) ; } } @Override public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { String launchId = UUID . randomUUID ( ) . toString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , launchId , super . getVMArguments ( configuration ) ) ; } @Override public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; @Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException { List<String> classpath = new ArrayList<String>(Arrays.asList(super.getClasspath(configuration))); ClojureProject clojureProject = ClojureCore.getClojureProject(LaunchUtils.getProject(configuration)); for (IFolder f: clojureProject.sourceFolders()) { String sourcePath = f.getLocation().toOSString(); while (classpath.contains(sourcePath)) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("nrepl-module")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); }} 
public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } 
public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " cemerick.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { try { REPLView replView = REPLView . connect ( " localhost " , port ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " cemerick.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { String launchId = UUID . randomUUID ( ) . toString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; 
private static boolean isLaunchREPL ( ILaunchConfiguration configuration ) throws CoreException { return configuration . getAttribute ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ; } 
public static boolean isAutoReloadEnabled ( ILaunch launch ) { return Boolean . valueOf ( launch . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED ) ) ; } 
public String getMainTypeName ( ILaunchConfiguration configuration ) tthrows CoreException { String main = configuration . getAttribute ( IJavaLaunchConfigurationConstants . ATTR_MAIN_TYPE_NAME , ( String ) null ) ; return main = = null ? clojure . main . class . getName ( ) : main ; } 
public String [ ] getClasspath ( ILaunchConfiguration configuration ) throws CoreException { List < String > classpath = new ArrayList < String > ( Arrays . asList ( super . getClasspath ( configuration ) ) ) ; ClojureProject clojureProject = ClojureCore . getClojureProject ( LaunchUtils . getProject ( configuration ) ) ; for ( IFolder f : clojureProject . sourceFolders ( ) ) { String sourcePath = f . getLocation ( ) . toOSString ( ) ; while ( classpath . contains ( sourcePath ) ) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("nrepl-module")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); } 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_CONFIG_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
private void createReplServerControl ( final Composite parent ) { Group section = SWTFactory . createGroup ( parent , " Repl settings " , 2 , 1 , 0 ) ; installREPLChoice = SWTFactory . createCheckButton ( tsection , " Run with REPL (see tooltip for detail) " , null , true , 2 ) ; installREPLChoice . setToolTipText ( " If checked, all files listed will be loaded with the -i option, " + " and a new REPL view will be opened and connected to the new process. " + " If unchecked, all files listed will be loaded with the -i option, " + " except for the last which will be loaded as a script. " ) ; installREPLChoice . addSelectionListener ( new SelectionListener ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { } 
public void widgetSelected ( SelectionEvent e ) { tupdateLaunchConfigurationDialog ( ) ; } 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; String currentProjName = fProjText . getText ( ) . trim ( ) ; IProject proj = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( currentProjName ) ; if ( proj = = null ) { return ; } try { tinstallREPLChoice . setSelection ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ) ; } catch ( CoreException e ) { tCCWPlugin . logError ( " error while initializing serverPort " , e ) ; tinstallREPLChoice . setSelection ( true ) ; } try { tsourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public void performApply ( ILaunchConfigurationWorkingCopy config ) { config . setAttribute ( ATTR_PROJECT_NAME , fProjText . getText ( ) . trim ( ) ) ; LaunchUtils . setFilesToLaunchString ( config , ( List < IFile > ) sourceFilesViewer . getInput ( ) ) ; tconfig . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; Overriden at launch time, set here just to make JavaMainTab happy config.setAttribute(LaunchUtils.ATTR_CLOJURE_START_REPL, installREPLChoice.getSelection()); mapResources(config); } 
private Map < String , List < String > > getRemoteNsTree ( Connection repl ) { ttry { Response res = repl . send ( " (ccw.debug.serverrepl/namespaces-info) " ) ; 
public static void setREPLConnection ( final Connection repl ) { if ( repl ! = null ) DisplayUtil . asyncExec ( new Runnable ( ) { 
 public void run ( ) { inUIThreadSetREPLConnection ( repl ) ; } } ) ; 
private static void inUIThreadSetREPLConnection ( Connection repl ) { tIViewPart [ ] views = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getViews ( ) ; tNamespaceBrowser co = null ; tfor ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { tco = ( NamespaceBrowser ) v ; tbreak ; } } if ( co = = null ) { treturn ; } tco . reset ( repl ) ; } 
protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; newShell . setText ( " Connect to REPL " ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " " ) ; don't know much about swt layouts yet :-( hosts.setFocus(); hosts.setSelection(new Point(0, hosts.getText().length())); new Label(parent, 0).setText("Port"); port = new Text(parent, SWT.BORDER); port.addKeyListener(new KeyListener() { public void keyReleased(KeyEvent e) { } public void keyPressed(KeyEvent e) { e.doit = Character.isDigit(e.character); } }); return composite; } 
public void keyReleased ( KeyEvent e ) { } public void keyPressed ( KeyEvent e ) { e . doit = Character . isDigit ( e . character ) ; } } ) ; return composite ; } protected void okPressed ( ) { host = hosts . getText ( ) ; try { portNumber = Integer . parseInt ( port . getText ( ) ) ; } catch ( NumberFormatException e ) { shouldn't happen given the keylistener above } super.okPressed(); } public String getHost () { return host; } public int getPort () { return portNumber; }} 
public void keyPressed ( KeyEvent e ) { e . doit = Character . isDigit ( e . character ) ; } 
protected void okPressed ( ) { host = hosts . getText ( ) ; try { portNumber = Integer . parseInt ( port . getText ( ) ) ; } catch ( NumberFormatException e ) { shouldn't happen given the keylistener above } super.okPressed(); } 
private void copyToLog ( StyledText s ) { int start = logPanel . getCharCount ( ) ; try { log . invoke ( logPanel , s . getText ( ) , null ) ; 
private void evalExpression ( ) { evalExpression ( viewerWidget . getText ( ) , false ) ; copyToLog ( viewerWidget ) ; viewerWidget . setText ( " " ) ; } 
public void evalExpression ( String s ) { TODO add highlighting of evaluated code pushed from editors evalExpression(s, true); } 
public void evalExpression ( String s , boolean copyToLog ) { try { if ( s . trim ( ) . length ( ) > 0 ) { 
public void closeView ( ) throws Exception { IWorkbenchPage page = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; page . hideView ( this ) ; closeConnections ( ) ; } 
public void closeConnections ( ) throws Exception { if ( interactive ! = null ) interactive . close ( ) ; if ( toolConnection ! = null ) toolConnection . close ( ) ; } 
public void reconnect ( ) throws Exception { closeConnections ( ) ; configure ( interactive . host , interactive . port ) ; } 
public void setCurrentNamespace ( String ns ) { TODO waaaay better to put a dropdown namespace chooser in the view's toolbar, and this would just change its selection setPartName(String.format("REPL @ %s:%s (%s)", interactive.host, interactive.port, ns)); } 
public boolean configure ( String host , int port ) throws Exception { try { interactive = new Connection ( host , port ) ; 
public static REPLView connect ( ) throws Exception { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; ConnectDialog dlg = new ConnectDialog ( window . getShell ( ) ) ; REPLView repl = null ; if ( dlg . open ( ) = = ConnectDialog . OK ) { cannot find any way to create a configured/connected REPLView, and install it programmatically String host = dlg.getHost(); int port = dlg.getPort(); if (host == null || host.length() == 0 || port < 0 || port > 65535) { MessageDialog.openInformation(window.getShell(), "Invalid connection info", "You must provide a useful hostname and port number to connect to a REPL."); } else { repl = connect(host, port); } } return repl; } 
public static REPLView connect ( String host , int port ) throws Exception { REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , host + " @ " + port , IWorkbenchPage . VIEW_ACTIVATE ) ; return repl . configure ( host , port ) ? repl : null ; } 
public Connection getToolingConnection ( ) { return toolConnection ; } 
public void setConsole ( IConsole console ) { this . console = console ; } 
public void showConsole ( ) { if ( console ! = null ) ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( console ) ; } 
public void createPartControl ( Composite parent ) { IPreferenceStore prefs = CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) ; SashForm split = new SashForm ( parent , SWT . VERTICAL ) ; logPanel = new StyledText ( split , SWT . V_SCROLL | SWT . WRAP ) ; logPanel . setWrapIndent ( 4 ) ; logPanel . setEditable ( false ) ; logPanel . setFont ( JFaceResources . getFont ( JFaceResources . TEXT_FONT ) ) ; viewer = new ClojureSourceViewer ( split , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL , prefs ) { public Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } }; viewerConfig = new ClojureSourceViewerConfiguration(prefs, viewer); viewer.configure(viewerConfig); getViewSite().setSelectionProvider(viewer); viewer.setDocument(ClojureDocumentProvider.configure(new Document())); viewerWidget = viewer.getTextWidget(); viewerWidget.setFont(JFaceResources.getFont(JFaceResources.TEXT_FONT)); viewerWidget.addVerifyKeyListener(new REPLInputVerifier()); split.setWeights(new int[] {80, 20}); viewer.propertyChange(null); viewerWidget.addFocusListener(new NamespaceRefreshFocusListener()); logPanel.addFocusListener(new NamespaceRefreshFocusListener()); parent.addDisposeListener(new DisposeListener () { public void widgetDisposed(DisposeEvent e) { 
public Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } 
public void widgetDisposed ( DisposeEvent e ) { activeREPL . compareAndSet ( REPLView . this , null ) ; } 
public void dispose ( ) { super . dispose ( ) ; interactive . close ( ) ; toolConnection . close ( ) ; } 
public boolean isDisposed ( ) { TODO we actually want to report whether the viewpart has been closed, not whether or not the platform has disposed the widget peer return viewerWidget.isDisposed(); } 
public void focusGained ( FocusEvent e ) { activeREPL . set ( REPLView . this ) ; NamespaceBrowser . setREPLConnection ( toolConnection ) ; } 
public void focusLost ( FocusEvent e ) { } } private class REPLInputVerifier implements VerifyKeyListener { private boolean isEvalEvent ( KeyEvent e ) { if ( e . stateMask = = SWT . SHIFT ) return false ; if ( e . keyCode = = '' | | e . keyCode = = '\r' ) { return e . stateMask = = SWT . CONTROL | | viewerWidget . getSelection ( ) . x = = viewerWidget . getCharCount ( ) ; } return false ; } public void verifyKey ( VerifyEvent e ) { if ( isEvalEvent ( e ) ) { evalExpression ( ) ; e . doit = false ; } } } } 
private boolean isEvalEvent ( KeyEvent e ) { if ( e . stateMask = = SWT . SHIFT ) return false ; if ( e . keyCode = = '' | | e . keyCode = = '\r' ) { return e . stateMask = = SWT . CONTROL | | viewerWidget . getSelection ( ) . x = = viewerWidget . getCharCount ( ) ; } return false ; } 
public void verifyKey ( VerifyEvent e ) { if ( isEvalEvent ( e ) ) { evalExpression ( ) ; 
public void run ( IAction action ) { try { repl . reconnect ( ) ; 
public void selectionChanged ( IAction action , ISelection selection ) { } public void init ( IViewPart view ) { repl = ( REPLView ) view ; } public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } public Object execute ( ExecutionEvent event ) throws ExecutionException { return null ; } public boolean isEnabled ( ) { return true ; } public boolean isHandled ( ) { return true ; } public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public void addHandlerListener ( IHandlerListener handlerListener ) { } public void dispose ( ) { } public Object execute ( ExecutionEvent event ) throws ExecutionException { return null ; } public boolean isEnabled ( ) { return true ; } public boolean isHandled ( ) { return true ; } public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public void dispose ( ) { } public Object execute ( ExecutionEvent event ) throws ExecutionException { return null ; } public boolean isEnabled ( ) { return true ; } public boolean isHandled ( ) { return true ; } public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { return null ; } 
public void removeHandlerListener ( IHandlerListener handlerListener ) { } } 
public void createPartControl ( Composite parent ) { IPreferenceStore prefs = CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) ; SashForm split = new SashForm ( parent , SWT . VERTICAL ) ; logPanel = new StyledText ( split , SWT . V_SCROLL | SWT . WRAP ) ; logPanel . setIndent ( 4 ) ; logPanel . setEditable ( false ) ; logPanel . setFont ( JFaceResources . getFont ( JFaceResources . TEXT_FONT ) ) ; viewer = new ClojureSourceViewer ( split , null , null , false , SWT . V_SCROLL | SWT . H_SCROLL , prefs ) { public Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } }; viewerConfig = new ClojureSourceViewerConfiguration(prefs, viewer); viewer.configure(viewerConfig); getViewSite().setSelectionProvider(viewer); viewer.setDocument(ClojureDocumentProvider.configure(new Document())); viewerWidget = viewer.getTextWidget(); viewerWidget.setFont(JFaceResources.getFont(JFaceResources.TEXT_FONT)); viewerWidget.addVerifyKeyListener(new REPLInputVerifier()); split.setWeights(new int[] {80, 20}); viewer.propertyChange(null); viewerWidget.addFocusListener(new NamespaceRefreshFocusListener()); logPanel.addFocusListener(new NamespaceRefreshFocusListener()); parent.addDisposeListener(new DisposeListener () { public void widgetDisposed(DisposeEvent e) { 
public final ClojureSourceViewer sourceViewer ( ) { return ( ClojureSourceViewer ) super . getSourceViewer ( ) ; } 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public boolean isInEscapeSequence ( ) ; @todo -- what does "unsigned"/"signed" mean in this context? public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public IJavaProject getAssociatedProject ( ) ; public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; } 
public static void gotoEditorLine ( Object editor , int line ) { if ( ITextEditor . class . isInstance ( editor ) ) { tITextEditor textEditor = ( ITextEditor ) editor ; 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void setStructuralEditingPossible (boolean possible); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isInEscapeSequence ( ) ; public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IJavaProject getAssociatedProject ( ) ; public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public REPLView getCorrespondingREPL ( ) ; public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public void setStructuralEditingPossible ( boolean possible ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public void setCurrentNamespace ( String ns ) { his.currentNamespaceName = ns; setPartName(String.format("REPL @ %s:%s (%s)", interactive.host, interactive.port, currentNamespaceName)); } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; startClojureCode ( context ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.RaiseSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; tClojureOSGi . require ( bundleContext , " ccw.repl.view-helpers " ) ; } 
public void consolesRemoved ( IConsole [ ] consoles ) { } public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } } ) ; } private class REPLViewLaunchMonitor extends ProgressMonitorWrapper { private ILaunch launch ; private REPLViewLaunchMonitor ( IProgressMonitor m , ILaunch launch ) { super ( m ) ; this . launch = launch ; } public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { try { REPLView replView = REPLView . connect ( " localhost " , port ) ; if ( replView ! = null ) { replView . setConsole ( lastConsoleOpened ) ; replView . setLaunch ( launch ) ; } } catch ( Exception e ) { CCWPlugin . logError ( " Could not connect REPL to local launch " , e ) ; } } } ) ; } } @Override public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " clojure.tools.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; super . launch ( configuration , mode , launch , ( monitor = = null | | ! isLaunchREPL ( configuration ) ) ? monitor : new REPLViewLaunchMonitor ( monitor , launch ) ) ; } finally { Var . popThreadBindings ( ) ; } } @Override public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { String launchId = UUID . randomUUID ( ) . toString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , launchId , super . getVMArguments ( configuration ) ) ; } @Override public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; @Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException { List<String> classpath = new ArrayList<String>(Arrays.asList(super.getClasspath(configuration))); ClojureProject clojureProject = ClojureCore.getClojureProject(LaunchUtils.getProject(configuration)); for (IFolder f: clojureProject.sourceFolders()) { String sourcePath = f.getLocation().toOSString(); while (classpath.contains(sourcePath)) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("org.clojure.tools.nrepl")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); }} 
public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " clojure.tools.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public String [ ] getClasspath ( ILaunchConfiguration configuration ) throws CoreException { List < String > classpath = new ArrayList < String > ( Arrays . asList ( super . getClasspath ( configuration ) ) ) ; ClojureProject clojureProject = ClojureCore . getClojureProject ( LaunchUtils . getProject ( configuration ) ) ; for ( IFolder f : clojureProject . sourceFolders ( ) ) { String sourcePath = f . getLocation ( ) . toOSString ( ) ; while ( classpath . contains ( sourcePath ) ) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("org.clojure.tools.nrepl")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); } 
public void handleEvent ( Event e ) { this prevents focus switch on cut/copy no event that would trigger a paste is sent as long as logPanel is uneditable, so we can't redirect it :-( boolean modifier = (e.keyCode & SWT.MODIFIER_MASK) != 0; if (modifier) return; viewerWidget.notifyListeners(SWT.KeyDown, e); viewerWidget.setFocus(); } 
public static void log ( String msg ) { plugin . getLog ( ) . log ( new Status ( IStatus . INFO , PLUGIN_ID , msg ) ) ; } 
public static IProject getProject ( ILaunchConfiguration configuration ) throws CoreException { return getProject ( configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; } 
public static IProject getProject ( ILaunch launch ) throws CoreException { return getProject ( getProjectName ( launch ) ) ; } 
public static String getProjectName ( ILaunch launch ) { return launch . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME ) ; } 
public static IProject getProject ( String projectName ) { here fundamentally to simplify things for repl cmd history return projectName == null ? null : ResourcesPlugin.getWorkspace().getRoot().getProject(projectName); } 
private void prepareView ( ) throws Exception { evalExpression = ( IFn ) configureREPLView . invoke ( this , logPanel , interactive . conn , requests ) ; } 
public void consolesRemoved ( IConsole [ ] consoles ) { } public void consolesAdded ( IConsole [ ] consoles ) { lastConsoleOpened = consoles . length > 0 ? consoles [ 0 ] : null ; } } ) ; } private class REPLViewLaunchMonitor extends ProgressMonitorWrapper { private ILaunch launch ; private REPLViewLaunchMonitor ( IProgressMonitor m , ILaunch launch ) { super ( m ) ; this . launch = launch ; } public void done ( ) { super . done ( ) ; final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { try { REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; } catch ( Exception e ) { CCWPlugin . logError ( " Could not connect REPL to local launch " , e ) ; } } } ) ; } } @Override public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; SafeFn . find ( " clojure.tools.nrepl " , " reset-ack-port! " ) . sInvoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; super . launch ( configuration , mode , launch , ( monitor = = null | | ! isLaunchREPL ( configuration ) ) ? monitor : new REPLViewLaunchMonitor ( monitor , launch ) ) ; } finally { Var . popThreadBindings ( ) ; } } @Override public String getVMArguments ( ILaunchConfiguration configuration ) throws CoreException { String launchId = UUID . randomUUID ( ) . toString ( ) ; return String . format ( " -D%s=%s %s " , LaunchUtils . SYSPROP_LAUNCH_ID , launchId , super . getVMArguments ( configuration ) ) ; } @Override public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString userProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLaunchREPL ( configuration ) ) { tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; @Override public String[] getClasspath(ILaunchConfiguration configuration) throws CoreException { List<String> classpath = new ArrayList<String>(Arrays.asList(super.getClasspath(configuration))); ClojureProject clojureProject = ClojureCore.getClojureProject(LaunchUtils.getProject(configuration)); for (IFolder f: clojureProject.sourceFolders()) { String sourcePath = f.getLocation().toOSString(); while (classpath.contains(sourcePath)) { The sourcePath already exists, remove it first classpath.remove(sourcePath); } classpath.add(0, sourcePath); } try { File repllib = FileLocator.getBundleFile(Platform.getBundle("org.clojure.tools.nrepl")); classpath.add(repllib.getAbsolutePath()); } catch (IOException e) { throw new WorkbenchException("Failed to find nrepl library", e); } return classpath.toArray(new String[classpath.size()]); }} 
public void run ( ) { try { REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; 
public static REPLView connect ( String host , int port ) throws Exception { return connect ( host , port , null , null ) ; } 
public static REPLView connect ( String host , int port , IConsole console , ILaunch launch ) throws Exception { REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , host + " @ " + port , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . console = console ; repl . launch = launch ; return repl . configure ( host , port ) ? repl : null ; } 
public void reconnect ( ) throws Exception { closeConnections ( ) ; logPanel . append ( " ;; Reconnecting... " ) ; configure ( interactive . host , interactive . port ) ; } 
public void run ( ) { tcolorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; tcolorRegistry . put ( " ccw.repl.expressionBackground " , new RGB ( 0xf0 , 0xf0 , 0xf0 ) ) ; } } ) ; 
private void copyToLog ( StyledText s ) { int start = logPanel . getCharCount ( ) ; int lineCnt = logPanel . getLineCount ( ) ; try { log . invoke ( logPanel , s . getText ( ) , null ) ; 
public void evalExpression ( String s ) { evalExpression ( s , true ) ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { return REPLView . connect ( ) ; 
public void run ( IAction action ) { repl . logPanel . setText ( " " ) ; } 
public void run ( IAction action ) { try { repl . reconnect ( ) ; 
public void run ( IAction action ) { ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( repl . getConsole ( ) ) ; } 
public boolean isEnabled ( ) { return repl . getConsole ( ) ! = null ; } 
public void selectionChanged ( IAction action , ISelection selection ) { } public void init ( IViewPart view ) { repl = ( REPLView ) view ; } public Object execute ( ExecutionEvent event ) throws ExecutionException { return null ; } } } 
public void init ( IViewPart view ) { repl = ( REPLView ) view ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { return null ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { return REPLView . connect ( ) ; 
private void copyToLog ( StyledText s ) { int start = logPanel . getCharCount ( ) ; try { log . invoke ( logPanel , s . getText ( ) , inputExprLogType ) ; 
public void setCurrentNamespace ( String ns ) { currentNamespace = ns; setPartName(String.format("REPL @ %s:%s (%s)", interactive.host, interactive.port, currentNamespace)); } 
private int incTempLaunchCount ( String projectName ) { synchronized ( tempLaunchCounters ) { Integer cnt = tempLaunchCounters . get ( projectName ) ; 
public void handleEvent ( Event e ) { if ( ! ( e . keyCode = = SWT . PAGE_DOWN | | e . keyCode = = SWT . PAGE_UP ) ) { this prevents focus switch on cut/copy 
public void handleEvent ( Event e ) { switch ( e . keyCode ) { case SWT . PAGE_DOWN : 
public static final void evaluateText ( final String text , boolean userInput ) { tevaluateText ( REPLView . activeREPL . get ( ) , text , userInput ) ; } 
public static final void evaluateText ( REPLView console , final String text , boolean userInput ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
private void evalExpression ( ) { evalExpression ( viewerWidget . getText ( ) , true , false ) ; copyToLog ( viewerWidget ) ; viewerWidget . setText ( " " ) ; } 
public void evalExpression ( String s ) { evalExpression ( s , true , true ) ; } 
public void evalExpression ( String s , boolean userInput , boolean logExpression ) { try { if ( s . trim ( ) . length ( ) > 0 ) { 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void run ( ) { REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl = = null | | repl . isDisposed ( ) ) { return ; } String ns = editor . getDeclaringNamespace ( ) ; if ( ns = = null ) { put error msg in footer instead 
public void run ( IAction action ) { repl . printErrorDetail ( ) ; } 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (clojure.tools.nrepl/*print-error-detail* *e)) " , false , false ) ; } 
public void verifyKey ( VerifyEvent e ) { TODO I desperately want this to be a proper, reconfigurable keybinding, but doing so looks like a PITA: http:www.eclipsezone.com/eclipse/forums/t69603.html http:dev.eclipse.org/newslists/news.eclipse.platform/msg60894.html http:wiki.eclipse.org/index.php/Platform_Command_Framework if (e.stateMask == SWT.CTRL && e.keyCode == 'j') { printErrorDetail(); 
public Object execute ( ExecutionEvent event ) throws ExecutionException { if ( execute ( true ) ) return null ; MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getDisplay ( ) . getActiveShell ( ) , " No Active REPL " , " No REPL is active. Click in an existing REPL to make it the active target, or open a new REPL. " ) ; return null ; } 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (if-not *e (println \" No prior exception bound to *e. \" ) (clojure.tools.nrepl/*print-error-detail* *e))) " , false , false ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , IClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tREPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; tConnection connection = repl . getToolingConnection ( ) ; tResponse response = connection . send ( " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) ; treturn ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; tConnection connection = repl . getToolingConnection ( ) ; tResponse response = connection . send ( " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; treturn ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private static Object extractSingleValue ( Response response , Object defaultValueIfNil ) { tObject r = response . values ( ) . get ( 0 ) ; if ( r = = null ) { treturn defaultValueIfNil ; 
public void run ( ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage page = window . getActivePage ( ) ; 
public void done ( ) { super . done ( ) ; new Thread ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { final Integer port = ( Integer ) SafeFn . find ( " clojure.tools.nrepl " , " wait-for-ack " ) . sInvoke ( 10000 ) ; if ( port = = null ) { CCWPlugin . logError ( " Waiting for new REPL process ack timed out " ) ; return ; } DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
 public void done ( ) { tconnectRepl ( ) ; } 
 private void connectRepl ( ) { try { REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; 
private void updateParseRef ( String text ) { tboolean firstTime = ( parseRef = = null ) ; parseRef = EditorSupport . updateParseRef ( text , parseRef ) ; if ( firstTime ) { tEditorSupport . startWatchParseRef ( parseRef , this ) ; 
private void syncWithStructuralEditionPossibleState ( ) { tDisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { tgetTextWidget ( ) . setBackground ( tstructuralEditionPossible ? null : Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_GRAY ) ) ; tgetTextWidget ( ) . setToolTipText ( structuralEditionPossible ? null : " Unparseable source code. Structural Edition temporarily disabled. " ) ; } 
public void updateTabsToSpacesConverter ( ) { } } }} 
public void setDocument ( IDocument document , tIAnnotationModel annotationModel , int modelRangeOffset , tint modelRangeLength ) { tsuper . setDocument ( document , annotationModel , modelRangeOffset , modelRangeLength ) ; if ( document ! = null ) { tupdateParseRef ( document . get ( ) ) ; 
public void selectAndReveal ( int start , int length ) ; public REPLView getCorrespondingREPL (); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isStructuralEditingEnabled ( ) ; public REPLView getCorrespondingREPL (); public void updateTabsToSpacesConverter ();public IDocument getDocument();public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public boolean isInEscapeSequence ( ) ; public void setStatusLineErrorMessage(String you_need_a_running_repl);} 
public IRegion getUnSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IRegion getSignedSelection ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public String getDeclaringNamespace ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public IJavaProject getAssociatedProject ( ) ; public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public Object getParsed ( ) ; public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public REPLView getCorrespondingREPL ( ) ; public void updateTabsToSpacesConverter ( ) ; public IDocument getDocument ( ) ; public void setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
protected void initializeKeyBindingScopes ( ) { tsetKeyBindingScopes ( new String [ ] { IClojureEditor . KEY_BINDING_SCOPE } ) ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);} 
boolean isInEscapeSequence ( ) ; void setStatusLineErrorMessage(String you_need_a_running_repl);} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
IRegion getSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
String getDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tIWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; if ( ! ( part instanceof REPLView ) ) { treturn null ; } tREPLView repl = ( REPLView ) part ; trepl . printErrorDetail ( ) ; treturn null ; } 
public void verifyKey ( VerifyEvent e ) { if (e.stateMask == SWT.CTRL && e.keyCode == 'k') { logPanel.setText(""); 
public static IStatus createErrorStatus ( String message , Throwable e ) { treturn new Status ( IStatus . ERROR , PLUGIN_ID , message , e ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( repl . getConsole ( ) ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { repl . logPanel . setText ( " " ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { try { repl . reconnect ( ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { trepl . printErrorDetail ( ) ; } 
public final Object execute ( ExecutionEvent event ) throws ExecutionException { tIWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; if ( ! ( part instanceof REPLView ) ) { treturn null ; } tdoExecute ( event , ( REPLView ) part ) ; treturn null ; } 
protected abstract void doExecute ( ExecutionEvent event , REPLView part ) throws ExecutionException ; } } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { tsupport . setCharacterPairMatcher ( viewer . getPairsMatcher ( ) ) ; tsupport . setMatchingCharacterPainterPreferenceKeys ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR ) ; tsuper . configureSourceViewerDecorationSupport ( support ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void contributeToMenu ( IMenuManager menu ) { tsuper . contributeToMenu ( menu ) ; 
public void gotoMatchingBracket ( ) { tIDocument document = getDocument ( ) ; if ( document = = null ) treturn ; tIRegion selection = getSignedSelection ( ) ; tint selectionLength = Math . abs ( selection . getLength ( ) ) ; if ( selectionLength > 1 ) { tsetStatusLineErrorMessage ( ClojureEditorMessages . GotoMatchingBracketAction_error_invalidSelection ) ; tgetTextWidget ( ) . getDisplay ( ) . beep ( ) ; treturn ; } } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tIWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; tIClojureEditor clojureEditor = ( IClojureEditor ) PlatformUtil . getAdapter ( part , IClojureEditor . class ) ; if ( clojureEditor = = null ) { tCCWPlugin . logWarning ( " Handler " + OpenDeclarationHandler . class . getSimpleName ( ) + " executed on a IWorkbenchPart (id: " + part . getSite ( ) . getId ( ) + " ) which is not able to adapt to " + IClojureEditor . class . getSimpleName ( ) ) ; treturn null ; } tclojureEditor . gotoMatchingBracket ( ) ; treturn null ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isInEscapeSequence ( ) ; DefaultCharacterPairMatcher getPairsMatcher();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
IRegion getSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
String getDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.RaiseSelectionHandler " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; tClojureOSGi . require ( bundleContext , " ccw.editors.antlrbased.handlers " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
public Object create ( ) throws CoreException { treturn new ClojureHandlerProxy ( handlerFn ) ; } 
public void setInitializationData ( IConfigurationElement config , tString propertyName , Object data ) throws CoreException { tassert data instanceof String ; thandlerFn = ( String ) data ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { ttry { texecute . invoke ( this , event ) ; } catch ( Exception e ) { tthrow new ExecutionException ( " clojure handler fn " + execute . ns + " / " + execute . sym + " threw an exception " , e ) ; } treturn null ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SplitSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.JoinSexprAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
public Object create ( ) throws CoreException { treturn new ClojureHandlerProxy ( bundleName , handlerFn ) ; } 
public void setInitializationData ( IConfigurationElement config , tString propertyName , Object data ) throws CoreException { tassert data instanceof String ; tbundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; thandlerFn = ( String ) data ; } 
private Bundle getBundle ( String bundleSymbolicName ) throws CoreException { Bundle b = Platform.getBundle(bundleSymbolicName); 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; don't know much about swt layouts yet :-( hosts.setSelection(new Point(0, hosts.getText().length())); new Label(parent, 0).setText("Port"); port = new Text(parent, SWT.BORDER); port.addKeyListener(new KeyListener() { public void keyReleased(KeyEvent e) { } public void keyPressed(KeyEvent e) { e.doit = Character.isDigit(e.character); } }); port.setFocus(); return composite; } 
public void keyReleased ( KeyEvent e ) { } public void keyPressed ( KeyEvent e ) { e . doit = Character . isDigit ( e . character ) ; } } ) ; port . setFocus ( ) ; return composite ; } protected void okPressed ( ) { host = hosts . getText ( ) ; try { portNumber = Integer . parseInt ( port . getText ( ) ) ; } catch ( NumberFormatException e ) { shouldn't happen given the keylistener above } super.okPressed(); } public String getHost () { return host; } public int getPort () { return portNumber; }} 
private synchronized void startREPLServer ( ) throws CoreException { if ( ackREPLServer = = null ) { try { 
public int getREPLServerPort ( ) throws CoreException { if ( ackREPLServer = = null ) { tstartREPLServer ( ) ; } treturn ackREPLServer . getLocalPort ( ) ; } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; startClojureCode ( context ) ; startREPLServer ( ) ; initializeParenRainbowColors ( ) ; createColorRegistry ( ) ; } 
public void stop ( BundleContext context ) throws Exception { tdisposeParenRainbowColors ( ) ; stopREPLServer(); plugin = null; super.stop(context); } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { return REPLView . connect ( " 127.0.0.1 " , CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ) ; 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionUpAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionLeftAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ExpandSelectionRightAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.OpenDeclarationAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; if ( fPreferenceStore ! = null ) { fPreferenceStore . addPropertyChangeListener ( this ) ; initializeViewerColors ( ) ; } if ( configuration instanceof ClojureSourceViewerConfiguration ) fConfiguration = ( ClojureSourceViewerConfiguration ) configuration ; tfSelectionHistory = new SelectionHistory ( this ) ; fIsConfigured = true ; } 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { tfForegroundColor . dispose ( ) ; tfForegroundColor = null ; } if ( fBackgroundColor ! = null ) { tfBackgroundColor . dispose ( ) ; tfBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { tfSelectionForegroundColor . dispose ( ) ; tfSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { tfSelectionBackgroundColor . dispose ( ) ; tfSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( this ) ; if ( fSelectionHistory ! = null ) { tfSelectionHistory . dispose ( ) ; tfSelectionHistory = null ; } super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();} 
boolean isInEscapeSequence ( ) ; DefaultCharacterPairMatcher getPairsMatcher();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; } 
public void remember ( ISourceRange range ) { tSystem . out . println ( " asked to remember range: " + range ) ; tfHistory . add ( range ) ; fHistoryAction.update(); TODO correctement 
public void flush ( ) { if ( fHistory . isEmpty ( ) ) treturn ; tfHistory . clear ( ) ; fHistoryAction.update(); TODO correctement 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.IndentSelectionAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tIWorkbenchPart part = HandlerUtil . getActivePart ( event ) ; tIClojureEditor clojureEditor = ( IClojureEditor ) PlatformUtil . getAdapter ( part , IClojureEditor . class ) ; if ( clojureEditor = = null ) { tCCWPlugin . logWarning ( " Handler " + GotoMatchingBracketHandler . class . getSimpleName ( ) + " executed on a IWorkbenchPart (id: " + part . getSite ( ) . getId ( ) + " ) which is not able to adapt to " + IClojureEditor . class . getSimpleName ( ) ) ; treturn null ; } tclojureEditor . gotoMatchingBracket ( ) ; treturn null ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
public boolean isStructuralEditionPossible ( ) { treturn sourceViewer ( ) . isStructuralEditionPossible ( ) ; } 
public boolean isStructuralEditionPossible ( ) { treturn structuralEditionPossible ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isInEscapeSequence ( ) ; boolean isStructuralEditionPossible();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
String getDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
private static boolean hasNsCall ( String sourceCode ) { tMatcher matcher = HAS_NS_CALL_PATTERN . matcher ( sourceCode ) ; treturn matcher . find ( ) ; } 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tString maybeLibName = ClojureCore . findMaybeLibNamespace ( ( IFile ) resource , currentSrcFolder . getKey ( ) . getFullPath ( ) ) ; if ( maybeLibName ! = null ) { tclojureLibs . add ( maybeLibName ) ; } } treturn true ; } 
public static String findDeclaringNamespace ( String sourceText ) { tMatcher matcher = SEARCH_DECLARING_NAMESPACE_PATTERN . matcher ( sourceText ) ; if ( matcher . find ( ) ) { tSystem . out . println ( " found declaring namespace: " + matcher . group ( 1 ) ) ; } treturn ( matcher . find ( ) ? matcher . group ( 1 ) : null ) ; } 
public String findDeclaringNamespace ( ) { treturn ( ( ClojureSourceViewer ) getSourceViewer ( ) ) . findDeclaringNamespace ( ) ; } 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( getDocument ( ) . get ( ) ) ; } 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tEvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , true ) ; editorFile.getProject().getFolder("classes").refreshLocal(IFolder.DEPTH_INFINITE, null); 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String you_need_a_running_repl);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();} 
boolean isInEscapeSequence ( ) ; boolean isStructuralEditionPossible();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String you_need_a_running_repl ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; } 
public void run ( ) { try { String lib = editor . findDeclaringNamespace ( ) ; 
public void run ( ) { REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl = = null | | repl . isDisposed ( ) ) { return ; } String ns = editor . findDeclaringNamespace ( ) ; if ( ns = = null ) { put error msg in footer instead 
public String findDeclaringNamespace ( ) { tString inline = super . findDeclaringNamespace ( ) ; if ( inline ! = null ) { treturn inline ; 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.SwitchStructuralEditionModeAction " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; tClojureOSGi . require ( bundleContext , " ccw.static-analysis " ) ; } 
public static String findDeclaringNamespace ( String sourceText ) { tVar sexp = RT . var ( " paredit.parser " , " sexp " ) ; ttry { treturn ( String ) findDeclaringNamespace ( ( Map ) sexp . invoke ( sourceText ) ) ; 
public static String findDeclaringNamespace ( Map tree ) { tVar findNamespace = RT . var ( " ccw.static-analysis " , " find-namespace " ) ; ttry { treturn ( String ) findNamespace . invoke ( tree ) ; 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) getParsed ( ) ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; "SwitchStructuralEditionModeAction", action);} 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { tEditorSupport . configureSourceViewerDecorationSupport ( support , viewer ) ; tsuper . configureSourceViewerDecorationSupport ( support ) ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = EditorSupport . disposeSourceViewerDecorationSupport ( fSourceViewerDecorationSupport ) ; interactive . close ( ) ; toolConnection . close ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; tClojureOSGi . require ( bundleContext , " ccw.static-analysis " ) ; } 
public void createPartControl ( Composite parent ) { tsuper . createPartControl ( parent ) ; tClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; tfProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
public void toggleStructuralEditionMode ( ) { tsourceViewer ( ) . toggleStructuralEditionMode ( ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; setAction("ClojureLaunchAction", action); 
public boolean isStructuralEditingEnabled ( ) { return sourceViewer ( ) . isStructuralEditingEnabled ( ) ; } 
public boolean isStructuralEditingEnabled ( ) { return useStrictStructuralEditing ; } 
public void toggleStructuralEditionMode ( ) { useStrictStructuralEditing = ! useStrictStructuralEditing ; updateStatusField ( ) ; } 
private void updateStatusField ( ) { if ( structuralEditionStatusField ! = null ) { / * 
public void contributeToStatusLine ( IStatusLineManager statusLineManager ) { tstatusLineManager . add ( structuralEditionStatusField ) ; tupdateStatusField ( ) ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
Object getParsed ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tString maybeLibName = ClojureCore . findMaybeLibNamespace ( ( IFile ) resource , currentSrcFolder . getKey ( ) . getFullPath ( ) ) ; if ( maybeLibName ! = null ) { tclojureLibs . add ( maybeLibName ) ; tSystem . out . println ( " maybe lib: " + resource . getLocation ( ) + " recognized as a lib " ) ; } else { tSystem . out . println ( " maybe lib: " + resource . getLocation ( ) + " NOT recognized as a lib " ) ; } } treturn true ; } 
public void run ( ) { tString selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . trim ( ) . equals ( " " ) ) { tselectedText = editor . getCurrentOrNextTopLevelSExpression ( ) ; } tREPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tString textToEvaluate = selectedText ; 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.antlrbased.ClojureHyperlink " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.serverrepl " ) ; ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; startClojureCode ( context ) ; startREPLServer ( ) ; initializeParenRainbowColors ( ) ; } 
public void run ( ) { tgetTextWidget ( ) . setBackground ( tstructuralEditionPossible ? fBackgroundColor : Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_GRAY ) ) ; tgetTextWidget ( ) . setToolTipText ( structuralEditionPossible ? null : " Unparseable source code. Structural Edition temporarily disabled. " ) ; } 
public synchronized void startREPLServer ( ) throws CoreException { if ( ackREPLServer = = null ) { try { 
public void start ( BundleContext context ) throws Exception { tSystem . out . println ( " CCWPlugin start() starts " ) ; super . start ( context ) ; plugin = this ; startClojureCode ( context ) ; tSystem . out . println ( " CCWPlugin start() ends " ) ; } 
private synchronized void createColorRegistry ( ) { if ( colorRegistry = = null ) { tcolorRegistry = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; 
private synchronized void initializeParenRainbowColors ( ) { if ( allColors = = null ) { allColors = new Color [ ] { 
private void copyToLog ( StyledText s ) { sadly, need to reset text on the ST in order to get formatting/style ranges... s.setText(boostIndent.matcher(s.getText()).replaceAll(" ").replaceFirst("^\\s+", "=> ")); int start = logPanel.getCharCount(); try { log.invoke(logPanel, s.getText(), inputExprLogType); 
public REPLView getCorrespondingREPL ( ) { tIFile file = ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( file ! = null ) { treturn CCWPlugin . getDefault ( ) . getProjectREPL ( file . getProject ( ) ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tevalExpression ( ) ; treturn null ; } 
private boolean isEvalEvent ( KeyEvent e ) { if ( e . keyCode = = '' | | e . keyCode = = '\r' ) { return e . stateMask ! = SWT . SHIFT & & 
 private void connectRepl ( ) { try { REPLView replView = REPLView . connect ( " localhost " , port , lastConsoleOpened , launch ) ; 
private static int incTempLaunchCount ( String projectName ) { synchronized ( tempLaunchCounters ) { Integer cnt = tempLaunchCounters . get ( projectName ) ; 
private ILaunch launchEditorPart ( IEditorPart editor , String mode , Boolean activateAutoReload ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public void connect ( Object element ) throws CoreException { tsuper . connect ( element ) ; tconfigure ( getDocument ( element ) ) ; } 
public void disconnect ( Object element ) { tTextUtilities . removeDocumentPartitioners ( getDocument ( element ) ) ; tsuper . disconnect ( element ) ; } 
public void documentChanged ( DocumentEvent event ) { updateTextBuffer ( event . getDocument ( ) . get ( ) ) ; } 
private void updateTextBuffer ( String text ) { tboolean firstTime = ( parseRef = = null ) ; parseRef = EditorSupport . updateTextBuffer ( 0 L , - 1L , text , parseRef ) ; if ( firstTime ) { tEditorSupport . startWatchParseRef ( parseRef , this ) ; 
public Object getParseTree ( ) { if ( parseRef = = null ) { updateTextBuffer ( getDocument ( ) . get ( ) ) ; } return EditorSupport . getParseTree ( getDocument ( ) . get ( ) , parseRef ) ; } 
public String findDeclaringNamespace ( ) { return ClojureCore . findDeclaringNamespace ( ( Map ) getParseTree ( ) ) ; } 
public void setDocument ( IDocument document , tIAnnotationModel annotationModel , int modelRangeOffset , tint modelRangeLength ) { tsuper . setDocument ( document , annotationModel , modelRangeOffset , modelRangeLength ) ; if ( document ! = null ) { tupdateTextBuffer ( document . get ( ) ) ; 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
Object getParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
public void documentChanged ( DocumentEvent event ) { updateTextBuffer ( event . getDocument ( ) . get ( ) , event . getOffset ( ) , event . getLength ( ) , event . getText ( ) ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String text ) { tboolean firstTime = ( parseRef = = null ) ; parseRef = EditorSupport . updateTextBuffer ( parseRef , finalText , offset , length , text ) ; if ( firstTime ) { tEditorSupport . startWatchParseRef ( parseRef , this ) ; 
public Object getParseTree ( ) { if ( parseRef = = null ) { tString text = getDocument ( ) . get ( ) ; updateTextBuffer ( text , 0 , - 1 , text ) ; } return EditorSupport . getParseTree ( getDocument ( ) . get ( ) , parseRef ) ; } 
public void setDocument ( IDocument document , tIAnnotationModel annotationModel , int modelRangeOffset , tint modelRangeLength ) { tsuper . setDocument ( document , annotationModel , modelRangeOffset , modelRangeLength ) ; if ( document ! = null ) { tString text = document . get ( ) ; 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.PareditAutoEditStrategy " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureTopLevelFormsDamager " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.serverrepl " ) ; ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public static void registerEditorColors ( IPreferenceStore store , RGB foregroundColor ) { final ColorRegistry colorRegistry = getDefault ( ) . getColorRegistry ( ) ; final RGB literalColor = getElementColor ( store , PreferenceConstants . EDITOR_LITERAL_COLOR , foregroundColor ) ; final RGB specialFormColor = getElementColor ( store , PreferenceConstants . EDITOR_SPECIAL_FORM_COLOR , foregroundColor ) ; final RGB functionColor = getElementColor ( store , PreferenceConstants . EDITOR_FUNCTION_COLOR , foregroundColor ) ; final RGB commentColor = getElementColor ( store , PreferenceConstants . EDITOR_COMMENT_COLOR , foregroundColor ) ; final RGB globalVarColor = getElementColor ( store , PreferenceConstants . EDITOR_GLOBAL_VAR_COLOR , foregroundColor ) ; final RGB keywordColor = getElementColor ( store , PreferenceConstants . EDITOR_KEYWORD_COLOR , foregroundColor ) ; final RGB metadataTypehintColor = getElementColor ( store , PreferenceConstants . EDITOR_METADATA_TYPEHINT_COLOR , foregroundColor ) ; final RGB macroColor = getElementColor ( store , PreferenceConstants . EDITOR_MACRO_COLOR , foregroundColor ) ; colorRegistry . put ( ClojureEditor . ID + " _ " + Keyword . intern ( " string " ) , literalColor ) ; $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("regex"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("int"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("float"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("char"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("literalSymbol"), literalColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("symbol"), foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.FUNCTION, functionColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.GLOBAL_VAR, globalVarColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.MACRO, macroColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.SPECIAL_FORM, specialFormColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_CLASS, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_STATIC_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.JAVA_INSTANCE_METHOD, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + IScanContext.SymbolType.RAW_SYMBOL, foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("keyword"), keywordColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("comment"), commentColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("whitespace"), foregroundColor); $NON-NLS-1$ colorRegistry.put(ClojureEditor.ID + "_" + Keyword.intern("meta"), metadataTypehintColor); $NON-NLS-1$ } 
protected void createActions ( ) { tsuper . createActions ( ) ; setAction("ClojureLaunchAction", action); 
public void run ( ) { tnew ClojureLaunchShortcut ( ) . launch ( ClojureEditor . this , ILaunchManager . RUN_MODE ) ; } ; 
public void documentAboutToBeChanged ( DocumentEvent event ) { updateTextBuffer(newText, event.getOffset(), event.getLength(), event.getText()); } 
private String replace ( String doc , int offset , int length , String text ) { treturn doc . substring ( 0 , offset ) + text + doc . substring ( offset + length ) ; } 
private void addDamagerRepairerForContentType ( tPresentationReconciler reconciler , String contentType ) { tIPresentationDamager d = new ClojureTopLevelFormsDamager ( editor ) ; treconciler . setDamager ( d , contentType ) ; tIPresentationRepairer r = new DefaultDamagerRepairer ( tokenScanner ) ; treconciler . setRepairer ( r , contentType ) ; 
public final void addTokenType ( Object tokenIndex , org . eclipse . jface . text . rules . IToken token ) { if ( initialized ) { throw lifeCycleError ( ) ; } tokenTypeToJFaceToken . put ( tokenIndex , token ) ; } 
private void advanceToken ( ) { tlong start = System . currentTimeMillis ( ) ; tboolean firstToken ; if ( currentToken = = null ) { tfirstToken = true ; } else { tfirstToken = false ; } if ( ! firstToken ) { tint count = ( Integer ) currentToken . get ( tokenLengthKeyword ) ; tcurrentOffset + = count ; ttokenSeq = tokenSeq . next ( ) ; } System.out.println(tokenSeq.first()); currentToken = (Map<?,?>)tokenSeq.first(); advanceTokenDuration += System.currentTimeMillis() - start; } 
public final IToken nextToken ( ) { tlong start = System . currentTimeMillis ( ) ; tadvanceToken ( ) ; tIToken result ; if ( currentToken . get ( tokenTypeKeyword ) . equals ( nestKeyword ) ) { currentParenLevel + = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( tokenTypeKeyword ) . equals ( unnestKeyword ) ) { tcurrentParenLevel - = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( tokenTypeKeyword ) . equals ( openListKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( openFnKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( openChimeraKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( closeListKeyword ) | | currentToken . get ( tokenTypeKeyword ) . equals ( closeFnKeyword ) | | currentToken . get ( tokenTypeKeyword ) . equals ( closeChimeraKeyword ) ) { if ( currentParenLevel < 0 ) { tresult = errorToken ; } else { tresult = parenLevelTokens [ currentParenLevel % parenLevelTokens . length ] ; } } else { result = toJFaceToken ( ) ; } if ( result . equals ( Token . EOF ) ) { long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return result; } long localDuration = System.currentTimeMillis() - start; nextTokenDuration += localDuration; duration += localDuration; return result; } 
private IToken toJFaceToken ( ) { tlong start = System . currentTimeMillis ( ) ; tObject type = currentToken . get ( tokenTypeKeyword ) ; if ( type . equals ( symbolKeyword ) ) { type = guessEclipseTokenTypeForSymbol ( text . substring ( currentOffset , currentOffset + ( ( Integer ) currentToken . get ( tokenLengthKeyword ) ) ) ) ; } tIToken retToken = tokenTypeToJFaceToken . get ( type ) ; if ( retToken = = null ) { retToken = Token . UNDEFINED ; } toJFaceTokenDuration + = System . currentTimeMillis ( ) - start ; return retToken ; return Token.UNDEFINED; 
private Object guessEclipseTokenTypeForSymbol ( String symbol ) { tlong start = System . currentTimeMillis ( ) ; tObject res ; if ( symbolLiterals . contains ( symbol ) ) { tres = Keyword . intern ( " literalSymbol " ) ; } else { tlong sttart = System . currentTimeMillis ( ) ; tres = context . getSymbolType ( symbol ) ; tgetSymbolTypeDuration + = System . currentTimeMillis ( ) - sttart ; } tguessEclipseTokenTypeForSymbolDuration + = System . currentTimeMillis ( ) - start ; treturn res ; } 
public ClojureTokenScanner create ( final ColorRegistry colorProvider , IScanContext scanContext , IClojureEditor clojureEditor ) { treturn new ClojureTokenScanner ( scanContext , clojureEditor ) { @Override 
protected void initClojureTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorProvider ) ; tu . addTokenType ( Keyword . intern ( " string " ) ) ; tu . addTokenType ( Keyword . intern ( " regex " ) ) ; tu . addTokenType ( Keyword . intern ( " int " ) ) ; tu . addTokenType ( Keyword . intern ( " float " ) ) ; tu . addTokenType ( Keyword . intern ( " char " ) ) ; tu . addTokenType ( Keyword . intern ( " literalSymbol " ) ) ; tu . addTokenType ( Keyword . intern ( " symbol " ) ) ; tu . addTokenType ( Keyword . intern ( " unexpected " ) , ClojureTokenScanner . errorToken ) ; tu . addTokenType ( IScanContext . SymbolType . FUNCTION ) ; tu . addTokenType ( IScanContext . SymbolType . GLOBAL_VAR ) ; tu . addTokenType ( IScanContext . SymbolType . MACRO ) ; tu . addTokenType ( IScanContext . SymbolType . SPECIAL_FORM ) ; tu . addItalicToken ( IScanContext . SymbolType . JAVA_CLASS ) ; tu . addItalicToken ( IScanContext . SymbolType . JAVA_INSTANCE_METHOD ) ; tu . addItalicToken ( IScanContext . SymbolType . JAVA_STATIC_METHOD ) ; tu . addTokenType ( SymbolType . RAW_SYMBOL ) ; tu . addTokenType ( Keyword . intern ( " meta " ) ) ; tu . addTokenType ( Keyword . intern ( " keyword " ) ) ; tu . addTokenType ( Keyword . intern ( " comment " ) ) ; tu . addTokenType ( Keyword . intern ( " whitespace " ) ) ; tu . addTokenType ( Keyword . intern ( " eof " ) , Token . EOF ) ; tu . addTokenType ( Keyword . intern ( " whitespace " ) , Token . WHITESPACE ) ; } 
private void replaceOriginalWithFormatted ( IDocument original , ISourceViewer sourceViewer , String formatted ) { IRegion selection = editor.getSignedSelection(); Tokens tokens = new Tokens(original, selection); Document formattedDocument = new Document(formatted); Tokens formattedTokens = new Tokens(formattedDocument); int targetOffset = formattedTokens.sameStructuralOffset(tokens); original.set(formatted); sourceViewer.setSelectedRange(targetOffset, 0); sourceViewer.revealRange(targetOffset, 0); }} 
public void caretMoved ( CaretEvent event ) { IDocument document = editor . getDocument ( ) ; Tokens tokens = new Tokens ( document , editor , event . caretOffset ) ; tokens . putTokenScannerRangeOnCurrentLine ( ) ; IToken tokenAtCaret = tokens . tokenAtCaret ( ) ; boolean wordIsNotFormatted = tokenAtCaret . getData ( ) = = null ; if ( wordIsNotFormatted ) { StyleRange range = createRange ( tokens ) ; 
public void addTokenType ( Object tokenIndex ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( colorProvider . get ( ClojureEditor . ID + " _ " + tokenIndex ) ) ) ; } 
public void addTokenType ( Object tokenIndex , IToken token ) { tscanner . addTokenType ( tokenIndex , token ) ; } 
public void addBoldToken ( Object tokenIndex ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( tcolorProvider . get ( ClojureEditor . ID + " _ " + tokenIndex ) , null , SWT . BOLD ) ) ; 
public void addItalicToken ( Object tokenIndex ) { tscanner . addTokenType ( tokenIndex , new TextAttribute ( tcolorProvider . get ( ClojureEditor . ID + " _ " + tokenIndex ) , null , SWT . ITALIC ) ) ; 
public static ITokenScanner tokenScanner ( IClojureEditor clojureEditor ) { return new ClojureTokenScannerFactory ( ) . create ( CCWPlugin . getDefault ( ) . getColorRegistry ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , clojureEditor ) ; } 
public Object getPreviousParseTree ( ) { if ( parseRef = = null ) { treturn null ; 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseTree ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
Object getParseTree ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
private void printSetRange ( String name , IDocument document , int offset , int length ) { tSystem . out . println ( " setRange() called on " + name ) ; tSystem . out . println ( " offset: " + offset ) ; tSystem . out . println ( " length: " + length ) ; tSystem . out . println ( " document: " + document ) ; tSystem . out . println ( " --------------------------- " ) ; } ; 
private void updateTextBuffer ( String finalText , long offset , long length , String text ) { tboolean firstTime = ( parseState = = null ) ; parseState = EditorSupport . updateTextBuffer ( parseState , finalText , offset , length , text ) ; if ( firstTime ) { tEditorSupport . startWatchParseRef ( parseState , this ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { tString text = getDocument ( ) . get ( ) ; updateTextBuffer ( text , 0 , - 1 , text ) ; } return EditorSupport . getParseState ( getDocument ( ) . get ( ) , parseState ) ; } 
public Object getPreviousParseTree ( ) { if ( parseState = = null ) { treturn null ; 
public String findDeclaringNamespace ( ) { treturn ClojureCore . findDeclaringNamespace ( ( Map ) EditorSupport . getParseTree ( getParseState ( ) ) ) ; } 
void selectAndReveal ( int start , int length ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isStructuralEditingEnabled ( ) ; REPLView getCorrespondingREPL (); void updateTabsToSpacesConverter ();IDocument getDocument();void setStatusLineErrorMessage(String msg);void gotoMatchingBracket();DefaultCharacterPairMatcher getPairsMatcher();boolean isStructuralEditionPossible();void toggleStructuralEditionMode();} 
boolean isInEscapeSequence ( ) ; void toggleStructuralEditionMode();} 
IRegion getUnSignedSelection ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
String findDeclaringNamespace ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; } 
private static void inUIThreadSetREPLConnection ( Connection repl ) { tIViewPart [ ] views = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . getViews ( ) ; } 
public void run ( ) { IDocument original = editor.getDocument(); ISourceViewer sourceViewer = editor.sourceViewer(); String originalContents = original.get(); String formatted = new ClojureFormat().formatCode(originalContents); if (!formatted.equals(originalContents)) { replaceOriginalWithFormatted(original, sourceViewer, formatted); } } private void replaceOriginalWithFormatted(IDocument original, ISourceViewer sourceViewer, String formatted) { IRegion selection = editor.getSignedSelection(); Tokens tokens = new Tokens(original, selection); Document formattedDocument = new Document(formatted); Tokens formattedTokens = new Tokens(formattedDocument); int targetOffset = formattedTokens.sameStructuralOffset(tokens); original.set(formatted); sourceViewer.setSelectedRange(targetOffset, 0); sourceViewer.revealRange(targetOffset, 0); }} 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . loadAOTClass ( bundleContext , " ccw.ClojureProjectNature " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.PareditAutoEditStrategyImpl " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureFormat " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.StacktraceHyperlink " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.EditorSupport " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureHyperlinkDetector " ) ; tClojureOSGi . loadAOTClass ( bundleContext , " ccw.editors.clojure.ClojureTopLevelFormsDamagerImpl " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.clientrepl " ) ; tClojureOSGi . require ( bundleContext , " ccw.debug.serverrepl " ) ; ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { tClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -configureSourceViewerDecorationSupport " , support , viewer ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String text ) { tboolean firstTime = ( parseState = = null ) ; tparseState = ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -updateTextBuffer " , parseState , finalText , offset , length , text ) ; ClojureUtils.invoke(EDITOR_SUPPORT_NS, "-startWatchParseRef", parseState, this); 
public Object getParseState ( ) { if ( parseState = = null ) { tString text = getDocument ( ) . get ( ) ; updateTextBuffer ( text , 0 , - 1 , text ) ; } return ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -getParseState " , getDocument ( ) . get ( ) , parseState ) ; return EditorSupport.getParseState(getDocument().get(), parseState); 
public String findDeclaringNamespace ( ) { treturn ClojureCore . findDeclaringNamespace ( ( Map ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -getParseTree " , getParseState ( ) ) ) ; return ClojureCore.findDeclaringNamespace((Map) EditorSupport.getParseTree(getParseState())); 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , tboolean documentPartitioningChanged ) { treturn ( IRegion ) ClojureUtils . invoke ( ClojureTopLevelFormsDamagerImpl_NS , " -getDamageRegion " , tthis , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , tDocumentCommand command ) { tClojureUtils . invoke ( PareditAutoEditStrategyImpl_NS , " -customizeDocumentCommand " , tthis , document , command ) ; 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " -disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; fSourceViewerDecorationSupport = EditorSupport.disposeSourceViewerDecorationSupport(fSourceViewerDecorationSupport); interactive.close(); toolConnection.close(); } 
private static Var var ( String ns , String name ) { tString varName = ns + " / " + name ; tVar v = cachedVars . get ( varName ) ; if ( v ! = null ) { treturn v ; 
public static Object invoke ( String ns , String name ) { ttry { treturn var ( ns , name ) . invoke ( ) ; 
public static Object invoke ( String ns , String name , Object arg1 ) { ttry { treturn var ( ns , name ) . invoke ( arg1 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 ) { ttry { treturn var ( ns , name ) . invoke ( arg1 , arg2 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 , Object arg3 ) { ttry { treturn var ( ns , name ) . invoke ( arg1 , arg2 , arg3 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 , Object arg3 , Object arg4 ) { ttry { treturn var ( ns , name ) . invoke ( arg1 , arg2 , arg3 , arg4 ) ; 
public static Object invoke ( String ns , String name , Object arg1 , Object arg2 , Object arg3 , Object arg4 , Object arg5 ) { ttry { treturn var ( ns , name ) . invoke ( arg1 , arg2 , arg3 , arg4 , arg5 ) ; 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public static IStatus createErrorStatus ( String message ) { treturn new Status ( IStatus . ERROR , PLUGIN_ID , message ) ; } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { tClojureUtils . invoke ( EDITOR_SUPPORT_NS , " configureSourceViewerDecorationSupport " , support , viewer ) ; tsuper . configureSourceViewerDecorationSupport ( support ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String text ) { tboolean firstTime = ( parseState = = null ) ; tparseState = ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " updateTextBuffer " , parseState , finalText , offset , length , text ) ; if ( firstTime ) { tClojureUtils . invoke ( EDITOR_SUPPORT_NS , " startWatchParseRef " , parseState , this ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { tString text = getDocument ( ) . get ( ) ; updateTextBuffer ( text , 0 , - 1 , text ) ; } return ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " getParseState " , getDocument ( ) . get ( ) , parseState ) ; } 
public String findDeclaringNamespace ( ) { treturn ClojureCore . findDeclaringNamespace ( ( Map ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " getParseTree " , getParseState ( ) ) ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , tboolean documentPartitioningChanged ) { treturn ( IRegion ) ClojureUtils . invoke ( ClojureTopLevelFormsDamagerImpl_NS , " getDamageRegion " , tthis , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , tDocumentCommand command ) { tClojureUtils . invoke ( PareditAutoEditStrategyImpl_NS , " customizeDocumentCommand " , tthis , document , command ) ; 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; interactive . close ( ) ; toolConnection . close ( ) ; } 
public static Var requireAndGetVar ( String bundleSymbolicName , String varName ) throws CoreException { tfinal String [ ] nsFn = varName . split ( " / " ) ; ttry { tClojureOSGi . require ( loadAndGetBundle ( bundleSymbolicName ) . getBundleContext ( ) , nsFn [ 0 ] ) ; 
public static Bundle loadAndGetBundle ( String bundleSymbolicName ) throws CoreException { Bundle b = Platform.getBundle(bundleSymbolicName); 
public Object create ( ) throws CoreException { ttry { tfinal Object [ ] ret = new Object [ 1 ] ; 
public void run ( ) throws Exception { tret [ 0 ] = factory . invoke ( factoryParams ) ; } 
public void setInitializationData ( IConfigurationElement config , tString propertyName , Object data ) throws CoreException { tassert data instanceof String ; tbundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; if ( data instanceof String ) { tString name = ( String ) data ; 
private void initFactory ( String varName ) throws CoreException { tfactory = BundleUtils . requireAndGetVar ( bundleName , varName ) ; } 
protected String name ( ) { String name = mainPage . text . getText ( ) . trim ( ) . replaceAll ( " - " , " _ " ) ; FIXME should call clojure.core/munge if (name.endsWith(".clj")) name = name.substring(0, name.length() - (".clj").length()); return name; } 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( i ) + " ' at index " + i + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { IDE.openEditor(page, file, true); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
private void advanceToken ( ) { tlong start = System . currentTimeMillis ( ) ; tboolean firstToken ; if ( currentToken = = null ) { tfirstToken = true ; } else { tfirstToken = false ; } if ( ! firstToken ) { tlong count = ( Long ) currentToken . get ( tokenLengthKeyword ) ; tcurrentOffset + = count ; ttokenSeq = tokenSeq . next ( ) ; } System.out.println(tokenSeq.first()); currentToken = (Map<?,?>)tokenSeq.first(); advanceTokenDuration += System.currentTimeMillis() - start; } 
private IToken toJFaceToken ( ) { tlong start = System . currentTimeMillis ( ) ; tObject type = currentToken . get ( tokenTypeKeyword ) ; if ( type . equals ( symbolKeyword ) ) { type = guessEclipseTokenTypeForSymbol ( text . substring ( currentOffset , currentOffset + ( ( Long ) currentToken . get ( tokenLengthKeyword ) ) . intValue ( ) ) ) ; } tIToken retToken = tokenTypeToJFaceToken . get ( type ) ; if ( retToken = = null ) { retToken = Token . UNDEFINED ; } toJFaceTokenDuration + = System . currentTimeMillis ( ) - start ; return retToken ; return Token.UNDEFINED; 
 private void connectRepl ( ) { try { REPLView replView = REPLView . connect ( " localhost " , port . intValue ( ) , lastConsoleOpened , launch ) ; 
private static int incTempLaunchCount ( String projectName ) { synchronized ( tempLaunchCounters ) { Long cnt = tempLaunchCounters . get ( projectName ) ; 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { ClojureOSGi.require(bundleContext, "ccw.static-analysis"); } 
public static Var requireAndGetVar ( String bundleSymbolicName , String varName ) throws CoreException { tfinal String [ ] nsFn = varName . split ( " / " ) ; ttry { if ( findNs . invoke ( Symbol . intern ( nsFn [ 0 ] ) ) = = null ) { 
public Object create ( ) throws CoreException { ttry { treturn ClojureOSGi . withBundle ( BundleUtils . loadAndGetBundle ( bundleName ) , new RunnableWithException ( ) { 
public Object run ( ) throws Exception { treturn factory . invoke ( factoryParams ) ; } 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl/reset-ack-port! " ) . invoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public boolean isParseTreeBroken ( ) { treturn ( Boolean ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " brokenParseTree? " , getParseState ( ) ) ; } 
private String removeTrailingSpaces ( String s ) { treturn ( String ) ClojureUtils . invoke ( CLOJURE_STRING_NS , " trimr " , s ) ; } 
private void evalExpression ( ) { viewerWidget.setText(removeTrailingSpaces(viewerWidget.getText())); evalExpression(viewerWidget.getText(), true, false); copyToLog(viewerWidget); viewerWidget.setText(""); } 
private void installAutoEvalExpressionOnEnter ( ) { viewerWidget . addVerifyKeyListener ( new VerifyKeyListener ( ) { private boolean enterAlonePressed ( VerifyEvent e ) { 
private boolean enterAlonePressed ( VerifyEvent e ) { treturn ( e . keyCode = = SWT . LF | | e . keyCode = = SWT . CR ) & & e . stateMask = = SWT . NONE ; 
private boolean noSelection ( ) { treturn viewerWidget . getSelectionCount ( ) = = 0 ; } 
private String textAfterCaret ( ) { treturn viewerWidget . getText ( ) . substring ( tviewerWidget . getSelection ( ) . x ) ; 
public void verifyKey ( VerifyEvent e ) { if ( enterAlonePressed ( e ) & & noSelection ( ) 
private void installEvalTopLevelSExpressionCommand ( ) { IHandlerService handlerService = ( IHandlerService ) getViewSite ( ) . getService ( IHandlerService . class ) ; handlerService . activateHandler ( IClojureEditorActionDefinitionIds . EVALUATE_TOP_LEVEL_S_EXPRESSION , new AbstractHandler ( ) { public Object execute ( ExecutionEvent event ) throws ExecutionException { 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tevalExpression ( ) ; treturn null ; } 
public boolean visit ( IResource resource ) throws CoreException { if ( resource instanceof IFile ) { tString maybeLibName = ClojureCore . findMaybeLibNamespace ( ( IFile ) resource , currentSrcFolder . getKey ( ) . getFullPath ( ) ) ; if ( maybeLibName ! = null ) { tclojureLibs . add ( maybeLibName ) ; } 
private void createMarker ( final String filename , final int line , final String message ) { ttry { System.out.println("(trying to) create a marker for " + filename); 
public void beginReporting ( ) { tsuper . beginReporting ( ) ; } 
public void acceptSearchMatch ( SearchMatch match ) throws CoreException { tcounter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { (IMethod) match.getElement(), 
public void endReporting ( ) { tsuper . endReporting ( ) ; System.out.println("end reporting : count=" + counter); 
public void remember ( ISourceRange range ) { fHistoryAction.update(); TODO correctement 
public void run ( ) { System.out.println("delayed refresh stop"); 
protected void initializeKeyBindingScopes ( ) { tsetKeyBindingScopes ( new String [ ] { " org.eclipse.ui.textEditorScope " , IClojureEditor . KEY_BINDING_SCOPE } ) ; } 
public void contributeToStatusLine ( IStatusLineManager statusLineManager ) { tsuper . contributeToStatusLine ( statusLineManager ) ; tfor ( int i = 0 ; i < STATUS_FIELD_DEFS . length ; i + + ) tstatusLineManager . add ( ( IContributionItem ) fStatusFields . get ( STATUS_FIELD_DEFS [ i ] ) ) ; 
protected void updateStatusField ( String category ) { if ( ClojureSourceViewer . STATUS_CATEGORY_STRUCTURAL_EDITION . equals ( category ) ) { tviewer . updateStructuralEditingModeStatusField ( ) ; 
protected void createActions ( ) { tsuper . createActions ( ) ; 
public static StatusLineContributionItem createStructuralEditionModeStatusContributionItem ( ) { treturn new StatusLineContributionItem ( tClojureSourceViewer . STATUS_CATEGORY_STRUCTURAL_EDITION , 
public void toggleStructuralEditionMode ( ) { useStrictStructuralEditing = ! useStrictStructuralEditing ; updateStructuralEditingModeStatusField ( ) ; } 
public void updateStructuralEditingModeStatusField ( ) { if ( this . statusLineHandler = = null ) { treturn ; } tStatusLineContributionItem field = this . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { tString text = " Structural Edition: " + ( isStructuralEditingEnabled ( ) ? " Strict mode " : " Default mode " ) ; 
private Connection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return toolConnection; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; if ( interactive ! = null ) { tinteractive . close ( ) ; } if ( toolConnection ! = null ) { ttoolConnection . close ( ) ; 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( i ) + " ' at index " + i + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { TextEditor editor = (TextEditor) IDE.openEditor(page, file, true); editor.selectAndReveal(contents.length(), 0); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
protected String name ( ) { String name = mainPage . text . getText ( ) . trim ( ) . replaceAll ( " - " , " _ " ) ; name = name.substring(0, name.length() - (".cljs").length()); } return name; } 
protected String suffix ( ) { String name = mainPage . text . getText ( ) . trim ( ) . replaceAll ( " - " , " _ " ) ; return name.substring(index); 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; String suffix = suffix ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( 0 ) + " ' at index " + 0 + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } for ( int i = 1 ; i < name . length ( ) ; i + + ) if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { mainPage . setErrorMessage ( " Invalid character ' " + name . charAt ( i ) + " ' at index " + i + " for Clojure namespace file ' " + name + " ' " ) ; return false ; } String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { TextEditor editor = (TextEditor) IDE.openEditor(page, file, true); editor.selectAndReveal(contents.length(), 0); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public void createFieldEditors ( ) { taddField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , Messages . REPLViewPreferencePage_activate_autoEval_on_Enter , getFieldEditorParent ( ) ) ) ; 
private boolean isAutoEvalOnEnterAllowed ( ) { treturn getPreferences ( ) . getBoolean ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE ) ; } 
public void verifyKey ( VerifyEvent e ) { if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
public static String format ( String message , Object . . . bindings ) { treturn NLS . bind ( message , bindings ) ; } 
private void installMessageDisplayer ( final StyledText textViewer , final MessageProvider hintProvider ) { ttextViewer . addListener ( SWT . Paint , new Listener ( ) { public void handleEvent ( Event event ) { 
public void handleEvent ( Event event ) { tString message = hintProvider . getMessageText ( ) ; if ( message = = null ) treturn ; tPoint topRightPoint = topRightPoint ( textViewer . getClientArea ( ) ) ; tint sWidth = textWidthPixels ( message , event ) ; tint x = Math . max ( topRightPoint . x - sWidth , 0 ) ; tint y = topRightPoint . y ; tevent . gc . setForeground ( Display . getCurrent ( ) . getSystemColor ( tSWT . COLOR_GRAY ) ) ; tevent . gc . drawText ( message , x , y , true ) ; } 
private Point topRightPoint ( Rectangle clipping ) { treturn new Point ( clipping . x + clipping . width , clipping . y ) ; } 
private int textWidthPixels ( String text , Event evt ) { tint width = 0 ; tfor ( int i = 0 ; i < text . length ( ) ; i + + ) { twidth + = evt . gc . getAdvanceWidth ( text . charAt ( i ) ) ; } treturn width ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public void createFieldEditors ( ) { taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , tMessages . REPLViewPreferencePage_activate_autoEval_on_Enter , tgetFieldEditorParent ( ) ) ) ; taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , 
public void updateStructuralEditingModeStatusField ( ) { if ( this . statusLineHandler = = null ) { treturn ; } tStatusLineContributionItem field = this . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { tString text = " Edit mode: " + ( isStructuralEditingEnabled ( ) ? " strict/paredit " : " unrestricted " ) ; 
public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( JFaceResources . TEXT_FONT ) ) resetFont ( ) ; } 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanel . setFont ( font ) ; viewerWidget . setFont ( font ) ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; if ( interactive ! = null ) { tinteractive . close ( ) ; } if ( toolConnection ! = null ) { ttoolConnection . close ( ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public void handleEvent ( Event event ) { tString message = hintProvider . getMessageText ( ) ; if ( message = = null ) treturn ; } 
public void handleEvent ( Event event ) { tString message = hintProvider . getMessageText ( ) ; if ( message = = null ) treturn ; } 
public boolean isInEscapeSequence ( ) { return ( ( IClojureEditor ) getSourceViewer ( ) ) . isInEscapeSequence ( ) ; } 
public IRegion getUnSignedSelection ( ) { return ( ( IClojureEditor ) getSourceViewer ( ) ) . getUnSignedSelection ( ) ; } 
public IRegion getSignedSelection ( ) { return ( ( IClojureEditor ) getSourceViewer ( ) ) . getSignedSelection ( ) ; } 
public String findDeclaringNamespace ( ) { treturn ( ( IClojureEditor ) getSourceViewer ( ) ) . findDeclaringNamespace ( ) ; } 
public boolean isShowRainbowParens ( ) { treturn sourceViewer ( ) . isShowRainbowParens ( ) ; } 
public void toggleShowRainbowParens ( ) { tsourceViewer ( ) . toggleShowRainbowParens ( ) ; } 
public void toggleShowRainbowParens ( ) { isShowRainbowParens = ! isShowRainbowParens ; markDamagedAndRedraw ( ) ; } 
public void markDamagedAndRedraw ( ) { try { isForceRepair = true ; 
public final IToken nextToken ( ) { tlong start = System . currentTimeMillis ( ) ; tadvanceToken ( ) ; tIToken result ; if ( currentToken . get ( tokenTypeKeyword ) . equals ( nestKeyword ) ) { currentParenLevel + = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( tokenTypeKeyword ) . equals ( unnestKeyword ) ) { tcurrentParenLevel - = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return nextToken ( ) ; } if ( currentToken . get ( tokenTypeKeyword ) . equals ( openListKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( openFnKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( openChimeraKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( closeListKeyword ) | | currentToken . get ( tokenTypeKeyword ) . equals ( closeFnKeyword ) | | currentToken . get ( tokenTypeKeyword ) . equals ( closeChimeraKeyword ) ) { if ( currentParenLevel < 0 ) { tresult = errorToken ; } else { if ( this . clojureEditor . isShowRainbowParens ( ) ) { tresult = parenLevelTokens [ currentParenLevel % parenLevelTokens . length ] ; } else { tresult = noRainbowParenToken ; } } } else { result = toJFaceToken ( ) ; } if ( result . equals ( Token . EOF ) ) { long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; return result; } long localDuration = System.currentTimeMillis() - start; nextTokenDuration += localDuration; duration += localDuration; return result; } 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();} 
boolean isInEscapeSequence ( ) ; void markDamagedAndRedraw();} 
IRegion getUnSignedSelection ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
String findDeclaringNamespace ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public boolean isEscapeInStringLiteralsEnabled ( ) { treturn sourceViewer ( ) . isEscapeInStringLiteralsEnabled ( ) ; } 
public boolean isEscapeInStringLiteralsEnabled ( ) { treturn fPreferenceStore . getBoolean ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void markDamagedAndRedraw();} 
private synchronized void createColorCache ( ) { if ( colorCache = = null ) { tcolorCache = new ColorRegistry ( getWorkbench ( ) . getDisplay ( ) ) ; 
public void stop ( BundleContext context ) throws Exception { stopREPLServer(); plugin = null; super.stop(context); } 
public static void registerEditorColors ( IPreferenceStore store , RGB foregroundColor ) { final ColorRegistry colorCache = getDefault ( ) . getColorCache ( ) ; for ( Keyword token : PreferenceConstants . colorizableTokens ) { tPreferenceConstants . ColorizableToken tokenStyle = PreferenceConstants . getColorizableToken ( store , token , foregroundColor ) ; 
protected void createActions ( ) { tsuper . createActions ( ) ; 
public void initTokenScanner ( ) { ttokenScanner = new ClojureTokenScanner ( tCCWPlugin . getDefault ( ) . getColorCache ( ) , 
protected void initClojureTokenTypeToJFaceTokenMap ( ) { tTokenScannerUtils u = new TokenScannerUtils ( this , colorCache ) ; tu . addTokenType ( Keyword . intern ( " unexpected " ) , ClojureTokenScanner . errorToken ) ; tu . addTokenType ( Keyword . intern ( " eof " ) , Token . EOF ) ; tu . addTokenType ( Keyword . intern ( " whitespace " ) , Token . WHITESPACE ) ; tfor ( Keyword token : PreferenceConstants . colorizableTokens ) { tPreferenceConstants . ColorizableToken tokenStyle = PreferenceConstants . getColorizableToken ( preferenceStore , token , null ) ; 
public final void addTokenType ( Keyword tokenIndex , org . eclipse . jface . text . rules . IToken token ) { if ( initialized ) { throw lifeCycleError ( ) ; } parserTokenKeywordToJFaceToken . put ( tokenIndex , token ) ; } 
public final void addTokenType ( Keyword tokenIndex , TextAttribute textAttribute ) { if ( initialized ) { throw lifeCycleError ( ) ; } addTokenType ( tokenIndex , new org . eclipse . jface . text . rules . Token ( textAttribute ) ) ; } 
public final IToken nextToken ( ) { tlong start = System . currentTimeMillis ( ) ; tadvanceToken ( ) ; tIToken result ; if ( currentToken . get ( tokenTypeKeyword ) . equals ( nestKeyword ) ) { currentParenLevel + = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; isCallableSymbol = true ; return nextToken ( ) ; } if ( currentToken . get ( tokenTypeKeyword ) . equals ( unnestKeyword ) ) { tcurrentParenLevel - = 1 ; long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; isCallableSymbol = false ; return nextToken ( ) ; } if ( currentToken . get ( tokenTypeKeyword ) . equals ( openListKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( openFnKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( openChimeraKeyword ) | | tcurrentToken . get ( tokenTypeKeyword ) . equals ( closeListKeyword ) | | currentToken . get ( tokenTypeKeyword ) . equals ( closeFnKeyword ) | | currentToken . get ( tokenTypeKeyword ) . equals ( closeChimeraKeyword ) ) { if ( currentParenLevel < 0 ) { tresult = errorToken ; } else { if ( this . clojureEditor . isShowRainbowParens ( ) ) { tresult = parserTokenKeywordToJFaceToken . get ( parenLevelPrefKeywords [ currentParenLevel % parenLevelPrefKeywords . length ] ) ; } else { tresult = parserTokenKeywordToJFaceToken . get ( PreferenceConstants . deactivatedRainbowParen ) ; } } } else { result = toJFaceToken ( ) ; } if ( result . equals ( Token . EOF ) ) { long localDuration = System . currentTimeMillis ( ) - start ; duration + = localDuration ; nextTokenDuration + = localDuration ; isCallableSymbol = false; } return result; } 
private IToken toJFaceToken ( ) { tlong start = System . currentTimeMillis ( ) ; tKeyword type = ( Keyword ) currentToken . get ( tokenTypeKeyword ) ; if ( type . equals ( symbolKeyword ) ) { type = guessEclipseTokenTypeForSymbol ( text . substring ( currentOffset , currentOffset + ( ( Long ) currentToken . get ( tokenLengthKeyword ) ) . intValue ( ) ) ) ; } tIToken retToken = parserTokenKeywordToJFaceToken . get ( type ) ; if ( retToken = = null ) { retToken = Token . UNDEFINED ; } toJFaceTokenDuration + = System . currentTimeMillis ( ) - start ; return retToken ; return Token.UNDEFINED; 
private Keyword guessEclipseTokenTypeForSymbol ( String symbol ) { tlong start = System . currentTimeMillis ( ) ; tKeyword res ; if ( symbolLiterals . contains ( symbol ) ) { tres = Keyword . intern ( " literalSymbol " ) ; } else { tlong sttart = System . currentTimeMillis ( ) ; tres = context . getSymbolType ( symbol , isCallableSymbol ) ; tgetSymbolTypeDuration + = System . currentTimeMillis ( ) - sttart ; } tguessEclipseTokenTypeForSymbolDuration + = System . currentTimeMillis ( ) - start ; treturn res ; } 
private void initColorRegistry ( ) { if ( ! colorCache . hasValueFor ( COLOR_KEY ) ) { tcolorCache . put ( COLOR_KEY , new RGB ( 225 , 225 , 225 ) ) ; } if ( ! colorCache . hasValueFor ( OTHER_MATCHES_COLOR_KEY ) ) { tcolorCache . put ( OTHER_MATCHES_COLOR_KEY , new RGB ( 255 , 255 , 180 ) ) ; 
public void caretMoved ( CaretEvent event ) { IDocument document = editor . getDocument ( ) ; Tokens tokens = new Tokens ( document , editor , store , event . caretOffset ) ; tokens . putTokenScannerRangeOnCurrentLine ( ) ; IToken tokenAtCaret = tokens . tokenAtCaret ( ) ; boolean wordIsNotFormatted = tokenAtCaret . getData ( ) = = null ; if ( wordIsNotFormatted ) { StyleRange range = createRange ( tokens ) ; 
private StyleRange createRange ( Tokens tokens ) { return tokens . styleRange ( colorCache . get ( COLOR_KEY ) ) ; } 
public void addTokenType ( Keyword tokenIndex , String rgb , Boolean isBold , Boolean isItalic ) { tTextAttribute textAttribute ; if ( isBold = = null & & isItalic = = null ) { } 
public void addTokenType ( Keyword tokenIndex , IToken token ) { tscanner . addTokenType ( tokenIndex , token ) ; } 
public static ITokenScanner tokenScanner ( IClojureEditor clojureEditor , IPreferenceStore store ) { return new ClojureTokenScanner ( CCWPlugin . getDefault ( ) . getColorCache ( ) , CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , store , clojureEditor ) ; } 
private void handleSyntaxColorListSelection ( ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; if ( item = = null ) { fEnableCheckbox . setEnabled ( false ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( false ) ; fColorEditorLabel . setEnabled ( false ) ; fBoldCheckBox . setEnabled ( false ) ; fItalicCheckBox . setEnabled ( false ) ; fEnableCheckbox . setEnabled ( true ) ; boolean enable = fOverlayStore . getBoolean ( item . getEnableKey ( ) ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; fBoldCheckBox . setEnabled ( enable ) ; fItalicCheckBox . setEnabled ( enable ) ; / * TODO depend on enable if text attributes are actually used 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; fOverlayStore . setValue ( item . getBoldKey ( ) , fBoldCheckBox . getSelection ( ) ) ; } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; fOverlayStore . setValue ( item . getItalicKey ( ) , fItalicCheckBox . getSelection ( ) ) ; } 
public void widgetSelected ( SelectionEvent e ) { HighlightingColorListItem item = getHighlightingColorListItem ( ) ; boolean enable = fEnableCheckbox . getSelection ( ) ; fOverlayStore . setValue ( item . getEnableKey ( ) , enable ) ; fEnableCheckbox . setSelection ( enable ) ; fSyntaxForegroundColorEditor . getButton ( ) . setEnabled ( enable ) ; fColorEditorLabel . setEnabled ( enable ) ; fBoldCheckBox . setEnabled ( enable ) ; fItalicCheckBox . setEnabled ( enable ) ; / * TODO re - enable once text attributes are used 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , getBoldPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , getItalicPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . toArray ( keys ) ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , IClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tREPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; tConnection connection = repl . getToolingConnection ( ) ; tResponse response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) ; treturn ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } REPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) return Collections . emptyList ( ) ; tConnection connection = repl . getToolingConnection ( ) ; tResponse response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; treturn ( List < List > ) extractSingleValue ( response , Collections . emptyList ( ) ) ; } 
private static Object extractSingleValue ( Response response , Object defaultValueIfNil ) { List vs = response . values ( ) ; if ( vs . isEmpty ( ) | | vs . get ( 0 ) = = null ) { treturn defaultValueIfNil ; 
private void runTests ( String lib , Connection repl ) throws Exception { Response results = repl . send ( " op " , " eval " , " code " , runTestsCommand ( lib ) ) ; if ( ( ( String ) results . combinedResponse ( ) . get ( Keyword . intern ( " out " ) ) ) . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
public void canceling ( ) { if ( monitor ! = null ) { monitor . setCanceled ( true ) ; 
private IStatus done ( IProgressMonitor monitor , IStatus status ) { monitor . done ( ) ; return status ; } 
 public void done ( ) { tlatch . countDown ( ) ; } 
 private void connectRepl ( ) { try { REPLView replView = REPLView . connect ( " nrepl:localhost: " + port . intValue ( ) , lastConsoleOpened , launch ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { launch . setAttribute ( LaunchUtils . ATTR_PROJECT_NAME , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { return REPLView . connect ( " nrepl:localhost: " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { repl . sendInterrupt ( ) ; } 
private Map < String , List < String > > getRemoteNsTree ( Connection repl ) { ttry { Response res = repl . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/namespaces-info) " ) ; 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (if-not *e (println \" No prior exception bound to *e. \" ) (clojure.repl/pst *e))) " , false , false ) ; } 
public void sendInterrupt ( ) { log . invoke ( logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; } 
public void getStdIn ( ) { InputDialog dlg = new InputDialog ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Input requested " , String . format ( " A REPL expression sent to %s requires a line of *in* input: " , interactive . url ) , " " , null ) ; no conditional here; what else would we do if they canceled the dialog? Just a recipe for *requiring* an interrupt...? dlg.open(); evalExpression.invoke(PersistentHashMap.create("op", "stdin", "stdin", dlg.getValue() + ""), false); } 
public void reconnect ( ) throws Exception { closeConnections ( ) ; logPanel . append ( " ;; Reconnecting... " ) ; configure ( interactive . url ) ; } 
public void setCurrentNamespace ( String ns ) { currentNamespace = ns; setPartName(String.format("REPL @ %s (%s)", interactive.url, currentNamespace)); } 
private void prepareView ( ) throws Exception { evalExpression = ( IFn ) configureREPLView . invoke ( this , logPanel , interactive . client ) ; } 
public static REPLView connect ( ) throws Exception { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; ConnectDialog dlg = new ConnectDialog ( window . getShell ( ) ) ; REPLView repl = null ; if ( dlg . open ( ) = = ConnectDialog . OK ) { cannot find any way to create a configured/connected REPLView, and install it programmatically String host = dlg.getHost(); int port = dlg.getPort(); if (host == null || host.length() == 0 || port < 0 || port > 65535) { MessageDialog.openInformation(window.getShell(), "Invalid connection info", "You must provide a useful hostname and port number to connect to a REPL."); } else { repl = connect(String.format("nrepl:%s:%s", host, port)); } } return repl; } 
public static REPLView connect ( String url ) throws Exception { return connect ( url , null , null ) ; } 
public static REPLView connect ( String url , IConsole console , ILaunch launch ) throws Exception { REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , UUID . randomUUID ( ) . toString ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . console = console ; repl . launch = launch ; return repl . configure ( url ) ? repl : null ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) ClojureUtils . invoke ( EDITOR_SUPPORT_NS , " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; try { if ( interactive ! = null ) interactive . close ( ) ; if ( toolConnection ! = null ) toolConnection . close ( ) ; } catch ( IOException e ) { CCWPlugin . logError ( e ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public void run ( ) { CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . setValue ( " LexicalSortingAction.isChecked " , sort = isChecked ( ) ) ; setInputInUiThread ( forms ) ; } 
private static Symbol symbol ( Object o ) { return o instanceof Symbol ? ( Symbol ) o : null ; } 
private static boolean isPrivate ( List form ) { if ( form . size ( ) < 2 ) return false ; Symbol def = symbol ( form . get ( 0 ) ) ; Symbol name = symbol ( form . get ( 1 ) ) ; if ( def = = null | | name = = null ) return false ; return def . getName ( ) . matches ( " (defn-|defvar-) " ) | | ( name . meta ( ) ! = null & & name . meta ( ) . valAt ( Keyword . intern ( " private " ) , false ) . equals ( Boolean . TRUE ) ) ; 
protected StructuredSelection findClosest ( int toFind ) { tObject selected = null ; tfor ( Object o : forms ) { if ( o instanceof Obj ) { tObj obj = ( Obj ) o ; tint lineNr = getLineNr ( obj ) ; if ( lineNr > = 0 & & lineNr < = toFind ) { tselected = obj ; } } } if ( selected ! = null ) { treturn new StructuredSelection ( selected ) ; } treturn StructuredSelection . EMPTY ; } 
private void refreshInput ( ) { tJob job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; tLineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( tnew StringReader ( string ) ) ; tObject EOF = new Object ( ) ; tArrayList < List > input = new ArrayList < List > ( ) ; tObject result = null ; twhile ( true ) { ttry { tresult = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) break ; if ( result instanceof List ) input . add ( ( List ) result ) ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; tLineNumberingPushbackReader pushbackReader = new LineNumberingPushbackReader ( tnew StringReader ( string ) ) ; tObject EOF = new Object ( ) ; tArrayList < List > input = new ArrayList < List > ( ) ; tObject result = null ; twhile ( true ) { ttry { tresult = LispReader . read ( pushbackReader , false , EOF , false ) ; if ( result = = EOF ) break ; if ( result instanceof List ) input . add ( ( List ) result ) ; } catch ( ReaderException e ) { } 
public void dispose ( ) { ttry { if ( document ! = null ) tdocument . removeDocumentListener ( documentChangedListener ) ; } catch ( Throwable ) { } ttry { tfinal TreeViewer viewer = getTreeViewer ( ) ; if ( viewer ! = null ) tviewer . removeSelectionChangedListener ( this ) ; if ( viewer ! = null ) tviewer . removeSelectionChangedListener ( treeSelectionChangedListener ) ; } catch ( Throwable ) { } ttry { tIPostSelectionProvider selectionProvider = ( IPostSelectionProvider ) editor . getSelectionProvider ( ) ; if ( selectionProvider ! = null ) tselectionProvider . removePostSelectionChangedListener ( editorSelectionChangedListener ) ; } catch ( Throwable ) { } tsuper . dispose ( ) ; } 
public void checkClasspath ( ) { IFile classpath = project . getProject ( ) . getFile ( " .classpath " ) ; if ( ! classpath . exists ( ) ) return ; if ( classpathUpdate = = IResource . NULL_STAMP ) { classpathUpdate = classpath . getModificationStamp ( ) ; return ; } if ( classpathUpdate = = classpath . getModificationStamp ( ) ) return ; classpathUpdate = classpath . getModificationStamp ( ) ; } 
private void installMessageDisplayer ( final StyledText textViewer , final MessageProvider hintProvider ) { ttextViewer . addListener ( SWT . Paint , new Listener ( ) { private int getScrollbarAdjustment ( ) { 
public void handleEvent ( Event event ) { tString message = hintProvider . getMessageText ( ) ; if ( message = = null ) treturn ; } 
public void updateStructuralEditingModeStatusField ( ) { if ( this . statusLineHandler = = null ) { treturn ; } tStatusLineContributionItem field = this . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { tString text = ( isStructuralEditingEnabled ( ) ? " strict/paredit " : " unrestricted " ) + " edit mode " ; 
private static boolean isPrivate ( List form ) { if ( form . size ( ) < 2 ) return false ; Symbol def = symbol ( RT . first ( form ) ) ; Symbol name = symbol ( RT . second ( form ) ) ; if ( def = = null | | name = = null ) return false ; return def . getName ( ) . matches ( " (defn-|defvar-) " ) | | ( name . meta ( ) ! = null & & name . meta ( ) . valAt ( Keyword . intern ( " private " ) , false ) . equals ( Boolean . TRUE ) ) ; 
protected void clean ( IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { tmonitor = new NullProgressMonitor ( ) ; } ttry { tgetClassesFolder ( getProject ( ) ) . delete ( true , monitor ) ; tcreateClassesFolder ( getProject ( ) , monitor ) ; getClassesFolder ( getProject ( ) ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; getClassesFolder ( getProject ( ) ) . setDerived ( true ) ; } deleteMarkers(getProject()); } 
public void run ( ) { || viewerWidget.getText().equals(widgetText + "\r") 
public void run ( ) { tfinal IProject project = editorFile . getProject ( ) ; tnew ClojureLaunchShortcut ( ) . launchProject ( project , ILaunchManager . RUN_MODE , false ) ; tDisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
 public void run ( ) { tREPLView repl = CCWPlugin . getDefault ( ) . getProjectREPL ( project ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tevaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , editorFile . getName ( ) ) ; 
private void evaluateFileText ( REPLView repl , String text , String filePath , String sourcePath , String fileName ) { try { tfinal String loadFileText = ( String ) loadFileCommand . invoke ( text , sourcePath , fileName ) ; 
public void run ( ) { REPLView repl = REPLView . activeREPL . get ( ) ; run ( repl , editor , true ) ; } 
public static void run ( REPLView repl , ClojureEditor editor , boolean activateREPL ) { if ( repl = = null | | repl . isDisposed ( ) ) { return ; } String ns = editor . findDeclaringNamespace ( ) ; if ( ns = = null ) { put error msg in footer instead 
 public void done ( ) { tprojectTouchLatch . countDown ( ) ; } 
public void start ( BundleContext context ) throws Exception { tSystem . out . println ( " Leiningen Plugin start() " ) ; super . start ( context ) ; plugin = this ; } 
public void stop ( BundleContext context ) throws Exception { tSystem . out . println ( " Leiningen Plugin stop() " ) ; plugin = null ; super . stop ( context ) ; } 
public void initialize ( IJavaProject project , IClasspathEntry [ ] currentEntries ) { _proj = project ; } 
public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NULL ) ; composite . setLayout ( new GridLayout ( ) ) ; composite . setLayoutData ( new GridData ( GridData . VERTICAL_ALIGN_FILL | GridData . HORIZONTAL_ALIGN_FILL ) ) ; composite . setFont ( parent . getFont ( ) ) ; createDirGroup ( composite ) ; createExtGroup ( composite ) ; setControl ( composite ) ; } 
private void createDirGroup ( Composite parent ) { Composite dirSelectionGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 3 ; dirSelectionGroup . setLayout ( layout ) ; dirSelectionGroup . setLayoutData ( new GridData ( GridData . GRAB_HORIZONTAL | GridData . VERTICAL_ALIGN_FILL ) ) ; new Label ( dirSelectionGroup , SWT . NONE ) . setText ( Messages . DirLabel ) ; _dirCombo = new Combo ( dirSelectionGroup , SWT . SINGLE | SWT . BORDER ) ; _dirCombo . setText ( getInitDir ( ) ) ; _dirBrowseButton = new Button ( dirSelectionGroup , SWT . PUSH ) ; _dirBrowseButton . setText ( Messages . Browse ) ; _dirBrowseButton . setLayoutData ( new GridData ( GridData . HORIZONTAL_ALIGN_FILL ) ) ; _dirBrowseButton . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { handleDirBrowseButtonPressed ( ) ; } } ) ; setControl ( dirSelectionGroup ) ; } 
public void widgetSelected ( SelectionEvent e ) { handleDirBrowseButtonPressed ( ) ; } 
private void createExtGroup ( Composite parent ) { Composite extSelectionGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; extSelectionGroup . setLayout ( layout ) ; extSelectionGroup . setLayoutData ( new GridData ( GridData . GRAB_HORIZONTAL | GridData . VERTICAL_ALIGN_FILL ) ) ; new Label ( extSelectionGroup , SWT . NONE ) . setText ( Messages . ExtLabel ) ; _extText = new Text ( extSelectionGroup , SWT . BORDER ) ; _extText . setText ( getInitExts ( ) + " " ) ; setControl ( extSelectionGroup ) ; } 
protected void handleDirBrowseButtonPressed ( ) { DirectoryDialog dialog = new DirectoryDialog ( getContainer ( ) . getShell ( ) , SWT . SAVE ) ; dialog . setMessage ( Messages . DirSelect ) ; dialog . setFilterPath ( getDirValue ( ) ) ; String dir = dialog . open ( ) ; if ( dir ! = null ) { _dirCombo . setText ( dir ) ; 
private boolean isDirValid ( String dir ) { Path dirPath = new Path ( dir ) ; return _proj . getProject ( ) . getLocation ( ) . makeAbsolute ( ) . isPrefixOf ( dirPath ) ; } 
private boolean areExtsValid ( String exts ) { if ( exts = = null | | exts . equals ( " " ) ) { return false ; } else return exts.matches("[a-z_][a-z_,]*"); } 
public void setInitializationData ( IConfigurationElement config , tString propertyName , Object data ) throws CoreException { tassert data instanceof String ; tbundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; tSystem . out . println ( " GenericExecutableExtension instance, bundleName= " + bundleName ) ; if ( data instanceof String ) { tString name = ( String ) data ; 
public void log ( int severity , Throwable e ) { Status s = new Status ( severity , pluginId , IStatus . OK , e . getMessage ( ) , e ) ; log . log ( s ) ; } 
public void log ( Severity severity , String msg ) { Status s = new Status ( severity . severityCode , pluginId , IStatus . OK , msg , null ) ; log . log ( s ) ; } 
public void start ( BundleContext context ) throws Exception { super . start ( context ) ; plugin = this ; startClojureCode ( plugin . getBundle ( ) . getBundleContext ( ) ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . require ( bundleContext , " ccw.util.bundle-utils " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , tIProgressMonitor monitor ) throws CoreException { if ( getProject ( ) = = null ) treturn null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) treturn null ; if ( projectCljPresentInDelta ( ) ) { ttry { tIJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; tClojureUtils . invoke ( ClasspathContainerNamespace , updateProjectDependencies , javaProject ) ; } catch ( Exception e ) { tthrow new CoreException ( Activator . createErrorStatus ( " Unexpected exception while trying to update Leiningen Managed Dependencies for project " + getProject ( ) . getName ( ) , e ) ) ; } } treturn null ; } 
private boolean projectCljPresentInDelta ( ) { tIResourceDelta delta = getDelta ( getProject ( ) ) ; tIResourceDelta deltaProjClj = delta . findMember ( new Path ( " project.clj " ) ) ; treturn deltaProjClj ! = null ; } 
public void log ( Severity severity , Throwable e ) { Status s = new Status ( severity . severityCode , pluginId , IStatus . OK , e . getMessage ( ) , e ) ; log . log ( s ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . require ( bundleContext , " ccw.util.eclipse.repl " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.eclipse " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.bundle-utils " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
public void start ( BundleContext context ) throws Exception { tSystem . out . println ( " Leiningen Plugin start() " ) ; super . start ( context ) ; plugin = this ; startClojureCode ( context ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . require ( bundleContext , " ccw.util.bundle " ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . require ( bundleContext , " ccw.util.eclipse.repl " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.eclipse " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.bundle " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { tfor ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it . hasNext ( ) ; ) { tObject element = it . next ( ) ; tIProject project = null ; if ( element instanceof IProject ) { tproject = ( IProject ) element ; } else if ( element instanceof IAdaptable ) { tproject = ( IProject ) ( ( IAdaptable ) element ) . getAdapter ( IProject . class ) ; } if ( project ! = null ) { tShell shell = HandlerUtil . getActiveShell ( event ) ; ttoggleNature ( project , shell ) ; } } } treturn null ; } 
public void addPages ( ) { super . addPages ( ) ; getStartingPage ( ) . setDescription ( " Create a new Leiningen project. " ) ; getStartingPage ( ) . setTitle ( " Leiningen project " ) ; setWindowTitle ( " New Leiningen project " ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; }); port.setFocus(); return composite; } 
public void verifyText ( VerifyEvent e ) { te . doit = ( e . text . equals ( " " ) | | Character . isDigit ( e . character ) ) ; } 
protected void clean ( IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { tmonitor = new NullProgressMonitor ( ) ; } ttry { tgetClassesFolder ( getProject ( ) ) . delete ( true , new SubProgressMonitor ( monitor , 0 ) ) ; tcreateClassesFolder ( getProject ( ) , new SubProgressMonitor ( monitor , 0 ) ) ; getClassesFolder ( getProject ( ) ) . refreshLocal ( IResource . DEPTH_INFINITE , new SubProgressMonitor ( monitor , 0 ) ) ; getClassesFolder ( getProject ( ) ) . setDerived ( true ) ; } deleteMarkers(getProject()); } 
protected void configureSourceViewerDecorationSupport ( SourceViewerDecorationSupport support ) { teditorSupport . _ ( " configureSourceViewerDecorationSupport " , support , viewer ) ; tsuper . configureSourceViewerDecorationSupport ( support ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String text ) { tboolean firstTime = ( parseState = = null ) ; tparseState = editorSupport . _ ( " updateTextBuffer " , parseState , finalText , offset , length , text ) ; if ( firstTime ) { teditorSupport . _ ( " startWatchParseRef " , parseState , this ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { tString text = getDocument ( ) . get ( ) ; updateTextBuffer ( text , 0 , - 1 , text ) ; } return editorSupport . _ ( " getParseState " , getDocument ( ) . get ( ) , parseState ) ; } 
public boolean isParseTreeBroken ( ) { treturn ( Boolean ) editorSupport . _ ( " brokenParseTree? " , getParseState ( ) ) ; } 
public String findDeclaringNamespace ( ) { treturn ClojureCore . findDeclaringNamespace ( ( Map ) editorSupport . _ ( " getParseTree " , getParseState ( ) ) ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , tboolean documentPartitioningChanged ) { treturn ( IRegion ) topLevelFormsDamager . _ ( " getDamageRegion " , tthis , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , tDocumentCommand command ) { tpareditAutoEditStrategyImpl . _ ( " customizeDocumentCommand " , tthis , document , command ) ; 
private String removeTrailingSpaces ( String s ) { treturn ( String ) str . _ ( " trimr " , s ) ; } 
public void dispose ( ) { super . dispose ( ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; try { if ( interactive ! = null ) interactive . close ( ) ; if ( toolConnection ! = null ) toolConnection . close ( ) ; } catch ( IOException e ) { CCWPlugin . logError ( e ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , tIProgressMonitor monitor ) throws CoreException { if ( getProject ( ) = = null ) treturn null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) treturn null ; if ( projectCljPresentInDelta ( ) ) { ttry { tIJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; tclasspathContainer . _ ( updateProjectDependencies , javaProject ) ; } catch ( Exception e ) { tthrow new CoreException ( Activator . createErrorStatus ( " Unexpected exception while trying to update Leiningen Managed Dependencies for project " + getProject ( ) . getName ( ) , e ) ) ; } } treturn null ; } 
public void addPages ( ) { super . addPages ( ) ; doAddPages ( ) ; } 
private void doAddPages ( ) { tgetStartingPage ( ) . setDescription ( " Create a new Leiningen project. " ) ; getStartingPage ( ) . setTitle ( " Leiningen project " ) ; setWindowTitle ( " New Leiningen project " ) ; } 
public boolean performFinish ( ) { if ( super . performFinish ( ) ) { return doPerformFinish ( ) ; 
private boolean doPerformFinish ( ) { tIProject project = getNewProject ( ) ; ttry { twizard . _ ( performFinish , 
public Object _ ( String varName , Object arg1 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 , Object arg3 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 , Object arg3 , Object arg4 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 ) ; } 
public Object _ ( String varName , Object arg1 , Object arg2 , Object arg3 , Object arg4 , Object arg5 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 , arg5 ) ; } 
public static ClojureInvoker newInvoker ( Plugin plugin , String namespace ) { ttry { tClojureOSGi . require ( plugin . getBundle ( ) . getBundleContext ( ) , namespace ) ; } catch ( Exception e ) { tthrow new RuntimeException ( e ) ; } treturn new ClojureInvoker ( namespace ) ; } 
public boolean test ( Object receiver , String property , Object [ ] args , Object expectedValue ) { assert IResource . class . isInstance ( receiver ) ; assert " hasClojureNature " . equals ( property ) ; return hasClojureNature ( ( IResource ) receiver ) ; } 
public static boolean hasClojureNature ( IResource resource ) { try { tIProject project = resource . getProject ( ) ; 
public static boolean isReplQuietLoggingMode ( ) { treturn CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . REPL_QUIET_LOGGING_MODE ) ; } 
public static boolean isReplExplicitLoggingMode ( ) { treturn ! isReplQuietLoggingMode ( ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public void createFieldEditors ( ) { taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , tMessages . REPLViewPreferencePage_activate_autoEval_on_Enter , tgetFieldEditorParent ( ) ) ) ; taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , tMessages . REPLViewPreferencePage_displayHint , tgetFieldEditorParent ( ) ) ) ; taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_QUIET_LOGGING_MODE , 
public void createControl ( Composite parent ) { tsuper . createControl ( parent ) ; tcreateWorkingSetGroup ( ( Composite ) getControl ( ) , tgetSelection ( ) , tnew String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
private void doLeinAddPagesPre ( ) { ttemplatePage = new WizardNewLeiningenProjectTemplatePage ( " Choose Newnew Template " ) ; tthis . addPage ( templatePage ) ; } 
private void doLeinAddPagesPost ( ) { tgetStartingPage ( ) . setDescription ( " Create a new Leiningen project. " ) ; getStartingPage ( ) . setTitle ( " Leiningen project " ) ; setWindowTitle ( " New Leiningen project " ) ; } 
public void run ( IProgressMonitor monitor ) tthrows InvocationTargetException { tCreateProjectOperation op = new CreateProjectOperation ( tdescription , ResourceMessages . NewProject_windowTitle ) ; ttry { see bug https:bugs.eclipse.org/bugs/show_bug.cgi?id=219901 
public void init ( IWorkbench workbench , IStructuredSelection currentSelection ) { tsuper . init ( workbench , currentSelection ) ; tsetNeedsProgressMonitor ( true ) ; tsetWindowTitle ( ResourceMessages . NewProject_windowTitle ) ; } 
protected void initializeDefaultPageImageDescriptor ( ) { tImageDescriptor desc = IDEWorkbenchPlugin . getIDEImageDescriptor ( " wizban/newprj_wiz.png " ) ; } 
private static void openInNewWindow ( IPerspectiveDescriptor desc ) { PlatformUI.getWorkbench().openWorkbenchWindow(desc.getId(), 
public boolean performFinish ( ) { if ( newProjectWizardPerformFinish ( ) ) { treturn doPerformFinish ( ) ; 
private boolean newProjectWizardPerformFinish ( ) { tcreateNewProject ( ) ; if ( newProject = = null ) { treturn false ; } tIWorkingSet [ ] workingSets = mainPage . getSelectedWorkingSets ( ) ; tgetWorkbench ( ) . getWorkingSetManager ( ) . addToWorkingSets ( newProject , tworkingSets ) ; tupdatePerspective ( ) ; tselectAndReveal ( newProject ) ; treturn true ; } 
private static void replaceCurrentPerspective ( IPerspectiveDescriptor persp ) { } 
public void setInitializationData ( IConfigurationElement cfig , tString propertyName , Object data ) { tconfigElement = cfig ; } 
private static void addPerspectiveAndDescendants ( List perspectiveIds , tString id ) { tIPerspectiveRegistry registry = PlatformUI . getWorkbench ( ) . getPerspectiveRegistry ( ) ; tIPerspectiveDescriptor [ ] perspectives = registry . getPerspectives ( ) ; tfor ( int i = 0 ; i < perspectives . length ; i + + ) { @issue illegal ref to workbench internal class; 
public void handleEvent ( Event e ) { boolean valid = validatePage ( ) ; setPageComplete ( valid ) ; } 
public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NULL ) ; initializeDialogUnits ( parent ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( composite , IIDEHelpContextIds . NEW_PROJECT_WIZARD_PAGE ) ; composite . setLayout ( new GridLayout ( ) ) ; composite . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; createProjectNameGroup ( composite ) ; setPageComplete ( validatePage ( ) ) ; Show description on opening setErrorMessage(null); setMessage(null); setControl(composite); Dialog.applyDialogFont(composite); } 
public WorkingSetGroup createWorkingSetGroup ( Composite composite , tIStructuredSelection selection , String [ ] supportedWorkingSetTypes ) { if ( workingSetGroup ! = null ) treturn workingSetGroup ; tworkingSetGroup = new WorkingSetGroup ( composite , selection , tsupportedWorkingSetTypes ) ; treturn workingSetGroup ; } 
public void reportError ( String errorMessage , boolean infoOnly ) { if ( infoOnly ) { tsetMessage ( errorMessage , IStatus . INFO ) ; tsetErrorMessage ( null ) ; } telse tsetErrorMessage ( errorMessage ) ; tboolean valid = errorMessage = = null ; if ( valid ) { tvalid = validatePage ( ) ; } tsetPageComplete ( valid ) ; } 
private final void createProjectNameGroup ( Composite parent ) { } projectNameField.addListener(SWT.Modify, nameModifyListener); } 
protected boolean validatePage ( ) { IWorkspace workspace = IDEWorkbenchPlugin . getPluginWorkspace ( ) ; String projectFieldContents = getProjectNameFieldValue ( ) ; if ( projectFieldContents . equals ( " " ) ) { $NON-NLS-1$ setErrorMessage(null); setMessage(IDEWorkbenchMessages.WizardNewProjectCreationPage_projectNameEmpty); return false; } IStatus nameStatus = workspace.validateName(projectFieldContents, IResource.PROJECT); if (!nameStatus.isOK()) { setErrorMessage(nameStatus.getMessage()); return false; } setErrorMessage(null); setMessage(null); return true; } 
 public void handleEvent ( Event e ) { boolean valid = validatePage ( ) ; setPageComplete ( valid ) ; } 
public void createControl ( Composite parent ) { tsuper . createControl ( parent ) ; tcreateLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; tcreateWorkingSetGroup ( ( Composite ) getControl ( ) , tthis . newLeiningenProjectWizard . getSelection ( ) , tnew String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
public void createLeinTemplateGroup ( Composite parent ) { } 
protected boolean validatePage ( ) { if ( super . validatePage ( ) ) { String templateFieldContents = getTemplateNameFieldValue ( ) ; 
public void stop ( BundleContext context ) throws Exception { plugin = null; super.stop(context); } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { tfor ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it . hasNext ( ) ; ) { tObject element = it . next ( ) ; tIProject project = null ; if ( element instanceof IProject ) { tproject = ( IProject ) element ; } else if ( element instanceof IAdaptable ) { tproject = ( IProject ) ( ( IAdaptable ) element ) . getAdapter ( IProject . class ) ; } if ( project ! = null ) { ttoggleNature ( project , false ) ; } } } treturn null ; } 
public void run ( ) { tMessageDialog . openInformation ( Display . getCurrent ( ) . getActiveShell ( ) , title , message ) ; } 
private static boolean doToggleNature ( IProject project ) throws CoreException { tIProjectDescription description = project . getDescription ( ) ; tString [ ] natures = description . getNatureIds ( ) ; tList < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; tboolean natureFound = false ; tfor ( String nature : natures ) { if ( nature . equals ( ClojureCore . NATURE_ID ) ) { } 
public synchronized void start ( ) { telementChangedListener = new ClojurePackageElementChangeListener ( ) ; tJavaCore . addElementChangedListener ( elementChangedListener ) ; } 
public synchronized void stop ( ) { if ( elementChangedListener = = null ) { tJavaCore . removeElementChangedListener ( elementChangedListener ) ; } telementChangedListener = null ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { ttry { if ( project . hasNature ( ClojureCore . NATURE_ID ) ) { treturn Status . CANCEL_STATUS ; } tboolean hasClojurePackage = JavaCore . create ( project ) . findElement ( ClojurePackageElementChangeListener . CLOJURE_PACKAGE_PATH ) ! = null ; if ( hasClojurePackage ) { tToggleNatureCommand . toggleNature ( project , true ) ; } } catch ( CoreException e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , te ) ; } treturn Status . OK_STATUS ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { tIJavaElementDelta delta = javaModelEvent . getDelta ( ) ; tIJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
private boolean visitPackageFragmentRootDelta ( IJavaElementDelta packageFragmentRootDelta ) { tIPackageFragmentRoot packageElement = ( IPackageFragmentRoot ) packageFragmentRootDelta . getElement ( ) ; if ( isClojureElement ( packageElement ) ) { taddClojureNature ( packageElement . getJavaProject ( ) . getProject ( ) ) ; 
private boolean isClojureElement ( IPackageFragmentRoot packageFragmentRoot ) { treturn packageFragmentRoot . getPackageFragment ( CLOJURE_PACKAGE ) . exists ( ) ; } 
private void addClojureNature ( final IProject project ) { tWorkspaceJob job = new ClojureNatureAdderWorkspaceJob ( project ) ; tjob . schedule ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { ttry { if ( ! project . exists ( ) | | ! project . isOpen ( ) ) treturn Status . CANCEL_STATUS ; if ( project . hasNature ( ClojureCore . NATURE_ID ) ) { treturn Status . CANCEL_STATUS ; } tboolean hasClojurePackage = JavaCore . create ( project ) . findElement ( ClojurePackageElementChangeListener . CLOJURE_PACKAGE_PATH ) ! = null ; if ( hasClojurePackage ) { tToggleNatureCommand . toggleNature ( project , true ) ; } } catch ( CoreException e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , te ) ; } treturn Status . OK_STATUS ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { if ( ! CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) treturn ; tIJavaElementDelta delta = javaModelEvent . getDelta ( ) ; tIJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public synchronized void start ( ) { telementChangedListener = new ClojurePackageElementChangeListener ( ) ; tJavaCore . addElementChangedListener ( elementChangedListener ) ; telementChangedListener . performFullScan ( ) ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) treturn ; tIJavaElementDelta delta = javaModelEvent . getDelta ( ) ; tIJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
private void addClojureNature ( final IProject project ) { tWorkspaceJob job = new ClojureNatureAdderWorkspaceJob ( project ) ; tjob . schedule ( 100 ) ; } 
private boolean isCandidateClojureProject ( IProject project ) { ttry { treturn ( project . exists ( ) 
protected void doSetInput ( IEditorInput input ) throws CoreException { tsuper . doSetInput ( input ) ; } 
public void handleEvent ( Event e ) { tboolean valid = validatePage ( ) ; tsetPageComplete ( valid ) ; } 
public void createControl ( Composite parent ) { tsuper . createControl ( parent ) ; tcreateLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; tcreateWorkingSetGroup ( ( Composite ) getControl ( ) , tthis . newLeiningenProjectWizard . getSelection ( ) , tnew String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
public void createLeinTemplateGroup ( Composite parent ) { } 
protected boolean validatePage ( ) { if ( super . validatePage ( ) ) { tString templateFieldContents = getTemplateNameFieldValue ( ) ; 
private static IEditorInput findEditorInput ( tIPackageFragmentRoot packageFragmentRoot , tString searchedPackage , tString searchedFileName ) tthrows JavaModelException { packageFragmentRoot, 
public void setInitializationData ( IConfigurationElement config , tString propertyName , Object data ) throws CoreException { tbundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; tSystem . out . println ( " GenericExecutableExtension instance, bundleName= " + bundleName ) ; if ( data instanceof String ) { tString name = ( String ) data ; 
public void run ( ) { evalExpression(); 
public void run ( ) { tfinal IProject project = editorFile . getProject ( ) ; tnew ClojureLaunchShortcut ( ) . launchProject ( project , ILaunchManager . RUN_MODE , null ) ; tDisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public ILaunch launchProject ( IProject project , String mode , Boolean activateAutoReload ) { treturn launchProject ( project , new IFile [ ] { } , mode , activateAutoReload ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] filesToLaunch , String mode , Boolean activateAutoReload ) { tactivateAutoReload = activateAutoReload ! = null ? activateAutoReload : ( filesToLaunch . length = = 0 ) ; try { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { ILaunchConfiguration config = null ; if ( files = = null ) files = new IFile [ ] { } ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = lm . getLaunchConfigurationType ( LaunchUtils . LAUNCH_CONFIG_ID ) ; String basename = project . getName ( ) + " REPL " ; if ( files . length = = 1 ) { basename + = " [ " + files [ 0 ] . getName ( ) + " ] " ; } ILaunchConfigurationWorkingCopy wc = type . newInstance ( null , DebugPlugin . getDefault ( ) . getLaunchManager ( ) . generateUniqueLaunchConfigurationNameFrom ( basename ) ) ; LaunchUtils . setFilesToLaunchString ( wc , Arrays . asList ( files ) ) ; wc . setAttribute ( ATTR_PROGRAM_ARGUMENTS , " " ) ; wc . setAttribute ( ATTR_MAIN_TYPE_NAME , LaunchUtils . CLOJURE_MAIN ) ; wc . setAttribute ( ATTR_PROJECT_NAME , project . getName ( ) ) ; wc . setMappedResources ( new IResource [ ] { project } ) ; config = wc . doSave ( ) ; } catch ( CoreException ce ) { throw new RuntimeException ( ce ) ; } return config ; } 
public ICompletionProposal [ ] computeCompletionProposals ( ITextViewer viewer , tint offset ) { terrorMessage = " " ; tassistant . setStatusMessage ( " " ) ; tfinal PrefixInfo prefixInfo ; ttry { tprefixInfo = computePrefix ( viewer , offset ) ; 
private List < ICompletionProposal > computeClojureFullyQualifiedSymbolsProposals ( tPrefixInfo prefixInfo ) { tfinal List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; tfinal List < List > dynamicSymbols = dynamicComplete ( tprefixInfo . currentNamespace , prefixInfo . namePart , editor , tprefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureSymbolsProposals ( tPrefixInfo prefixInfo ) { tfinal List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; tfinal List < List > dynamicSymbols = dynamicComplete ( tprefixInfo . currentNamespace , prefixInfo . namePart , editor , tprefixInfo . fullyQualified ) ; } 
private List < ICompletionProposal > computeClojureNamespacesProposals ( tPrefixInfo prefixInfo ) { tfinal List < ICompletionProposal > proposals = new ArrayList < ICompletionProposal > ( ) ; tfinal List < List > dynamicSymbols = dynamicNamespaceComplete ( prefixInfo . prefix ) ; } 
public void beginReporting ( ) { tsuper . beginReporting ( ) ; } 
public void acceptSearchMatch ( SearchMatch match ) tthrows CoreException { tcounter + + ; if ( counter > = MAX_JAVA_SEARCH_RESULT_NUMBER ) { (IMethod) match.getElement(), methodPrefix, 
public void endReporting ( ) { tsuper . endReporting ( ) ; System.out.println("end reporting : count=" + 
public int [ ] searchFor ( ) { treturn new int [ ] { IJavaSearchConstants . METHOD } ; } 
public int [ ] matchRule ( ) { treturn new int [ ] { SearchPattern . R_CAMELCASE_MATCH / * * | 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { treturn new String [ ] { prefixInfo . nsPart + " . " + prefixInfo . namePart } ; 
public AbstractLazyCompletionProposal lazyCompletionProposal ( tPrefixInfo prefixInfo , IClojureEditor editor , tSearchMatch match ) { treturn new MethodLazyCompletionProposal ( ( IMethod ) match . getElement ( ) , prefixInfo . nsPart + " / " 
public int [ ] searchFor ( ) { treturn new int [ ] { IJavaSearchConstants . TYPE , tIJavaSearchConstants . TYPE } ; 
public String [ ] patternStr ( PrefixInfo prefixInfo ) { treturn new String [ ] { prefixInfo . prefix , tprefixInfo . prefix + " * " } ; 
public AbstractLazyCompletionProposal lazyCompletionProposal ( tPrefixInfo prefixInfo , IClojureEditor editor , tSearchMatch match ) { treturn new ClassLazyCompletionProposal ( ( IType ) match . getElement ( ) , prefixInfo . prefix , 
public int [ ] searchFor ( ) { treturn new int [ ] { IJavaSearchConstants . PACKAGE } ; } 
public int [ ] matchRule ( ) { treturn new int [ ] { SearchPattern . R_PATTERN_MATCH / * * | 
public AbstractLazyCompletionProposal lazyCompletionProposal ( tPrefixInfo prefixInfo , IClojureEditor editor , tSearchMatch match ) { treturn new PackageLazyCompletionProposal ( ( IPackageFragment ) match . getElement ( ) , 
private boolean checkJavaPrefixLength ( PrefixInfo prefixInfo ) { if ( prefixInfo . prefix . length ( ) < JAVA_PREFIX_MIN_LENGTH ) { tCCWPlugin 
public void acceptSearchMatch ( SearchMatch match ) tthrows CoreException { tproposals . add ( searchType . lazyCompletionProposal ( prefixInfo , teditor , match ) ) ; 
private boolean invalidSymbolCharacter ( char c ) { if ( Character . isWhitespace ( c ) ) treturn true ; tchar [ ] invalidChars = { '(' , ')' , '[' , ']' , '{' , '}' , '\'' , '@' , '~' , '^' , '`' , '#' , '"' } ; tfor ( int i = 0 ; i < invalidChars . length ; i + + ) { if ( invalidChars [ i ] = = c ) treturn true ; } treturn false ; } 
private static List < List > dynamicComplete ( String namespace , String prefix , tIClojureEditor editor , boolean findOnlyPublic ) { if ( namespace = = null ) { treturn Collections . emptyList ( ) ; } if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tREPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) treturn Collections . emptyList ( ) ; tConnection connection = repl . getToolingConnection ( ) ; tResponse response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete \" " + namespace + " \" \" " + prefix + " \" " + ( findOnlyPublic ? " true " : " false " ) + " ) " ) ; treturn ( List < List > ) extractSingleValue ( response , tCollections . emptyList ( ) ) ; 
private List < List > dynamicNamespaceComplete ( String prefix ) { if ( prefix = = null ) { treturn Collections . emptyList ( ) ; } tREPLView repl = editor . getCorrespondingREPL ( ) ; if ( repl = = null ) treturn Collections . emptyList ( ) ; tConnection connection = repl . getToolingConnection ( ) ; tResponse response = connection . send ( " op " , " eval " , " code " , " (ccw.debug.serverrepl/code-complete-ns \" " + prefix + " \" ) " ) ; treturn ( List < List > ) extractSingleValue ( response , tCollections . emptyList ( ) ) ; 
private static Object extractSingleValue ( Response response , tObject defaultValueIfNil ) { tList vs = response . values ( ) ; if ( vs . isEmpty ( ) | | vs . get ( 0 ) = = null ) { treturn defaultValueIfNil ; 
public IContextInformation [ ] computeContextInformation ( ITextViewer viewer , tint offset ) { treturn new IContextInformation [ ] { new IContextInformation ( ) { 
private String shortenNamespace ( String namespace ) { tString [ ] segments = namespace . split ( " \\ . " ) ; tint nextToLast = segments . length - 2 ; tStringBuilder sb = new StringBuilder ( ) ; tfor ( int i = 0 ; i < nextToLast ; i + + ) { tsb . append ( segments [ i ] . charAt ( 0 ) ) ; tsb . append ( '.' ) ; } if ( nextToLast > = 0 ) { tsb . append ( segments [ nextToLast ] ) ; tsb . append ( '.' ) ; } tsb . append ( segments [ nextToLast + 1 ] ) ; treturn sb . toString ( ) ; } 
private void updatePartNameAndDescription ( ) { tfinal String maybeNamespace = this . findDeclaringNamespace ( ) ; if ( ! StringUtils . isEmpty ( maybeNamespace ) ) { tthis . setPartName ( shortenNamespace ( maybeNamespace ) ) ; 
public void createPartControl ( Composite parent ) { tsuper . createPartControl ( parent ) ; tClojureSourceViewer viewer = ( ClojureSourceViewer ) getSourceViewer ( ) ; viewer . propertyChange ( null ) ; tfProjectionSupport = new ProjectionSupport ( viewer , getAnnotationAccess ( ) , getSharedColors ( ) ) ; } 
protected void editorSaved ( ) { tsuper . editorSaved ( ) ; tupdatePartNameAndDescription ( ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
private boolean isEarmuffedVar ( String symbol ) { treturn ( symbol . startsWith ( " * " ) | | symbol . contains ( " /* " ) ) & & 
private static String namespaceToPackage ( final String searchedNS ) { tString packagePart = ( searchedNS . contains ( " . " ) ) ? searchedNS . substring ( 0 , searchedNS . lastIndexOf ( " . " ) ) : " " ; treturn packagePart . replace ( '-' , '_' ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { tClojureOSGi . require ( bundleContext , " ccw.util.eclipse.repl " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.eclipse " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.doc-utils " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.bundle " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.factories " ) ; tClojureOSGi . require ( bundleContext , " ccw.util.string " ) ; } 
public void setInitializationData ( IConfigurationElement config , tString propertyName , Object data ) throws CoreException { tbundleName = config . getDeclaringExtension ( ) . getContributor ( ) . getName ( ) ; if ( data instanceof String ) { tString name = ( String ) data ; 
public REPLView getCorrespondingREPL ( ) { tIFile file = ( IFile ) getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( file ! = null ) { tREPLView repl = CCWPlugin . getDefault ( ) . getProjectREPL ( file . getProject ( ) ) ; if ( repl ! = null ) { treturn repl ; } } } 
protected boolean validatePage ( ) { if ( super . validatePage ( ) ) { tString mess = ( String ) wizard . _ ( checkProjectName , getProjectName ( ) ) ; 
public REPLView getCorrespondingREPL ( ) { } 
public void keyPressed ( KeyEvent e ) { if ( e . character = = SWT . ESC ) { if ( ! isContentAssistantActive ) { 
private void addKeyListenerFirst ( Control control , KeyListener listener ) { tListener [ ] keyDownListeners = control . getListeners ( SWT . KeyDown ) ; tListener [ ] keyUpListeners = control . getListeners ( SWT . KeyUp ) ; tremoveAll ( control , SWT . KeyDown , keyDownListeners ) ; tremoveAll ( control , SWT . KeyUp , keyUpListeners ) ; tcontrol . addKeyListener ( listener ) ; taddAll ( control , SWT . KeyDown , keyDownListeners ) ; taddAll ( control , SWT . KeyUp , keyUpListeners ) ; } 
private void removeAll ( Control control , int eventType , Listener [ ] listeners ) { tfor ( Listener listener : listeners ) { tcontrol . removeListener ( eventType , listener ) ; 
private void addAll ( Control control , int eventType , Listener [ ] listeners ) { tfor ( Listener listener : listeners ) { tcontrol . addListener ( eventType , listener ) ; 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { tfForegroundColor . dispose ( ) ; tfForegroundColor = null ; } if ( fBackgroundColor ! = null ) { tfBackgroundColor . dispose ( ) ; tfBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { tfSelectionForegroundColor . dispose ( ) ; tfSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { tfSelectionBackgroundColor . dispose ( ) ; tfSelectionBackgroundColor = null ; } if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( this ) ; if ( fSelectionHistory ! = null ) { tfSelectionHistory . dispose ( ) ; tfSelectionHistory = null ; } super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public boolean isContentAssistantActive ( ) { treturn isContentAssistantActive ; } 
public void assistSessionStarted ( ContentAssistEvent event ) { ( ( ClojureSourceViewer ) sourceViewer ) . setContentAssistantActive ( true ) ; } 
public void assistSessionEnded ( ContentAssistEvent event ) { ( ( ClojureSourceViewer ) sourceViewer ) . setContentAssistantActive ( false ) ; } 
public void handleResponse ( Response resp , String expression ) { handleResponses . invoke ( this , logPanel , expression , resp . seq ( ) ) ; } 
private void prepareView ( ) throws Exception { sessionId = interactive . newSession ( null ) ; evalExpression = ( IFn ) configureREPLView . invoke ( this , logPanel , interactive . client , sessionId ) ; } 
public Set < String > getAvailableOperations ( ) throws IllegalStateException { if ( describeInfo = = null ) { Response r = toolConnection . send ( " op " , " describe " ) ; if ( ! r . statuses ( ) . contains ( " done " ) ) throw new IllegalStateException ( " Invalid response to \" describe \" request: " + r . combinedResponse ( ) ) ; describeInfo = r . combinedResponse ( ) ; } Map < String , Object > ops = ( Map < String , Object > ) describeInfo . get ( " ops " ) ; return ops = = null ? new HashSet ( ) : ops . keySet ( ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { try { REPLView . connect ( repl . getConnection ( ) . url ) ; 
public void run ( ) { tTreeViewer treeViewer = getTreeViewer ( ) ; if ( treeViewer ! = null ) { ttreeViewer . getTree ( ) . setRedraw ( false ) ; 
private static String getSecondaryId ( ) { synchronized ( SECONDARY_VIEW_IDS ) { String id = SECONDARY_VIEW_IDS . iterator ( ) . next ( ) ; 
private static void releaseSecondaryId ( String id ) { synchronized ( SECONDARY_VIEW_IDS ) { SECONDARY_VIEW_IDS . add ( id ) ; 
public static REPLView connect ( String url , IConsole console , ILaunch launch ) throws Exception { String secondaryId ; REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . launch = launch ; return repl . configure ( url ) ? repl : null ; } 
public void dispose ( ) { super . dispose ( ) ; releaseSecondaryId ( secondaryId ) ; fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; try { if ( interactive ! = null ) interactive . close ( ) ; if ( toolConnection ! = null ) toolConnection . close ( ) ; } catch ( IOException e ) { CCWPlugin . logError ( e ) ; } JFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; } 
public Set < String > getAvailableOperations ( ) throws IllegalStateException { if ( describeInfo = = null ) { Response r = toolConnection . send ( " op " , " describe " ) ; working around the fact that nREPL < 0.2.0-beta9 does *not* send a :done status when an operation is unknown! TODO remove this and just check r.statuses() after we can assume usage of later versions of nREPL Object status = ((Map<String, String>)r.seq().first()).get(Keyword.intern("status")); if (clojure.lang.Util.equals(status, "unknown-op") || (status instanceof Collection && ((Collection)status).contains("error"))) { CCWPlugin.logError("Invalid response to \"describe\" request"); describeInfo = new HashMap(); } else { describeInfo = r.combinedResponse(); } } Map<String, Object> ops = (Map<String, Object>)describeInfo.get("ops"); return ops == null ? new HashSet() : ops.keySet(); } 
public void updateStructuralEditingModeStatusField ( ) { if ( this . statusLineHandler = = null ) { treturn ; } tStatusLineContributionItem field = this . statusLineHandler . getEditingModeStatusContributionItem ( ) ; if ( field ! = null ) { tfield . setText ( ( isStructuralEditingEnabled ( ) ? " strict/paredit " : " unrestricted " ) 
private boolean isEarmuffedVar ( String symbol ) { treturn ( ! symbol . equals ( " * " ) & & 
public void unconfigure ( ) { if ( fForegroundColor ! = null ) { tfForegroundColor . dispose ( ) ; tfForegroundColor = null ; } if ( fBackgroundColor ! = null ) { tfBackgroundColor . dispose ( ) ; tfBackgroundColor = null ; } if ( fSelectionForegroundColor ! = null ) { tfSelectionForegroundColor . dispose ( ) ; tfSelectionForegroundColor = null ; } if ( fSelectionBackgroundColor ! = null ) { tfSelectionBackgroundColor . dispose ( ) ; 
public void initializeViewerColors ( ) { tinitializeViewerColors ( getTextWidget ( ) , fPreferenceStore , editorColors ) ; if ( fPreferenceStore ! = null ) { tCCWPlugin . registerEditorColors ( fPreferenceStore , getTextWidget ( ) . getForeground ( ) . getRGB ( ) ) ; 
public static void initializeViewerColors ( StyledText styledText , IPreferenceStore preferenceStore , EditorColors editorColors ) { if ( preferenceStore ! = null ) { ----------- foreground color -------------------- 
public void unconfigure ( ) { teditorColors . unconfigure ( ) ; if ( fPreferenceStore ! = null ) fPreferenceStore . removePropertyChangeListener ( this ) ; if ( fSelectionHistory ! = null ) { tfSelectionHistory . dispose ( ) ; tfSelectionHistory = null ; } super . unconfigure ( ) ; fIsConfigured = false ; fConfiguration = null ; } 
public void run ( ) { tgetTextWidget ( ) . setBackground ( tstructuralEditionPossible ? editorColors . fBackgroundColor : Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_GRAY ) ) ; tgetTextWidget ( ) . setToolTipText ( structuralEditionPossible ? null : " Unparseable source code. Structural Edition temporarily disabled. " ) ; } 
public void widgetDisposed ( DisposeEvent e ) { tlogPanelEditorColors . unconfigure ( ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { tinitializeLogPanelColors ( ) ; } 
private void initializeLogPanelColors ( ) { tClojureSourceViewer . initializeViewerColors ( logPanel , getPreferences ( ) , logPanelEditorColors ) ; 
public void widgetDisposed ( DisposeEvent e ) { tJFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; tprefs . removePropertyChangeListener ( prefsListener ) ; tactiveREPL . compareAndSet ( REPLView . this , null ) ; } 
public void widgetDisposed ( DisposeEvent e ) { tgetPreferenceStore ( ) . removePropertyChangeListener ( prefsListener ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , Messages . ClojurePreferencePage_show_more_context_in_tabs , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public synchronized void stop ( ) { if ( elementChangedListener ! = null ) { tJavaCore . removeElementChangedListener ( elementChangedListener ) ; 
public boolean test ( Object receiver , String property , Object [ ] args , Object expectedValue ) { tassert " hasClojureNature " . equals ( property ) ; if ( receiver instanceof IResource ) treturn hasClojureNature ( ( IResource ) receiver ) ; 
private static void releaseSecondaryId ( String id ) { tassert id ! = null ; synchronized ( SECONDARY_VIEW_IDS ) { SECONDARY_VIEW_IDS . add ( id ) ; 
public void dispose ( ) { super . dispose ( ) ; if ( secondaryId ! = null ) { treleaseSecondaryId ( secondaryId ) ; } fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; try { if ( interactive ! = null ) interactive . close ( ) ; 
public void run ( ) { if ( getControl ( ) . isDisposed ( ) ) treturn ; tTreeViewer treeViewer = getTreeViewer ( ) ; if ( treeViewer ! = null ) { ttreeViewer . getTree ( ) . setRedraw ( false ) ; 
public void focusLost ( FocusEvent e ) { for ( IContextActivation activation : activations ) { ( ( IContextService ) getSite ( ) . getService ( IContextService . class ) ) . deactivateContext ( activation ) ; } activations = new ArrayList ( ) ; } 
private void activate ( String contextId ) { activations . add ( ( ( IContextService ) getSite ( ) . getService ( IContextService . class ) ) . activateContext ( contextId ) ) ; } 
public void focusGained ( FocusEvent e ) { activate ( IClojureEditor . KEY_BINDING_SCOPE ) ; activate ( CCW_UI_CONTEXT_REPL ) ; } 
protected void activateContext ( ) { if ( handlerActivations . isEmpty ( ) ) { tactivateHandler ( ISourceViewer . QUICK_ASSIST , 
protected void activateHandler ( int operation , String actionDefinitionId ) { tStyledText textWidget = textViewer . getTextWidget ( ) ; tIHandler actionHandler = createActionHandler ( operation , tactionDefinitionId ) ; tIHandlerActivation handlerActivation = handlerService . activateHandler ( tactionDefinitionId , actionHandler , tnew ActiveFocusControlExpression ( textWidget ) ) ; thandlerActivations . add ( handlerActivation ) ; } 
private IHandler createActionHandler ( final int operation , tString actionDefinitionId ) { tAction action = new Action ( ) { @Override public void run ( ) { if ( textViewer . canDoOperation ( operation ) ) { ttextViewer . doOperation ( operation ) ; } } } ; taction . setActionDefinitionId ( actionDefinitionId ) ; treturn new ActionHandler ( action ) ; } 
public void run ( ) { if ( textViewer . canDoOperation ( operation ) ) { ttextViewer . doOperation ( operation ) ; 
protected void deactivateContext ( ) { if ( ! handlerActivations . isEmpty ( ) ) { tfor ( IHandlerActivation activation : handlerActivations ) { 
public void collectExpressionInfo ( ExpressionInfo info ) { tinfo . markDefaultVariableAccessed ( ) ; } 
private void startClojureCode ( BundleContext bundleContext ) throws Exception { ClojureOSGi.require(bundleContext, "paredit.static-analysis"); } 
public static String findDeclaringNamespace ( Map tree ) { tVar findNamespace = RT . var ( " paredit.static-analysis " , " find-namespace " ) ; ttry { treturn ( String ) findNamespace . invoke ( tree ) ; 
public void unconfigure ( ) { tfForegroundColor = unconfigure ( fForegroundColor ) ; tfBackgroundColor = unconfigure ( fBackgroundColor = null ) ; tfSelectionForegroundColor = unconfigure ( fSelectionForegroundColor ) ; tfSelectionBackgroundColor = unconfigure ( fSelectionBackgroundColor ) ; tfCurrentLineBackgroundColor = unconfigure ( fCurrentLineBackgroundColor ) ; } 
private Color unconfigure ( Color c ) { if ( c ! = null ) { tc . dispose ( ) ; } treturn null ; } 
static public Color createColor ( IPreferenceStore store , String key , Display display ) { RGB rgb = getRGBColor ( store , key ) ; return ( rgb ! = null ) ? new Color ( display , rgb ) : null ; } 
public void initializeViewerColors ( ) { tinitializeViewerColors ( getTextWidget ( ) , fPreferenceStore , editorColors ) ; if ( fPreferenceStore ! = null ) { tCCWPlugin . registerEditorColors ( fPreferenceStore , getTextWidget ( ) . getForeground ( ) . getRGB ( ) ) ; 
private void copyToLog ( StyledText s ) { sadly, need to reset text on the ST in order to get formatting/style ranges... s.setText(boostIndent.matcher(s.getText()).replaceAll(" ").replaceFirst("^\\s+", "=> ")); int start = logPanel.getCharCount(); try { log.invoke(this, logPanel, s.getText(), inputExprLogType); 
public void sendInterrupt ( ) { log . invoke ( this , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; } 
public void optionsChanged ( DebugOptions options ) { tDEBUG = options . isDebugEnabled ( ) ; tTRACE = options . newDebugTrace ( getBundle ( ) . getSymbolicName ( ) , CCWPlugin . this . getClass ( ) ) ; ttraceOptions . updateOptions ( options ) ; } 
public static boolean isTraceOptionEnabled ( String traceOption ) { tTraceOptions traceOptions = CCWPlugin . getDefault ( ) . traceOptions ; if ( traceOptions = = null ) { treturn false ; 
private void enableTracing ( BundleContext context ) { ttraceOptions = new TraceOptions ( context . getBundle ( ) . getSymbolicName ( ) ) ; tDictionary < String , String > props = new Hashtable < String , String > ( ) ; tprops . put ( DebugOptions . LISTENER_SYMBOLICNAME , getBundle ( ) . getSymbolicName ( ) ) ; tdebugOptionsListenerRegistration = context . registerService ( tDebugOptionsListener . class . getName ( ) , 
private void disableTracing ( BundleContext context ) { if ( debugOptionsListenerRegistration ! = null ) { tdebugOptionsListenerRegistration . unregister ( ) ; 
public void stop ( BundleContext context ) throws Exception { tdisableTracing ( context ) ; plugin = null; super.stop(context); } 
public static void trace ( final String traceOption , final Object . . . messageParts ) { if ( CCWPlugin . DEBUG & & CCWPlugin . isTraceOptionEnabled ( traceOption ) ) { tStringBuilder sb = new StringBuilder ( ) ; 
public void updateOptions ( DebugOptions options ) { tfor ( String option : this . options . keySet ( ) ) { tthis . options . put ( option , options . getBooleanOption ( bundleSymbolicName + " / " + option , false ) ) ; 
public boolean isOptionEnabled ( String option ) { tBoolean res = options . get ( option ) ; if ( res ! = null ) { treturn res ; 
public void widgetDisposed ( DisposeEvent e ) { tCCWPlugin . trace ( TraceOptions . REPL , " REPLView " , REPLView . this . secondaryId , " parent composite disposed " ) ; tJFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; tprefs . removePropertyChangeListener ( prefsListener ) ; tactiveREPL . compareAndSet ( REPLView . this , null ) ; } 
public void focusGained ( FocusEvent e ) { tCCWPlugin . trace ( TraceOptions . REPL_FOCUS , " focus gained, marking repl as active " ) ; activeREPL . set ( REPLView . this ) ; NamespaceBrowser . setREPLConnection ( toolConnection ) ; } 
public void init ( IViewSite site ) throws PartInitException { tsuper . init ( site ) ; activeREPL . set ( REPLView . this ) ; } 
public void stop ( BundleContext context ) throws Exception { plugin = null; super.stop(context); } 
public static void logError ( String msg ) { tgetTracer ( ) . trace ( TraceOptions . LOG_ERROR , " ERROR - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg ) ) ; } 
public static void logError ( String msg , Throwable e ) { tgetTracer ( ) . trace ( TraceOptions . LOG_ERROR , e , " ERROR - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , msg , e ) ) ; } 
public static void logError ( Throwable e ) { tgetTracer ( ) . trace ( TraceOptions . LOG_ERROR , e , " ERROR - " ) ; plugin . getLog ( ) . log ( new Status ( IStatus . ERROR , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public static void logWarning ( String msg ) { tgetTracer ( ) . trace ( TraceOptions . LOG_WARNING , " WARNING - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg ) ) ; } 
public static void logWarning ( String msg , Throwable e ) { tgetTracer ( ) . trace ( TraceOptions . LOG_WARNING , e , " WARNING - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , msg , e ) ) ; } 
public static void logWarning ( Throwable e ) { tgetTracer ( ) . trace ( TraceOptions . LOG_WARNING , e ) ; plugin . getLog ( ) . log ( new Status ( IStatus . WARNING , PLUGIN_ID , e . getMessage ( ) , e ) ) ; 
public static void log ( String msg ) { tgetTracer ( ) . trace ( TraceOptions . LOG_INFO , " INFO - " + msg ) ; plugin . getLog ( ) . log ( new Status ( IStatus . INFO , PLUGIN_ID , msg ) ) ; } 
public void widgetDisposed ( DisposeEvent e ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " REPLView " , REPLView . this . secondaryId , " parent composite disposed " ) ; tJFaceResources . getFontRegistry ( ) . removeListener ( fontChangeListener ) ; tprefs . removePropertyChangeListener ( prefsListener ) ; tactiveREPL . compareAndSet ( REPLView . this , null ) ; } 
public void focusGained ( FocusEvent e ) { tgetTracer ( ) . trace ( TraceOptions . REPL_FOCUS , " focus gained, marking repl as active " ) ; activeREPL . set ( REPLView . this ) ; NamespaceBrowser . setREPLConnection ( toolConnection ) ; } 
boolean isEnabled ( String traceOption ) ; void trace ( String traceOption , Object . . . message ) ; void trace ( String traceOption , Throwable throwable , Object . . . message ) ; void traceDumpStack ( String traceOption ) ; void traceEntry ( String traceOption ) ; void traceEntry ( String traceOption , Object . . . arguments ) ; void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void trace ( String traceOption , Object . . . message ) ; void trace ( String traceOption , Throwable throwable , Object . . . message ) ; void traceDumpStack ( String traceOption ) ; void traceEntry ( String traceOption ) ; void traceEntry ( String traceOption , Object . . . arguments ) ; void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void trace ( String traceOption , Throwable throwable , Object . . . message ) ; void traceDumpStack ( String traceOption ) ; void traceEntry ( String traceOption ) ; void traceEntry ( String traceOption , Object . . . arguments ) ; void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceDumpStack ( String traceOption ) ; void traceEntry ( String traceOption ) ; void traceEntry ( String traceOption , Object . . . arguments ) ; void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceEntry ( String traceOption ) ; void traceEntry ( String traceOption , Object . . . arguments ) ; void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceEntry ( String traceOption , Object . . . arguments ) ; void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
public void trace ( String traceOption , Object . . . message ) { } public void trace ( String traceOption , Throwable throwable , Object . . . message ) { } public void traceDumpStack ( String traceOption ) { } public void traceEntry ( String traceOption ) { } public void traceEntry ( String traceOption , Object . . . arguments ) { } public void traceExit ( String traceOption ) { } public void traceExit ( String traceOption , Object returnValue ) { } } 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { } public void traceDumpStack ( String traceOption ) { } public void traceEntry ( String traceOption ) { } public void traceEntry ( String traceOption , Object . . . arguments ) { } public void traceExit ( String traceOption ) { } public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceDumpStack ( String traceOption ) { } public void traceEntry ( String traceOption ) { } public void traceEntry ( String traceOption , Object . . . arguments ) { } public void traceExit ( String traceOption ) { } public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceEntry ( String traceOption ) { } public void traceEntry ( String traceOption , Object . . . arguments ) { } public void traceExit ( String traceOption ) { } public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceEntry ( String traceOption , Object . . . arguments ) { } public void traceExit ( String traceOption ) { } public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceExit ( String traceOption ) { } public void traceExit ( String traceOption , Object returnValue ) { } } 
public void optionsChanged ( DebugOptions options ) { if ( options . isDebugEnabled ( ) ) { debugTrace = options . newDebugTrace ( bundleSymbolicName , Tracer . class ) ; } else { debugTrace = null ; } updateOptions ( options ) ; } 
private void enableTracing ( BundleContext context ) { Dictionary < String , String > props = new Hashtable < String , String > ( ) ; props . put ( DebugOptions . LISTENER_SYMBOLICNAME , context . getBundle ( ) . getSymbolicName ( ) ) ; context . registerService ( DebugOptionsListener . class . getName ( ) , 
private void updateOptions ( DebugOptions options ) { for ( String option : this . options . keySet ( ) ) { this . options . put ( option , options . getBooleanOption ( bundleSymbolicName + " / " + option , false ) ) ; 
public boolean isEnabled ( String traceOption ) { if ( debugTrace = = null ) { return false ; } Boolean res = options . get ( traceOption ) ; if ( res ! = null ) { return res ; 
private String buildMessage ( Object [ ] message ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object m : message ) { sb . append ( m ) ; } return sb . toString ( ) ; } 
public void trace ( String traceOption , Object . . . message ) { if ( isEnabled ( traceOption ) ) { debugTrace . trace ( " / " + traceOption , buildMessage ( message ) ) ; 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { if ( isEnabled ( traceOption ) ) { debugTrace . trace ( " / " + traceOption , buildMessage ( message ) , throwable ) ; 
public void traceDumpStack ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceDumpStack ( " / " + traceOption ) ; 
public void traceEntry ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( " / " + traceOption ) ; 
public void traceEntry ( String traceOption , Object . . . arguments ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( " / " + traceOption , arguments ) ; 
public void traceExit ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( " / " + traceOption ) ; 
public void traceExit ( String traceOption , Object returnValue ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( " / " + traceOption , returnValue ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { tLaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( configuration . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , false ) ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public static String getProjectName ( ILaunch launch ) { return launch . getAttribute ( LaunchUtils . LAUNCH_ATTR_PROJECT_NAME ) ; } 
private static void inUIThreadSetREPLConnection ( Connection repl ) { tIWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; treturn ; } tIWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activePage is null " ) ; } tIViewPart [ ] views = activePage . getViews ( ) ; tNamespaceBrowser co = null ; tfor ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { tco = ( NamespaceBrowser ) v ; tbreak ; } } if ( co = = null ) { treturn ; } tco . reset ( repl ) ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Text ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; don't know much about swt layouts yet :-( hosts.setSelection(new Point(0, hosts.getText().length())); new Label(parent, 0).setText("Port"); port = new Text(parent, SWT.BORDER); port.setFocus(); return composite; } 
protected void okPressed ( ) { url = String . format ( " nrepl:%s:%s " , hosts . getText ( ) , port . getText ( ) ) ; super . okPressed ( ) ; } 
public void printErrorDetail ( ) { evalExpression ( " (binding [*out* *err*] (if-not *e (println \" No prior exception bound to *e. \" ) (require 'clojure.repl) (clojure.repl/pst *e))) " , false , false ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; hosts = new Combo ( parent , SWT . BORDER ) ; hosts . setText ( " 127.0.0.1 " ) ; }); port.setFocus(); return composite; } 
public void verifyText ( VerifyEvent e ) { tString newText = port . getText ( ) . substring ( 0 , e . start ) + e . text + port . getText ( ) . substring ( e . end ) ; te . doit = newText . matches ( " \\ d* " ) ; } 
 private void connectRepl ( ) { try { REPLView replView = REPLView . connect ( " nrepl:localhost: " + port . intValue ( ) , lastConsoleOpened , launch , makeActiveREPL ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { return REPLView . connect ( " nrepl:localhost: " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) , true ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { try { REPLView . connect ( repl . getConnection ( ) . url , true ) ; 
public static REPLView connect ( String url , boolean makeActiveREPL ) throws Exception { return connect ( url , null , null , makeActiveREPL ) ; } 
public static REPLView connect ( String url , IConsole console , ILaunch launch , boolean makeActiveREPL ) throws Exception { String secondaryId ; REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public void printErrorDetail ( ) { evalExpression ( " (require 'clojure.repl) " + " (binding [*out* *err*] " + 
public void createControl ( Composite parent ) { tsuper . createControl ( parent ) ; tlocationArea = new ProjectContentsLocationArea ( getErrorReporter ( ) , ( Composite ) getControl ( ) ) ; tcreateLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; tcreateWorkingSetGroup ( ( Composite ) getControl ( ) , tthis . newLeiningenProjectWizard . getSelection ( ) , tnew String [ ] { " org.eclipse.ui.resourceWorkingSetPage " } ) ; } 
protected boolean validatePage ( ) { if ( superValidatePage ( ) ) { tString mess = ( String ) wizard . _ ( checkProjectName , getProjectName ( ) ) ; 
protected boolean superValidatePage ( ) { IWorkspace workspace = IDEWorkbenchPlugin . getPluginWorkspace ( ) ; String projectFieldContents = getProjectName ( ) ; if ( projectFieldContents . equals ( " " ) ) { } setErrorMessage(null); setMessage(null); return true; } 
public void propertyChanged ( Object source , int propId ) { if ( propId = = IEditorPart . PROP_INPUT ) { tupdatePartNameAndDescription ( ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . FORCE_TWO_SPACES_INDENT , Messages . ClojurePreferencePage_force_two_spaces_indent , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , Messages . ClojurePreferencePage_show_more_context_in_tabs , getFieldEditorParent ( ) ) ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
private void advanceToken ( ) { tlong start = System . currentTimeMillis ( ) ; tboolean firstToken ; if ( currentToken = = null ) { tfirstToken = true ; } else { tfirstToken = false ; } if ( ! firstToken ) { tNumber count = ( Number ) currentToken . get ( tokenLengthKeyword ) ; tcurrentOffset + = count . intValue ( ) ; ttokenSeq = tokenSeq . next ( ) ; } System.out.println(tokenSeq.first()); currentToken = (Map<?,?>)tokenSeq.first(); advanceTokenDuration += System.currentTimeMillis() - start; } 
public ITextHover getTextHover ( ISourceViewer sourceViewer , tString contentType ) { treturn ( ITextHover ) textHover . _ ( " make-TextHover " , editor ) ; } 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isInEscapeSequence ( ) ; boolean isForceRepair();} 
IRegion getUnSignedSelection ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
String findDeclaringNamespace ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
REPLView getCorrespondingREPL ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
public static boolean isAutoReloadEnabled ( ) { treturn CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE ) ; } 
public void run ( ) { tfinal IProject project = editorFile . getProject ( ) ; tnew ClojureLaunchShortcut ( ) . launchProject ( project , ILaunchManager . RUN_MODE ) ; tDisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public static boolean isAutoReloadEnabled ( ILaunch launch ) { if ( launch = = null ) { treturn false ; 
private ILaunch launchEditorPart ( IEditorPart editor , String mode ) { IEditorInput input = editor . getEditorInput ( ) ; if ( input instanceof FileEditorInput ) { FileEditorInput fei = ( FileEditorInput ) input ; 
public ILaunch launchProject ( IProject project , String mode ) { treturn launchProject ( project , new IFile [ ] { } , mode ) ; } 
protected ILaunch launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { tBoolean activateAutoReload = CCWPlugin . isAutoReloadEnabled ( ) ; try { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringPreferencePage . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
public void launchProject ( IProject project , String mode ) { tlaunchProject ( project , new IFile [ ] { } , mode ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesFor ( projectName ) ; if ( running . size ( ) = = 0 ) { tlaunchProject2 ( project , filesToLaunch , mode ) ; 
private boolean userConfirmsNewLaunch ( final IProject project , final int nb ) { tfinal boolean [ ] ret = new boolean [ 1 ] ; tfinal String title = " Clojure Application Launcher " ; tfinal String msg = ( nb = = 1 ? " A " : nb ) + " REPL " + ( nb = = 1 ? " is " : " s are " ) + " already running for this project. Changes you made can " + " be evaluated in an existing REPL (see Clojure menu). " + " nAre you sure you want to start up another REPL for this project? " + " (Cancel will open existing REPL) " ; DisplayUtil . syncExec ( new Runnable ( ) { public void run ( ) { tShell shell = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) ; ret [ 0 ] = MessageDialog . openConfirm ( shell , title , msg ) ; } } ) ; treturn ret [ 0 ] ; } 
public void run ( ) { tShell shell = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) ; ret [ 0 ] = MessageDialog . openConfirm ( shell , title , msg ) ; } 
protected void launchProject2 ( IProject project , IFile [ ] filesToLaunch , String mode ) { tBoolean activateAutoReload = CCWPlugin . isAutoReloadEnabled ( ) ; try { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; parent = new Composite ( composite , 0 ) ; parent . setLayout ( new GridLayout ( 2 , false ) ) ; new Label ( parent , 0 ) . setText ( " Hostname " ) ; host = new Text ( parent , SWT . BORDER ) ; new Label ( parent , 0 ) . setText ( " Port " ) ; port = new Text ( parent , SWT . BORDER ) ; port . addVerifyListener ( new VerifyListener ( ) { public void verifyText ( VerifyEvent e ) { tString newText = port . getText ( ) . substring ( 0 , e . start ) + e . text + port . getText ( ) . substring ( e . end ) ; te . doit = newText . matches ( " \\ d* " ) ; } } ) ; initValues ( ) ; composite . addDisposeListener ( new DisposeListener ( ) { @Override public void widgetDisposed ( DisposeEvent e ) { tsaveValues ( ) ; } } ) ; port . setFocus ( ) ; port . setSelection ( 0 , port . getText ( ) . length ( ) ) ; return composite ; } 
private void initValues ( ) { if ( dialogSettings = = null ) return ; tsetText ( host , dialogSettings . get ( HOST_SETTING ) , HOST_SETTING_DEFAULT ) ; tsetText ( port , dialogSettings . get ( PORT_SETTING ) , PORT_SETTING_DEFAULT ) ; } 
private void saveValues ( ) { if ( dialogSettings = = null ) return ; tsaveValue ( host , HOST_SETTING , HOST_SETTING_DEFAULT ) ; tsaveValue ( port , PORT_SETTING , PORT_SETTING_DEFAULT ) ; } 
private void saveValue ( Text w , String key , String defaultValue ) { tString value = w . getText ( ) ; tdialogSettings . put ( tkey , 
protected void okPressed ( ) { url = String . format ( " nrepl:%s:%s " , host . getText ( ) , port . getText ( ) ) ; super . okPressed ( ) ; } 
public static String findDeclaringNamespace ( Map tree ) { ttry { treturn ( String ) staticAnalysis . _ ( " find-namespace " , tree ) ; 
public Object run ( ) throws Exception { tcore . _ ( " require " , Symbol . intern ( " clojure.tools.nrepl.helpers " ) ) ; treturn null ; } 
public Object run ( ) throws Exception { ttry { if ( ! project . exists ( ) | | ! project . isOpen ( ) ) treturn Status . CANCEL_STATUS ; if ( project . hasNature ( ClojureCore . NATURE_ID ) ) { treturn Status . CANCEL_STATUS ; } tboolean hasClojurePackage = JavaCore . create ( project ) . findElement ( ClojurePackageElementChangeListener . CLOJURE_PACKAGE_PATH ) ! = null ; if ( hasClojurePackage ) { tToggleNatureCommand . toggleNature ( project , true ) ; } } catch ( CoreException e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , te ) ; } treturn Status . OK_STATUS ; } 
protected void configureShell ( Shell newShell ) { super . configureShell ( newShell ) ; newShell . setText ( " Connect to a REPL " ) ; } 
protected Control createDialogArea ( Composite parent ) { Composite composite = ( Composite ) super . createDialogArea ( parent ) ; GridLayout layout = ( GridLayout ) composite . getLayout ( ) ; layout . numColumns = 1 ; { Label l = new Label ( composite , 0 ) ; GridData gd = new GridData ( ) ; l . setLayoutData ( gd ) ; l . setText ( " nRepl URL: " ) ; } { rawUrl = new Text ( composite , SWT . BORDER ) ; GridData gd = new GridData ( ) ; gd . grabExcessHorizontalSpace = true ; gd . horizontalAlignment = SWT . FILL ; gd . widthHint = 300 ; rawUrl . setLayoutData ( gd ) ; } { tLabel l ; tl = new Label ( composite , SWT . NONE ) ; tl . setText ( " Example: nrepl:127.0.0.1:5678 " ) ; tl . setForeground ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_DARK_GRAY ) ) ; tl = new Label ( composite , SWT . NONE ) ; tl . setText ( " Example: http:yourapp.herokuapp.com/repl " ) ; tl . setForeground ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_DARK_GRAY ) ) ; } initValues ( ) ; composite . addDisposeListener ( new DisposeListener ( ) { @Override public void widgetDisposed ( DisposeEvent e ) { tsaveValues ( ) ; } } ) ; applyDialogFont ( composite ) ; return composite ; } 
private void initValues ( ) { tsetText ( rawUrl , dialogSettings . get ( URL_SETTING ) , URL_SETTING_DEFAULT ) ; } 
private void saveValues ( ) { tsaveValue ( rawUrl , URL_SETTING , URL_SETTING_DEFAULT ) ; } 
private void saveValue ( Text w , String key , String defaultValue ) { if ( dialogSettings = = null ) return ; tString value = w . getText ( ) ; tdialogSettings . put ( tkey , 
protected void okPressed ( ) { url = rawUrl . getText ( ) ; super . okPressed ( ) ; } 
public Object run ( ) throws Exception { tcore . _ ( " require " , Symbol . intern ( " ccw.repl.view-helpers " ) ) ; } 
public static Var requireAndGetVar ( final String bundleSymbolicName , final String varName ) throws CoreException { tfinal String [ ] nsFn = varName . split ( " / " ) ; ttry { treturn ( Var ) ClojureOSGi . withBundle ( loadAndGetBundle ( bundleSymbolicName ) , new RunnableWithException ( ) { 
public Object run ( ) throws Exception { tSymbol nsSymbol = Symbol . intern ( nsFn [ 0 ] ) ; if ( findNs . invoke ( nsSymbol ) = = null ) { trequire . invoke ( nsSymbol ) ; } 
public Object run ( ) throws Exception { trequire . invoke ( Symbol . intern ( namespace ) ) ; treturn null ; } 
public Object run ( ) throws Exception { tSystem . out . println ( " GenericExecutableExtension.create() - with factory: " + factory ) ; tObject ret = factory . invoke ( factoryParams ) ; tSystem . out . println ( " GenericExecutableExtension.create() - factory: " + factory + " returned " ) ; treturn ret ; } 
private void initFactory ( String varName ) throws CoreException { tSystem . out . println ( " initFactory( " + varName + " ) - START " ) ; tfactory = BundleUtils . requireAndGetVar ( bundleName , varName ) ; tSystem . out . println ( " initFactory( " + varName + " ) - STOP " ) ; } 
protected Class < ? > findClass ( String name ) throws ClassNotFoundException { treturn _bundle . loadClass ( name ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) tthrows Exception { tClassLoader loader = new BundleClassLoader ( aBundle ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , tloader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
protected IProject [ ] build ( int kind , Map < String , String > args , tIProgressMonitor monitor ) throws CoreException { if ( getProject ( ) = = null ) treturn null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) treturn null ; if ( projectCljPresentInDelta ( ) ) { ttry { tIJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; tclasspathContainer . _ ( updateProjectDependencies , javaProject ) ; } catch ( Exception e ) { tthrow new CoreException ( CCWPlugin . createErrorStatus ( " Unexpected exception while trying to update Leiningen Managed Dependencies for project " + getProject ( ) . getName ( ) , e ) ) ; } } treturn null ; } 
public static boolean isAutoReloadOnStartupSaveEnabled ( ) { treturn CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE ) ; } 
public static boolean isAutoReloadOnStartupSaveEnabled ( ILaunch launch ) { treturn ( Boolean . parseBoolean ( launch . getAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED ) ) ) ; } 
protected void launchProject2 ( IProject project , IFile [ ] filesToLaunch , String mode ) { tBoolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; try { ILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected void clean ( IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { tmonitor = new NullProgressMonitor ( ) ; } ttry { if ( CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ) { } deleteMarkers(getProject()); } 
public Object run ( ) throws Exception { treturn RT . var ( " clojure.core " , " require " ) ; } 
public Object _ ( final String varName , final Object arg1 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 ) ; } 
public Object _ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 , final Object arg5 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 , arg5 ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) tthrows RuntimeException { tSystem . out . println ( " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; tClassLoader loader = new BundleClassLoader ( aBundle ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public void createControl ( Composite parent ) { tsuper . createControl ( parent ) ; tcreateLeinTemplateGroup ( ( Composite ) getControl ( ) ) ; } 
private void doLeinAddPagesPost ( ) { tgetStartingPage ( ) . setDescription ( " Leverages Leiningen 2.0, the recommanded project management tool for Clojure. " + " n(Don't wanna use Leiningen? Then simply create a maven/gradle/whatever java project, and add Clojure in its classpath) " ) ; getStartingPage ( ) . setTitle ( " Clojure project " ) ; setWindowTitle ( " New Clojure project " ) ; } 
private void copyToLog ( StyledText s ) { sadly, need to reset text on the ST in order to get formatting/style ranges... s.setText(boostIndent.matcher(s.getText()).replaceAll(" ").replaceFirst("^\\s+", "=> ")); int start = logPanel.getCharCount(); try { viewHelpers._("log", this, logPanel, s.getText(), inputExprLogType); 
public void sendInterrupt ( ) { viewHelpers . _ ( " log " , this , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; } 
public void handleResponse ( Response resp , String expression ) { viewHelpers . _ ( " handle-responses " , this , logPanel , expression , resp . seq ( ) ) ; } 
private void prepareView ( ) throws Exception { sessionId = interactive . newSession ( null ) ; evalExpression = ( IFn ) viewHelpers . _ ( " configure-repl-view " , this , logPanel , interactive . client , sessionId ) ; } 
public static Var requireAndGetVar ( final Bundle bundle , final String varName ) throws CoreException { tfinal String [ ] nsFn = varName . split ( " / " ) ; ttry { tfinal String nsName = nsFn [ 0 ] ; 
public Object run ( ) throws Exception { treturn RT . var ( nsName , nsFn [ 1 ] ) ; } 
public static Var requireAndGetVar ( final String bundleSymbolicName , final String varName ) throws CoreException { treturn requireAndGetVar ( loadAndGetBundle ( bundleSymbolicName ) , varName ) ; } 
public static ClojureInvoker newInvoker ( Plugin plugin , final String namespace ) { ttry { tClojureOSGi . require ( plugin . getBundle ( ) , namespace ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { tClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
public Object run ( ) throws Exception { ttry { tSystem . out . println ( " ClojureOSGi.require( " + bundle . getSymbolicName ( ) + " , " + namespace + " ) - START " ) ; 
public Object run ( ) throws Exception { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " GenericExecutableExtension.create() - with factory: " + factory ) ; tObject ret = factory . invoke ( factoryParams ) ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " GenericExecutableExtension.create() - factory: " + factory + " returned " ) ; treturn ret ; } 
private void initFactory ( String varName ) throws CoreException { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " initFactory( " + varName + " ) - START " ) ; tfactory = BundleUtils . requireAndGetVar ( bundleName , varName ) ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " initFactory( " + varName + " ) - STOP " ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) tthrows RuntimeException { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; tClassLoader loader = new BundleClassLoader ( aBundle ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public Object run ( ) throws Exception { ttry { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.require( " + bundle . getSymbolicName ( ) + " , " + namespace + " ) - START " ) ; 
public void stop ( BundleContext context ) throws Exception { plugin = null; super.stop(context); } 
public void trace ( String traceOption , Object . . . message ) { } public void trace ( String traceOption , Throwable throwable , Object . . . message ) { tSystem . out . println ( " trace[traceOption: " + traceOption + " , message: " + Tracer . buildMessage ( message ) + " ] " ) ; tthrowable . printStackTrace ( ) ; } public void traceDumpStack ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceDumpStack[traceOption: " + traceOption + " ] " ) ; } catch ( RuntimeException e ) { te . printStackTrace ( ) ; } } public void traceEntry ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceEntry[traceOption: " + traceOption + " ] " ) ; } catch ( RuntimeException e ) { te . printStackTrace ( ) ; } } public void traceEntry ( String traceOption , Object . . . arguments ) { ttry { tthrow new RuntimeException ( " traceEntry[traceOption: " + traceOption + " , arguments: " + Tracer . buildMessage ( arguments ) + " ] " ) ; } catch ( RuntimeException e ) { te . printStackTrace ( ) ; } } public void traceExit ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceExit[traceOption: " + traceOption + " ] " ) ; } catch ( RuntimeException e ) { te . printStackTrace ( ) ; } } public void traceExit ( String traceOption , Object returnValue ) { ttry { tthrow new RuntimeException ( " traceExit[traceOption: " + traceOption + " , returnValue: " + returnValue + " ] " ) ; } catch ( RuntimeException e ) { te . printStackTrace ( ) ; } } } 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { tSystem . out . println ( " trace[traceOption: " + traceOption + " , message: " + Tracer . buildMessage ( message ) + " ] " ) ; tthrowable . printStackTrace ( ) ; } 
public void traceDumpStack ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceDumpStack[traceOption: " + traceOption + " ] " ) ; 
public void traceEntry ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceEntry[traceOption: " + traceOption + " ] " ) ; 
public void traceEntry ( String traceOption , Object . . . arguments ) { ttry { tthrow new RuntimeException ( " traceEntry[traceOption: " + traceOption 
public void traceExit ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceExit[traceOption: " + traceOption + " ] " ) ; 
public void traceExit ( String traceOption , Object returnValue ) { ttry { tthrow new RuntimeException ( " traceExit[traceOption: " + traceOption 
public static String buildMessage ( Object [ ] message ) { StringBuilder sb = new StringBuilder ( ) ; for ( Object m : message ) { sb . append ( m ) ; } return sb . toString ( ) ; } 
public static REPLView connect ( String url , IConsole console , ILaunch launch , boolean makeActiveREPL ) throws Exception { String secondaryId ; REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . showConsoleAction . setEnabled ( console ! = null ) ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public void showConsole ( ) { if ( console ! = null ) ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( console ) ; } 
private void createActions ( ) { tprintErrorAction = new Action ( " Print detailed output from the last exception " ) { @Override public void run ( ) { tprintErrorDetail ( ) ; } } ; tprintErrorAction . setToolTipText ( " Print detailed output from the last exception " ) ; tprintErrorAction . setImageDescriptor ( getImageDescriptor ( " repl/print_last_error.gif " ) ) ; tinterruptAction = new Action ( " Interrupt Evaluation " ) { @Override public void run ( ) { tsendInterrupt ( ) ; } } ; tinterruptAction . setToolTipText ( " Forcibly interrupt the currently-running evaluation for this session. " ) ; tinterruptAction . setImageDescriptor ( getImageDescriptor ( " repl/interrupt.gif " ) ) ; treconnectAction = new Action ( " Reconnect " ) { @Override public void run ( ) { try { reconnect ( ) ; } catch ( Exception e ) { tfinal String MSG = " Unexpected exception occured while trying to reconnect REPL view to clojure server " ; tErrorDialog . openError ( tREPLView . this . getSite ( ) . getShell ( ) , " Reconnection Error " , tMSG , tCCWPlugin . createErrorStatus ( MSG , e ) ) ; } } } ; treconnectAction . setToolTipText ( " Reconnect to this REPL's host and port (first disconnecting if necessary) " ) ; treconnectAction . setImageDescriptor ( getImageDescriptor ( " repl/reconnect.gif " ) ) ; tclearLogAction = new Action ( " Clear REPL log " ) { public void run ( ) { tlogPanel . setText ( " " ) ; } } ; tclearLogAction . setToolTipText ( " Clear the REPL&apos;s log " ) ; tclearLogAction . setImageDescriptor ( getImageDescriptor ( " repl/clear.gif " ) ) ; tnewSessionAction = new Action ( " New Session " ) { public void run ( ) { try { REPLView . connect ( getConnection ( ) . url , true ) ; } catch ( Exception e ) { final String msg = " Unexpected exception occured while trying to connect REPL view to clojure server " ; ErrorDialog . openError ( tREPLView . this . getSite ( ) . getShell ( ) , " Connection Error " , msg , CCWPlugin . createErrorStatus ( msg , e ) ) ; } } } ; tnewSessionAction . setToolTipText ( " Open a new REPL session connected to this REPL's Clojure process. " ) ; tnewSessionAction . setImageDescriptor ( getImageDescriptor ( " repl/new_wiz.gif " ) ) ; tshowConsoleAction = new Action ( " Show Console " ) { public void run ( ) { tshowConsole ( ) ; } } ; tshowConsoleAction . setToolTipText ( " Show the console for the JVM process to which this REPL is connected " ) ; tshowConsoleAction . setDisabledImageDescriptor ( getImageDescriptor ( " repl/console_disabled.gif " ) ) ; tshowConsoleAction . setImageDescriptor ( getImageDescriptor ( " repl/console.gif " ) ) ; 
public void run ( ) { try { REPLView . connect ( getConnection ( ) . url , true ) ; 
private void createToolbar ( ) { tIToolBarManager mgr = getViewSite ( ) . getActionBars ( ) . getToolBarManager ( ) ; tmgr . add ( printErrorAction ) ; tmgr . add ( interruptAction ) ; tmgr . add ( reconnectAction ) ; tmgr . add ( clearLogAction ) ; tmgr . add ( newSessionAction ) ; tmgr . add ( showConsoleAction ) ; } 
private void activate ( String contextId ) { ( ( IContextService ) getSite ( ) . getService ( IContextService . class ) ) . activateContext ( contextId ) ; 
public void focusLost ( FocusEvent e ) { for (IContextActivation activation : activations) { ((IContextService)REPLView.this.getSite().getService(IContextService.class)).deactivateContext(activation); } activations = new ArrayList(); } 
public void trace ( String traceOption , Object . . . message ) { tSystem . out . println ( " trace[traceOption: " + traceOption + " , message: " + Tracer . buildMessage ( message ) + " ] " ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, loading clojure.core " ) ; tClassLoader loader = new BundleClassLoader ( CCWPlugin . getDefault ( ) . getBundle ( ) ) ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; tRT . var ( " clojure.core " , " require " ) ; } catch ( Exception e ) { tthrow new RuntimeException ( " ClojureOSGi: Static initialization, Exception while loading clojure.core " , e ) ; } finally { tThread . currentThread ( ) . setContextClassLoader ( saved ) ; } tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, clojure.core loaded " ) ; tinitialized = true ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) tthrows RuntimeException { tinitialize ( ) ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; tClassLoader loader = new BundleClassLoader ( aBundle ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public Object run ( ) throws Exception { ttry { treturn RT . var ( nsName , nsFn [ 1 ] ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; tSystem . out . println ( " ClojureOSGi: Static initialization, loading clojure.core " ) ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, loading clojure.core " ) ; tClassLoader loader = new BundleClassLoader ( CCWPlugin . getDefault ( ) . getBundle ( ) ) ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; tRT . var ( " clojure.core " , " require " ) ; } catch ( Exception e ) { tthrow new RuntimeException ( " ClojureOSGi: Static initialization, Exception while loading clojure.core " , e ) ; } finally { tThread . currentThread ( ) . setContextClassLoader ( saved ) ; } tSystem . out . println ( " ClojureOSGi: Static initialization, clojure.core loaded " ) ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, clojure.core loaded " ) ; tinitialized = true ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) tthrows RuntimeException { tinitialize ( ) ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.withBundle( " + aBundle . getSymbolicName ( ) + " ) " ) ; tClassLoader loader = new BundleClassLoader ( aBundle ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { tSystem . out . println ( " ClojureOSGi.require( " + bundle . getSymbolicName ( ) + " , " + namespace + " ) " ) ; tClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
private synchronized static void initialize ( ) { if ( initialized ) return ; tSystem . out . println ( " ClojureOSGi: Static initialization, loading clojure.core " ) ; tSystem . out . flush ( ) ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi: Static initialization, loading clojure.core " ) ; tCCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { tSystem . out . println ( " ======= ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; tSystem . out . flush ( ) ; } tClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; tClass . forName ( " clojure.lang.RT " , true , loader ) ; } 
public static SWTWorkbenchBot eclipseBot ( ) { tSWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; ttry { tbot . viewByTitle ( " Welcome " ) . close ( ) ; } catch ( Exception e ) { } 
public static SWTBotMenu menu ( SWTWorkbenchBot bot , String menu , String . . . subMenus ) { tSWTBotMenu ret = bot . menu ( menu ) ; tfor ( String subMenu : subMenus ) { tret = ret . menu ( subMenu ) ; } treturn ret ; } 
public static SWTBotShell activateShell ( SWTWorkbenchBot bot , String shell ) { tSWTBotShell s = bot . shell ( shell ) ; ts . activate ( ) ; treturn s ; } 
public static void createClojureProject ( SWTWorkbenchBot bot , String projectName ) { tmenu ( bot , " File " , " New " , " Project... " ) . click ( ) ; tactivateShell ( bot , " New Project " ) ; tbot . tree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; tbot . button ( " Next > " ) . click ( ) ; tbot . textWithLabel ( " Project name: " ) . setText ( projectName ) ; tbot . button ( " Finish " ) . click ( ) ; } 
public static void assertProjectExists ( SWTWorkbenchBot bot , String projectName ) { tbot . viewByTitle ( " Package Explorer " ) . bot ( ) . tree ( ) . expandNode ( projectName ) ; } 
public void canCreateANewClojureProject ( ) throws Exception { tcreateClojureProject ( bot , " MyFirstClojureProject " ) ; tassertProjectExists ( bot , " MyFirstClojureProject " ) ; } 
public void canCreateANewClojureProject ( ) throws Exception { tcreateClojureProject ( bot , " MyFirstClojureProject " ) ; tassertProjectExists ( bot , " MyFirstClojreProject " ) ; } 
public void run ( IProgressMonitor monitor ) throws CoreException { } } 
public static void createClojureProject ( SWTWorkbenchBot bot , String projectName ) throws Exception { tmenu ( bot , " File " , " New " , " Project... " ) . click ( ) ; tactivateShell ( bot , " New Project " ) ; tbot . tree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; tbot . button ( " Next > " ) . click ( ) ; tbot . textWithLabel ( " Project name: " ) . setText ( projectName ) ; tbot . button ( " Finish " ) . click ( ) ; twaitForWorkspace ( ) ; } 
public static void assertProjectExists ( SWTWorkbenchBot bot , String projectName ) { tSWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; tSWTBotTree projectsTree = packageExplorer . bot ( ) . tree ( ) ; tprojectsTree . setFocus ( ) ; tprojectsTree . expandNode ( projectName ) ; } 
public void canCreateANewClojureProject ( ) throws Exception { tcreateClojureProject ( bot , " MyFirstClojureProject " ) ; tassertProjectExists ( bot , " MyFirstClojureProject " ) ; } 
public void run ( IProgressMonitor monitor ) throws CoreException { } } 
public static void createClojureProject ( SWTWorkbenchBot bot , String projectName ) throws Exception { tmenu ( bot , " File " , " New " , " Project... " ) . click ( ) ; tactivateShell ( bot , " New Project " ) ; tbot . tree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; tbot . button ( " Next > " ) . click ( ) ; tbot . textWithLabel ( " Project name: " ) . setText ( projectName ) ; tbot . button ( " Finish " ) . click ( ) ; waitForWorkspace(); 
public void run ( IProgressMonitor monitor ) throws CoreException { } } 
public static void assertProjectExists ( SWTWorkbenchBot bot , String projectName ) { tSWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; tSWTBotTree projectsTree = packageExplorer . bot ( ) . tree ( ) ; tprojectsTree . expandNode ( projectName ) ; } 
public void run ( IIntroSite site , Properties params ) { tIIntroManager introManager = site . getWorkbenchWindow ( ) . getWorkbench ( ) . getIntroManager ( ) ; tIIntroPart introPart = introManager . getIntro ( ) ; if ( introPart ! = null ) { tintroManager . closeIntro ( introPart ) ; } topenWizard ( site . getShell ( ) , site . getWorkbenchWindow ( ) . getWorkbench ( ) , null , " ccw.project.new.wizard " ) ; } 
public void openWizard ( Shell shell , IWorkbench workbench , IStructuredSelection selection , String id ) { Then if we have a wizard, open it. 
public static SWTWorkbenchBot eclipseBot ( ) { tSWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; ttry { tbot . viewByTitle ( " Welcome " ) . close ( ) ; } catch ( Exception e ) { } 
public void run ( IProgressMonitor monitor ) throws CoreException { } } 
public static void setupClass ( ) { tbot = eclipseBot ( ) ; tcheckProductDefaultConfiguration ( ) ; } 
private static void checkProductDefaultConfiguration ( ) { tassertEquals ( " Java " , bot . activePerspective ( ) . getLabel ( ) ) ; } 
private boolean newProjectWizardPerformFinish ( ) { tcreateNewProject ( ) ; if ( newProject = = null ) { treturn false ; } tIWorkingSet [ ] workingSets = mainPage . getSelectedWorkingSets ( ) ; tgetWorkbench ( ) . getWorkingSetManager ( ) . addToWorkingSets ( tnewProject , tworkingSets ) ; tupdatePerspective ( ) ; tselectAndReveal ( newProject ) ; treturn true ; } 
public static SWTWorkbenchBot eclipseBot ( ) { tSWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; treturn bot ; } 
public static SWTWorkbenchBot openJavaPerspective ( SWTWorkbenchBot bot ) { tbot . perspectiveByLabel ( " Java " ) . activate ( ) ; treturn bot ; } 
public static SWTWorkbenchBot closeWelcome ( SWTWorkbenchBot bot ) { ttry { tbot . viewByTitle ( " Welcome " ) . close ( ) ; } catch ( Exception e ) { 
public void run ( IProgressMonitor monitor ) throws CoreException { } } 
public static SWTWorkbenchBot createClojureProject ( SWTWorkbenchBot bot , String projectName ) throws Exception { tmenu ( bot , " File " , " New " , " Project... " ) . click ( ) ; treturn fillNewProject ( bot , projectName ) ; } 
public static SWTWorkbenchBot fillNewProject ( SWTWorkbenchBot bot , String projectName ) throws Exception { tactivateShell ( bot , " New Project " ) ; tbot . tree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; tbot . button ( " Next > " ) . click ( ) ; tbot . textWithLabel ( " Project name: " ) . setText ( projectName ) ; tbot . button ( " Finish " ) . click ( ) ; twaitForWorkspace ( ) ; treturn bot ; } 
public static void setupClass ( ) throws Exception { tbot = eclipseBot ( ) ; } 
private static void checkProductDefaultConfiguration ( ) throws Exception { tbot . viewByTitle ( " Welcome " ) . setFocus ( ) ; tbot . link ( " New Clojure Project " ) . click ( ) ; tfillNewProject ( bot , " ProjectFromWelcomePageLink " ) ; tassertProjectExists ( bot , " ProjectFromWelcomePageLink " ) ; } 
public void beforeTest ( ) { topenJavaPerspective ( bot ) ; tassertEquals ( " Java " , bot . activePerspective ( ) . getLabel ( ) ) ; } 
public void run ( IProgressMonitor monitor ) throws CoreException { } } 
public static void setupClass ( ) throws Exception { tSWTBotPreferences . TIMEOUT = 30000 ; tbot = eclipseBot ( ) ; } 
public void run ( ) { tString selectedText = editor . getSelectedText ( ) ; if ( selectedText = = null | | selectedText . trim ( ) . equals ( " " ) ) { tselectedText = editor . getCurrentTopLevelSExpression ( ) ; } tREPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tString textToEvaluate = selectedText ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } store . setDefault ( PreferenceConstants . REPL_QUIET_LOGGING_MODE , false ) ; } 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , SyntaxColoringHelper . getBoldPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , SyntaxColoringHelper . getItalicPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , SyntaxColoringHelper . getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . toArray ( keys ) ; } 
private void doLeinAddPagesPost ( ) { tgetStartingPage ( ) . setDescription ( " Leverages Leiningen 2.0, the recommended project management tool for Clojure. " + " n(Don't wanna use Leiningen? Then simply create a maven/gradle/whatever java project, and add Clojure in its classpath) " ) ; getStartingPage ( ) . setTitle ( " Clojure project " ) ; setWindowTitle ( " New Clojure project " ) ; } 
 private void connectRepl ( ) { try { REPLView replView = REPLView . connect ( " nrepl:127.0.0.1: " + port . intValue ( ) , lastConsoleOpened , launch , makeActiveREPL ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { try { return REPLView . connect ( " nrepl:127.0.0.1: " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) , true ) ; 
private static void requireNamespaces ( List < String > namespaces ) { tfor ( String namespace : namespaces ) { tClojureOSGi . require ( CCWPlugin . getDefault ( ) . getBundle ( ) , namespace ) ; 
public static boolean isAutoReloadOnStartupSaveEnabled ( ) { treturn CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE ) ; } 
public static boolean isReplQuietLoggingMode ( ) { treturn CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . REPL_QUIET_LOGGING_MODE ) ; } 
public void evalExpression ( String s , boolean addToHistory , boolean printToLog ) { try { if ( s . trim ( ) . length ( ) > 0 ) { 
public void afterExpressionSentFromEditor ( ) { if ( ! autoRepeatLastAction . isChecked ( ) ) treturn ; tString lastREPLExpr = getLastExpressionSentFromREPL ( ) ; if ( ! StringUtils . isBlank ( lastREPLExpr ) ) { tevalExpression ( lastREPLExpr , false , false ) ; 
public boolean configure ( String url ) throws Exception { try { TODO - don't need multiple connections anymore, just separate sessions will do. 
private void createActions ( ) { tautoRepeatLastAction = new Action ( " Repeat last evaluation each time editor sends changes " , Action . AS_CHECK_BOX ) { @Override public void run ( ) { .setImageDescriptor(getImageDescriptor("repl/console.gif")); 
private void createToolbar ( ) { tIToolBarManager mgr = getViewSite ( ) . getActionBars ( ) . getToolBarManager ( ) ; tmgr . add ( autoRepeatLastAction ) ; tmgr . add ( printErrorAction ) ; tmgr . add ( interruptAction ) ; tmgr . add ( reconnectAction ) ; tmgr . add ( clearLogAction ) ; tmgr . add ( newSessionAction ) ; tmgr . add ( showConsoleAction ) ; } 
public static boolean isBlank ( String s ) { treturn s = = null | | s . trim ( ) . length ( ) = = 0 ; } 
private void registerEvalStatus ( Object evalResponse ) { tISeq responseSeq = ( ISeq ) evalResponse ; twhile ( responseSeq ! = null ) { tMap < ? , ? > m = ( Map < ? , ? > ) responseSeq . first ( ) ; if ( m . containsKey ( errorResponseKey ) ) { tlastEvalSentInError = true ; treturn ; } tresponseSeq = responseSeq . next ( ) ; } tlastEvalSentInError = false ; } 
public void afterExpressionSentFromEditor ( ) { if ( ! autoRepeatLastAction . isChecked ( ) ) treturn ; if ( lastEvalSentInError ) treturn ; tString lastREPLExpr = getLastExpressionSentFromREPL ( ) ; if ( ! StringUtils . isBlank ( lastREPLExpr ) ) { tevalExpression ( lastREPLExpr , false , false ) ; 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tIFolder classesFolder = editorFile . getProject ( ) . getFolder ( " classes " ) ; ttry { tclassesFolder . refreshLocal ( IFolder . DEPTH_INFINITE , null ) ; if ( ! classesFolder . exists ( ) ) { tclassesFolder . create ( true , true , null ) ; } } catch ( CoreException e ) { te . printStackTrace ( ) ; } tEvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , false ) ; classesFolder.refreshLocal(IFolder.DEPTH_INFINITE, null); 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tIFolder classesFolder = editorFile . getProject ( ) . getFolder ( " classes " ) ; ttry { tclassesFolder . refreshLocal ( IFolder . DEPTH_INFINITE , null ) ; if ( ! classesFolder . exists ( ) ) { tclassesFolder . create ( true , true , null ) ; } } catch ( CoreException e ) { te . printStackTrace ( ) ; } tEvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , false , true ) ; classesFolder.refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static final void evaluateText ( REPLView console , final String text , boolean userInput , boolean repeatLastREPLEvalIfActive ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void evalExpression ( String s , boolean addToHistory , boolean printToLog , boolean repeatLastREPLEvalIfActive ) { try { if ( s . trim ( ) . length ( ) > 0 ) { 
public void run ( ) { if ( hasEvalResponseException ( ret ) ) treturn ; tevalExpression ( lastREPLExpr , false , false , false ) ; } 
private boolean hasEvalResponseException ( Object evalResponse ) { tISeq responseSeq = ( ISeq ) evalResponse ; twhile ( responseSeq ! = null ) { tMap < ? , ? > m = ( Map < ? , ? > ) responseSeq . first ( ) ; if ( m . containsKey ( errorResponseKey ) ) { treturn true ; } tresponseSeq = responseSeq . next ( ) ; } treturn false ; } 
protected final void compileLoadFile ( ) { tIFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; if ( editorFile = = null ) treturn ; tString lib = editor . findDeclaringNamespace ( ) ; if ( lib = = null | | lib . trim ( ) . equals ( " " ) ) { tString title = " Compilation impossible " ; tString message = " The file " + editorFile . getName ( ) + " cannot be compiled because it does not declare a namespace. " ; tMessageDialog . openError ( editor . getSite ( ) . getShell ( ) , title , message ) ; treturn ; } tIFolder classesFolder = editorFile . getProject ( ) . getFolder ( " classes " ) ; ttry { tclassesFolder . refreshLocal ( IFolder . DEPTH_INFINITE , null ) ; if ( ! classesFolder . exists ( ) ) { tclassesFolder . create ( true , true , null ) ; } } catch ( CoreException e ) { te . printStackTrace ( ) ; } tEvaluateTextUtil . evaluateText ( editor . getCorrespondingREPL ( ) , compileLibCommand ( lib ) , true ) ; classesFolder.refreshLocal(IFolder.DEPTH_INFINITE, null); 
public static final void evaluateText ( REPLView console , final String text , boolean repeatLastREPLEvalIfActive ) { if ( console = = null | | console . isDisposed ( ) ) { DisplayUtil . syncExec ( new Runnable ( ) { 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , 
public IAutoEditStrategy [ ] getAutoEditStrategies ( tISourceViewer sourceViewer , final String contentType ) { treturn new IAutoEditStrategy [ ] { tnew PareditAutoEditStrategy ( editor , fPreferenceStore ) , 
public void customizeDocumentCommand ( IDocument document , tDocumentCommand command ) { tpareditAutoAdjustWhitespacetrategyImpl . _ ( " customizeDocumentCommand " , tthis , document , command ) ; 
public void createFieldEditors ( ) { taddField ( tnew BooleanFieldEditor ( tccw . preferences . PreferenceConstants . EXPERIMENTAL_AUTOSHIFT_ENABLED , " EXPERIMENTAL - Editor text Autoshift ('fix indentation as you type') " , tgetFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( PreferenceConstants . EDITOR_MATCHING_BRACKETS , Messages . ClojurePreferencePage_highlight_matching_brackets , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , Messages . ClojurePreferencePage_displayed_tab_width , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , Messages . ClojurePreferencePage_switch_to_ns_on_repl_startup , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , Messages . ClojurePreferencePage_use_strict_structural_editing_mode_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , Messages . ClojurePreferencePage_show_rainbow_parens_by_default , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , Messages . ClojurePreferencePage_escape_on_paste , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , Messages . ClojurePreferencePage_use_tab_for_reindenting_line , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . FORCE_TWO_SPACES_INDENT , Messages . ClojurePreferencePage_force_two_spaces_indent , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , Messages . ClojurePreferencePage_code_completion_auto_activate , getFieldEditorParent ( ) ) ) ; addField ( tnew BooleanFieldEditor ( ccw . preferences . PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , Messages . ClojurePreferencePage_show_more_context_in_tabs , getFieldEditorParent ( ) ) ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { if ( isLeiningenConfiguration ( configuration ) ) { String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
private static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) throws CoreException { treturn configuration . getAttribute ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , true ) ; } 
public String getMainTypeName ( ILaunchConfiguration configuration ) tthrows CoreException { if ( isLeiningenConfiguration ( configuration ) ) { } 
public void launchProject ( IProject project , String mode ) { tlaunchProjectCheckRunning ( project , new IFile [ ] { } , mode ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; if ( running . size ( ) = = 0 ) { tlaunchProject ( project , filesToLaunch , mode ) ; 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { tBoolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; try { tILaunchConfiguration config ; 
public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { tLaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; tBoolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( activateAutoReload ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public String [ ] getEnvironment ( ILaunchConfiguration configuration ) tthrows CoreException { tString [ ] ret ; tString [ ] superEnv = super . getEnvironment ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { if ( superEnv ! = null ) { tret = new String [ superEnv . length + 1 ] ; tSystem . arraycopy ( superEnv , 0 , ret , 1 , superEnv . length ) ; } else { tret = new String [ 1 ] ; } tret [ 0 ] = " LEIN_REPL_ACK_PORT " + " = " + CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ; } else { tret = superEnv ; } treturn ret ; } 
public static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) throws CoreException { treturn configuration . getAttribute ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , true ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { try { tILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project ) { tclojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) tleiningenConfiguration . _ ( " lein-launch-configuration " , project , " update-in :dependencies conj \" [ccw/ccw-server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " type-id " ) , Keyword . intern ( " ccw " ) ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , true ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " private " ) , false ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " launch-in-background " ) , false ) ; treturn ( ILaunchConfiguration ) tlaunch . _ ( " launch-configuration " , 
protected ILaunchConfiguration chooseConfiguration ( final List configList ) { tfinal AtomicReference < ILaunchConfiguration > ret = new AtomicReference < ILaunchConfiguration > ( ) ; tDisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { IDebugModelPresentation labelProvider = null ; ttry { tlabelProvider = DebugUITools . newDebugModelPresentation ( ) ; ElementListSelectionDialog dialog = new ElementListSelectionDialog ( JDIDebugUIPlugin . getActiveWorkbenchShell ( ) , labelProvider ) ; dialog . setElements ( configList . toArray ( ) ) ; dialog . setTitle ( " Choose a Clojure launch configuration " ) ; dialog . setMessage ( LauncherMessages . JavaLaunchShortcut_2 ) ; dialog . setMultipleSelection ( false ) ; dialog . setAllowDuplicates ( true ) ; int result = dialog . open ( ) ; if ( result = = Window . OK ) { tret . set ( ( ILaunchConfiguration ) dialog . getFirstResult ( ) ) ; } } finally { if ( labelProvider ! = null ) { tlabelProvider . dispose ( ) ; } } } } ) ; treturn ret . get ( ) ; } 
public void run ( ) { IDebugModelPresentation labelProvider = null ; ttry { tlabelProvider = DebugUITools . newDebugModelPresentation ( ) ; 
public void initializeFrom ( ILaunchConfiguration config ) { super . initializeFrom ( config ) ; try { tinstallREPLChoice . setSelection ( config . getAttribute ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ) ; } catch ( CoreException e ) { tCCWPlugin . logError ( " error while initializing serverPort " , e ) ; tinstallREPLChoice . setSelection ( true ) ; } try { tsourceFilesViewer . setInput ( LaunchUtils . getFilesToLaunchList ( config ) ) ; 
public static boolean isEmpty ( String s ) { treturn s = = null | | s . length ( ) = = 0 ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; if ( running . size ( ) = = 0 ) { tlaunchProject ( project , filesToLaunch , mode ) ; 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { try { tILaunchConfiguration config = findLaunchConfiguration ( project ) ; 
protected ILaunchConfiguration createConfiguration ( IProject project , IFile [ ] files ) { if ( files = = null ) files = new IFile [ ] { } ; try { ILaunchManager lm = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; 
protected ILaunchConfiguration chooseConfiguration ( final List < ILaunchConfiguration > configList ) { tfinal AtomicReference < ILaunchConfiguration > ret = new AtomicReference < ILaunchConfiguration > ( ) ; tDisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { IDebugModelPresentation labelProvider = null ; ttry { tlabelProvider = DebugUITools . newDebugModelPresentation ( ) ; ElementListSelectionDialog dialog = new ElementListSelectionDialog ( JDIDebugUIPlugin . getActiveWorkbenchShell ( ) , labelProvider ) ; dialog . setElements ( configList . toArray ( ) ) ; dialog . setTitle ( " Choose a Clojure launch configuration " ) ; dialog . setMessage ( LauncherMessages . JavaLaunchShortcut_2 ) ; dialog . setMultipleSelection ( false ) ; dialog . setAllowDuplicates ( true ) ; int result = dialog . open ( ) ; if ( result = = Window . OK ) { tret . set ( ( ILaunchConfiguration ) dialog . getFirstResult ( ) ) ; } } finally { if ( labelProvider ! = null ) { tlabelProvider . dispose ( ) ; } } } } ) ; treturn ret . get ( ) ; } 
public static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) throws CoreException { treturn configuration . getAttribute ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , false ) ; } 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project ) { tclojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) tleiningenConfiguration . _ ( " lein-launch-configuration " , project , " update-in :dependencies conj \" [ccw/ccw-server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " type-id " ) , Keyword . intern ( " ccw " ) ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen " ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , true ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " private " ) , false ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " launch-in-background " ) , false ) ; treturn ( ILaunchConfiguration ) tlaunch . _ ( " launch-configuration " , 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project ) { tclojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) tleiningenConfiguration . _ ( " lein-launch-configuration " , project , " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " type-id " ) , Keyword . intern ( " ccw " ) ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen " ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , true ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " private " ) , false ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " launch-in-background " ) , false ) ; treturn ( ILaunchConfiguration ) tlaunch . _ ( " launch-configuration " , 
public static boolean isLeiningenConfiguration ( ILaunchConfiguration configuration ) throws CoreException { treturn false ; return configuration.getAttribute(LaunchUtils.ATTR_LEININGEN_CONFIGURATION, false); 
private boolean useLeiningenLaunchConfiguration ( IProject project ) throws CoreException { treturn false ; return project.hasNature(CCWPlugin.LEININGEN_NATURE_ID); 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; tSystem . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
public void trace ( String traceOption , Object . . . message ) { if ( debugTrace ! = null ) debugTrace . trace ( " / " + traceOption , buildMessage ( message ) ) ; tSystem . out . println ( traceOption + " : " + buildMessage ( message ) ) ; if ( isEnabled ( traceOption ) ) { debugTrace . trace ( " / " + traceOption , buildMessage ( message ) ) ; 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { if ( debugTrace ! = null ) debugTrace . trace ( " / " + traceOption , buildMessage ( message ) , throwable ) ; tSystem . out . println ( traceOption + " : " + buildMessage ( message ) + " . Exception: " + throwable . getMessage ( ) ) ; tthrowable . printStackTrace ( ) ; if ( isEnabled ( traceOption ) ) { debugTrace . trace ( " / " + traceOption , buildMessage ( message ) , throwable ) ; 
public void traceDumpStack ( String traceOption ) { if ( debugTrace ! = null ) debugTrace . traceDumpStack ( " / " + traceOption ) ; System . out . println ( " trace dump stack: " + traceOption ) ; if ( isEnabled ( traceOption ) ) { debugTrace . traceDumpStack ( " / " + traceOption ) ; 
public void traceEntry ( String traceOption ) { if ( debugTrace ! = null ) tdebugTrace . traceEntry ( " / " + traceOption ) ; tSystem . out . println ( " trace entry: " + traceOption ) ; if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( " / " + traceOption ) ; 
public void traceEntry ( String traceOption , Object . . . arguments ) { if ( debugTrace ! = null ) tdebugTrace . traceEntry ( " / " + traceOption , arguments ) ; tSystem . out . print ( " trace entry: " + traceOption ) ; if ( arguments ! = null ) { tSystem . out . print ( " [ " ) ; tboolean isFirst = true ; tfor ( Object o : arguments ) { tSystem . out . println ( o ) ; if ( isFirst ) { tisFirst = false ; } else { tSystem . out . println ( " , " ) ; } } tSystem . out . print ( " ] " ) ; } tSystem . out . println ( ) ; if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( " / " + traceOption , arguments ) ; 
public void traceExit ( String traceOption ) { if ( debugTrace ! = null ) tdebugTrace . traceExit ( " / " + traceOption ) ; tSystem . out . println ( " trace exit: " + traceOption ) ; if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( " / " + traceOption ) ; 
public void traceExit ( String traceOption , Object returnValue ) { if ( debugTrace ! = null ) debugTrace . traceExit ( " / " + traceOption , returnValue ) ; tSystem . out . print ( " trace entry: " + traceOption ) ; if ( returnValue ! = null ) { tSystem . out . print ( " [ " + returnValue + " ] " ) ; } tSystem . out . println ( ) ; if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( " / " + traceOption , returnValue ) ; 
public void startUserPlugins ( final MApplication app , final EModelService modelService , tfinal IEventBroker eventBroker ) throws CoreException { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . LOG_INFO , " CCW Model Processor called. " ) ; teventBroker . subscribe ( UIEvents . UILifeCycle . APP_STARTUP_COMPLETE , tnew EventHandler ( ) { 
public void handleEvent ( Event event ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . LOG_INFO , " App startup complete, launching user plugins " ) ; ttry { tBundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; 
public Object create ( final Bundle bundle , final String varAndParams , tfinal IEclipseContext context ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . LOG_INFO , " create object for bundleclass: " + bundle . getSymbolicName ( ) + " / " + " clojure " + " / " + varAndParams ) ; ttry { tfinal String [ ] parts = varAndParams . split ( " \\ / " ) ; 
public Object run ( ) throws Exception { tswitch ( parts . length ) { tcase 2 : return v . invoke ( context ) ; 
public Object call ( Object object , String methodName , tIEclipseContext context , Object defaultValue ) { tthrow new UnsupportedOperationException ( " call for object " + object + " , methodName " + methodName + " , context " + context + " , defaultValue " + defaultValue ) ; } 
public void execute ( IEclipseContext context ) throws CoreException { if ( var = = null ) { var = BundleUtils . requireAndGetVar ( " ccw.core " , varName ) ; } tvar . invoke ( context ) ; } 
public Object _ ( final String varName ) { treturn ClojureUtils . invoke ( namespace , varName ) ; } 
public static ClojureInvoker newInvoker ( Plugin plugin , final String namespace ) { treturn newInvoker ( plugin . getBundle ( ) , namespace ) ; } 
public static ClojureInvoker newInvoker ( Bundle bundle , final String namespace ) { ttry { tClojureOSGi . require ( bundle , namespace ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; tCCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { tSystem . out . println ( " ======= ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; tSystem . out . flush ( ) ; } tClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) tthrows RuntimeException { treturn withBundle ( aBundle , aCode , null ) ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) tthrows RuntimeException { tinitialize ( ) ; tClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; tfinal URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . toArray ( new URL [ additionalURLs . size ( ) ] ) ; tURLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public Object run ( ) throws Exception { ttry { tRT . var ( " clojure.core " , " require " ) . invoke ( Symbol . intern ( namespace ) ) ; 
public void trace ( String traceOption , Object . . . message ) { tSystem . out . println ( " trace: " + traceOption + " , message: " + Tracer . buildMessage ( message ) ) ; 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { tSystem . out . println ( " trace: " + traceOption + " , message: " + Tracer . buildMessage ( message ) ) ; tthrowable . printStackTrace ( ) ; } 
public void traceDumpStack ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceDumpStack: " + traceOption ) ; 
public void traceEntry ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceEntry: " + traceOption ) ; 
public void traceEntry ( String traceOption , Object . . . arguments ) { ttry { tthrow new RuntimeException ( " traceEntry: " + traceOption 
public void traceExit ( String traceOption ) { ttry { tthrow new RuntimeException ( " traceExit: " + traceOption ) ; 
public void traceExit ( String traceOption , Object returnValue ) { ttry { tthrow new RuntimeException ( " traceExit: " + traceOption 
public void run ( ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { teditor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; treturn ; } final String sourcePath = computeSourcePath ( editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tevaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
 public void run ( ) { tREPLView repl = CCWPlugin . getDefault ( ) . getProjectREPL ( project ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tevaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
private String computeFilePath ( final IFile editorFile ) { tString filePath ; if ( editorFile ! = null ) { tfilePath = editorFile . getLocation ( ) . toOSString ( ) ; } else { tFileStoreEditorInput fei = ( FileStoreEditorInput ) editor . getEditorInput ( ) ; tIPath path = URIUtil . toPath ( fei . getURI ( ) ) ; if ( path ! = null ) { tfilePath = path . toOSString ( ) ; } else { tfilePath = null ; } } treturn filePath ; } 
public void execute ( final IEclipseContext context ) throws CoreException { if ( var = = null ) { var = BundleUtils . requireAndGetVar ( " ccw.core " , varName ) ; } tClojureOSGi . withBundle ( CCWPlugin . getDefault ( ) . getBundle ( ) , tnew RunnableWithException ( ) { 
@Override public Object run ( ) throws Exception { tvar . invoke ( context ) ; treturn null ; } 
public static void connectToEclipseNREPL ( ) throws ExecutionException { tnew ConnectToEclipseNREPL ( ) . execute ( null ) ; } 
public void addPages ( ) { tsuper . addPages ( ) ; tmainPage = new WizardNewLeiningenProjectTemplatePage ( this , " basicNewProjectPage " ) ; tthis . addPage ( mainPage ) ; tdoLeinAddPagesPost ( ) ; } 
private boolean newProjectWizardPerformFinish ( ) { tcreateNewProject ( ) ; if ( newProject = = null ) { treturn false ; } } 
public void createControl ( Composite parent ) { Composite composite = new Composite ( parent , SWT . NULL ) ; initializeDialogUnits ( parent ) ; PlatformUI . getWorkbench ( ) . getHelpSystem ( ) . setHelp ( composite , IIDEHelpContextIds . NEW_PROJECT_WIZARD_PAGE ) ; FormLayout layout = new FormLayout ( ) ; tcomposite . setLayout ( layout ) ; composite . setLayoutData ( new GridData ( GridData . FILL_HORIZONTAL ) ) ; Composite projectGroup = createProjectNameGroup ( composite ) ; FormData projectLayoutData = new FormData ( ) ; tprojectGroup . setLayoutData ( projectLayoutData ) ; tComposite createInGroup = createCreateInGroup ( composite ) ; tFormData createInLayoutData = new FormData ( ) ; createInLayoutData . top = new FormAttachment ( projectGroup ) ; createInLayoutData . left = new FormAttachment ( 0 , 0 ) ; createInLayoutData . right = new FormAttachment ( 100 , 0 ) ; tcreateInGroup . setLayoutData ( createInLayoutData ) ; Composite leinTemplateGroup = createLeinTemplateGroup ( composite ) ; FormData leinTemplateLayoutData = new FormData ( ) ; leinTemplateLayoutData . top = new FormAttachment ( createInGroup ) ; leinTemplateLayoutData . left = new FormAttachment ( 0 , 0 ) ; leinTemplateLayoutData . right = new FormAttachment ( 100 , 0 ) ; leinTemplateGroup . setLayoutData ( leinTemplateLayoutData ) ; setPageComplete ( validatePage ( ) ) ; } 
@Override public void modifyText ( ModifyEvent e ) { tsetPageComplete ( validatePage ( ) ) ; } 
@Override public void widgetDefaultSelected ( SelectionEvent e ) { twidgetSelected ( e ) ; } 
@Override public void widgetSelected ( SelectionEvent e ) { tDirectoryDialog dialog = new DirectoryDialog ( browse . getShell ( ) , SWT . NONE ) ; tdialog . setText ( " Choose Project parent directory " ) ; tdialog . setMessage ( " Select a parent directory within with the project's directory will be created " ) ; tdialog . setFilterPath ( locationText . getText ( ) ) ; tString result = dialog . open ( ) ; if ( result ! = null ) { tlocationText . setText ( result ) ; 
public void handleEvent ( Event e ) { setPageComplete ( validatePage ( ) ) ; } 
private final Composite createProjectNameGroup ( Composite parent ) { project specification group Composite projectGroup = new Composite(parent, SWT.NONE); GridLayout layout = new GridLayout(); layout.numColumns = 2; projectGroup.setLayout(layout); new project label Label projectLabel = new Label(projectGroup, SWT.NONE); projectLabel.setText(IDEWorkbenchMessages.WizardNewProjectCreationPage_nameLabel); projectLabel.setFont(parent.getFont()); new project name entry field projectNameText = new Text(projectGroup, SWT.BORDER); GridData data = new GridData(GridData.FILL_HORIZONTAL); data.widthHint = SIZING_TEXT_FIELD_WIDTH; projectNameText.setLayoutData(data); projectNameText.setFont(parent.getFont()); projectNameText.addListener(SWT.Modify, nameModifyListener); BidiUtils.applyBidiProcessing(projectNameText, BidiUtils.BTD_DEFAULT); return projectGroup; } 
public Composite createLeinTemplateGroup ( Composite parent ) { tComposite projectGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; tprojectGroup . setLayout ( layout ) ; tLabel projectLabel = new Label ( projectGroup , SWT . NONE ) ; tprojectLabel . setText ( " Leiningen template: " ) ; tprojectLabel . setFont ( parent . getFont ( ) ) ; ttemplateNameText = new Text ( projectGroup , SWT . BORDER ) ; tGridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; tdata . widthHint = SIZING_TEXT_FIELD_WIDTH ; ttemplateNameText . setLayoutData ( data ) ; ttemplateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { ttemplateNameText . setText ( initialTemplateNameTextValue ) ; } ttemplateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; treturn projectGroup ; } 
public String computeTemplateName ( ) { tString fieldValue = getTemplateNameFieldValue ( ) ; if ( fieldValue = = null | | fieldValue . equals ( " " ) ) { treturn initialTemplateNameTextValue ; } treturn fieldValue ; } 
public String checkValidLocation ( IProject project , boolean isDefaultParentLocation , String projectParentLocation , String projectFolderName ) { if ( projectParentLocation = = null | | projectParentLocation . trim ( ) . equals ( " " ) ) { treturn " A location to create the project folder in must be specified " ; } tFile parentFolder = new File ( projectParentLocation ) ; if ( ! parentFolder . exists ( ) ) { treturn " Parent folder ' " + projectParentLocation + " ' does not exist " ; } tFile file = new File ( parentFolder , projectFolderName ) ; tURI uri = file . toURI ( ) ; if ( uri = = null ) { treturn IDEWorkbenchMessages . ProjectLocationSelectionDialog_locationError ; } if ( file . exists ( ) ) { treturn " Cannot create a project at an existing location ( " + file . getAbsolutePath ( ) + " ) " ; } tIStatus locationStatus = ResourcesPlugin . getWorkspace ( ) . validateProjectLocationURI ( project , } 
public boolean useDefaultProjectParentLocation ( ) { treturn defaultLocationCheckbox . getSelection ( ) ; } 
public boolean isPageComplete ( ) { return super.isPageComplete(); } 
public SafeConnection getProjectREPLSafeConnection ( IProject project ) { REPLView repl = getProjectREPL ( project ) ; return repl = = null ? null : repl . getSafeToolingConnection ( ) ; } 
public void visit ( Map < IFolder , IFolder > srcFolders ) throws CoreException { tthis . srcFolders = new HashMap < IFolder , IFolder > ( srcFolders ) ; for ( Map . Entry < IFolder , IFolder > srcFolderEntry : srcFolders . entrySet ( ) ) { tsetSrcFolder ( srcFolderEntry ) ; srcFolderEntry . getKey ( ) . accept ( this ) ; } if ( replConnection ! = null ) { try { 
@Override public < T > T withConnection ( Connection c ) { tfor ( String maybeLib 
private void runTests ( String lib , SafeConnection repl ) throws Exception { Response results = repl . send ( 15000 , " op " , " eval " , " code " , runTestsCommand ( lib ) ) ; if ( ( ( String ) results . combinedResponse ( ) . get ( Keyword . intern ( " out " ) ) ) . contains ( " :fail 0, :error 0 " ) ) { editor . setStatusLineErrorMessage ( ClojureEditorMessages . Tests_passed ) ; 
private Map < String , List < String > > getRemoteNsTree ( SafeConnection repl ) { ttry { Response res = repl . send ( 10000 , " op " , " eval " , " code " , " (ccw.debug.serverrepl/namespaces-info) " ) ; 
public static void setREPLConnection ( final SafeConnection repl ) { if ( repl ! = null ) DisplayUtil . asyncExec ( new Runnable ( ) { 
private static void inUIThreadSetREPLConnection ( SafeConnection repl ) { tIWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; treturn ; } tIWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activePage is null " ) ; } tIViewPart [ ] views = activePage . getViews ( ) ; tNamespaceBrowser co = null ; tfor ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { tco = ( NamespaceBrowser ) v ; tbreak ; } } if ( co = = null ) { treturn ; } tco . reset ( repl ) ; } 
public void closeConnections ( ) throws Exception { if ( interactive ! = null ) interactive . close ( ) ; if ( safeToolConnection ! = null ) safeToolConnection . close ( ) ; } 
public void setCurrentNamespace ( String ns ) { @Override public void run() { 
@Override public void run ( ) { tsetPartName ( String . format ( " REPL @ %s (%s) " , interactive . url , currentNamespace ) ) ; } } ) ; 
@Override public void run ( ) { tlogPanel . append ( " ;; Clojure " + clojureVersion + " " ) ; } 
public static REPLView connect ( final String url , IConsole console , ILaunch launch , final boolean makeActiveREPL ) throws Exception { String secondaryId ; final REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . showConsoleAction . setEnabled ( console ! = null ) ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public Set < String > getAvailableOperations ( ) throws IllegalStateException { if ( describeInfo = = null ) { ttry { Response r = safeToolConnection . send ( 10000 , " op " , " describe " ) ; } } Map<String, Object> ops = (Map<String, Object>)describeInfo.get("ops"); return ops == null ? new HashSet() : ops.keySet(); } 
private SafeConnection getCorrespondingREPLConnection ( ) { we'll be connected by the time this is called return safeToolConnection; } 
public void focusGained ( FocusEvent e ) { tgetTracer ( ) . trace ( TraceOptions . REPL_FOCUS , " focus gained, marking repl as active " ) ; activeREPL . set ( REPLView . this ) ; NamespaceBrowser . setREPLConnection ( safeToolConnection ) ; } 
public < T > T withConnection ( final IConnectionClient client , long imeoutMillis ) tthrows InterruptedException , java . util . concurrent . ExecutionException , TimeoutException { Future < T > future = toolConnectionExecutor . submit ( new Callable < T > ( ) { @Override public T call ( ) throws Exception { treturn client . withConnection ( connection ) ; } } ) ; return future . get ( imeoutMillis , TimeUnit . MILLISECONDS ) ; } 
@Override public T call ( ) throws Exception { treturn client . withConnection ( connection ) ; } 
public Connection . Response send ( long imeoutMillis , final String . . . args ) tthrows InterruptedException , ExecutionException , TimeoutException { treturn withConnection ( new IConnectionClient ( ) { @Override public Connection . Response withConnection ( Connection c ) { 
@Override public Connection . Response withConnection ( Connection c ) { treturn c . send ( args ) ; } 
public void close ( ) { ttoolConnectionExecutor . execute ( new Runnable ( ) { @Override public void run ( ) { 
public void handleEvent ( Event e ) { } 
public Composite createLeinTemplateGroup ( Composite parent ) { tComposite leinTemplateGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; tleinTemplateGroup . setLayout ( layout ) ; tLabel projectLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; tprojectLabel . setText ( " Leiningen template: " ) ; tprojectLabel . setFont ( parent . getFont ( ) ) ; ttemplateNameText = new Text ( leinTemplateGroup , SWT . BORDER ) ; tGridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; tdata . widthHint = SIZING_TEXT_FIELD_WIDTH ; ttemplateNameText . setLayoutData ( data ) ; ttemplateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { ttemplateNameText . setText ( initialTemplateNameTextValue ) ; } ttemplateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; treturn leinTemplateGroup ; } 
public String computeTemplateName ( ) { tString fieldValue = getSafeTemplateNameFieldValue ( ) ; if ( fieldValue = = null | | fieldValue . trim ( ) . equals ( " " ) ) { treturn initialTemplateNameTextValue ; 
private final Composite createProjectNameGroup ( Composite parent ) { project specification group Composite projectGroup = new Composite(parent, SWT.NONE); GridLayout layout = new GridLayout(); layout.numColumns = 2; projectGroup.setLayout(layout); new project label Label projectLabel = new Label(projectGroup, SWT.NONE); projectLabel.setText(IDEWorkbenchMessages.WizardNewProjectCreationPage_nameLabel); projectLabel.setFont(parent.getFont()); new project name entry field projectNameText = new Text(projectGroup, SWT.BORDER); GridData data = new GridData(GridData.FILL_HORIZONTAL); data.widthHint = SIZING_TEXT_FIELD_WIDTH; projectNameText.setLayoutData(data); projectNameText.setFont(parent.getFont()); projectNameText.addListener(SWT.Modify, nameModifyListener); Not working with Indigo BidiUtils.applyBidiProcessing(projectNameText, BidiUtils.BTD_DEFAULT); return projectGroup; } 
protected void createActions ( ) { tsuper . createActions ( ) ; 
public void run ( ) { tnew ClojureLaunchShortcut ( ) . launch ( ClojureEditor . this , ILaunchManager . DEBUG_MODE ) ; } ; 
public static void run ( final ClojureEditor editor , final String mode ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editor , editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { teditor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; treturn ; } final String sourcePath = computeSourcePath ( editor , editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tevaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
public void run ( ) { tfinal IProject project = editorFile . getProject ( ) ; tnew ClojureLaunchShortcut ( ) . launchProject ( project , mode ) ; tDisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
private static String computeFilePath ( final ClojureEditor editor , final IFile editorFile ) { tString filePath ; if ( editorFile ! = null ) { tfilePath = editorFile . getLocation ( ) . toOSString ( ) ; } else { tFileStoreEditorInput fei = ( FileStoreEditorInput ) editor . getEditorInput ( ) ; tIPath path = URIUtil . toPath ( fei . getURI ( ) ) ; if ( path ! = null ) { tfilePath = path . toOSString ( ) ; } else { tfilePath = null ; } } treturn filePath ; } 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; if ( filesToLaunch . size ( ) > 0 ) { tint headlessReplOffset = superProgramArguments . indexOf ( " repl :headless " ) ; tString arguments = superProgramArguments . substring ( 0 , headlessReplOffset ) + " " + createFileLoadInjections ( filesToLaunch ) + " -- " + superProgramArguments . substring ( headlessReplOffset ) ; treturn arguments ; } else { treturn superProgramArguments ; } } tString userProgramArguments = superProgramArguments ; if ( isLaunchREPL ( configuration ) ) { tString filesToLaunchArguments = LaunchUtils . getFilesToLaunchAsCommandLineList ( configuration , false ) ; 
private String createFileLoadInjections ( List < IFile > filesToLaunch ) { tassert filesToLaunch . size ( ) > 0 ; tStringBuilder sb = new StringBuilder ( ) ; tsb . append ( " update-in :injections conj \" " ) ; tfor ( IFile file : filesToLaunch ) { } 
public void launch ( IEditorPart editor , String mode ) { if ( editor instanceof ClojureEditor ) { tLoadFileAction . run ( ( ClojureEditor ) editor , mode ) ; 
private boolean useLeiningenLaunchConfiguration ( IProject project ) throws CoreException { treturn project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { try { tILaunchConfiguration config ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { tString command = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ; if ( createInDebugMode ) { tcommand = " update-in :jvm-opts concat \" [ \\ \" -Xdebug \\ \" \\ \" -Xrunjdwp:transport=dt_socket,server=y,suspend=n \\ \" ] \" -- " + command ; } tclojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) tleiningenConfiguration . _ ( " lein-launch-configuration " , project , command ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " type-id " ) , Keyword . intern ( " ccw " ) ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen VM " ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , true ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " private " ) , true ) ; treturn ( ILaunchConfiguration ) tlaunch . _ ( " launch-configuration " , configMap ) ; 
public synchronized void startREPLServer ( ) { if ( ackREPLServer = = null ) { try { 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { tString command = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.0 \\ \" ] \" -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" -- repl :headless " ; if ( createInDebugMode ) { tcommand = " update-in :jvm-opts concat \" [ \\ \" -Xdebug \\ \" \\ \" -Xrunjdwp:transport=dt_socket,server=y,suspend=n \\ \" ] \" -- " + command ; } tclojure . lang . IPersistentMap configMap = ( clojure . lang . IPersistentMap ) tleiningenConfiguration . _ ( " lein-launch-configuration " , project , command ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " type-id " ) , Keyword . intern ( " ccw " ) ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " name " ) , project . getName ( ) + " Leiningen VM " ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_CLOJURE_START_REPL , true ) ; tconfigMap = configMap . assoc ( LaunchUtils . ATTR_LEININGEN_CONFIGURATION , true ) ; tconfigMap = configMap . assoc ( Keyword . intern ( " private " ) , true ) ; launch._("launch-configuration", configMap); 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { tString command = launch._("launch-configuration", configMap); 
protected void createActions ( ) { tsuper . createActions ( ) ; 
public void run ( ) { ClojureEditor.this, 
public void launchProject ( IProject project , String runMode ) { trunMode = ( runMode ! = null ) ? runMode : getDefaultRunMode ( ) ; tlaunchProjectCheckRunning ( project , new IFile [ ] { } , runMode ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode ) { tassert mode ! = null ; tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; tSystem . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void launchProject ( IProject project , String runMode ) { tlaunchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) ) ; } 
private boolean useLeiningenLaunchConfiguration ( IProject project ) throws CoreException { treturn project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) & & getPreferences ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER ) ; } 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode ) { tmode = getRunMode ( mode ) ; try { tILaunchConfiguration config ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
 public void run ( ) { tREPLView repl = CCWPlugin . getProjectREPL ( project ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tevaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; tfinal Object replURLPromise = ClojureLaunchShortcut . launchNameREPLURLPromise . get ( launchName ) ; if ( replURLPromise = = null ) { tCCWPlugin . log ( " No REPL required for launch " + launchName ) ; 
@Override public void run ( ) { tIFn realized = Clojure . var ( " clojure.core " , " realized? " ) ; twhile ( true ) { if ( ( Boolean ) realized . invoke ( replURLPromise ) ) { 
private void connectRepl ( final String replURL ) { tDisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { ttry { tREPLView replView = REPLView . connect ( replURL , lastConsoleOpened , launch , makeActiveREPL ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , final ILaunch launch , IProgressMonitor monitor ) throws CoreException { tLaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; tBoolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( activateAutoReload ) ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
public void launch ( final IEditorPart editor , final String mode ) { if ( editor instanceof ClojureEditor ) { a new thread ensures we're not in the UI thread 
@Override public void run ( ) { tLoadFileAction . run ( ( ClojureEditor ) editor , mode ) ; } } ) . start ( ) ; 
public void launch ( ISelection selection , final String mode ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; 
@Override public void run ( ) { tlaunchProjectCheckRunning ( theProj , files . toArray ( new IFile [ ] { } ) , mode ) ; } 
public void launchProject ( final IProject project , final String runMode ) { @Override public void run() { 
@Override public void run ( ) { tlaunchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) ) ; } 
private Object promise ( ) { tIFn promise = clojure . java . api . Clojure . var ( " clojure.core " , " promise " ) ; treturn promise . invoke ( ) ; } 
public void run ( final REPLView repl ) { if ( repl ! = null & & ! repl . isDisposed ( ) ) { tevaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; tfinal Pair < Object , IWithREPLView > o = ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . get ( launchName ) ; tfinal Object replURLPromise = o . e1 ; if ( replURLPromise = = null ) { tCCWPlugin . log ( " No REPL required for launch " + launchName ) ; 
private void syncConnectRepl ( final String replURL , final IWithREPLView withREPLView ) { tDisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { tlaunchProjectCheckRunning ( theProj , files . toArray ( new IFile [ ] { } ) , mode , null ) ; } 
public void launchProject ( final IProject project , final String runMode , final IWithREPLView runOnceREPLAvailable ) { @Override public void run() { 
@Override public void run ( ) { tlaunchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) , runOnceREPLAvailable ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode , IWithREPLView runOnceREPLAvailable ) { tassert mode ! = null ; tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; tSystem . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode , IWithREPLView runOnceREPLAvailable ) { tmode = getRunMode ( mode ) ; try { tILaunchConfiguration config ; 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { tfor ( IProject project : projects ) { ttry { if ( isCandidateClojureProject ( project ) ) { tToggleNatureCommand . toggleNature ( project , true ) ; } } catch ( Exception e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , te ) ; } } treturn Status . OK_STATUS ; } 
private boolean isCandidateClojureProject ( IProject project ) { ttry { tboolean maybeCandidate = project . exists ( ) 
private void addClojureNature ( final IProject project ) { taddClojureNature ( new IProject [ ] { project } ) ; } 
private void addClojureNature ( final IProject [ ] projects ) { if ( projects . length ! = 0 ) { tWorkspaceJob job = new ClojureNatureAdderWorkspaceJob ( projects ) ; 
public void performFullScan ( ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) treturn ; tIWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; taddClojureNature ( workspaceRoot . getProjects ( ) ) ; } 
public static void run ( final ClojureEditor editor , final String mode , boolean forceLeinLaunchWhenPossible ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editor , editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { teditor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; treturn ; } final String sourcePath = computeSourcePath ( editor , editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { tevaluateFileText ( repl , editor . getDocument ( ) . get ( ) , filePath , sourcePath , fileName ) ; 
public void launch ( final IEditorPart editor , final String mode ) { tlaunch ( editor , mode , false ) ; } 
public void launch ( final IEditorPart editor , final String mode , final boolean forceLeinLaunchWhenPossible ) { if ( editor instanceof ClojureEditor ) { a new thread ensures we're not in the UI thread 
@Override public void run ( ) { tLoadFileAction . run ( ( ClojureEditor ) editor , mode , forceLeinLaunchWhenPossible ) ; } } ) . start ( ) ; 
public void launch ( ISelection selection , final String mode ) { tlaunch ( selection , mode , false ) ; } 
public void launch ( ISelection selection , final String mode , final boolean forceLeinLaunchWhenPossible ) { if ( selection instanceof IStructuredSelection ) { IStructuredSelection strSel = ( IStructuredSelection ) selection ; 
@Override public void run ( ) { tlaunchProjectCheckRunning ( theProj , files . toArray ( new IFile [ ] { } ) , mode , forceLeinLaunchWhenPossible , null ) ; } 
public void launchProject ( final IProject project , final String runMode , final boolean forceLeinLaunchWhenPossible , final IWithREPLView runOnceREPLAvailable ) { @Override public void run() { 
@Override public void run ( ) { tlaunchProjectCheckRunning ( project , new IFile [ ] { } , getRunMode ( runMode ) , forceLeinLaunchWhenPossible , runOnceREPLAvailable ) ; } 
protected void launchProjectCheckRunning ( IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , IWithREPLView runOnceREPLAvailable ) { tassert mode ! = null ; tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; tSystem . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
private boolean useLeiningenLaunchConfiguration ( IProject project , tboolean forceLeinLaunchWhenPossible ) throws CoreException { treturn project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) & & ( forceLeinLaunchWhenPossible 
protected void launchProject ( IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , IWithREPLView runOnceREPLAvailable ) { tmode = getRunMode ( mode ) ; try { tILaunchConfiguration config ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { tString command = launch._("launch-configuration", configMap); 
public boolean performFinish ( ) { IContainer dest = dest ( ) ; if ( dest = = null ) { mainPage . setErrorMessage ( " Must select an existing destination folder. " ) ; return false ; } String name = name ( ) ; String suffix = suffix ( ) ; if ( name . length ( ) = = 0 ) { mainPage . setErrorMessage ( " Empty file name. " ) ; return false ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) & & ! Character . isDigit ( name . charAt ( 0 ) ) String contents = "(ns " + namespace + ")"; file.create(new StringBufferInputStream(contents), true, null); IWorkbenchWindow dw = getWorkbench().getActiveWorkbenchWindow(); if (dw != null) { IWorkbenchPage page = dw.getActivePage(); if (page != null) { TextEditor editor = (TextEditor) IDE.openEditor(page, file, true); editor.selectAndReveal(contents.length(), 0); } } } catch (CoreException e) { CCWPlugin.logError(e); return false; } return true; } 
private final Composite createProjectNameGroup ( Composite parent ) { project specification group Composite projectGroup = new Composite(parent, SWT.NONE); GridLayout layout = new GridLayout(); layout.numColumns = 3; projectGroup.setLayout(layout); new project label Label projectLabel = new Label(projectGroup, SWT.NONE); projectLabel.setText(IDEWorkbenchMessages.WizardNewProjectCreationPage_nameLabel); projectLabel.setFont(parent.getFont()); new project name entry field projectNameText = new Text(projectGroup, SWT.BORDER); GridData data = new GridData(GridData.FILL_HORIZONTAL); data.widthHint = SIZING_TEXT_FIELD_WIDTH; projectNameText.setLayoutData(data); projectNameText.setFont(parent.getFont()); projectNameText.addListener(SWT.Modify, nameModifyListener); Not working with Indigo BidiUtils.applyBidiProcessing(projectNameText, BidiUtils.BTD_DEFAULT); Label hint = new Label(projectGroup, SWT.NONE); hint.setText("e.g. my-project, or com.my-company/my-project"); hint.setFont(parent.getFont()); hint.setForeground(Display.getCurrent().getSystemColor(SWT.COLOR_GRAY)); return projectGroup; } 
public static String join ( Collection < String > c , String sep ) { tStringBuilder sb = new StringBuilder ( ) ; tboolean seenFirst = false ; tfor ( String e : c ) { if ( seenFirst ) { tsb . append ( sep ) ; } else { tseenFirst = true ; } tsb . append ( e ) ; } treturn sb . toString ( ) ; } 
public static void createMissingParentFolders ( IResource r ) throws CoreException { tassert r ! = null & & r . getType ( ) ! = IResource . ROOT & & r . getType ( ) ! = IResource . PROJECT & & r . getProject ( ) . exists ( ) & & r . getProject ( ) . isOpen ( ) ; tStack < IFolder > toCreate = new Stack < IFolder > ( ) ; tIContainer parent = r . getParent ( ) ; twhile ( ! parent . exists ( ) ) { ttoCreate . push ( ( IFolder ) parent ) ; tparent = parent . getParent ( ) ; } twhile ( ! toCreate . isEmpty ( ) ) { ttoCreate . pop ( ) . create ( true , true , null ) ; 
public static IPath createPathFromList ( List < String > segments ) { tassert segments . size ( ) > 0 ; tIPath path = new Path ( segments . get ( 0 ) ) ; tfor ( int i = 1 ; i < segments . size ( ) ; i + + ) { tpath = path . append ( segments . get ( i ) ) ; } treturn path ; } 
private String extractExtension ( List < String > parts ) { tString extension ; tfinal String s = parts . get ( parts . size ( ) - 1 ) ; if ( s . equals ( " clj " ) | | s . equals ( " cljs " ) ) { textension = parts . remove ( parts . size ( ) - 1 ) ; } else { extension = " clj " ; } return extension ; } 
private String checkNamespaceSegment ( String name ) { if ( StringUtils . isBlank ( name ) ) { treturn " Empty namespace segment found " ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) & & ! Character . isDigit ( name . charAt ( 0 ) ) return null; } 
private String checkNamespacename ( List < String > parts ) { if ( parts . size ( ) = = 0 ) { treturn " Empty namespace name " ; } tfor ( String part : parts ) { tString msg = checkNamespaceSegment ( part ) ; if ( ! StringUtils . isBlank ( msg ) ) { treturn msg ; } } treturn null ; } 
private String mungePart ( String p ) { treturn p . replaceAll ( " - " , " _ " ) ; FIXME should call clojure.core/munge } 
private List < String > mungeParts ( List < String > l ) { tList < String > ret = new ArrayList < String > ( l . size ( ) ) ; tfor ( String p : l ) { tret . add ( mungePart ( p ) ) ; } treturn ret ; } 
public boolean performFinish ( ) { tfinal String userInput = mainPage . text . getText ( ) . trim ( ) ; tfinal List < String > unmungedParts = new ArrayList < String > ( Arrays . asList ( userInput . split ( " \\ . " ) ) ) ; tfinal String extension = extractExtension ( unmungedParts ) ; tfinal String namespace = CollectionUtils . join ( unmungedParts , " . " ) ; tfinal List < String > parts = mungeParts ( unmungedParts ) ; final String msg = checkNamespacename ( parts ) ; if ( msg ! = null ) { tmainPage . setErrorMessage ( msg ) ; treturn false ; } final IPath path = ccw . util . ResourceUtil . createPathFromList ( parts ) . addFileExtension ( extension ) ; final IFile file = mainPage . javaSourceFolder . getFile ( path ) ; if ( file . exists ( ) ) { mainPage . setErrorMessage ( " Namespace " + namespace + " already exists. " ) ; return false ; } try { tfinal String contents = " (ns " + namespace + " ) " ; tccw . util . ResourceUtil . createMissingParentFolders ( file ) ; file . create ( stringToStream ( contents , ResourcesPlugin . getEncoding ( ) ) , true , null ) ; IWorkbenchWindow dw = getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( dw ! = null ) { IWorkbenchPage page = dw . getActivePage ( ) ; if ( page ! = null ) { TextEditor editor = ( TextEditor ) IDE . openEditor ( page , file , true ) ; editor . selectAndReveal ( contents . length ( ) , 0 ) ; } } } catch ( CoreException e ) { CCWPlugin . logError ( e ) ; return false ; } return true ; } 
private ByteArrayInputStream stringToStream ( String s , String encoding ) { ttry { treturn new ByteArrayInputStream ( s . getBytes ( encoding ) ) ; 
private static IEditorInput findEditorInput ( tIPackageFragmentRoot packageFragmentRoot , tString searchedPackage , tString searchedFileName ) tthrows JavaModelException { packageFragmentRoot, 
public Composite createLeinTemplateGroup ( Composite parent ) { tComposite leinTemplateGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; tleinTemplateGroup . setLayout ( layout ) ; tLabel projectLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; tprojectLabel . setText ( " Leiningen template: " ) ; tprojectLabel . setFont ( parent . getFont ( ) ) ; ttemplateNameText = new Text ( leinTemplateGroup , SWT . BORDER ) ; tGridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; tdata . widthHint = SIZING_TEXT_FIELD_WIDTH ; ttemplateNameText . setLayoutData ( data ) ; ttemplateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { ttemplateNameText . setText ( initialTemplateNameTextValue ) ; } ttemplateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; tLabel emptyLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; tLabel helpLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; thelpLabel . setText ( " specify template name. You can use template options, e.g.: luminus +cljs +http-kit " ) ; thelpLabel . setFont ( parent . getFont ( ) ) ; treturn leinTemplateGroup ; } 
public List < String > computeTemplateArgs ( ) { tString fieldValue = getSafeTemplateNameFieldValue ( ) ; if ( fieldValue = = null ) { treturn null ; 
public boolean configure ( String url ) throws Exception { try { Require the drawbridge client to ensure http: support is started 
public Object execute ( final ExecutionEvent event ) throws ExecutionException { tConnectDialog dlg = null ; tREPLView repl = null ; try { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
@Override public void run ( ) { tMessageDialog . openError ( null , title , msg ) ; if ( maybeREPL ! = null ) { ttry { 
public boolean reconnect ( ) throws Exception { closeConnections ( ) ; logPanel . append ( " ;; Reconnecting... " ) ; return configure ( interactive . url ) ; } 
private void prepareView ( ) throws Exception { 10s timeout for establishing session (somewhat arbitrary atm) sessionId = SafeConnection.safeNewSession(interactive, 10000); evalExpression = (IFn) viewHelpers._("configure-repl-view", this, logPanel, interactive.client, sessionId); } 
public boolean configure ( final String url ) throws Exception { try { Require the drawbridge client to ensure http: support is started 
@Override public void run ( ) { tMessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , ttitle , msg ) ; 
public static String safeNewSession ( final Connection connection , final long imeoutMillis ) throws InterruptedException , ExecutionException , TimeoutException { Future < String > future = toolConnectionExecutor . submit ( new Callable < String > ( ) { @Override public String call ( ) throws Exception { treturn connection . newSession ( null ) ; } } ) ; return future . get ( imeoutMillis , TimeUnit . MILLISECONDS ) ; } 
@Override public String call ( ) throws Exception { treturn connection . newSession ( null ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void createFieldEditors ( ) { taddField ( new IntegerFieldEditor ( tccw . preferences . PreferenceConstants . REPL_HISTORY_MAX_SIZE , tMessages . REPLHistoryPreferencePage_max_size , tgetFieldEditorParent ( ) ) ) ; taddField ( new IntegerFieldEditor ( tccw . preferences . PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 
public static void run ( final ClojureEditor editor , final String mode , boolean forceLeinLaunchWhenPossible ) { final IFile editorFile = ( IFile ) editor . getEditorInput ( ) . getAdapter ( IFile . class ) ; final String filePath = computeFilePath ( editor , editorFile ) ; final String fileName = FilenameUtils . getName ( filePath ) ; if ( filePath = = null ) { teditor . setStatusLineErrorMessage ( " Unable to create a Clojure Application for this editor's content " ) ; treturn ; } final String sourcePath = computeSourcePath ( editor , editorFile , filePath ) ; final REPLView repl = REPLView . activeREPL . get ( ) ; if ( repl ! = null & & ! repl . isDisposed ( ) ) { ttry { 
public void run ( final REPLView repl ) { if ( repl ! = null & & ! repl . isDisposed ( ) ) { ttry { 
private Map < String , List < String > > getRemoteNsTree ( SafeConnection repl ) throws Exception { Response res = repl . send ( 10000 , " op " , " eval " , " code " , " (ccw.debug.serverrepl/namespaces-info) " ) ; List < Object > values = res . values ( ) ; if ( values . isEmpty ( ) ) { treturn null ; 
public void reset ( final SafeConnection repl ) { if ( repl = = null ) { tasyncResetInput ( null ) ; treturn ; } tJob job = new Job ( " Namespace browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( treeViewer = = null ) { treturn Status . CANCEL_STATUS ; } ttry { tObject oldInput = treeViewer . getInput ( ) ; tfinal Object newInput = getRemoteNsTree ( repl ) ; if ( oldInput ! = null & & oldInput . equals ( newInput ) ) { treturn Status . CANCEL_STATUS ; } else { tasyncResetInput ( null ) ; treturn Status . OK_STATUS ; } } catch ( Exception e ) { trepl . connectionLost ( ) ; tasyncResetInput ( null ) ; treturn Status . OK_STATUS ; } } @Override public boolean belongsTo ( Object family ) { treturn NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } } ; tjob . setSystem ( true ) ; tJob . getJobManager ( ) . cancel ( NS_BROWSER_REFRESH_FAMILY ) ; tjob . schedule ( 200 ) ; } 
protected IStatus run ( IProgressMonitor monitor ) { if ( treeViewer = = null ) { treturn Status . CANCEL_STATUS ; } ttry { tObject oldInput = treeViewer . getInput ( ) ; 
private void asyncResetInput ( final Object newInput ) { tDisplayUtil . asyncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { tISelection sel = treeViewer . getSelection ( ) ; tTreePath [ ] expandedTreePaths = treeViewer . getExpandedTreePaths ( ) ; ttreeViewer . setInput ( newInput ) ; ttreeViewer . setExpandedTreePaths ( expandedTreePaths ) ; ttreeViewer . setSelection ( sel ) ; } 
public static void setREPLConnection ( final SafeConnection repl ) { DisplayUtil . asyncExec ( new Runnable ( ) { public void run ( ) { 
public void run ( ) { inUIThreadSetREPLConnection ( repl ) ; } 
public void connectionLost ( ) { if ( inConnectionLost ) { if (launch != null && !launch.isTerminated()) { 
private void markAsLost ( ) { tisConnectionLost = true ; ttry { tcloseConnections ( ) ; } catch ( Exception e ) { te . printStackTrace ( ) ; } @Override public void run() { 
@Override public void run ( ) { tsetPartName ( " REPL disconnected " ) ; autoRepeatLastAction . setEnabled ( false ) ; printErrorAction . setEnabled ( false ) ; interruptAction . setEnabled ( false ) ; reconnectAction . setEnabled ( false ) ; clearLogAction . setEnabled ( false ) ; newSessionAction . setEnabled ( false ) ; showConsoleAction . setEnabled ( false ) ; tactiveREPL . compareAndSet ( REPLView . this , null ) ; if ( viewerWidget ! = null & & ! viewerWidget . isDisposed ( ) ) { tviewerWidget . setEditable ( false ) ; tStyledTextUtil . lightenStyledTextColors ( viewerWidget , 0.5 ) ; } if ( logPanel ! = null & & ! logPanel . isDisposed ( ) ) { tStyledTextUtil . lightenStyledTextColors ( logPanel , DISCONNECTED_REPL_FG_TRANSPARENCY_PCT ) ; 
public void focusGained ( FocusEvent e ) { if ( isConnectionLost ) { tNamespaceBrowser . setREPLConnection ( null ) ; 
public < T > T withConnection ( final IConnectionClient client , long imeoutMillis ) tthrows Exception { Future < T > future = toolConnectionExecutor . submit ( new Callable < T > ( ) { @Override public T call ( ) throws Exception { treturn client . withConnection ( connection ) ; } } ) ; try { tT = future . get ( imeoutMillis , TimeUnit . MILLISECONDS ) ; 
public Connection . Response send ( long imeoutMillis , final String . . . args ) tthrows Exception { treturn withConnection ( new IConnectionClient ( ) { @Override public Connection . Response withConnection ( Connection c ) { 
public static RGB lighten ( RGB c , double pct ) { treturn new RGB ( tlighten ( c . red , pct ) , 
private static int lighten ( int c , double pct ) { tdouble nc = c + ( 255 - c ) * pct ; treturn Math . max ( 0 , Math . min ( 255 , ( int ) nc ) ) ; } 
public static void lightenStyledTextColors ( StyledText st , double pct ) { tStyleRange [ ] srs = st . getStyleRanges ( ) ; tColor defaultFGColor = CCWPlugin . getColor ( RGBUtil . lighten ( st . getForeground ( ) . getRGB ( ) , pct ) ) ; tfor ( int i = 0 ; i < srs . length ; i + + ) { tStyleRange oldSR = srs [ i ] ; tStyleRange newSR = newStyleRange ( oldSR ) ; tColor lightForeground = ( oldSR . foreground = = null ) ? defaultFGColor : CCWPlugin . getColor ( RGBUtil . lighten ( oldSR . foreground . getRGB ( ) , pct ) ) ; tnewSR . foreground = lightForeground ; tst . setStyleRange ( newSR ) ; } tst . setForeground ( defaultFGColor ) ; } 
public static StyleRange newStyleRange ( StyleRange from ) { tStyleRange r = new StyleRange ( from ) ; tr . start = from . start ; tr . length = from . length ; treturn r ; } 
public void reset ( final SafeConnection repl ) { if ( repl = = null ) { tasyncResetInput ( null ) ; treturn ; } tJob job = new Job ( " Namespace browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( treeViewer = = null ) { treturn Status . CANCEL_STATUS ; } ttry { tObject oldInput = treeViewer . getInput ( ) ; tfinal Object newInput = getRemoteNsTree ( repl ) ; if ( oldInput ! = null & & oldInput . equals ( newInput ) ) { treturn Status . CANCEL_STATUS ; } else { tasyncResetInput ( newInput ) ; treturn Status . OK_STATUS ; } } catch ( Exception e ) { trepl . connectionLost ( ) ; tasyncResetInput ( null ) ; treturn Status . OK_STATUS ; } } @Override public boolean belongsTo ( Object family ) { treturn NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } } ; tjob . setSystem ( true ) ; tJob . getJobManager ( ) . cancel ( NS_BROWSER_REFRESH_FAMILY ) ; tjob . schedule ( 200 ) ; } 
@Override public void run ( ) { tISelection sel = treeViewer . getSelection ( ) ; tTreePath [ ] expandedTreePaths = treeViewer . getExpandedTreePaths ( ) ; ttreeViewer . setInput ( newInput ) ; if ( newInput ! = null ) { ttreeViewer . setExpandedTreePaths ( expandedTreePaths ) ; 
public void reset ( final SafeConnection repl ) { if ( repl = = null ) { tasyncResetInput ( null ) ; treturn ; } tJob job = new Job ( " Namespace browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( treeViewer = = null ) { treturn Status . CANCEL_STATUS ; } ttry { tObject oldInput = treeViewer . getInput ( ) ; tfinal Object newInput = getRemoteNsTree ( repl ) ; if ( oldInput ! = null & & oldInput . equals ( newInput ) ) { treturn Status . CANCEL_STATUS ; } else { tasyncResetInput ( newInput ) ; treturn Status . OK_STATUS ; } } catch ( Exception e ) { te . printStackTrace ( ) ; trepl . connectionLost ( ) ; tasyncResetInput ( null ) ; treturn Status . OK_STATUS ; } } @Override public boolean belongsTo ( Object family ) { treturn NS_BROWSER_REFRESH_FAMILY . equals ( family ) ; } } ; tjob . setSystem ( true ) ; tJob . getJobManager ( ) . cancel ( NS_BROWSER_REFRESH_FAMILY ) ; tjob . schedule ( 200 ) ; } 
@Override public void run ( ) { tISelection sel = treeViewer . getSelection ( ) ; tTreePath [ ] expandedTreePaths = treeViewer . getExpandedTreePaths ( ) ; ttreeViewer . setInput ( newInput ) ; if ( newInput ! = null ) { ttreeViewer . setExpandedTreePaths ( expandedTreePaths ) ; 
public static void setREPLConnection ( final SafeConnection repl ) { DisplayUtil . asyncExec ( new Runnable ( ) { @Override 
public void run ( ) { inUIThreadSetREPLConnection ( repl ) ; } 
private static void inUIThreadSetREPLConnection ( SafeConnection repl ) { tIWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; treturn ; } tIWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activePage is null " ) ; } tIViewPart [ ] views = activePage . getViews ( ) ; tNamespaceBrowser co = null ; tfor ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { tco = ( NamespaceBrowser ) v ; tbreak ; } } if ( co = = null ) { treturn ; } tco . reset ( repl ) ; } 
public void earlyStartup ( ) { tSystem . out . println ( " CCW EARLY STARTUP " ) ; tUIJob registerJob = new UIJob ( Display . getDefault ( ) , " CCWDropAdapterEarlyStartup " ) { { tsetPriority ( Job . SHORT ) ; tsetSystem ( true ) ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { tIWorkbench workbench = PlatformUI . getWorkbench ( ) ; tworkbench . addWindowListener ( workbenchListener ) ; tIWorkbenchWindow [ ] workbenchWindows = workbench . getWorkbenchWindows ( ) ; tfor ( IWorkbenchWindow window : workbenchWindows ) { tworkbenchListener . hookWindow ( window ) ; } treturn Status . OK_STATUS ; } } ; tregisterJob . schedule ( ) ; } 
public IStatus runInUIThread ( IProgressMonitor monitor ) { tIWorkbench workbench = PlatformUI . getWorkbench ( ) ; tworkbench . addWindowListener ( workbenchListener ) ; tIWorkbenchWindow [ ] workbenchWindows = workbench . getWorkbenchWindows ( ) ; tfor ( IWorkbenchWindow window : workbenchWindows ) { tworkbenchListener . hookWindow ( window ) ; } treturn Status . OK_STATUS ; } 
public void installDropTarget ( final Shell shell ) { thookUrlTransfer ( shell , dropListener ) ; } 
private DropTarget hookUrlTransfer ( final Shell c , tDropTargetListener dropTargetListener ) { tDropTarget target = findDropTarget ( c ) ; if ( target ! = null ) { } 
private void registerDropListener ( DropTarget target , tDropTargetListener dropTargetListener ) { ttarget . removeDropListener ( dropTargetListener ) ; ttarget . addDropListener ( dropTargetListener ) ; } 
private void hookChildren ( Control c , DropTargetListener dropTargetListener ) { if ( c instanceof Composite ) { tControl [ ] children = ( ( Composite ) c ) . getChildren ( ) ; 
private void hookRecursive ( Control c , DropTargetListener dropTargetListener ) { tDropTarget target = findDropTarget ( c ) ; if ( target ! = null ) { } 
private DropTarget findDropTarget ( Control control ) { tObject object = control . getData ( DND . DROP_TARGET_KEY ) ; if ( object instanceof DropTarget ) { treturn ( DropTarget ) object ; } treturn null ; } 
public void dragLeave ( DropTargetEvent e ) { if ( e . detail = = DND . DROP_NONE ) { tsetDropOperation ( e ) ; 
public void dragOperationChanged ( DropTargetEvent e ) { tupdateDragDetails ( e ) ; } 
private void updateDragDetails ( DropTargetEvent e ) { if ( dropTargetIsValid ( e ) ) { tsetDropOperation ( e ) ; 
private boolean dropTargetIsValid ( DropTargetEvent e ) { treturn transfer . isSupportedType ( e . currentDataType ) ; } 
public void drop ( DropTargetEvent event ) { if ( ! transfer . isSupportedType ( event . currentDataType ) ) { if (!proceedProjectsCreation(files)) { 
private boolean proceedProjectsCreation ( String [ ] files ) { tboolean atLeastOneProjectCreated = false ; tfor ( String f : files ) { tboolean created = proceedProjectCreation ( new File ( f ) ) ; if ( created ) { tatLeastOneProjectCreated = true ; } } treturn atLeastOneProjectCreated ; } 
private boolean proceedProjectCreation ( File file ) { if ( ! file . exists ( ) | | ! file . isDirectory ( ) ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . LOG_INFO , " Cannot create project because ' " + file . getAbsolutePath ( ) + " ' does not exist or is not a directory " ) ; treturn false ; } tFile projectClj = new File ( file , " project.clj " ) ; if ( projectClj . exists ( ) ) { treturn proceedLeiningenProjectCreation ( file ) ; } } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { tIProjectDescription desc = ResourcesPlugin . getWorkspace ( ) . newProjectDescription ( projectName ) ; tdesc . setLocation ( new Path ( folder . getAbsolutePath ( ) ) ) ; tproject . create ( desc , null ) ; tproject . open ( null ) ; } 
public void perspectiveActivated ( IWorkbenchPage page , tIPerspectiveDescriptor perspective ) { tpageChanged ( page ) ; } 
public void perspectiveChanged ( IWorkbenchPage page , tIPerspectiveDescriptor perspective , String changeId ) { } @Override public void pageActivated ( IWorkbenchPage page ) { tpageChanged ( page ) ; } @Override public void pageClosed ( IWorkbenchPage page ) { } @Override public void pageOpened ( IWorkbenchPage page ) { tpageChanged ( page ) ; } private void pageChanged ( IWorkbenchPage page ) { if ( page = = null ) { treturn ; } tIWorkbenchWindow workbenchWindow = page . getWorkbenchWindow ( ) ; twindowChanged ( workbenchWindow ) ; } @Override public void windowActivated ( IWorkbenchWindow window ) { twindowChanged ( window ) ; } private void windowChanged ( IWorkbenchWindow window ) { if ( window = = null ) { treturn ; } tShell shell = window . getShell ( ) ; trunUpdate ( shell ) ; } @Override public void windowDeactivated ( IWorkbenchWindow window ) { } @Override public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { thookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { twindow . addPageListener ( this ) ; twindow . addPerspectiveListener ( this ) ; tIPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; tpartService . addPartListener ( this ) ; twindowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { tIWorkbenchPage page = partRef . getPage ( ) ; tpageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { treturn ; } tDisplay display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { treturn ; } ttry { tdisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { tinstallDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void pageClosed ( IWorkbenchPage page ) { } @Override public void pageOpened ( IWorkbenchPage page ) { tpageChanged ( page ) ; } private void pageChanged ( IWorkbenchPage page ) { if ( page = = null ) { treturn ; } tIWorkbenchWindow workbenchWindow = page . getWorkbenchWindow ( ) ; twindowChanged ( workbenchWindow ) ; } @Override public void windowActivated ( IWorkbenchWindow window ) { twindowChanged ( window ) ; } private void windowChanged ( IWorkbenchWindow window ) { if ( window = = null ) { treturn ; } tShell shell = window . getShell ( ) ; trunUpdate ( shell ) ; } @Override public void windowDeactivated ( IWorkbenchWindow window ) { } @Override public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { thookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { twindow . addPageListener ( this ) ; twindow . addPerspectiveListener ( this ) ; tIPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; tpartService . addPartListener ( this ) ; twindowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { tIWorkbenchPage page = partRef . getPage ( ) ; tpageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { treturn ; } tDisplay display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { treturn ; } ttry { tdisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { tinstallDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
private void pageChanged ( IWorkbenchPage page ) { if ( page = = null ) { treturn ; } tIWorkbenchWindow workbenchWindow = page . getWorkbenchWindow ( ) ; twindowChanged ( workbenchWindow ) ; } 
public void windowActivated ( IWorkbenchWindow window ) { twindowChanged ( window ) ; } 
private void windowChanged ( IWorkbenchWindow window ) { if ( window = = null ) { treturn ; } tShell shell = window . getShell ( ) ; trunUpdate ( shell ) ; } 
public void windowDeactivated ( IWorkbenchWindow window ) { } @Override public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { thookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { twindow . addPageListener ( this ) ; twindow . addPerspectiveListener ( this ) ; tIPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; tpartService . addPartListener ( this ) ; twindowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { tIWorkbenchPage page = partRef . getPage ( ) ; tpageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { treturn ; } tDisplay display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { treturn ; } ttry { tdisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { tinstallDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void windowClosed ( IWorkbenchWindow window ) { } @Override public void windowOpened ( IWorkbenchWindow window ) { thookWindow ( window ) ; } public void hookWindow ( IWorkbenchWindow window ) { twindow . addPageListener ( this ) ; twindow . addPerspectiveListener ( this ) ; tIPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; tpartService . addPartListener ( this ) ; twindowChanged ( window ) ; } @Override public void partOpened ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { tIWorkbenchPage page = partRef . getPage ( ) ; tpageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { treturn ; } tDisplay display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { treturn ; } ttry { tdisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { tinstallDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void hookWindow ( IWorkbenchWindow window ) { twindow . addPageListener ( this ) ; twindow . addPerspectiveListener ( this ) ; tIPartService partService = ( IPartService ) window . getService ( IPartService . class ) ; tpartService . addPartListener ( this ) ; twindowChanged ( window ) ; } 
public void partOpened ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } 
public void partActivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } 
public void partBroughtToTop ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } 
public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partHidden ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { tIWorkbenchPage page = partRef . getPage ( ) ; tpageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { treturn ; } tDisplay display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { treturn ; } ttry { tdisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { tinstallDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
public void partClosed ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } 
public void partDeactivated ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } 
public void partHidden ( IWorkbenchPartReference partRef ) { tpartUpdate ( partRef ) ; } 
public void partInputChanged ( IWorkbenchPartReference partRef ) { } private void partUpdate ( IWorkbenchPartReference partRef ) { tIWorkbenchPage page = partRef . getPage ( ) ; tpageChanged ( page ) ; } private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { treturn ; } tDisplay display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { treturn ; } ttry { tdisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! shell . isDisposed ( ) ) { tinstallDropTarget ( shell ) ; } } } ) ; } catch ( SWTException ex ) { if ( ex . code = = SWT . ERROR_DEVICE_DISPOSED ) { }} 
private void partUpdate ( IWorkbenchPartReference partRef ) { tIWorkbenchPage page = partRef . getPage ( ) ; tpageChanged ( page ) ; } 
private void runUpdate ( final Shell shell ) { if ( shell = = null | | shell . isDisposed ( ) ) { treturn ; } tDisplay display = shell . getDisplay ( ) ; if ( display = = null | | display . isDisposed ( ) ) { treturn ; } ttry { tdisplay . asyncExec ( new Runnable ( ) { 
public void run ( ) { if ( ! shell . isDisposed ( ) ) { tinstallDropTarget ( shell ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tISelection selection = HandlerUtil . getCurrentSelection ( event ) ; if ( selection instanceof IStructuredSelection ) { tfor ( Iterator < ? > it = ( ( IStructuredSelection ) selection ) . iterator ( ) ; it . hasNext ( ) ; ) { tObject element = it . next ( ) ; tIProject project = null ; if ( element instanceof IProject ) { tproject = ( IProject ) element ; } else if ( element instanceof IAdaptable ) { tproject = ( IProject ) ( ( IAdaptable ) element ) . getAdapter ( IProject . class ) ; } if ( project ! = null ) { ttoggleNature ( project , false ) ; } } } treturn null ; } 
private static boolean doToggleNature ( IProject project ) throws CoreException { tIProjectDescription description = project . getDescription ( ) ; tString [ ] natures = description . getNatureIds ( ) ; tList < String > newNatures = new ArrayList < String > ( natures . length + 1 ) ; tboolean natureFound = false ; tfor ( String nature : natures ) { if ( nature . equals ( ClojureCore . NATURE_ID ) ) { } 
public synchronized void start ( ) { telementChangedListener = new ClojurePackageElementChangeListener ( ) ; tJavaCore . addElementChangedListener ( elementChangedListener ) ; telementChangedListener . performFullScan ( ) ; tstartLeininingenAdapter ( ) ; } 
private void startLeininingenAdapter ( ) { tleiningenProjectResourceListener = new LeiningenProjectResourceListener ( ) ; tResourcesPlugin . getWorkspace ( ) . addResourceChangeListener ( leiningenProjectResourceListener ) ; tleiningenProjectResourceListener . performFullScan ( ) ; } 
private void stopLeiningenAdapter ( ) { if ( leiningenProjectResourceListener ! = null ) { tResourcesPlugin . getWorkspace ( ) . removeResourceChangeListener ( leiningenProjectResourceListener ) ; 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { tfor ( IProject project : projects ) { ttry { if ( isCandidateClojureProject ( project ) ) { tToggleClojureNatureCommand . toggleNature ( project , true ) ; } } catch ( Exception e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Clojure nature for project " + project . getName ( ) , te ) ; } } treturn Status . OK_STATUS ; } 
public void elementChanged ( ElementChangedEvent javaModelEvent ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) treturn ; tIJavaElementDelta delta = javaModelEvent . getDelta ( ) ; tIJavaElement element = delta . getElement ( ) ; if ( element instanceof IJavaModel ) { 
public void performFullScan ( ) { if ( ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ) treturn ; tIWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; taddClojureNature ( workspaceRoot . getProjects ( ) ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { tfor ( IProject project : projects ) { ttry { if ( isCandidateLeiningenProject ( project ) ) { tleinHandlers . _ ( " add-leiningen-nature " , project ) ; } } catch ( Exception e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Leiningen nature for project " + project . getName ( ) , te ) ; } } treturn Status . OK_STATUS ; } 
private boolean isCandidateLeiningenProject ( IProject project ) { ttry { tboolean maybeCandidate = project . exists ( ) 
public void resourceChanged ( IResourceChangeEvent event ) { if ( automaticNatureAdditionDisabled ( ) ) return ; tIResourceDelta rootDelta = event . getDelta ( ) ; if ( rootDelta = = null ) return ; tIResourceDelta [ ] projectsDelta = rootDelta . getAffectedChildren ( ) ; tList < IProject > projects = new ArrayList < IProject > ( ) ; tfor ( IResourceDelta projectDelta : projectsDelta ) { tIProject project = ( IProject ) projectDelta . getResource ( ) ; if ( project = = null | | ! project . exists ( ) | | ! project . isOpen ( ) | | hasLeiningenNature ( project ) ) tcontinue ; if ( project . getFile ( " project.clj " ) . exists ( ) ) tprojects . add ( project ) ; } taddLeiningenNature ( projects . toArray ( new IProject [ projects . size ( ) ] ) ) ; } 
private boolean hasLeiningenNature ( IProject project ) { ttry { treturn project . hasNature ( CCWPlugin . LEININGEN_NATURE_ID ) ; 
private void addLeiningenNature ( final IProject [ ] projects ) { if ( projects . length ! = 0 ) { tWorkspaceJob job = new LeiningenNatureAdderWorkspaceJob ( projects ) ; 
public void performFullScan ( ) { if ( automaticNatureAdditionDisabled ( ) ) return ; tIWorkspaceRoot workspaceRoot = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; taddLeiningenNature ( workspaceRoot . getProjects ( ) ) ; } 
private boolean automaticNatureAdditionDisabled ( ) { treturn ! CCWPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION ) ; } 
private DropTarget hookUrlTransfer ( final Shell c , tDropTargetListener dropTargetListener ) { tDropTarget target = findDropTarget ( c ) ; if ( target ! = null ) { } 
private void hookRecursive ( Control c , DropTargetListener dropTargetListener ) { tDropTarget target = findDropTarget ( c ) ; if ( target ! = null ) { } 
private boolean dropTargetIsValid ( DropTargetEvent e ) { treturn fileTransfer . isSupportedType ( e . currentDataType ) | | urlTransfer . isSupportedType ( e . currentDataType ) ; } 
public void drop ( DropTargetEvent event ) { if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { if (!proceedProjectsCreation(files)) { 
@Override public void run ( ) { tGitImportWizard w1 = new GitImportWizard ( new IRepositorySearchResult ( ) { @Override public GitRepositoryInfo getGitRepositoryInfo ( ) tthrows NoRepositoryInfoException { treturn new GitRepositoryInfo ( sanitizedUrl ) ; } } ) ; tnew WizardDialog ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , w1 ) . open ( ) ; } 
public GitRepositoryInfo getGitRepositoryInfo ( ) tthrows NoRepositoryInfoException { treturn new GitRepositoryInfo ( sanitizedUrl ) ; } 
private String sanitizeForGit ( String url ) { tMatcher m = p . matcher ( url ) ; treturn m . matches ( ) ? m . group ( 1 ) : null ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { tIProjectDescription desc = ResourcesPlugin . getWorkspace ( ) . newProjectDescription ( projectName ) ; tdesc . setLocation ( new Path ( folder . getAbsolutePath ( ) ) ) ; tproject . create ( desc , null ) ; tproject . open ( null ) ; } 
public void resourceChanged ( IResourceChangeEvent event ) { if ( automaticNatureAdditionDisabled ( ) ) return ; tIResourceDelta rootDelta = event . getDelta ( ) ; if ( rootDelta = = null ) return ; tIResourceDelta [ ] projectsDelta = rootDelta . getAffectedChildren ( ) ; tList < IProject > projects = new ArrayList < IProject > ( ) ; tfor ( IResourceDelta projectDelta : projectsDelta ) { tIProject project = ( IProject ) projectDelta . getResource ( ) ; if ( project = = null | | ! project . exists ( ) | | ! project . isOpen ( ) ) tcontinue ; if ( hasLeiningenNature ( project ) ) { if ( ! checkLeiningenProjectConsistency ( project ) ) thandlers . _ ( " reset-project-build-path " , JavaCore . create ( project ) ) ; tcontinue ; } if ( project . getFile ( " project.clj " ) . exists ( ) ) tprojects . add ( project ) ; } taddLeiningenNature ( projects . toArray ( new IProject [ projects . size ( ) ] ) ) ; } 
private boolean checkLeiningenProjectConsistency ( IProject project ) { treturn project . getFile ( " .classpath " ) . exists ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { ttry { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) treturn Status . OK_STATUS ; if ( hasLeiningenNature ( project ) ) { if ( ! checkLeiningenProjectConsistency ( project ) ) { tSystem . out . println ( " UPGRADING PROJECT BUILD PATH " + project . getName ( ) ) ; tleinHandlers . _ ( " upgrade-project-build-path " , JavaCore . create ( project ) , monitor ) ; } treturn Status . OK_STATUS ; } if ( isCandidateLeiningenProject ( project ) ) { tSystem . out . println ( " CREATING LEININGEN PROJECT " + project . getName ( ) ) ; tleinHandlers . _ ( " add-leiningen-nature " , project ) ; } } catch ( Exception e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Leiningen nature for project " + project . getName ( ) , te ) ; } treturn Status . OK_STATUS ; } 
public void resourceChanged ( IResourceChangeEvent event ) { if ( automaticNatureAdditionDisabled ( ) ) return ; tIResourceDelta rootDelta = event . getDelta ( ) ; if ( rootDelta = = null ) return ; tIResourceDelta [ ] projectsDelta = rootDelta . getAffectedChildren ( ) ; tfor ( IResourceDelta projectDelta : projectsDelta ) { tIProject project = ( IProject ) projectDelta . getResource ( ) ; 
private void addLeiningenNature ( final IProject [ ] projects ) { if ( projects . length ! = 0 ) { tfor ( IProject project : projects ) { 
public void drop ( DropTargetEvent event ) { if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { final AtomicBoolean userConfirms = new AtomicBoolean(); 
@Override public void run ( ) { tString msg ; if ( files . length = = 1 ) { tmsg = " Will research and create projects from " + files [ 0 ] ; } else { tmsg = " Will research and create projects from: " ; tfor ( String file : files ) { tmsg + = " - " + file + " " ; } } tboolean c = MessageDialog . openConfirm ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Drag & Drop project creation " , tmsg ) ; tuserConfirms . set ( c ) ; } 
private boolean proceedProjectsCreation ( String [ ] files ) { tboolean atLeastOneProjectCreated = false ; tfor ( String f : files ) { tFile file = new File ( f ) ; tboolean created = proceedProjectCreation ( file , file ) ; if ( created ) { tatLeastOneProjectCreated = true ; } } treturn atLeastOneProjectCreated ; } 
private boolean proceedProjectCreation ( File startFolder , File file ) { if ( ! file . exists ( ) | | ! file . isDirectory ( ) ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . LOG_INFO , " Cannot create project because ' " + file . getAbsolutePath ( ) + " ' does not exist or is not a directory " ) ; treturn false ; } tFile projectClj = new File ( file , " project.clj " ) ; if ( projectClj . exists ( ) ) { treturn proceedLeiningenProjectCreation ( startFolder , file ) ; } } 
private boolean proceedLeiningenProjectCreation ( final File startFolder , final File folder ) { } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { tfinal String initialProjectName = folder . getName ( ) ; } 
@Override public void run ( ) { tMessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Project " + projectName + " created " , 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { ttry { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) treturn Status . OK_STATUS ; if ( hasLeiningenNature ( project ) ) { if ( ! checkLeiningenProjectConsistency ( project ) ) { tSystem . out . println ( " UPGRADING PROJECT BUILD PATH " + project . getName ( ) ) ; tleinHandlers . _ ( " upgrade-project-build-path " , JavaCore . create ( project ) , monitor ) ; } treturn Status . OK_STATUS ; } if ( isCandidateLeiningenProject ( project ) ) { tSystem . out . println ( " CREATING LEININGEN PROJECT " + project . getName ( ) ) ; tleinHandlers . _ ( " add-leiningen-nature-with-monitor " , project , monitor ) ; } } catch ( Exception e ) { te . printStackTrace ( ) ; treturn CCWPlugin . createErrorStatus ( " Exception occured while trying to automatically " + " add Leiningen nature for project " + project . getName ( ) , te ) ; } treturn Status . OK_STATUS ; } 
@Override public void run ( ) { tString msg ; if ( files . length = = 1 ) { tmsg = " Find and create projects from " + files [ 0 ] + " ? " ; } else { tmsg = " Find and create projects from ... ? " ; tfor ( String file : files ) { tmsg + = " - " + file + " " ; } } tboolean c = MessageDialog . openConfirm ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Drag & Drop project creation " , tmsg ) ; tuserConfirms . set ( c ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { ttry { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) treturn Status . OK_STATUS ; if ( hasJavaNature ( project ) ) { } 
private boolean hasJavaNature ( IProject project ) { ttry { treturn project . hasNature ( JavaCore . NATURE_ID ) ; 
public Object execute ( final ExecutionEvent event ) throws ExecutionException { tConnectDialog dlg = null ; tREPLView repl = null ; try { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; 
@Override public void run ( ) { if ( activate ) { p . activate ( active ) ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { if ( execute ( true ) ) return null ; MessageDialog . openError ( PlatformUI . getWorkbench ( ) . getDisplay ( ) . getActiveShell ( ) , " No Active REPL " , " No REPL is active. Click in an existing REPL to make it the active target, or open a new REPL. " ) ; return null ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . showConsoleView ( repl . getConsole ( ) ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { repl . logPanel . setText ( " " ) ; } 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { try { repl . reconnect ( ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { try { REPLView . connect ( repl . getConnection ( ) . url , true ) ; 
public void doExecute ( ExecutionEvent event , REPLView repl ) throws ExecutionException { repl . sendInterrupt ( ) ; } 
protected abstract void doExecute ( ExecutionEvent event , REPLView part ) throws ExecutionException ; } } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) throws CoreException { ttry { if ( project = = null | | ! project . isOpen ( ) | | ! project . exists ( ) ) 
private static void releaseSecondaryId ( String id ) { tassert id ! = null ; synchronized ( SECONDARY_VIEW_IDS ) { SECONDARY_VIEW_IDS . add ( id ) ; 
public void propertyChange ( PropertyChangeEvent event ) { if ( event . getProperty ( ) . equals ( JFaceResources . TEXT_FONT ) ) resetFont ( ) ; } 
public void connectionLost ( ) { if ( inConnectionLost ) { if (launch != null && !launch.isTerminated()) { 
private void markAsLost ( ) { tisConnectionLost = true ; ttry { tcloseConnections ( ) ; } catch ( Exception e ) { te . printStackTrace ( ) ; } @Override public void run() { 
public void handleResponse ( Response resp , String expression ) { viewHelpers . _ ( " handle-responses " , this , logPanel , expression , resp . seq ( ) ) ; } 
public Set < String > getAvailableOperations ( ) throws IllegalStateException { if ( describeInfo = = null ) { ttry { Response r = safeToolConnection . send ( 10000 , " op " , " describe " ) ; } } Map<String, Object> ops = (Map<String, Object>)describeInfo.get("ops"); return ops == null ? new HashSet() : ops.keySet(); } 
public String findDeclaringNamespace ( ) { tString inline = super . findDeclaringNamespace ( ) ; if ( inline ! = null ) { treturn inline ; 
public void handleEvent ( Event e ) { switch ( e . keyCode ) { case SWT . PAGE_DOWN : 
@Override public void widgetDisposed ( DisposeEvent e ) { tgetPreferences ( ) . removePropertyChangeListener ( replHintsListener ) ; } 
@Override public void focusLost ( FocusEvent e ) { thasFocus = false ; trenderPlaceholder ( ) ; } 
@Override public void focusGained ( FocusEvent e ) { thasFocus = true ; trenderPlaceholder ( ) ; } 
private void renderPlaceholder ( ) { if ( hasFocus ) { if ( isPlaceholderDisplayed ) { 
private void createActions ( ) { tautoRepeatLastAction = new Action ( " Repeat last evaluation each time editor sends changes " , Action . AS_CHECK_BOX ) { @Override public void run ( ) { .setImageDescriptor(getImageDescriptor("repl/console.gif")); 
private void initializeLogPanelColors ( ) { tClojureSourceViewer . initializeViewerColors ( logPanel , getPreferences ( ) , logPanelEditorColors ) ; 
public void handleEvent ( Event event ) { tString message = hintProvider . getMessageText ( ) ; if ( message = = null ) treturn ; } 
public void verifyKey ( VerifyEvent e ) { if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
public Object execute ( ExecutionEvent event ) throws ExecutionException { tevalExpression ( ) ; treturn null ; } 
public void focusLost ( FocusEvent e ) { for (IContextActivation activation : activations) { ((IContextService)REPLView.this.getSite().getService(IContextService.class)).deactivateContext(activation); } activations = new ArrayList(); } 
public void focusGained ( FocusEvent e ) { activate ( IClojureEditor . KEY_BINDING_SCOPE ) ; activate ( CCW_UI_CONTEXT_REPL ) ; } 
public void dispose ( ) { super . dispose ( ) ; if ( secondaryId ! = null ) { treleaseSecondaryId ( secondaryId ) ; } fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . _ ( " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; try { if ( interactive ! = null ) interactive . close ( ) ; 
public void focusGained ( FocusEvent e ) { if ( isConnectionLost ) { tNamespaceBrowser . setREPLConnection ( null ) ; 
public void drop ( DropTargetEvent event ) { tSystem . out . println ( " drop " + event . widget . hashCode ( ) ) ; if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { DisplayUtil.asyncExec(new Runnable() { 
@Override public void run ( ) { tString msg ; if ( candidateProjects . size ( ) = = 1 ) { tmsg = " Find and create projects from " + candidateProjects . get ( 0 ) + " ? " ; } else { tmsg = " Find and create projects from ... ? " ; tfor ( File file : candidateProjects ) { tmsg + = " - " + file . getAbsolutePath ( ) + " " ; } } tboolean c = MessageDialog . openConfirm ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Drag & Drop project creation " , tmsg ) ; if ( c ) { proceedLeiningenProjectsCreation ( candidateProjects ) ; 
private void collectCandidateProjects ( String [ ] files , List < File > collect ) { tfor ( String f : files ) { tFile file = new File ( f ) ; 
private void collectCandidateProjects ( File folder , List < File > collect ) { if ( ! folder . exists ( ) | | ! folder . isDirectory ( ) ) { treturn ; } tFile projectClj = new File ( folder , " project.clj " ) ; if ( ! projectClj . exists ( ) ) { try recursively 
private void proceedLeiningenProjectsCreation ( List < File > folders ) { tfor ( File folder : folders ) { tproceedLeiningenProjectCreation ( folder ) ; 
@Override public void run ( ) { tMessageDialog . openInformation ( PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) , " Project " + projectName + " created " , 
public void run ( ) { tStyledText textWidget = getTextWidget ( ) ; if ( textWidget ! = null & & ! textWidget . isDisposed ( ) ) { tgetTextWidget ( ) . setBackground ( 
public static boolean isCandidateClojureProject ( IProject project ) { ttry { tboolean maybeCandidate = project . exists ( ) 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , Messages . ClojureGeneralPreferencePage_use_leiningen_launcher , getFieldEditorParent ( ) ) ) ; addField ( tnew FileFieldEditor ( 
public void addPages ( ) { tsuper . addPages ( ) ; tmainPage = new WizardNewLeiningenProjectTemplatePage ( " basicNewProjectPage " ) ; tthis . addPage ( mainPage ) ; tdoLeinAddPagesPost ( ) ; } 
public boolean performFinish ( ) { if ( newProjectWizardPerformFinish ( ) ) { tboolean res = doPerformFinish ( ) ; 
@Override public void widgetSelected ( SelectionEvent e ) { tDirectoryDialog dialog = new DirectoryDialog ( browse . getShell ( ) , SWT . NONE ) ; tdialog . setText ( " Choose Project parent directory " ) ; tdialog . setMessage ( " Select a parent directory within which the project's directory will be created " ) ; tdialog . setFilterPath ( locationText . getText ( ) ) ; tString result = dialog . open ( ) ; if ( result ! = null ) { tlocationText . setText ( result ) ; 
private String computeDefaultParentLocation ( ) { tString pref = getDefaultParentLocationDialogSettings ( ) ; treturn ( pref = = null ) ? System . getProperty ( " user.home " ) : pref ; } 
public Composite createLeinTemplateGroup ( Composite parent ) { tComposite leinTemplateGroup = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 2 ; tleinTemplateGroup . setLayout ( layout ) ; tLabel projectLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; tprojectLabel . setText ( " Leiningen template: " ) ; tprojectLabel . setFont ( parent . getFont ( ) ) ; ttemplateNameText = new Text ( leinTemplateGroup , SWT . BORDER ) ; tGridData data = new GridData ( GridData . FILL_HORIZONTAL ) ; tdata . widthHint = SIZING_TEXT_FIELD_WIDTH ; ttemplateNameText . setLayoutData ( data ) ; ttemplateNameText . setFont ( parent . getFont ( ) ) ; if ( initialTemplateNameTextValue ! = null ) { ttemplateNameText . setText ( initialTemplateNameTextValue ) ; } ttemplateNameText . addListener ( SWT . Modify , emplateNameModifyListener ) ; tLabel ph = new Label ( leinTemplateGroup , SWT . NONE ) ; tph . setLayoutData ( new GridData ( ) ) ; tLabel helpLabel = new Label ( leinTemplateGroup , SWT . NONE ) ; thelpLabel . setText ( " specify template name. You can use template options, e.g.: luminus +cljs +http-kit " ) ; thelpLabel . setFont ( parent . getFont ( ) ) ; tGridData lData = new GridData ( GridData . FILL_HORIZONTAL ) ; thelpLabel . setLayoutData ( lData ) ; treturn leinTemplateGroup ; } 
public String checkValidLocation ( IProject project , String projectParentLocation , String projectFolderName ) { if ( projectParentLocation = = null | | projectParentLocation . trim ( ) . equals ( " " ) ) { treturn " A location to create the project folder in must be specified " ; } tfinal File parentFolder = new File ( projectParentLocation ) ; if ( ! parentFolder . exists ( ) ) { treturn " Parent folder ' " + projectParentLocation + " ' does not exist " ; } tFile file = new File ( parentFolder , projectFolderName ) ; tURI uri = file . toURI ( ) ; if ( uri = = null ) { treturn IDEWorkbenchMessages . ProjectLocationSelectionDialog_locationError ; } if ( file . exists ( ) ) { treturn " Cannot create a project at an existing location ( " + file . getAbsolutePath ( ) + " ) " ; } tIStatus locationStatus = ResourcesPlugin . getWorkspace ( ) . validateProjectLocationURI ( project , } 
public boolean useDefaultProjectParentLocation ( ) { treturn previousLocationCheckbox . getSelection ( ) ; } 
public void persistSettings ( ) { tgetDialogSettings ( ) . put ( NEW_PROJECT_PREVIOUS_LOCATION , locationText . getText ( ) ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , tIProgressMonitor monitor ) throws CoreException { if ( getProject ( ) = = null ) treturn null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) treturn null ; if ( projectCljPresentInDelta ( ) ) { } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { ttry { tIJavaProject javaProject = JavaCore . create ( getProject ( ) ) ; 
private boolean projectCljPresentInDelta ( ) { tIResourceDelta delta = getDelta ( getProject ( ) ) ; tIResourceDelta deltaProjClj = delta . findMember ( new Path ( " project.clj " ) ) ; treturn deltaProjClj ! = null ; } 
protected void editorSaved ( ) { tsuper . editorSaved ( ) ; tupdatePartNameAndDescription ( ) ; teditorSupport . _ ( " editor-saved " , this ) ; } 
public static boolean showActiveREPL ( final boolean activate ) { treturn showActiveREPL ( REPLView . activeREPL . get ( ) , activate ) ; } 
@Override public void run ( ) { if ( activate ) { p . activate ( active ) ; 
public static boolean execute ( final boolean activate ) { return showActiveREPL ( activate ) ; } 
protected void clean ( IProgressMonitor monitor ) throws CoreException { if ( monitor = = null ) { tmonitor = new NullProgressMonitor ( ) ; } ttry { if ( CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ) { } deleteMarkers(getProject()); } 
@Override public < T > T withConnection ( Connection c ) { tfor ( String maybeLib 
private void createMarker ( final String filename , final int line , final String message ) { ttry { tfor ( IFolder srcFolder : srcFolders . keySet ( ) ) { 
public void startREPLServer ( ) { ttry { ClojureInvoker . newInvoker ( this , " ccw.core.launch " ) . _ ( " ccw-nrepl-start-if-necessary " ) ; 
private void stopREPLServer ( ) { ttry { ClojureInvoker . newInvoker ( this , " ccw.core.launch " ) . _ ( " ccw-nrepl-stop " ) ; 
public static boolean isCljExtension ( String ext ) { treturn ext ! = null & & ext . startsWith ( " clj " ) ; } 
private void refreshInput ( ) { tJob job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; ttry { tClojureOutlinePage . this . forms = ( List < List > ) outline . _ ( " read-forms " , string ) ; tsetInputInUiThread ( ClojureOutlinePage . this . forms ) ; treturn Status . OK_STATUS ; } catch ( ReaderException e ) { } 
protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; ttry { tClojureOutlinePage . this . forms = ( List < List > ) outline . _ ( " read-forms " , string ) ; 
public void run ( ) { if ( getControl ( ) . isDisposed ( ) ) treturn ; tTreeViewer treeViewer = getTreeViewer ( ) ; if ( treeViewer ! = null ) { ttreeViewer . getTree ( ) . setRedraw ( false ) ; 
private void refreshInput ( ) { tJob job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; ttry { tClojureOutlinePage . this . forms = ( List < List > ) outline . _ ( " read-forms " , string ) ; tsetInputInUiThread ( ClojureOutlinePage . this . forms ) ; treturn Status . OK_STATUS ; } catch ( Exception e ) { tthrow new RuntimeException ( e ) ; } } @Override public boolean belongsTo ( Object family ) { treturn REFRESH_OUTLINE_JOB_FAMILY . equals ( family ) ; } } ; tjob . setSystem ( true ) ; tJob . getJobManager ( ) . cancel ( REFRESH_OUTLINE_JOB_FAMILY ) ; tjob . schedule ( 500 ) ; } 
private final void logDependenciesInformation ( final BundleContext context ) { plugin.getLog().log(new Status(IStatus.INFO, PLUGIN_ID, sb.toString())); } 
@Override public int compare ( CCWDependency d1 , CCWDependency d2 ) { if ( d1 . groupId . equals ( d2 . groupId ) ) { treturn d1 . artifactId . compareTo ( d2 . artifactId ) ; 
public void trace ( String traceOption , Object . . . message ) { } @Override public void trace ( String traceOption , Throwable throwable , Object . . . message ) { } @Override public void traceDumpStack ( String traceOption ) { } @Override public void traceEntry ( String traceOption ) { } @Override public void traceEntry ( String traceOption , Object . . . arguments ) { } @Override public void traceExit ( String traceOption ) { } @Override public void traceExit ( String traceOption , Object returnValue ) { } } 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { } @Override public void traceDumpStack ( String traceOption ) { } @Override public void traceEntry ( String traceOption ) { } @Override public void traceEntry ( String traceOption , Object . . . arguments ) { } @Override public void traceExit ( String traceOption ) { } @Override public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceDumpStack ( String traceOption ) { } @Override public void traceEntry ( String traceOption ) { } @Override public void traceEntry ( String traceOption , Object . . . arguments ) { } @Override public void traceExit ( String traceOption ) { } @Override public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceEntry ( String traceOption ) { } @Override public void traceEntry ( String traceOption , Object . . . arguments ) { } @Override public void traceExit ( String traceOption ) { } @Override public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceEntry ( String traceOption , Object . . . arguments ) { } @Override public void traceExit ( String traceOption ) { } @Override public void traceExit ( String traceOption , Object returnValue ) { } } 
public void traceExit ( String traceOption ) { } @Override public void traceExit ( String traceOption , Object returnValue ) { } } 
public void optionsChanged ( DebugOptions options ) { if ( options . isDebugEnabled ( ) ) { debugTrace = options . newDebugTrace ( bundleSymbolicName , Tracer . class ) ; } else { debugTrace = null ; } updateOptions ( options ) ; } 
public boolean isEnabled ( String traceOption ) { if ( debugTrace = = null ) { return false ; } Boolean res = options . get ( traceOption ) ; if ( res ! = null ) { return res ; 
public void trace ( String traceOption , Object . . . message ) { if ( isEnabled ( traceOption ) ) { debugTrace . trace ( " / " + traceOption , buildMessage ( message ) ) ; 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { if ( isEnabled ( traceOption ) ) { debugTrace . trace ( " / " + traceOption , buildMessage ( message ) , throwable ) ; 
public void traceDumpStack ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceDumpStack ( " / " + traceOption ) ; 
public void traceEntry ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( " / " + traceOption ) ; 
public void traceEntry ( String traceOption , Object . . . arguments ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( " / " + traceOption , arguments ) ; 
public void traceExit ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( " / " + traceOption ) ; 
public void traceExit ( String traceOption , Object returnValue ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( " / " + traceOption , returnValue ) ; 
public Object create ( final Bundle bundle , final String varAndParams , tfinal IEclipseContext context ) { tString msg = " create object for bundleclass: " + bundle . getSymbolicName ( ) + " / " + " clojure " + " / " + varAndParams ; tCCWPlugin . getTracer ( ) . trace ( TraceOptions . LOG_INFO , msg ) ; ttry { tfinal String [ ] parts = varAndParams . split ( " \\ / " ) ; 
private synchronized static void initialize ( ) { if ( initialized ) return ; tCCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; } tClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) tthrows RuntimeException { tinitialize ( ) ; tClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; tfinal URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . toArray ( new URL [ additionalURLs . size ( ) ] ) ; tURLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
@Override public void optionsChanged ( DebugOptions options ) { if ( options . isDebugEnabled ( ) ) { debugTrace = options . newDebugTrace ( bundleSymbolicName , Tracer . class ) ; } else { debugTrace = null ; } updateOptions ( options ) ; } 
public boolean isEnabled ( String traceOption ) { if ( debugTrace = = null ) { return false ; } Boolean res = options . get ( bundleSymbolicName + traceOption ) ; if ( res ! = null ) { return res ; 
public void trace ( String traceOption , Object . . . message ) { if ( isEnabled ( traceOption ) ) { debugTrace . trace ( traceOption , buildMessage ( message ) ) ; 
public void trace ( String traceOption , Throwable throwable , Object . . . message ) { if ( isEnabled ( traceOption ) ) { debugTrace . trace ( traceOption , buildMessage ( message ) , throwable ) ; 
public void traceDumpStack ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceDumpStack ( traceOption ) ; 
public void traceEntry ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( traceOption ) ; 
public void traceEntry ( String traceOption , Object . . . arguments ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceEntry ( traceOption , arguments ) ; 
public void traceExit ( String traceOption ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( traceOption ) ; 
public void traceExit ( String traceOption , Object returnValue ) { if ( isEnabled ( traceOption ) ) { debugTrace . traceExit ( traceOption , returnValue ) ; 
public void earlyStartup ( ) { tUIJob registerJob = new UIJob ( Display . getDefault ( ) , " CCWDropAdapterEarlyStartup " ) { { tsetPriority ( Job . SHORT ) ; tsetSystem ( true ) ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { tIWorkbench workbench = PlatformUI . getWorkbench ( ) ; tworkbench . addWindowListener ( workbenchListener ) ; tIWorkbenchWindow [ ] workbenchWindows = workbench . getWorkbenchWindows ( ) ; tfor ( IWorkbenchWindow window : workbenchWindows ) { tworkbenchListener . hookWindow ( window ) ; } treturn Status . OK_STATUS ; } } ; tregisterJob . schedule ( ) ; } 
public void drop ( DropTargetEvent event ) { if ( urlTransfer . isSupportedType ( event . currentDataType ) ) { DisplayUtil.asyncExec(new Runnable() { 
@Override public void run ( ) { tsetPartName ( " REPL disconnected " ) ; autoRepeatLastAction . setEnabled ( false ) ; printErrorAction . setEnabled ( false ) ; interruptAction . setEnabled ( false ) ; reconnectAction . setEnabled ( false ) ; clearLogAction . setEnabled ( false ) ; newSessionAction . setEnabled ( false ) ; showConsoleAction . setEnabled ( false ) ; tactiveREPL . compareAndSet ( REPLView . this , null ) ; if ( inputStyledText ! = null & & ! inputStyledText . isDisposed ( ) ) { tinputStyledText . setEditable ( false ) ; tStyledTextUtil . lightenStyledTextColors ( inputStyledText , 0.5 ) ; } if ( logPanel ! = null & & ! logPanel . isDisposed ( ) ) { tStyledTextUtil . lightenStyledTextColors ( logPanel , DISCONNECTED_REPL_FG_TRANSPARENCY_PCT ) ; 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanel . setFont ( font ) ; inputStyledText . setFont ( font ) ; } 
private void evalExpression ( ) { ttry { We remove trailing spaces so that we do not embark extra spaces, 
public void getStdIn ( ) { inputAreaMode = InputAreaMode.STDIN; setPlaceHolder(inputStyledText, InputAreaMode.STDIN.getPlaceHolder()); 
private void installAutoEvalExpressionOnEnter ( ) { inputStyledText . addVerifyKeyListener ( new VerifyKeyListener ( ) { private boolean enterAlonePressed ( VerifyEvent e ) { 
private boolean noSelection ( ) { treturn inputStyledText . getSelectionCount ( ) = = 0 ; } 
private String textAfterCaret ( ) { treturn inputStyledText . getText ( ) . substring ( tinputStyledText . getSelection ( ) . x ) ; 
public void run ( ) { evalExpression(); 
public boolean isDisposed ( ) { TODO we actually want to report whether the viewpart has been closed, not whether or not the platform has disposed the widget peer return inputStyledText.isDisposed(); } 
@Override public void run ( ) { tsetPartName ( " REPL disconnected " ) ; autoRepeatLastAction . setEnabled ( false ) ; printErrorAction . setEnabled ( false ) ; interruptAction . setEnabled ( false ) ; reconnectAction . setEnabled ( false ) ; clearLogAction . setEnabled ( false ) ; newSessionAction . setEnabled ( false ) ; showConsoleAction . setEnabled ( false ) ; tactiveREPL . compareAndSet ( REPLView . this , null ) ; if ( inputStyledText ! = null & & ! inputStyledText . isDisposed ( ) ) { tinputStyledText . setEditable ( false ) ; tStyledTextUtil . lightenStyledTextColors ( inputStyledText , 0.5 ) ; } if ( stdinStyledText ! = null & & ! stdinStyledText . isDisposed ( ) ) { tstdinStyledText . setEditable ( false ) ; tStyledTextUtil . lightenStyledTextColors ( stdinStyledText , 0.5 ) ; } if ( logPanel ! = null & & ! logPanel . isDisposed ( ) ) { tStyledTextUtil . lightenStyledTextColors ( logPanel , DISCONNECTED_REPL_FG_TRANSPARENCY_PCT ) ; 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanel . setFont ( font ) ; inputStyledText . setFont ( font ) ; stdinStyledText . setFont ( font ) ; } 
private void evalExpression ( ) { switch ( inputAreaMode ) { tcase CODE : 
public void sendInterrupt ( ) { viewHelpers . _ ( " log " , this , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; If we were in STDIN mode, switch back to CODE inputAreaMode = InputAreaMode.CODE; stdinViewer.getDocument().set(""); updateInputControls(); } 
private void updateInputControls ( ) { Control newVisibleControl = ( inputAreaMode = = InputAreaMode . STDIN ) ? stdinStyledText : inputStyledText ; if ( inputControlsLayout . topControl ! = newVisibleControl ) { inputControlsLayout . topControl = newVisibleControl ; 
public void verifyKey ( VerifyEvent e ) { if ( inputAreaMode ! = InputAreaMode . CODE ) return ; if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
private void installAutoSendStdinTextOnEnter ( ) { stdinStyledText . addVerifyKeyListener ( new VerifyKeyListener ( ) { private boolean enterAlonePressed ( VerifyEvent e ) { 
private boolean enterAlonePressed ( VerifyEvent e ) { return ( e . keyCode = = SWT . LF | | e . keyCode = = SWT . CR ) & & e . stateMask = = SWT . NONE ; 
private boolean noSelection ( ) { return stdinStyledText . getSelectionCount ( ) = = 0 ; } 
private String textAfterCaret ( ) { return stdinStyledText . getText ( ) . substring ( stdinStyledText . getSelection ( ) . x ) ; 
private boolean isAutoEvalOnEnterAllowed ( ) { Let's share the preference with auto_eval_on_enter, this seems consistent return getPreferences().getBoolean(PreferenceConstants.REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE); } 
public void verifyKey ( VerifyEvent e ) { if ( inputAreaMode ! = InputAreaMode . STDIN ) return ; if ( isAutoEvalOnEnterAllowed ( ) & & enterAlonePressed ( e ) 
public boolean isPPrintAvailable ( ) { System . out . println ( " operations: " + getAvailableOperations ( ) ) ; return getAvailableOperations ( ) . contains ( " pprint " ) FIXME This second check is a hack while waiting for cider-nrepl 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , true ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void createFieldEditors ( ) { taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , tMessages . REPLViewPreferencePage_activate_autoEval_on_Enter , tgetFieldEditorParent ( ) ) ) ; taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , tMessages . REPLViewPreferencePage_displayHint , tgetFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_PPRINT_RESULT , 
public boolean usePPrint ( ) { return getPreferences ( ) . getBoolean ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void createFieldEditors ( ) { taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , tMessages . REPLViewPreferencePage_activate_autoEval_on_Enter , tgetFieldEditorParent ( ) ) ) ; taddField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , tMessages . REPLViewPreferencePage_displayHint , tgetFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( ccw . preferences . PreferenceConstants . REPL_VIEW_PPRINT_RESULT , Messages . REPLViewPreferencePage_pprintResult , getFieldEditorParent ( ) ) ) ; addField ( new IntegerFieldEditor ( 
boolean isEnabled ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void trace ( String traceOption , Object . . . message ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void trace ( String traceOption , Throwable throwable , Object . . . message ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceDumpStack ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceEntry ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceEntry ( String traceOption , Object . . . arguments ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
void traceExit ( String traceOption ) ; void traceExit ( String traceOption , Object returnValue ) ; } 
public boolean isPPrintAvailable ( ) { return getAvailableOperations ( ) . contains ( " pprint-middleware " ) ; } 
private void resetFont ( ) { Font font = JFaceResources . getTextFont ( ) ; logPanelStyleCache . setFont ( font ) ; logPanel . setFont ( font ) ; inputStyledText . setFont ( font ) ; stdinStyledText . setFont ( font ) ; } 
private void copyToLog ( StyledText s ) { Add styles before adding text to the log panel 
private void createActions ( ) { tautoRepeatLastAction = new Action ( " Repeat last evaluation each time editor sends changes " , Action . AS_CHECK_BOX ) { @Override public void run ( ) { .setImageDescriptor(getImageDescriptor("repl/console.gif")); 
public void run ( ) { tlogPanelStyleCache . reset ( ) ; tlogPanel . setText ( " " ) ; } 
public void lineGetStyle ( LineStyleEvent event ) { if ( event = = null | | event . lineText = = null | | event . lineText . length ( ) = = 0 ) return ; int length = event . lineText . length ( ) ; tevent . styles = logPanelStyleCache . getStyleRanges ( event . lineOffset , length , true ) ; } 
public void replaceStyleRanges ( int start , int length , StyleRange [ ] ranges ) { if ( ranges = = null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; tsetStyleRanges ( start , length , null , ranges , false ) ; } 
tint addMerge ( int [ ] mergeRanges , StyleRange [ ] mergeStyles , int mergeCount , int modifyStart , int modifyEnd ) { tint rangeCount = styleCount < < 1 ; tStyleRange endStyle = null ; tint endStart = 0 , endLength = 0 ; if ( modifyEnd < rangeCount ) { tendStyle = styles [ modifyEnd > > 1 ] ; tendStart = ranges [ modifyEnd ] ; tendLength = ranges [ modifyEnd + 1 ] ; } tint grow = mergeCount - ( modifyEnd - modifyStart ) ; if ( rangeCount + grow > = ranges . length ) { tint [ ] tmpRanges = new int [ ranges . length + grow + ( GROW < < 1 ) ] ; tSystem . arraycopy ( ranges , 0 , tmpRanges , 0 , modifyStart ) ; tStyleRange [ ] tmpStyles = new StyleRange [ styles . length + ( grow > > 1 ) + GROW ] ; tSystem . arraycopy ( styles , 0 , tmpStyles , 0 , modifyStart > > 1 ) ; if ( rangeCount > modifyEnd ) { tSystem . arraycopy ( ranges , modifyEnd , tmpRanges , modifyStart + mergeCount , rangeCount - modifyEnd ) ; tSystem . arraycopy ( styles , modifyEnd > > 1 , tmpStyles , ( modifyStart + mergeCount ) > > 1 , styleCount - ( modifyEnd > > 1 ) ) ; } tranges = tmpRanges ; tstyles = tmpStyles ; } else { if ( rangeCount > modifyEnd ) { tSystem . arraycopy ( ranges , modifyEnd , ranges , modifyStart + mergeCount , rangeCount - modifyEnd ) ; tSystem . arraycopy ( styles , modifyEnd > > 1 , styles , ( modifyStart + mergeCount ) > > 1 , styleCount - ( modifyEnd > > 1 ) ) ; } } if ( MERGE_STYLES ) { tint j = modifyStart ; tfor ( int i = 0 ; i < mergeCount ; i + = 2 ) { if ( j > 0 & & ranges [ j - 2 ] + ranges [ j - 1 ] = = mergeRanges [ i ] & & mergeStyles [ i > > 1 ] . similarTo ( styles [ ( j - 2 ) > > 1 ] ) ) { tranges [ j - 1 ] + = mergeRanges [ i + 1 ] ; } else { tstyles [ j > > 1 ] = mergeStyles [ i > > 1 ] ; tranges [ j + + ] = mergeRanges [ i ] ; tranges [ j + + ] = mergeRanges [ i + 1 ] ; } } if ( endStyle ! = null & & ranges [ j - 2 ] + ranges [ j - 1 ] = = endStart & & endStyle . similarTo ( styles [ ( j - 2 ) > > 1 ] ) ) { tranges [ j - 1 ] + = endLength ; modifyEnd + = 2 ; tmergeCount + = 2 ; } if ( rangeCount > modifyEnd ) { tSystem . arraycopy ( ranges , modifyStart + mergeCount , ranges , j , rangeCount - modifyEnd ) ; tSystem . arraycopy ( styles , ( modifyStart + mergeCount ) > > 1 , styles , j > > 1 , styleCount - ( modifyEnd > > 1 ) ) ; } tgrow = ( j - modifyStart ) - ( modifyEnd - modifyStart ) ; } else { tSystem . arraycopy ( mergeRanges , 0 , ranges , modifyStart , mergeCount ) ; tSystem . arraycopy ( mergeStyles , 0 , styles , modifyStart > > 1 , mergeCount > > 1 ) ; } tstyleCount + = grow > > 1 ; treturn grow ; } 
tint addMerge ( StyleRange [ ] mergeStyles , int mergeCount , int modifyStart , int modifyEnd ) { tint grow = mergeCount - ( modifyEnd - modifyStart ) ; tStyleRange endStyle = null ; if ( modifyEnd < styleCount ) endStyle = styles [ modifyEnd ] ; if ( styleCount + grow > = styles . length ) { tStyleRange [ ] tmpStyles = new StyleRange [ styles . length + grow + GROW ] ; tSystem . arraycopy ( styles , 0 , tmpStyles , 0 , modifyStart ) ; if ( styleCount > modifyEnd ) { tSystem . arraycopy ( styles , modifyEnd , tmpStyles , modifyStart + mergeCount , styleCount - modifyEnd ) ; } tstyles = tmpStyles ; } else { if ( styleCount > modifyEnd ) { tSystem . arraycopy ( styles , modifyEnd , styles , modifyStart + mergeCount , styleCount - modifyEnd ) ; } } if ( MERGE_STYLES ) { tint j = modifyStart ; tfor ( int i = 0 ; i < mergeCount ; i + + ) { tStyleRange newStyle = mergeStyles [ i ] , style ; if ( j > 0 & & ( style = styles [ j - 1 ] ) . start + style . length = = newStyle . start & & newStyle . similarTo ( style ) ) { tstyle . length + = newStyle . length ; } else { tstyles [ j + + ] = newStyle ; } } tStyleRange style = styles [ j - 1 ] ; if ( endStyle ! = null & & style . start + style . length = = endStyle . start & & endStyle . similarTo ( style ) ) { tstyle . length + = endStyle . length ; modifyEnd + + ; tmergeCount + + ; } if ( styleCount > modifyEnd ) { tSystem . arraycopy ( styles , modifyStart + mergeCount , styles , j , styleCount - modifyEnd ) ; } tgrow = ( j - modifyStart ) - ( modifyEnd - modifyStart ) ; } else { tSystem . arraycopy ( mergeStyles , 0 , styles , modifyStart , mergeCount ) ; } tstyleCount + = grow ; treturn grow ; } 
tvoid setStyleRanges ( int [ ] newRanges , StyleRange [ ] newStyles ) { if ( newStyles = = null ) { tstylesSetCount = styleCount = 0 ; tranges = null ; tstyles = null ; tstylesSet = null ; thasLinks = false ; treturn ; } if ( newRanges = = null & & COMPACT_STYLES ) { tnewRanges = new int [ newStyles . length < < 1 ] ; tStyleRange [ ] tmpStyles = new StyleRange [ newStyles . length ] ; if ( stylesSet = = null ) stylesSet = new StyleRange [ 4 ] ; tfor ( int i = 0 , j = 0 ; i < newStyles . length ; i + + ) { tStyleRange newStyle = newStyles [ i ] ; tnewRanges [ j + + ] = newStyle . start ; tnewRanges [ j + + ] = newStyle . length ; tint index = 0 ; twhile ( index < stylesSetCount ) { if ( stylesSet [ index ] . similarTo ( newStyle ) ) break ; tindex + + ; } if ( index = = stylesSetCount ) { if ( stylesSetCount = = stylesSet . length ) { tStyleRange [ ] tmpStylesSet = new StyleRange [ stylesSetCount + 4 ] ; tSystem . arraycopy ( stylesSet , 0 , tmpStylesSet , 0 , stylesSetCount ) ; tstylesSet = tmpStylesSet ; } tstylesSet [ stylesSetCount + + ] = newStyle ; } ttmpStyles [ i ] = stylesSet [ index ] ; } tnewStyles = tmpStyles ; } if ( styleCount = = 0 ) { if ( newRanges ! = null ) { tranges = new int [ newRanges . length ] ; tSystem . arraycopy ( newRanges , 0 , ranges , 0 , ranges . length ) ; } tstyles = new StyleRange [ newStyles . length ] ; tSystem . arraycopy ( newStyles , 0 , styles , 0 , styles . length ) ; tstyleCount = newStyles . length ; treturn ; } if ( newRanges ! = null & & ranges = = null ) { tranges = new int [ styles . length < < 1 ] ; tfor ( int i = 0 , j = 0 ; i < styleCount ; i + + ) { tranges [ j + + ] = styles [ i ] . start ; tranges [ j + + ] = styles [ i ] . length ; } } if ( newRanges = = null & & ranges ! = null ) { tnewRanges = new int [ newStyles . length < < 1 ] ; tfor ( int i = 0 , j = 0 ; i < newStyles . length ; i + + ) { tnewRanges [ j + + ] = newStyles [ i ] . start ; tnewRanges [ j + + ] = newStyles [ i ] . length ; } } if ( ranges ! = null ) { tint rangeCount = styleCount < < 1 ; 
tvoid updateRanges ( int start , int replaceCharCount , int newCharCount ) { if ( styleCount = = 0 | | ( replaceCharCount = = 0 & & newCharCount = = 0 ) ) return ; if ( ranges ! = null ) { tint rangeCount = styleCount < < 1 ; 
tvoid reset ( ) { tstylesSetCount = styleCount = 0 ; tranges = null ; tstyles = null ; tstylesSet = null ; thasLinks = false ; } 
public void lineGetStyle ( LineStyleEvent event ) { if ( event = = null | | event . lineText = = null | | event . lineText . length ( ) = = 0 ) return ; int length = event . lineText . length ( ) ; StyleRange [ ] styles = logPanelStyleCache . getStyleRanges ( event . lineOffset , length , true ) ; if ( styles ! = null & & styles . length > 0 ) { event . styles = styles ; 
public Object execute ( ExecutionEvent event ) throws ExecutionException { } 
protected IStatus run ( IProgressMonitor monitor ) { try { final int replServerPort = CCWPlugin . getDefault ( ) . getREPLServerPort ( ) ; 
@Override public void run ( ) { ttry { tREPLView . connect ( " nrepl:127.0.0.1: " + replServerPort , true ) ; 
private static void inUIThreadSetREPLConnection ( SafeConnection repl ) { tIWorkbenchWindow activeWorkbenchWindow = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( activeWorkbenchWindow = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activeWorkbenchWindow is null " ) ; treturn ; } tIWorkbenchPage activePage = activeWorkbenchWindow . getActivePage ( ) ; if ( activePage = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . REPL , " activePage is null " ) ; } tNamespaceBrowser co = null ; if ( activePage ! = null ) { tIViewPart [ ] views = activePage . getViews ( ) ; tfor ( IViewPart v : views ) { if ( NamespaceBrowser . class . isInstance ( v ) ) { tco = ( NamespaceBrowser ) v ; tbreak ; } } } if ( co = = null ) { treturn ; } tco . reset ( repl ) ; } 
private void initInjections ( BundleContext bundleContext ) { IEclipseContext c = EclipseContextFactory . getServiceContext ( bundleContext ) ; ClojureInvoker . newInvoker ( this , " ccw.editors.clojure.hover-support " ) . _ ( " init-injections " , c ) ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id = = null ) ? 0 : id . hashCode ( ) ) ; return result ; } 
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; HoverDescriptor other = ( HoverDescriptor ) obj ; if ( id = = null ) { if ( other . id ! = null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; return true ; } 
public String toString ( ) { return " {id: " + id + " , label: " + label + " , enabled: " + enabled + " , stateMask: " + stateMask + " , modifierString: " + modifierString + " , description: " + description + " } " ; 
tIObservableList observableHoverDescriptors ( ) ; tvoid persistHoverDescriptors ( List < HoverDescriptor > descriptors ) ; } 
public void init ( IWorkbench workbench ) { setPreferenceStore ( CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ) ; } 
public Control createContents ( Composite parent ) { ScrolledPageContent scrolled = new ScrolledPageContent ( parent , SWT . H_SCROLL | SWT . V_SCROLL ) ; scrolled . setExpandHorizontal ( true ) ; scrolled . setExpandVertical ( true ) ; Composite cointainerComposite = new Composite ( scrolled , SWT . NONE ) ; FillLayout fillLayout = new FillLayout ( SWT . VERTICAL ) ; cointainerComposite . setLayout ( fillLayout ) ; Hover Table Composite hoverComposite = new Composite(cointainerComposite, SWT.NONE); fHoverTableViewer = CheckboxTableViewer.newCheckList(hoverComposite, SWT.H_SCROLL | SWT.V_SCROLL | SWT.SINGLE | SWT.BORDER | SWT.FULL_SELECTION | SWT.CHECK); ColumnViewerToolTipSupport.enableFor(fHoverTableViewer, ToolTip.NO_RECREATE); Cell Editor fHoverModifierStringTextCellEditor = new TextCellEditor(fHoverTableViewer.getTable()); Setup fHoverTableViewer.setUseHashlookup(true); fHoverTableViewer.getTable().setHeaderVisible(true); fHoverTableViewer.getTable().setLinesVisible(true); TableColumnLayout layout = new TableColumnLayout(); hoverComposite.setLayout(layout); TableViewerColumn viewerColumn = new TableViewerColumn(fHoverTableViewer, SWT.NONE); TableColumn column = viewerColumn.getColumn(); column.setText(Messages.HoverPreferencePage_labelColumnTitle); column.setResizable(true); column.setMoveable(true); column.setResizable(true); layout.setColumnData(column, new ColumnWeightData(35, true)); fModifierTableViewerColumn = new TableViewerColumn(fHoverTableViewer, SWT.NONE); column = fModifierTableViewerColumn.getColumn(); column.setText(Messages.HoverPreferencePage_modifierColumnTitle); column.setResizable(true); column.setMoveable(true); layout.setColumnData(column, new ColumnWeightData(25, true)); viewerColumn = new TableViewerColumn(fHoverTableViewer, SWT.NONE); column = viewerColumn.getColumn(); column.setText(Messages.HoverPreferencePage_descriptionColumnTitle); column.setResizable(true); column.setMoveable(true); layout.setColumnData(column, new ColumnWeightData(40, true)); Summary Composite summaryComposite = new Composite(cointainerComposite, SWT.NONE); summaryComposite.setLayout(new FillLayout(SWT.HORIZONTAL)); fGrpSummary = new Group(summaryComposite, SWT.NONE); GridLayout gridLayout = new GridLayout(2, false); gridLayout.marginLeft = 4; gridLayout.marginRight = 4; gridLayout.horizontalSpacing = 8; gridLayout.verticalSpacing = 8; gridLayout.marginTop = 4; gridLayout.marginHeight = 0; gridLayout.marginWidth = 0; fGrpSummary.setLayout(gridLayout); Summary Label fSummaryHoverNameLabel = new Label(fGrpSummary, SWT.HORIZONTAL); GridData fieldLayoutData = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING); fieldLayoutData.widthHint = 120; fSummaryHoverNameLabel.setLayoutData(fieldLayoutData); Summary Modifier String fSummaryHoverModifierStringText = new Text(fGrpSummary, SWT.BORDER); fieldLayoutData = new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING); fieldLayoutData.widthHint = 120; fSummaryHoverModifierStringText.setLayoutData(fieldLayoutData); Summary Description fSummaryHoverDescriptionLabel = new Label(fGrpSummary, SWT.BORDER | SWT.WRAP); fieldLayoutData = new GridData(SWT.FILL, SWT.BEGINNING, true, false); fieldLayoutData.heightHint = 100; fieldLayoutData.horizontalSpan = 2; fSummaryHoverDescriptionLabel.setLayoutData(fieldLayoutData); summaryComposite.pack(); End Summary scrolled.setContent(cointainerComposite); final Point size = cointainerComposite.computeSize(SWT.DEFAULT, SWT.DEFAULT); scrolled.setMinSize(size.x, size.y); Dialog.applyDialogFont(scrolled); initDataBindings(); return scrolled; } 
protected Object calculate ( ) { return Boolean . valueOf ( selectedHover . getValue ( ) ! = null ) ; } 
public void keyPressed ( KeyEvent e ) { boolean isPressedKeyModifier = e . keyCode > 0 & & e . character = = 0 & & ( e . keyCode & SWT . MODIFIER_MASK ) ! = 0 ; boolean isStateKeyModifier = e . stateMask > 0 & & ( e . stateMask & SWT . MODIFIER_MASK ) ! = 0 ; int mask = SWT . NONE ; if ( isPressedKeyModifier ) { mask = e . keyCode ; 
public void keyReleased ( KeyEvent e ) { if ( e . keyCode = = SWT . BS | | e . keyCode = = SWT . DEL ) { stateMaskOfSelected . setValue ( SWT . NONE ) ; 
public boolean performOk ( ) { fModel . persistHoverDescriptors ( fViewModel . hoverObservableList ) ; boolean result = true ; try { Platform . getPreferencesService ( ) . getRootNode ( ) . node ( InstanceScope . SCOPE ) . node ( CCWPlugin . PLUGIN_ID ) . flush ( ) ; } catch ( BackingStoreException e ) { CCWPlugin . logError ( " Saving Preferences failed " , e ) ; result = false ; } return result ; } 
public void handleListChange ( ListChangeEvent event ) { updateCheckedSet ( ( List < HoverDescriptor > ) event . getObservableList ( ) ) ; } 
private void updateCheckedSet ( List < HoverDescriptor > descriptors ) { checkedSet . clear ( ) ; for ( HoverDescriptor hd : descriptors ) { if ( hd . isEnabled ( ) = = Boolean . TRUE ) { 
public Object convert ( Object object ) { Integer stateMask = SWT . DEFAULT ; if ( object instanceof String ) { String s = ( String ) object ; stateMask = s ! = null ? EditorUtility . computeStateMask ( s ) : SWT . NONE ; } return stateMask ; } 
public Object convert ( Object object ) { String modifierString = null ; if ( object instanceof Integer ) { Integer i = ( Integer ) object ; modifierString = EditorUtility . getModifierString ( i ) ; } return modifierString ! = null ? modifierString : " " ; } 
public IStatus validate ( Object modifiers ) { if ( modifiers instanceof String ) { int stateMask = EditorUtility . computeStateMask ( ( String ) modifiers ) ; if ( ! isStateMaskUnique ( stateMask ) ) { return stateMaskError ( stateMask ) ; } } return ValidationStatus . ok ( ) ; } 
public IStatus validate ( Object stateMask ) { if ( stateMask instanceof Integer ) { int sm = ( Integer ) stateMask ; if ( ! isStateMaskUnique ( sm ) ) { return stateMaskError ( sm ) ; } } return ValidationStatus . ok ( ) ; } 
public IStatus stateMaskError ( int stateMask ) { if ( stateMask = = SWT . NONE | | stateMask = = SWT . DEFAULT ) { return ValidationStatus . error ( Messages . HoverPreferencePage_errorDefaultHoverNotUnique ) ; 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringDefault d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( SyntaxColoringHelper . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( SyntaxColoringHelper . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( SyntaxColoringHelper . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void addPropertyChangeListener ( PropertyChangeListener listener ) { tpropertyChangeSupport . addPropertyChangeListener ( listener ) ; } 
public void addPropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { tpropertyChangeSupport . addPropertyChangeListener ( propertyName , listener ) ; } 
public void removePropertyChangeListener ( PropertyChangeListener listener ) { tpropertyChangeSupport . removePropertyChangeListener ( listener ) ; } 
public void removePropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { tpropertyChangeSupport . removePropertyChangeListener ( propertyName , listener ) ; } 
protected void firePropertyChange ( String propertyName , Object oldValue , Object newValue ) { tpropertyChangeSupport . firePropertyChange ( propertyName , oldValue , newValue ) ; } 
public static int computeStateMask ( @Nullable String modifiers ) { if ( modifiers = = null ) { return SWT . DEFAULT ; } if ( modifiers . length ( ) = = 0 ) { return SWT . NONE ; } int stateMask = 0 ; StringTokenizer modifierTokenizer = new StringTokenizer ( modifiers , " ,;.:+-* " ) ; $NON-NLS-1$ while (modifierTokenizer.hasMoreTokens()) { int modifier= findLocalizedModifier(modifierTokenizer.nextToken()); if (modifier == 0 || (stateMask & modifier) == modifier) { return SWT.DEFAULT; } stateMask= stateMask | modifier; } return stateMask; } 
public static int findLocalizedModifier ( @Nullable String modifierName ) { if ( modifierName = = null ) { return 0 ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . CTRL ) ) ) { return SWT . CTRL ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . SHIFT ) ) ) { return SWT . SHIFT ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . ALT ) ) ) { return SWT . ALT ; } if ( modifierName . equalsIgnoreCase ( Action . findModifierString ( SWT . COMMAND ) ) ) { return SWT . COMMAND ; } return 0 ; } 
private static String appendModifierString ( @Nullable String modifierString , int modifier ) { if ( modifierString = = null ) { modifierString = " " ; $NON-NLS-1$ } String newModifierString= Action.findModifierString(modifier); if (modifierString.length() == 0) { return newModifierString; } return String.format("%s + %s", modifierString, newModifierString); } 
public @Nullable REPLView getCorrespondingREPL ( ) { return sourceViewer ( ) . getCorrespondingREPL ( ) ; } 
public @Nullable REPLView getCorrespondingREPL ( ) { Experiment: always return the active REPL instead of a potentially better match being a REPL started from same project as the file IFile file = (IFile) getEditorInput().getAdapter(IFile.class); if (file != null) { REPLView repl = CCWPlugin.getDefault().getProjectREPL(file.getProject()); if (repl != null) { return repl; } } Last resort : we return the current active REPL, if any return REPLView.activeREPL.get(); } 
void selectAndReveal ( int start , int length ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isStructuralEditingEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void markDamagedAndRedraw();boolean isForceRepair();} 
boolean isInEscapeSequence ( ) ; } 
IRegion getUnSignedSelection ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
String findDeclaringNamespace ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
Object getPreviousParseTree ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
@Nullable SafeConnection getSafeToolingConnection ( ) ; void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
tvoid toggleShowRainbowParens ( ) ; tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; } 
public void init ( IWorkbench workbench ) { AR - Note: init() will always be called once, the constructor can be called multiple times ContextInjectionFactory.inject(this, CCWPlugin.getEclipseContext()); fViewModel = new HoverViewModel(fModel); setPreferenceStore(CCWPlugin.getDefault().getPreferenceStore()); } 
public void handleChange ( ChangeEvent event ) { checkedBindSet . updateModelToTarget ( ) ; } 
public void contributeToMenu ( IMenuManager menu ) { tsuper . contributeToMenu ( menu ) ; tIMenuManager editMenu = menu . findMenuUsingPath ( IWorkbenchActionConstants . M_EDIT ) ; if ( editMenu ! = null ) { editMenu . appendToGroup ( ITextEditorActionConstants . GROUP_INFORMATION , showInformationAction ) ; 
public IInformationControl createInformationControl ( Shell parent ) { treturn new DefaultInformationControl ( parent , false ) ; } 
protected @Nullable ToolBarManager toolBarManager ( ) { return null ; } 
protected String symbolicFontName ( ) { return StaticStrings . CCW_HOVER_FONT ; } 
public boolean canReuse ( IInformationControl control ) { if ( ! super . canReuse ( control ) ) return false ; if ( control instanceof IInformationControlExtension4 ) { ( ( IInformationControlExtension4 ) control ) . setStatusText ( UiUtils . getTooltipAffordanceString ( ) ) ; } return true ; } 
public IInformationControl doCreateInformationControl ( Shell parent ) { if ( BrowserInformationControl . isAvailable ( parent ) ) { BrowserInformationControl iControl = new BrowserInformationControl ( parent , symbolicFontName ( ) , toolBarManager ( ) ) ; 
public Object convert ( Object object ) { Integer stateMask = SWT . DEFAULT ; if ( object instanceof String ) { String s = ( String ) object ; stateMask = s ! = null ? UiUtils . computeStateMask ( s ) : SWT . NONE ; } return stateMask ; } 
public Object convert ( Object object ) { String modifierString = null ; if ( object instanceof Integer ) { Integer i = ( Integer ) object ; modifierString = UiUtils . getModifierString ( i ) ; } return modifierString ! = null ? modifierString : " " ; } 
public IStatus validate ( Object modifiers ) { if ( modifiers instanceof String ) { int stateMask = UiUtils . computeStateMask ( ( String ) modifiers ) ; if ( ! isStateMaskUnique ( stateMask ) ) { return stateMaskError ( stateMask ) ; } } return ValidationStatus . ok ( ) ; } 
private static @Nullable String appendModifierString ( @Nullable String modifierString , int modifier ) { if ( modifierString = = null ) { modifierString = " " ; $NON-NLS-1$ } String newModifierString= Action.findModifierString(modifier); if (modifierString.length() == 0) { return newModifierString; } return String.format("%s + %s", modifierString, newModifierString); } 
private static RGB blend ( @NonNull RGB bg , @NonNull RGB fg , float factor ) { copy of org.eclipse.jface.internal.text.revisions.Colors#blend(..) Assert.isLegal(bg != null); Assert.isLegal(fg != null); Assert.isLegal(factor >= 0f && factor <= 1f); float complement= 1f - factor; return new RGB( (int) (complement * bg.red + factor * fg.red), 
public void handleEvent ( Event event ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . LOG_INFO , " App startup complete, launching user plugins " ) ; tlaunchUserPluginsWithinJob ( app ) ; } 
private void launchUserPluginsWithinJob ( final MApplication app ) { tJob j = new WorkspaceJob ( " CCW User Plugins launcher " ) { @Override public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { ttry { tBundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; tClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; te4Model . _ ( " application! " , app ) ; tClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; tuserPlugins . _ ( " start-user-plugins " ) ; } catch ( CoreException e ) { treturn CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } treturn Status . OK_STATUS ; } } ; tj . setUser ( false ) ; tj . schedule ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { ttry { tBundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; tClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; te4Model . _ ( " application! " , app ) ; tClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; tuserPlugins . _ ( " start-user-plugins " ) ; } catch ( CoreException e ) { treturn CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } treturn Status . OK_STATUS ; } 
public synchronized static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) tthrows RuntimeException { if ( DisplayUtil . isUIThread ( ) ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " should not be called from UI Tread " ) ; tCCWPlugin . getTracer ( ) . traceDumpStack ( TraceOptions . CLOJURE_OSGI ) ; } tinitialize ( ) ; tClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; tfinal URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . toArray ( new URL [ additionalURLs . size ( ) ] ) ; tURLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
private synchronized void createColorCache ( ) { if ( colorCache = = null ) { colorCache = PlatformUI . getWorkbench ( ) . getThemeManager ( ) . getCurrentTheme ( ) . getColorRegistry ( ) ; 
private static void ensureColorInCache ( ColorRegistry registry , String id , RGB rgb ) { if ( ! registry . hasValueFor ( id ) ) { registry . put ( id , rgb ) ; 
public static void registerEditorColors ( IPreferenceStore store ) { final ColorRegistry colorCache = getDefault ( ) . getColorCache ( ) ; for ( Keyword token : PreferenceConstants . colorizableTokens ) { tPreferenceConstants . ColorizableToken tokenStyle = PreferenceConstants . getColorizableToken ( store , token ) ; 
void addPropertyChangeListener ( IPropertyChangeListener listener ) ; void removePropertyChangeListener ( IPropertyChangeListener listener ) ; } 
private ClojureSourceViewerConfiguration createClojureSourceViewerConfiguration ( ) { return new ClojureSourceViewerConfiguration ( getPreferenceStore ( ) , this ) ; } 
protected void initializeViewerColors ( ISourceViewer viewer ) { sourceViewer ( ) . initializeViewerColors ( ) ; } 
protected void updateStatusField ( String category ) { if ( ClojureSourceViewer . STATUS_CATEGORY_STRUCTURAL_EDITION . equals ( category ) ) { sourceViewer ( ) . updateStructuralEditingModeStatusField ( ) ; 
public boolean isInEscapeSequence ( ) { return sourceViewer ( ) . isInEscapeSequence ( ) ; } 
protected void createActions ( ) { tsuper . createActions ( ) ; 
public void run ( ) { sourceViewer ( ) . updateStructuralEditingModeStatusField ( ) ; } 
public IRegion getUnSignedSelection ( ) { return sourceViewer ( ) . getUnSignedSelection ( ) ; } 
public IRegion getSignedSelection ( ) { return sourceViewer ( ) . getSignedSelection ( ) ; } 
public String findDeclaringNamespace ( ) { treturn sourceViewer ( ) . findDeclaringNamespace ( ) ; } 
public REPLView getCorrespondingREPL ( ) { treturn sourceViewer ( ) . getCorrespondingREPL ( ) ; } 
public final @NonNull ClojureSourceViewer sourceViewer ( ) { return ( ClojureSourceViewer ) super . getSourceViewer ( ) ; } 
public void initializeViewerColors ( ) { sourceViewer ( ) . initializeViewerColors ( ) ; } 
public void configure ( SourceViewerConfiguration configuration ) { super . configure ( configuration ) ; initializeViewerColors ( ) ; fConfiguration = ( SimpleSourceViewerConfiguration ) configuration ; fSelectionHistory = new SelectionHistory ( this ) ; AR - In order to respect the configure/unconfigure life-cycle while propagating and refreshing I need to do this little trick addPropertyChangeListener(fConfiguration); } 
public void initializeViewerColors ( ) { tinitializeViewerColors ( getTextWidget ( ) , fPreferenceStore , editorColors ) ; AR - it has to be initialized before SourceViewerConfiguration or 
public void unconfigure ( ) { removePropertyChangeListener ( fConfiguration ) ; if ( fSelectionHistory ! = null ) { fSelectionHistory . dispose ( ) ; fSelectionHistory = null ; } super . unconfigure ( ) ; fConfiguration = null ; } 
public @Nullable REPLView getCorrespondingREPL ( ) { this gets overridden in REPLView as appropriate so that the toolConnection there gets returned return null; } 
public @Nullable SafeConnection getSafeToolingConnection ( ) { this gets overridden in REPLView as appropriate so that the toolConnection there gets returned return null; } 
public void markDamagedAndRedraw ( ) { isForceRepair = true; 
public void addPropertyChangeListener ( IPropertyChangeListener listener ) { fPreferenceStore . addPropertyChangeListener ( listener ) ; } 
public void removePropertyChangeListener ( IPropertyChangeListener listener ) { fPreferenceStore . removePropertyChangeListener ( listener ) ; } 
public IInformationControlCreator getInformationControlCreator ( ISourceViewer sourceViewer ) { return new IInformationControlCreator ( ) { public IInformationControl createInformationControl ( Shell parent ) { 
public IInformationControl createInformationControl ( Shell parent ) { return new DefaultInformationControl ( parent , new HTMLTextPresenter ( ) ) ; 
void selectAndReveal ( int start , int length ) ; void initializeViewerColors();} 
boolean isStructuralEditingEnabled ( ) ; void initializeViewerColors();} 
boolean isEscapeInStringLiteralsEnabled ( ) ; void initializeViewerColors();} 
boolean isInEscapeSequence ( ) ; void initializeViewerColors();} 
IRegion getUnSignedSelection ( ) ; tvoid initializeViewerColors ( ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid initializeViewerColors ( ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; tvoid initializeViewerColors ( ) ; } 
ISelectionProvider getSelectionProvider ( ) ; tvoid initializeViewerColors ( ) ; } 
String findDeclaringNamespace ( ) ; tvoid initializeViewerColors ( ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid initializeViewerColors ( ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; tvoid initializeViewerColors ( ) ; } 
Object getPreviousParseTree ( ) ; tvoid initializeViewerColors ( ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; tvoid initializeViewerColors ( ) ; } 
@Nullable SafeConnection getSafeToolingConnection ( ) ; tvoid initializeViewerColors ( ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tvoid toggleShowRainbowParens ( ) ; tvoid initializeViewerColors ( ) ; } 
tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; tvoid initializeViewerColors ( ) ; } 
tboolean isForceRepair ( ) ; tvoid initializeViewerColors ( ) ; } 
private Pair < Collection < ITokenScanner > , Collection < IPropertyChangeListener > > initScanners ( ) { Collection < IPropertyChangeListener > listeners = new ArrayList < > ( ) ; Collection < ITokenScanner > scanners = new ArrayList < > ( ) ; ITokenScanner scanner = new ClojureTokenScanner ( CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) , editor ) ; listeners . add ( ( IPropertyChangeListener ) scanner ) ; scanners . add ( scanner ) ; return new Pair < Collection < ITokenScanner > , Collection < IPropertyChangeListener > > ( Collections . unmodifiableCollection ( scanners ) , Collections . unmodifiableCollection ( listeners ) ) ; 
public void propertyChange ( PropertyChangeEvent event ) { for ( IPropertyChangeListener listener : propertyChangeListeners ) { listener . propertyChange ( event ) ; 
protected void addDamagerRepairerForContentType ( PresentationReconciler reconciler , String contentType ) { IPresentationDamager d = new ClojureTopLevelFormsDamager ( editor ) ; reconciler . setDamager ( d , contentType ) ; for ( ITokenScanner scanner : tokenScanners ) { IPresentationRepairer r = new DefaultDamagerRepairer ( scanner ) ; 
public IPresentationReconciler getPresentationReconciler ( ISourceViewer sourceViewer ) { PresentationReconciler reconciler = new PresentationReconciler ( ) ; reconciler . setDocumentPartitioning ( getConfiguredDocumentPartitioning ( sourceViewer ) ) ; addDamagerRepairerForContentType ( reconciler , IDocument . DEFAULT_CONTENT_TYPE ) ; return reconciler ; } 
protected void initClojureTokenTypeToJFaceTokenMap ( TokenScannerUtils u ) { tu . addTokenType ( Keyword . intern ( " unexpected " ) , ClojureTokenScanner . errorToken ) ; tu . addTokenType ( Keyword . intern ( " eof " ) , Token . EOF ) ; tu . addTokenType ( Keyword . intern ( " whitespace " ) , Token . WHITESPACE ) ; tfor ( Keyword token : PreferenceConstants . colorizableTokens ) { tPreferenceConstants . ColorizableToken tokenStyle = PreferenceConstants . getColorizableToken ( preferenceStore , token ) ; 
public final void addTokenType ( Keyword tokenIndex , org . eclipse . jface . text . rules . IToken token ) { parserTokenKeywordToJFaceToken . put ( tokenIndex , token ) ; } 
public final void addTokenType ( Keyword tokenIndex , TextAttribute textAttribute ) { addTokenType ( tokenIndex , new org . eclipse . jface . text . rules . Token ( textAttribute ) ) ; } 
private void printSetRange ( String name , IDocument document , int offset , int length ) { tSystem . out . println ( " setRange() called on " + name ) ; tSystem . out . println ( " offset: " + offset ) ; tSystem . out . println ( " length: " + length ) ; tSystem . out . println ( " document: " + document ) ; tSystem . out . println ( " --------------------------- " ) ; } 
public static @NonNull IToken adaptToken ( IToken token , String key , Object newValue ) { TextAttribute textAttribute = ( TextAttribute ) token . getData ( ) ; Boolean isBold = ( textAttribute . getStyle ( ) & SWT . BOLD ) = = SWT . BOLD ; Boolean isItalic = ( textAttribute . getStyle ( ) & SWT . ITALIC ) = = SWT . ITALIC ; RGB rgb = textAttribute . getForeground ( ) . getRGB ( ) ; boolean newValueProcessed = false ; if ( PreferenceConstants . isBoldPreferenceKey ( key ) = = Boolean . TRUE ) { if ( newValue instanceof Boolean ) { isBold = ( Boolean ) newValue ; newValueProcessed = true ; } else if ( newValue instanceof String ) { isBold = Boolean . valueOf ( ( String ) newValue ) ; newValueProcessed = true ; } } if ( ! newValueProcessed & & PreferenceConstants . isItalicPreferenceKey ( key ) = = Boolean . TRUE ) { if ( newValue instanceof Boolean ) { isItalic = ( Boolean ) newValue ; newValueProcessed = true ; } else if ( newValue instanceof String ) { isItalic = Boolean . valueOf ( ( String ) newValue ) ; newValueProcessed = true ; } } if ( ! newValueProcessed ) { if ( newValue instanceof RGB ) { rgb = ( ( RGB ) newValue ) ; } else if ( newValue instanceof String ) { rgb = StringConverter . asRGB ( ( String ) newValue ) ; } } return new org . eclipse . jface . text . rules . Token ( TokenScannerUtils . createTokenData ( rgb , isBold , isItalic ) ) ; } 
public void propertyChange ( PropertyChangeEvent event ) { Keyword keyword = PreferenceConstants . guessPreferenceKeyword ( event . getProperty ( ) ) ; if ( PreferenceConstants . colorizableTokens . contains ( keyword ) ) { IToken eclipseToken = parserTokenKeywordToJFaceToken . get ( keyword ) ; 
public static TextAttribute createTokenData ( RGB rgb , Boolean isBold , Boolean isItalic ) { return createTokenData ( StringConverter . asString ( rgb ) , isBold , isItalic ) ; } 
public static TextAttribute createTokenData ( String rgb , Boolean isBold , Boolean isItalic ) { TextAttribute textAttribute ; if ( isBold = = null & & isItalic = = null ) { } 
public void addTokenType ( Keyword tokenIndex , String rgb , Boolean isBold , Boolean isItalic ) { tscanner . addTokenType ( tokenIndex , createTokenData ( rgb , isBold , isItalic ) ) ; } 
public static ITokenScanner tokenScanner ( IClojureEditor clojureEditor , IPreferenceStore store ) { return new ClojureTokenScanner ( CCWPlugin . getDefault ( ) . getDefaultScanContext ( ) , store , clojureEditor ) ; } 
public static @NonNull String stripPreferenceSuffix ( String suffixToStrip , String suffixedTokenkey ) { int categoryIdx = suffixedTokenkey . indexOf ( suffixToStrip ) ; if ( categoryIdx = = - 1 ) { return suffixedTokenkey ; } return suffixedTokenkey . substring ( 0 , categoryIdx ) ; } 
public static @Nullable Keyword guessPreferenceKeyword ( String key ) { AR - If more keyword->string are introduced, more attempts need to be added to this guessing method. Strip bold suffix String stripped = stripPreferenceSuffix(PreferenceConstants.EDITOR_BOLD_SUFFIX, key); Keyword keyword = getTokenColorPreferenceKeyword(stripped); if (keyword != null) { return keyword; } Strip bold suffix stripped = stripPreferenceSuffix(PreferenceConstants.EDITOR_ITALIC_SUFFIX, key); keyword = getTokenColorPreferenceKeyword(stripped); if (keyword != null) { return keyword; } keyword = getTokenColorPreferenceKeyword(key); return keyword; } 
public static Boolean isBoldPreferenceKey ( String key ) { return key . endsWith ( PreferenceConstants . EDITOR_BOLD_SUFFIX ) ; } 
public static Boolean isItalicPreferenceKey ( String key ) { return key . endsWith ( PreferenceConstants . EDITOR_ITALIC_SUFFIX ) ; } 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringPreference d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( PreferenceConstants . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( PreferenceConstants . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( PreferenceConstants . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void dispose ( ) { if ( fOverlayStore ! = null ) { fOverlayStore . stop ( ) ; fOverlayStore = null ; } super . dispose ( ) ; } 
private OverlayPreferenceStore . OverlayKey [ ] createOverlayStoreKeys ( ) { ArrayList < OverlayPreferenceStore . OverlayKey > overlayKeys = new ArrayList < OverlayPreferenceStore . OverlayKey > ( ) ; for ( String [ ] s : fSyntaxColorListModel ) { overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , s [ 1 ] ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . getBoldPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . STRING , PreferenceConstants . getItalicPreferenceKey ( s [ 1 ] ) ) ) ; overlayKeys . add ( new OverlayPreferenceStore . OverlayKey ( OverlayPreferenceStore . BOOLEAN , PreferenceConstants . getEnabledPreferenceKey ( s [ 1 ] ) ) ) ; } OverlayPreferenceStore . OverlayKey [ ] keys = new OverlayPreferenceStore . OverlayKey [ overlayKeys . size ( ) ] ; return overlayKeys . toArray ( keys ) ; } 
private synchronized static void initialize ( ) { if ( initialized ) return ; tsynchronizedInitialize ( ) ; } 
private synchronized static void synchronizedInitialize ( ) { if ( initialized ) return ; tCCWPlugin plugin = CCWPlugin . getDefault ( ) ; if ( plugin = = null ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " ClojureOSGi.initialize will fail because ccw.core plugin not activated yet " ) ; } tClassLoader loader = new BundleClassLoader ( plugin . getBundle ( ) ) ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode ) tthrows RuntimeException { treturn withBundle ( aBundle , aCode , null ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) tthrows RuntimeException { if ( DisplayUtil . isUIThread ( ) ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " should not be called from UI Tread " ) ; tCCWPlugin . getTracer ( ) . traceDumpStack ( TraceOptions . CLOJURE_OSGI ) ; } tinitialize ( ) ; tClassLoader bundleLoader = new BundleClassLoader ( aBundle ) ; tfinal URL [ ] urls = ( additionalURLs = = null ) ? new URL [ ] { } : additionalURLs . toArray ( new URL [ additionalURLs . size ( ) ] ) ; tURLClassLoader loader = new URLClassLoader ( urls , bundleLoader ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
private static IEditorInput findEditorInput ( tIPackageFragmentRoot packageFragmentRoot , tString searchedPackage , tString searchedFileName ) tthrows JavaModelException { packageFragmentRoot, 
private static String namespaceToPackage ( final String searchedNS ) { tString packagePart = ( searchedNS . contains ( " . " ) ) ? searchedNS . substring ( 0 , searchedNS . lastIndexOf ( " . " ) ) : " " ; treturn packagePart . replace ( '-' , '_' ) ; } 
public static String findDeclaringNamespace ( String sourceText ) { tVar sexp = RT . var ( " paredit.parser " , " sexp " ) ; ttry { treturn findDeclaringNamespace ( ( Map ) sexp . invoke ( sourceText ) ) ; 
private static boolean hasNsCall ( String sourceCode ) { tMatcher matcher = HAS_NS_CALL_PATTERN . matcher ( sourceCode ) ; treturn matcher . find ( ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) tthrows RuntimeException { if ( DisplayUtil . isUIThread ( ) ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI , " should not be called from UI Tread " ) ; tCCWPlugin . getTracer ( ) . traceDumpStack ( TraceOptions . CLOJURE_OSGI ) ; } tinitialize ( ) ; Thread.currentThread().setContextClassLoader(loader); 
public Point computeSizeHint ( ) { AR - this hack is necessary because BrowserInformationControl does not take into consideration <pre> tags during its computation of the displayed widget Point newSizeHint = super.computeSizeHint(); BrowserInformationControlInput input = getInput(); if (input != null) { Document doc = Jsoup.parse(input.getHtml()); Element styleElement = doc.select("style").first(); int preCssPoints = -1; Matcher preCssPointsMatcher = Pattern.compile("pre.*[{].*font-size:[ ]+(\\d+)p").matcher(styleElement.html()); if (preCssPointsMatcher.find()) { try { preCssPoints = Integer.valueOf(preCssPointsMatcher.group(1)); CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> tag points found: " + preCssPoints); } catch (NumberFormatException ex) { CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> NumberFormatException, cannot read from it."); } } AR - Given that we are in *hack-mode*, for the height we will first subtract the estimate calculated with the used font and then sum the one obtained using the Monospace font. Font originalFont = JFaceResources.getFont(fSymbolicFontName); FontData[] monoFd = SWTFontUtils.getMonospacedFont().getFontData(); assertNotNull(monoFd); Font monospaceFont; if (preCssPoints != -1) { monospaceFont = new Font(getShell().getDisplay(), SWTFontUtils.newHeightFontData(monoFd, preCssPoints)); } else { monospaceFont = new Font(getShell().getDisplay(), monoFd); } Elements preElements = doc.getElementsByTag("pre"); for (Element el : preElements) { String txt = el.text(); AR - Estimate with original font Point originalSize = UiUtils.estimateSizeHint(getShell().getDisplay(), originalFont, txt); AR - Jsoup flattens all the tag's texts. Point monospaceSize = UiUtils.estimateSizeHint(getShell().getDisplay(), monospaceFont, txt); AR - Canonical "+ something" as in BrowserInformationControl.computeSizeHint newSizeHint = new Point(Math.max(newSizeHint.x, monospaceSize.x + 16), Math.max(newSizeHint.y, newSizeHint.y - originalSize.y + monospaceSize.y + 8)); } monospaceFont.dispose(); } return newSizeHint; } 
public void run ( ) { synchronized ( MONOSPACED_FONTS ) { MONOSPACED_FONTS . remove ( display ) ; 
public static FontData [ ] newStyleFontData ( @NonNull FontData [ ] fontDatas , int style ) { for ( int i = 0 ; i < fontDatas . length ; i + + ) { fontDatas [ i ] . setStyle ( style ) ; } return fontDatas ; } 
public static FontData [ ] newHeightFontData ( @NonNull FontData [ ] fontDatas , int height ) { for ( int i = 0 ; i < fontDatas . length ; i + + ) { fontDatas [ i ] . setHeight ( height ) ; } return fontDatas ; } 
public static Point estimateSizeHint ( Device device , Font font , String text ) { Fake widget TextLayout t = new TextLayout(device); t.setFont(font); t.setText(text); Rectangle bounds = t.getBounds(); return new Point(bounds.x + bounds.width, bounds.y + bounds.height); } 
public void configure ( SourceViewerConfiguration configuration ) { assert ( configuration instanceof IPropertyChangeListener ) ; super . configure ( configuration ) ; initializeViewerColors ( ) ; fConfiguration = ( IPropertyChangeListener ) configuration ; fSelectionHistory = new SelectionHistory ( this ) ; AR - In order to respect the configure/unconfigure life-cycle while propagating and refreshing I need to do this little trick addPropertyChangeListener(fConfiguration); } 
void selectAndReveal ( int start , int length ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isStructuralEditingEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isEscapeInStringLiteralsEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isInEscapeSequence ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
IRegion getUnSignedSelection ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
String findDeclaringNamespace ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
@Nullable SafeConnection getSafeToolingConnection ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
void updateTabsToSpacesConverter ( ) ; tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tIDocument getDocument ( ) ; tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tvoid setStatusLineErrorMessage ( String msg ) ; tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tvoid gotoMatchingBracket ( ) ; tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tDefaultCharacterPairMatcher getPairsMatcher ( ) ; tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tboolean isStructuralEditionPossible ( ) ; tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tvoid toggleStructuralEditionMode ( ) ; tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tboolean isShowRainbowParens ( ) ; tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tvoid toggleShowRainbowParens ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tvoid markDamagedAndRedraw ( ) ; tboolean isForceRepair ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tboolean isForceRepair ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tvoid initializeViewerColors ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
private void createTestWidget ( ) { fTestWidget = new TextLayout ( getShell ( ) . getDisplay ( ) ) ; Initialize fonts Font font= JFaceResources.getFont(fSymbolicFontName == null ? JFaceResources.DIALOG_FONT : fSymbolicFontName); fTestWidget.setFont(font); fTestWidget.setWidth(-1); Compute and set tab width fTestWidget.setText(" "); $NON-NLS-1$ int tabWidth = fTestWidget.getBounds().width; fTestWidget.setTabs(new int[] { tabWidth }); fTestWidget.setText(""); $NON-NLS-1$ } 
protected void createContent ( Composite parent ) { super . createContent ( parent ) ; createTestWidget ( ) ; } 
protected void handleDispose ( ) { super . handleDispose ( ) ; if ( fTestWidget ! = null ) { fTestWidget . dispose ( ) ; 
private Point estimateSizeHint ( Font font , String text ) { fTestWidget . setFont ( font ) ; fTestWidget . setText ( text ) ; Rectangle bounds = fTestWidget . getBounds ( ) ; does not return minimum width, see https:bugs.eclipse.org/bugs/show_bug.cgi?id=217446 int height = bounds.height; int lineCount= fTestWidget.getLineCount(); int width= 0; for (int i= 0; i < lineCount; i++) { Rectangle rect= fTestWidget.getLineBounds(i); width = Math.max(width, rect.x + rect.width); } fTestWidget.setText(""); return new Point(bounds.x + width + 16, bounds.y + height + 16); } 
public Point computeSizeHint ( ) { AR - this hack is necessary because BrowserInformationControl does not take into consideration <pre> tags during its computation of the displayed widget Point newSizeHint = super.computeSizeHint(); BrowserInformationControlInput input = getInput(); if (input != null) { Document doc = Jsoup.parse(input.getHtml()); Element styleElement = doc.select("style").first(); int preCssPoints = -1; Matcher preCssPointsMatcher = Pattern.compile("pre.*[{].*font-size:[ ]+(\\d+)p").matcher(styleElement.html()); if (preCssPointsMatcher.find()) { try { preCssPoints = Integer.valueOf(preCssPointsMatcher.group(1)); CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> tag points found: " + preCssPoints); } catch (NumberFormatException ex) { CCWPlugin.getTracer().trace(TraceOptions.HOVER_SUPPORT, "CSS <pre> NumberFormatException, cannot read from it."); } } AR - Given that we are in *hack-mode*, for the height we will first subtract the estimate calculated with the used font and then sum the one obtained using the Monospace font. Font originalFont = JFaceResources.getFont(fSymbolicFontName); FontData[] monoFd = SWTFontUtils.getMonospacedFont().getFontData(); assertNotNull(monoFd); Font monospaceFont; if (preCssPoints != -1) { monospaceFont = new Font(getShell().getDisplay(), SWTFontUtils.newHeightFontData(monoFd, preCssPoints)); } else { monospaceFont = new Font(getShell().getDisplay(), monoFd); } Elements preElements = doc.getElementsByTag("pre"); for (Element el : preElements) { String txt = el.text(); AR - Estimate with original font Point originalSize = estimateSizeHint(originalFont, txt); AR - Jsoup flattens all the tag's texts. Point monospaceSize = estimateSizeHint(monospaceFont, txt); AR - Canonical "+ something" as in BrowserInformationControl.computeSizeHint newSizeHint = new Point(Math.max(newSizeHint.x, monospaceSize.x), Math.max(newSizeHint.y, newSizeHint.y - originalSize.y + monospaceSize.y)); } monospaceFont.dispose(); AR - Considering <p> as occuping more than nothing in height Elements pElements = doc.getElementsByTag("p"); AR - Trim for taking into consideration the scrollbars Rectangle trim = computeTrim(); AR - final sum newSizeHint = new Point(newSizeHint.x + trim.width, newSizeHint.y + trim.height + pElements.size() * 6); } return newSizeHint; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) tthrows RuntimeException { tinitialize ( ) ; tDynamicClassLoader loader = getDynamicClassLoader ( aBundle , additionalURLs ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tbindings = bindings . assoc ( RT . USE_CONTEXT_CLASSLOADER , true ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { if ( DisplayUtil . isUIThread ( ) ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI_UI_THREAD , " should not be called from UI Tread " ) ; tCCWPlugin . getTracer ( ) . traceDumpStack ( TraceOptions . CLOJURE_OSGI_UI_THREAD ) ; } if ( alreadyRequiredNamespaces . containsKey ( namespace ) ) { treturn ; } tClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
public Object run ( ) throws Exception { ttry { tClojure . var ( " clojure.core " , " require " ) . invoke ( Clojure . read ( namespace ) ) ; 
public synchronized static void require ( final Bundle bundle , final String namespace ) { if ( DisplayUtil . isUIThread ( ) ) { tCCWPlugin . getTracer ( ) . trace ( TraceOptions . CLOJURE_OSGI_UI_THREAD , " should not be called from UI Tread " ) ; tCCWPlugin . getTracer ( ) . traceDumpStack ( TraceOptions . CLOJURE_OSGI_UI_THREAD ) ; } if ( synchronizedAlreadyRequiredNamespaces . contains ( namespace ) ) { treturn ; } tClojureOSGi . withBundle ( bundle , new RunnableWithException ( ) { @Override 
protected void createActions ( ) { tsuper . createActions ( ) ; 
public @Nullable REPLView getCorrespondingREPL ( ) { } 
void selectAndReveal ( int start , int length ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isStructuralEditingEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isEscapeInStringLiteralsEnabled ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
boolean isInEscapeSequence ( ) ; @Nullable String getTopLevelSExpression(final int caretOffset);} 
IRegion getUnSignedSelection ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IRegion getSignedSelection ( ) ; tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
tSelectionHistory getSelectionHistory ( ) ; ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
ISelectionProvider getSelectionProvider ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
String findDeclaringNamespace ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
IJavaProject getAssociatedProject ( ) ; Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getParseState ( ) ; Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
Object getPreviousParseTree ( ) ; @Nullable String getTopLevelSExpression ( final int caretOffset ) ; } 
@Nullable REPLView getCorrespondingREPL ( ) ; @Nullable SafeConnection getSafeToolingConnection ( ) ; } 
private DropTarget hookUrlTransfer ( final Shell c , tDropTargetListener dropTargetListener ) { tDropTarget target = findDropTarget ( c ) ; if ( target ! = null ) { } 
private void hookRecursive ( Control c , DropTargetListener dropTargetListener ) { tDropTarget target = findDropTarget ( c ) ; if ( target ! = null ) { } 
private boolean dropTargetIsValid ( DropTargetEvent e ) { treturn FileTransfer . getInstance ( ) . isSupportedType ( e . currentDataType ) | | URLTransfer . getInstance ( ) . isSupportedType ( e . currentDataType ) ; } 
public static SWTBotShell activateShell ( SWTBot bot , String shell ) { tSWTBotShell s = bot . shell ( shell ) ; ts . activate ( ) ; treturn s ; } 
public void run ( IProgressMonitor monitor ) throws CoreException { } } 
public static SWTBot createClojureProject ( SWTWorkbenchBot bot , String projectName ) throws Exception { tmenu ( bot , " File " , " New " , " Project... " ) . click ( ) ; treturn fillNewProject ( bot , projectName ) ; } 
public static SWTBot fillNewProject ( SWTBot bot , String projectName ) throws Exception { tbot = activateShell ( bot , " New Project " ) . bot ( ) ; tbot . tree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; tbot . button ( " Next > " ) . click ( ) ; tbot . textWithLabel ( " Project name: " ) . setText ( projectName ) ; tbot . textWithId ( " location " ) . setText ( ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getLocation ( ) . toOSString ( ) ) ; tbot . button ( " Finish " ) . click ( ) ; twaitForWorkspace ( ) ; treturn bot ; } 
public static void setupClass ( ) throws Exception { tbot = eclipseBot ( ) ; tcloseWelcome ( bot ) ; } 
public void canCreateANewClojureProject ( ) throws Exception { tcreateClojureProject ( bot , " my-first-clojure-project " ) ; tassertProjectExists ( bot , " my-first-clojure-project " ) ; } 
public SWTWorkbenchBot eclipseBot ( ) { tSWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; treturn bot ; } 
public BotUtils openJavaPerspective ( ) { tcloseWelcome ( ) ; tbot . perspectiveByLabel ( " Java " ) . activate ( ) ; treturn this ; } 
public BotUtils closeWelcome ( ) { ttry { tSWTBotView v = bot . viewByTitle ( " Welcome " ) ; if ( v ! = null ) { tv . close ( ) ; } } catch ( Exception e ) { 
public SWTBotMenu menu ( String menu , String . . . subMenus ) { tSWTBotMenu ret = bot . menu ( menu ) ; tfor ( String subMenu : subMenus ) { tret = ret . menu ( subMenu ) ; } treturn ret ; } 
public BotUtils activateShell ( String shell ) { tSWTBotShell s = bot . shell ( shell ) ; ts . activate ( ) ; treturn this ; } 
public void run ( IProgressMonitor monitor ) throws CoreException { } 
public BotUtils createClojureProject ( String projectName ) throws Exception { tmenu ( " File " , " New " , " Project... " ) . click ( ) ; treturn fillNewProject ( bot , projectName ) ; } 
public BotUtils fillNewProject ( SWTBot bot , String projectName ) throws Exception { tbot = activateShell ( " New Project " ) . bot ( ) ; tbot . tree ( ) . expandNode ( " Clojure " ) . select ( " Clojure Project " ) ; tbot . button ( " Next > " ) . click ( ) ; tbot . textWithLabel ( " Project name: " ) . setText ( projectName ) ; tbot . textWithId ( " location " ) . setText ( ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getLocation ( ) . toOSString ( ) ) ; tbot . button ( " Finish " ) . click ( ) ; twaitForWorkspace ( ) ; treturn this ; } 
public BotUtils assertProjectExists ( String projectName ) { tSWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; tSWTBotTree projectsTree = packageExplorer . bot ( ) . tree ( ) ; tprojectsTree . expandNode ( projectName ) ; treturn this ; } 
public void canCreateANewClojureProject ( ) throws Exception { tbot . createClojureProject ( " editor-test " ) ; tfinal IFile f = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getFile ( new Path ( " editor-test/src/editor_test/core.clj " ) ) ; tDisplayUtil . syncExec ( new Runnable ( ) { @Override public void run ( ) { 
@Override public void run ( ) { tIEditorPart ep ; ttry { tep = IDE . openEditor ( bot . bot ( ) . activeView ( ) . getReference ( ) . getPage ( ) , f ) ; 
public void canCreateANewClojureProject ( ) throws Exception { tbot . createClojureProject ( " my-first-clojure-project " ) 
private static void initialize ( ) { if ( initialized ) return ; tsynchronizedInitialize ( ) ; } 
public static boolean canLoadCodeInBundle ( ) { CCWPlugin plugin = CCWPlugin . getDefault ( ) ; return ( plugin ! = null & & plugin . bundleState = = Bundle . ACTIVE ) ; } 
public static Object withBundle ( Bundle aBundle , RunnableWithException aCode , List < URL > additionalURLs ) tthrows RuntimeException { if ( Thread . currentThread ( ) . isInterrupted ( ) | | CCWPlugin . canLoadCodeInBundle ( ) ) { treturn null ; } tinitialize ( ) ; tDynamicClassLoader loader = getDynamicClassLoader ( aBundle , additionalURLs ) ; tIPersistentMap bindings = RT . map ( Compiler . LOADER , loader ) ; tbindings = bindings . assoc ( RT . USE_CONTEXT_CLASSLOADER , true ) ; tboolean pushed = true ; tClassLoader saved = Thread . currentThread ( ) . getContextClassLoader ( ) ; ttry { tThread . currentThread ( ) . setContextClassLoader ( loader ) ; 
protected void launchProjectCheckRunning ( final IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , IWithREPLView runOnceREPLAvailable ) { tassert mode ! = null ; tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; tSystem . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
@Override public void run ( ) { tIViewPart replView = CCWPlugin . getDefault ( ) . getProjectREPL ( project ) ; if ( replView ! = null ) { treplView . getViewSite ( ) . getPage ( ) . activate ( replView ) ; 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , Messages . ClojureGeneralPreferencePage_use_leiningen_launcher , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , Messages . ClojureGeneralPreferencePage_use_cider_nrepl , getFieldEditorParent ( ) ) ) ; addField ( tnew FileFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringPreference d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( PreferenceConstants . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( PreferenceConstants . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( PreferenceConstants . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
private boolean isUseCiderNrepl ( ) { treturn CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL ) ; } 
private File getCCWPluginDirectory ( ) throws IOException , WorkbenchException { File ccwPluginDir = FileLocator . getBundleFile ( CCWPlugin . getDefault ( ) . getBundle ( ) ) ; CCWPlugin . getTracer ( ) . trace ( TraceOptions . LAUNCHER , " ccwPluginDir: " + ccwPluginDir ) ; if ( ccwPluginDir . isFile ( ) ) { tthrow new WorkbenchException ( " Bundle ccw.core cannot be returned as a file. " ) ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { tString injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.1 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; tString injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " launch._("launch-configuration", configMap); 
protected String name ( ) { String name = mainPage . text . getText ( ) . trim ( ) . replaceAll ( " - " , " _ " ) ; name = name.substring(0, name.length() - (".cljx").length()); } return name; } 
private String extractExtension ( List < String > parts ) { tString extension ; tfinal String lastPart = parts . get ( parts . size ( ) - 1 ) ; if ( clojureEditorExtensions . contains ( lastPart ) ) { textension = parts . remove ( parts . size ( ) - 1 ) ; } else { textension = " clj " ; } treturn extension ; } 
private String extractExtension ( List < String > parts ) { tString extension ; tfinal String lastPart = parts . get ( parts . size ( ) - 1 ) ; if ( wizard . _ ( " clojure-editor-extensions " , lastPart ) ! = null ) { textension = parts . remove ( parts . size ( ) - 1 ) ; } else { textension = " clj " ; } treturn extension ; } 
public boolean performFinish ( ) { tfinal String userInput = mainPage . text . getText ( ) . trim ( ) ; tfinal List < String > unmungedParts = new ArrayList < String > ( Arrays . asList ( userInput . split ( " \\ . " ) ) ) ; tfinal String extension = extractExtension ( unmungedParts ) ; tfinal String namespace = CollectionUtils . join ( unmungedParts , " . " ) ; tfinal List < String > parts = mungeParts ( unmungedParts ) ; final String msg = checkNamespacename ( parts ) ; if ( msg ! = null ) { tmainPage . setErrorMessage ( msg ) ; treturn false ; } final IPath path = ccw . util . ResourceUtil . createPathFromList ( parts ) . addFileExtension ( extension ) ; final IFile file = mainPage . javaSourceFolder . getFile ( path ) ; if ( file . exists ( ) ) { mainPage . setErrorMessage ( " Namespace " + namespace + " already exists. " ) ; return false ; } try { tfinal String content = content ( namespace , extension ) ; tccw . util . ResourceUtil . createMissingParentFolders ( file ) ; file . create ( stringToStream ( content ( namespace , extension ) , ResourcesPlugin . getEncoding ( ) ) , true , null ) ; IWorkbenchWindow dw = getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( dw ! = null ) { IWorkbenchPage page = dw . getActivePage ( ) ; if ( page ! = null ) { TextEditor editor = ( TextEditor ) IDE . openEditor ( page , file , true ) ; editor . selectAndReveal ( content . length ( ) , 0 ) ; } } } catch ( CoreException e ) { CCWPlugin . logError ( e ) ; return false ; } return true ; } 
private String content ( String namespace , String extension ) { treturn ( String ) wizard . _ ( " content " , namespace , extension ) ; } 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; tfinal Pair < Object , IWithREPLView > o = ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . get ( launchName ) ; tCCWPlugin . log ( " reading in launchNameREPLURLPromiseAndWithREPLView the key: " + launchName ) ; if ( o = = null | | o . e1 = = null ) { tCCWPlugin . log ( " No REPL required for launch " + launchName + " o = " + o ) ; 
public void launch ( ILaunchConfiguration configuration , String mode , final ILaunch launch , IProgressMonitor monitor ) throws CoreException { tLaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; tBoolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( activateAutoReload ) ) ; tfinal String name = configuration . getName ( ) ; tClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . put ( name , new Pair < Object , IWithREPLView > ( promise ( ) , null ) ) ; tCCWPlugin . log ( " putting in launchNameREPLURLPromiseAndWithREPLView the key: " + name ) ; BundleUtils . requireAndGetVar ( CCWPlugin . getDefault ( ) . getBundle ( ) . getSymbolicName ( ) , " clojure.tools.nrepl.ack/reset-ack-port! " ) . invoke ( ) ; try { Var . pushThreadBindings ( RT . map ( currentLaunch , launch ) ) ; 
protected org . eclipse . core . runtime . IStatus run ( final IProgressMonitor monitor ) { final String launchName = launch . getLaunchConfiguration ( ) . getName ( ) ; tfinal Pair < Object , IWithREPLView > o = ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . get ( launchName ) ; tCCWPlugin . log ( " reading in launchNameREPLURLPromiseAndWithREPLView the key: " + launchName ) ; if ( o = = null | | o . e1 = = null ) { tCCWPlugin . log ( " No REPL required for launch " + launchName + " o = " + o ) ; 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; tString injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.1.1 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; tString injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { launch._("launch-configuration", configMap); 
private static boolean openExternalFileInEditor ( final String searchedNS , final String initialSearchedFileName , final int line , tIFileStore store ) throws PartInitException { if ( initialSearchedFileName = = null ) { treturn false ; } tCCWPlugin . log ( " searched ns : " + searchedNS ) ; tIEditorPart editor = IDE . openInternalEditorOnFileStore ( CCWPlugin . getActivePage ( ) , store ) ; tgotoEditorLine ( editor , line ) ; treturn false ; } 
public void connect ( IDocument document , boolean delayInitialization ) { super . connect ( document , delayInitialization ) ; printPartitions ( document ) ; } 
private void printPartitions ( IDocument document ) { ITracer tracer = CCWPlugin . getTracer ( ) ; if ( tracer . isEnabled ( TraceOptions . PARTITIONERS ) ) { 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; tString injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.0 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; tString injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; tString injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.0 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; tString injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; tString injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.0 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; tString injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
private boolean isInstallClojure1_6_print_object_hack ( ) { treturn CCWPlugin . getDefault ( ) . getCombinedPreferenceStore ( ) . getBoolean ( PreferenceConstants . CCW_GENERAL_USE_CLOJURE_1_6_PRINT_OBJECT_HACK ) ; } 
public void createFieldEditors ( ) { addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , Messages . ClojureGeneralPreferencePage_automatic_nature_addition , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , Messages . ClojureGeneralPreferencePage_auto_reload_on_startup_save , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , Messages . ClojureGeneralPreferencePage_launch_repls_in_debug_mode , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , Messages . ClojureGeneralPreferencePage_use_leiningen_launcher , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , Messages . ClojureGeneralPreferencePage_use_cider_nrepl , getFieldEditorParent ( ) ) ) ; addField ( new BooleanFieldEditor ( tccw . preferences . PreferenceConstants . CCW_GENERAL_USE_CLOJURE_1_6_PRINT_OBJECT_HACK , Messages . ClojureGeneralPreferencePage_use_clojure_1_6_print_object_hack , getFieldEditorParent ( ) ) ) ; addField ( tnew FileFieldEditor ( 
public void initializeDefaultPreferences ( ) { IPreferenceStore store = CCWPlugin . getDefault ( ) . getPreferenceStore ( ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTOMATIC_NATURE_ADDITION , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_AUTO_RELOAD_ON_STARTUP_SAVE , false ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_LAUNCH_REPLS_IN_DEBUG_MODE , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_LEININGEN_LAUNCHER , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_CIDER_NREPL , true ) ; store . setDefault ( PreferenceConstants . CCW_GENERAL_USE_CLOJURE_1_6_PRINT_OBJECT_HACK , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS , true ) ; store . setDefault ( org . eclipse . jdt . ui . PreferenceConstants . EDITOR_MATCHING_BRACKETS_COLOR , StringConverter . asString ( new RGB ( 150 , 150 , 150 ) ) ) ; store . setDefault ( PreferenceConstants . EDITOR_ESCAPE_ON_PASTE , false ) ; store . setDefault ( PreferenceConstants . EDITOR_CODE_COMPLETION_AUTO_ACTIVATE , true ) ; store . setDefault ( PreferenceConstants . EDITOR_DISPLAY_NAMESPACE_IN_TABS , true ) ; store . setDefault ( AbstractDecoratedTextEditorPreferenceConstants . EDITOR_TAB_WIDTH , 2 ) ; store . setDefault ( PreferenceConstants . SWITCH_TO_NS_ON_REPL_STARTUP , true ) ; store . setDefault ( USE_STRICT_STRUCTURAL_EDITING_MODE_BY_DEFAULT , false ) ; store . setDefault ( PreferenceConstants . SHOW_RAINBOW_PARENS_BY_DEFAULT , true ) ; store . setDefault ( PreferenceConstants . USE_TAB_FOR_REINDENTING_LINE , true ) ; store . setDefault ( PreferenceConstants . FORCE_TWO_SPACES_INDENT , false ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_AUTO_EVAL_ON_ENTER_ACTIVE , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_DISPLAY_HINTS , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RESULT , true ) ; store . setDefault ( PreferenceConstants . REPL_VIEW_PPRINT_RIGHT_MARGIN , 40 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_MAX_SIZE , 1000 ) ; store . setDefault ( PreferenceConstants . REPL_HISTORY_PERSIST_SCHEDULE , 30000 ) ; for ( SyntaxColoringPreference d : coloringDefaults ) { store . setDefault ( d . getPreferenceConstant ( ) , StringConverter . asString ( d . getDefaultColor ( ) ) ) ; store . setDefault ( PreferenceConstants . getEnabledPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isDefaultEnabled ( ) ) ; store . setDefault ( PreferenceConstants . getBoldPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isBold ( ) ) ; store . setDefault ( PreferenceConstants . getItalicPreferenceKey ( d . getPreferenceConstant ( ) ) , d . isItalic ( ) ) ; } } 
public void run ( ) { TreeViewer treeViewer = getTreeViewer ( ) ; if ( treeViewer ! = null ) { treeViewer . getTree ( ) . setRedraw ( false ) ; 
public static void asyncExec ( Runnable r ) { boolean launched = false ; IWorkbench workbench = PlatformUI . getWorkbench ( ) ; if ( workbench ! = null ) { Display display = workbench . getDisplay ( ) ; if ( display ! = null & & ! display . isDisposed ( ) ) { display . asyncExec ( r ) ; launched = true ; } } if ( launched = = false ) { CCWPlugin . logWarning ( " Either the Workbench or the Display was null, cannot asyncExec runnable " ) ; 
public static void beep ( ) { IWorkbench workbench = PlatformUI . getWorkbench ( ) ; if ( workbench ! = null ) { Display display = workbench . getDisplay ( ) ; 
public String [ ] getEnvironment ( ILaunchConfiguration configuration ) throws CoreException { treturn ( String [ ] ) support . _ ( " get-environment " , this , configuration ) ; } 
public String [ ] superGetEnvironment ( ILaunchConfiguration configuration ) throws CoreException { treturn super . getEnvironment ( configuration ) ; } 
@Override public void doubleClicked ( ITextViewer viewer ) { tdoubleClickStrategy . _ ( " double-clicked " , viewer , defaultStrategy ) ; } 
public void launch ( ILaunchConfiguration configuration , String mode , final ILaunch launch , IProgressMonitor monitor ) throws CoreException { tLaunchUtils . setProjectName ( launch , configuration . getAttribute ( LaunchUtils . ATTR_PROJECT_NAME , ( String ) null ) ) ; tBoolean activateAutoReload = CCWPlugin . isAutoReloadOnStartupSaveEnabled ( ) ; launch . setAttribute ( LaunchUtils . ATTR_IS_AUTO_RELOAD_ENABLED , Boolean . toString ( activateAutoReload ) ) ; tfinal String name = configuration . getName ( ) ; if ( ! ClojureLaunchShortcut . launchNameREPLURLPromiseAndWithREPLView . containsKey ( name ) ) { } BundleUtils.requireAndGetVar(CCWPlugin.getDefault().getBundle().getSymbolicName(), "clojure.tools.nrepl.ack/reset-ack-port!").invoke(); try { Var.pushThreadBindings(RT.map(currentLaunch, launch)); 
public static Object promise ( ) { tIFn promise = clojure . java . api . Clojure . var ( " clojure.core " , " promise " ) ; treturn promise . invoke ( ) ; } 
protected void launchProjectCheckRunning ( final IProject project , IFile [ ] filesToLaunch , String mode , boolean forceLeinLaunchWhenPossible , final IWithREPLView runOnceREPLAvailable ) { tassert mode ! = null ; tString projectName = project . getName ( ) ; tList < ILaunch > running = findRunningLaunchesForProject ( projectName ) ; tSystem . out . println ( " found " + running . size ( ) + " running launches " ) ; if ( running . size ( ) = = 0 | | 
@Override public void run ( ) { tREPLView replView = CCWPlugin . getProjectREPL ( project ) ; if ( replView ! = null ) { treplView . getViewSite ( ) . getPage ( ) . activate ( replView ) ; 
public BotUtils createClojureProject ( String projectName ) throws Exception { tmenu ( " File " , " New " , " Project... " ) . click ( ) ; treturn fillNewProject ( bot , projectName ) . runningInBackground ( ) ; } 
public BotUtils runningInBackground ( ) { try { bot . buttonWithLabel ( " Run in background " ) ; } catch ( WidgetNotFoundException e ) { } 
public BotUtils whenSelectInClojureMenu ( String entryName ) throws Exception { menu ( " Clojure " , entryName ) . click ( ) ; return this ; } 
public void canAlwaysShowClojureMenu ( ) throws Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " ) ) ; } 
public void swtbotDoesNotRunOnTheUIThread ( ) throws Exception { assertNull ( Display . getCurrent ( ) ) ; assertNotSame ( Thread . currentThread ( ) , SWTUtils . display ( ) . getThread ( ) ) ; } 
public void canShowTestGeneratorEntryInClojureMenu ( ) throws Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " , " Test " , " Generator... " ) ) ; } 
public static void setupClass ( ) throws Exception { System . setProperty ( StaticStrings . CCW_PROPERTY_TEST_MODE , " true " ) ; bot = new BotUtils ( ) ; } 
public void canShowTestGeneratorEntryInClojureMenu ( ) throws Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " , " Test Generator... " ) ) ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { StartupRecorder . openRecorder ( null ) ; return null ; } 
public SWTWorkbenchBot createSWTBot ( ) { tSWTWorkbenchBot bot = new SWTWorkbenchBot ( ) ; treturn bot ; } 
public BotUtils createClojureProject ( String projectName ) { tmenu ( " File " , " New " , " Project... " ) . click ( ) ; treturn fillNewProject ( bot , projectName ) ; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout , long delay ) { try { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout , delay ) ; bot . button ( " Run in Background " ) . click ( ) ; } catch ( WidgetNotFoundException e ) { wooosh } return this; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout ) { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout ) ; bot . button ( " Run in Background " ) . click ( ) ; return this ; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher ) { bot . waitUntil ( Conditions . waitForWidget ( matcher ) ) ; bot . button ( " Run in Background " ) . click ( ) ; return this ; } 
public < T extends Widget > BotUtils sendUpdateDependeciesToBackground ( ) { return sendToBackground ( MATCHER_WIDGET_UPDATE_DEPENDENCIES , TIMEOUT_UPDATE_DEPENDENCIES , DELAY_UPDATE_DEPENDENCIES ) ; } 
public BotUtils whenSelectInClojureMenu ( String entryLabel ) throws Exception { menu ( " Clojure " , entryLabel ) . click ( ) ; return this ; } 
public BotUtils whenSelectInLeiningenContextMenu ( String projectName , String entryLabel ) throws Exception { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . tree ( ) ; SWTBotTreeItem node = projectsTree . getTreeItem ( projectName ) ; node . contextMenu ( " Leiningen " ) . menu ( entryLabel ) . click ( ) ; return this ; } 
public BotUtils waitForRepl ( ) throws Exception { try { bot . waitUntil ( Conditions . waitForWidget ( MATCHER_WIDGET_REPL_LOG ) , TIMEOUT_REPL ) ; } catch ( TimeoutException e ) { String message = " Could not find repl widget " ; $NON-NLS-1$ throw new WidgetNotFoundException(message, e); } return this; } 
public BotUtils quietlyCloseRepl ( ) throws Exception { try { bot . viewByPartName ( NAME_REPLVIEW ) . close ( ) ; } catch ( WidgetNotFoundException e ) { wooosh } return this; } 
public BotUtils purgeProject ( String projectName ) { return deleteProject ( projectName ) . deletingOnDisk ( ) . OK ( ) . quietlyContinuingIfNotInSync ( ) ; } 
public BotUtils deleteProject ( String projectName ) { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . tree ( ) ; SWTBotTreeItem node = projectsTree . getTreeItem ( projectName ) ; node . contextMenu ( " Refresh " ) . click ( ) ; node . contextMenu ( " Delete " ) . click ( ) ; return this ; } 
public BotUtils deletingOnDisk ( ) { bot . waitUntil ( Conditions . waitForWidget ( MATCHER_WIDGET_DELETE_PROJECT ) ) ; bot . checkBox ( ) . click ( ) ; return this ; } 
public BotUtils quietlyContinuingIfNotInSync ( ) { try { bot . button ( " Continue " ) . click ( ) ; } catch ( Exception e ) { wooosh } return this; } 
public BotUtils OK ( ) { bot . button ( " OK " ) . click ( ) ; return this ; } 
public BotUtils cancel ( ) { bot . button ( " Cancel " ) . click ( ) ; return this ; } 
public void canCreateANewClojureProject ( ) throws Exception { tbot . createClojureProject ( PROJECT_NAME ) 
public void canShowTestGeneratorEntryInClojureMenu ( ) throws Exception { SWTBotAssert . assertVisible ( bot . menu ( " Clojure " , MenuLabels . TEST , MenuLabels . TEST_GENERATOR ) ) ; } 
public SWTBotMenu menu ( String menu , String . . . subMenus ) { mainShell . setFocus ( ) ; tSWTBotMenu ret = bot . menu ( menu ) ; tfor ( String subMenu : subMenus ) { tret = ret . menu ( subMenu ) ; } treturn ret ; } 
public < T extends Widget > SWTBotMenu contextMenu ( AbstractSWTBot < T > node , String menu , String . . . subMenus ) { SWTBotMenu m = null; boolean found = false; long elapsed = 0; while (!found && elapsed < 5000) { standard SWTBot timeout try { m = node.contextMenu(menu); for (String subMenu: subMenus) { m = m.menu(subMenu); } found = true; } catch (Exception e) { try { Thread.sleep(250); } catch (InterruptedException e1) { wooosh } elapsed += 250; } } if (found == false) { throw new WidgetNotFoundException("Could not find menu: " + MenuLabels.LEININGEN); } return m; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout , long delay ) { try { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout , delay ) ; bot . button ( " Run in Background " ) . click ( ) ; } catch ( Exception e ) { wooosh } return this; } 
public BotUtils selectInClojureMenu ( String entryLabel ) throws Exception { menu ( " Clojure " , entryLabel ) . click ( ) ; return this ; } 
public BotUtils clickInLeiningenMenuForProject ( String projectName , String . . . labels ) { SWTBotView packageExplorer = bot . viewByTitle ( " Package Explorer " ) ; SWTBotTree projectsTree = packageExplorer . bot ( ) . tree ( ) ; SWTBotTreeItem node = projectsTree . getTreeItem ( projectName ) ; contextMenu ( node , MenuLabels . LEININGEN , labels ) . click ( ) ; return this ; } 
public BotUtils quietlyCloseRepl ( ) throws Exception { try { bot . viewByPartName ( NAME_REPLVIEW ) . close ( ) ; } catch ( Exception e ) { wooosh } return this; } 
public static void setupClass ( ) throws Exception { bot = new BotUtils ( ) ; bot . openJavaPerspective ( ) ; } 
public static void cleanClass ( ) throws Exception { bot . quietlyCloseRepl ( ) . purgeProject ( PROJECT_NAME ) ; 
public void beforeTest ( ) { bot . openJavaPerspective ( ) . createClojureProject ( PROJECT_NAME ) 
public BotUtils doubleClickOnFileInProject ( String projectName , String fileName ) { SWTBotTree packageExplorerTree = bot . viewByTitle ( " Package Explorer " ) . bot ( ) . tree ( ) ; splitting on "/"; String [] segments = fileName.split("/"); SWTBotTreeItem prj = packageExplorerTree.getTreeItem(projectName); boolean found = false; long elapsed = 0; prj.expand(); prj.setFocus(); AR -I need to wait for the correct display of the tree or it won't work! TODO find another way? while (!found && elapsed < TIMEOUT_FIND_ITEM_IN_PROJECT) { try { prj.expandNode(segments).doubleClick(); found = true; } catch (Exception e) { bot.sleep(500); elapsed += 500; } } if (found == false) { throw new WidgetNotFoundException("Could not find the file " + fileName + " in " + projectName); } return this; } 
public BotUtils waitForProject ( String projName ) { IProject project = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getProject ( projName ) ; return waitForResource ( project ) ; } 
public BotUtils waitForResource ( IResource resource ) { boolean isSync = false ; while ( isSync ) { bot . sleep ( 500 ) ; isSync = resource . isSynchronized ( IResource . DEPTH_INFINITE ) ; } return this ; } 
public BotUtils createAndWaitForProject ( String projectName ) { return createClojureProject ( projectName ) . waitForWorkspace ( ) 
public < T extends Widget > BotUtils quietlySendUpdateDependenciesToBackground ( ) { try { sendToBackground ( MATCHER_WIDGET_UPDATE_DEPENDENCIES , TIMEOUT_UPDATE_DEPENDENCIES ) ; } catch ( WidgetNotFoundException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlySendUpdateDependenciesToBackground: " + e . getMessage ( ) ) ; } catch ( SWTException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlySendUpdateDependenciesToBackground: " + e . getMessage ( ) ) ; } catch ( TimeoutException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlySendUpdateDependenciesToBackground: " + e . getMessage ( ) ) ; } return this ; } 
public static void setupClass ( ) throws Exception { tbot = new BotUtils ( ) ; tbot . openJavaPerspective ( ) . createAndWaitForProject ( PROJECT_NAME ) ; } 
public static void cleanClass ( ) throws Exception { bot . purgeProject ( PROJECT_NAME ) ; } 
public void canOpenEditor ( ) throws Exception { bot . doubleClickOnFileInProject ( PROJECT_NAME , CORE_CLJ_NAME ) ; bot . bot ( ) . activeEditor ( ) . toTextEditor ( ) ; } 
public void canOpenEditorAndInsertText ( ) throws Exception { tbot . doubleClickOnFileInProject ( PROJECT_NAME , CORE_CLJ_NAME ) ; tSWTBotEclipseEditor e = bot . bot ( ) . activeEditor ( ) . toTextEditor ( ) ; te . insertText ( " salut laurent " ) ; te . save ( ) ; tassertTextContains ( " salut laurent " , e . bot ( ) . getFocusedWidget ( ) ) ; } 
public static void setupClass ( ) throws Exception { bot = new BotUtils ( ) ; } 
public void beforeTest ( ) { bot . openJavaPerspective ( ) . createAndWaitForProject ( PROJECT_NAME ) 
public void canCreateANewClojureProject ( ) throws Exception { tbot . createAndWaitForProject ( " my-first-clojure-project " ) . purgeProject ( " my-first-clojure-project " ) ; 
public BotUtils openJavaPerspective ( ) { tquietlyCloseWelcome ( ) ; tbot . perspectiveByLabel ( " Java " ) . activate ( ) ; treturn this ; } 
public BotUtils doubleClickOnFileInProject ( String projectName , String fileName ) { SWTBotTree packageExplorerTree = bot . viewByTitle ( " Package Explorer " ) . bot ( ) . tree ( ) ; splitting on "/"; String [] segments = fileName.split("/"); SWTBotTreeItem prj = packageExplorerTree.getTreeItem(projectName); boolean found = false; long elapsed = 0; prj.expand(); prj.setFocus(); AR -I need to wait for the correct display of the tree or it won't work! TODO find another way? while (!found && elapsed < TIMEOUT_FIND_ITEM_IN_PROJECT) { try { prj.expandNode(segments).doubleClick(); found = true; } catch (WidgetNotFoundException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } catch (SWTException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } catch (TimeoutException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } } if (found == false) { throw new WidgetNotFoundException("Could not find the file " + fileName + " in " + projectName); } return this; } 
public BotUtils quietlyCloseWelcome ( ) { try { SWTBotView v = bot . viewByTitle ( " Welcome " ) ; if ( v ! = null ) { v . close ( ) ; } } catch ( WidgetNotFoundException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlyCloseWelcome: " + e . getMessage ( ) ) ; } catch ( SWTException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlyCloseWelcome: " + e . getMessage ( ) ) ; } catch ( TimeoutException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlyCloseWelcome: " + e . getMessage ( ) ) ; } treturn this ; 
public < T extends Widget > SWTBotMenu contextMenu ( AbstractSWTBot < T > node , String menu , String . . . subMenus ) { SWTBotMenu m = null; boolean found = false; long elapsed = 0; while (!found && elapsed < 5000) { standard SWTBot timeout try { m = node.contextMenu(menu); for (String subMenu: subMenus) { m = m.menu(subMenu); } found = true; } catch (WidgetNotFoundException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(250); elapsed += 250; } catch (SWTException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } catch (TimeoutException e) { Logger.getLogger(this.getClass()).debug("Caught and handled exception: " + e.getMessage()); bot.sleep(500); elapsed += 500; } } if (found == false) { throw new WidgetNotFoundException("Could not find menu: " + MenuLabels.LEININGEN); } return m; } 
public < T extends Widget > BotUtils sendToBackground ( Matcher < T > matcher , long imeout , long delay ) { bot . waitUntil ( Conditions . waitForWidget ( matcher ) , imeout , delay ) ; bot . button ( " Run in Background " ) . click ( ) ; return this ; } 
public BotUtils waitForRepl ( ) throws Exception { bot . waitUntil ( Conditions . waitForWidget ( MATCHER_WIDGET_REPL_LOG ) , TIMEOUT_REPL ) ; return this ; } 
public BotUtils closeRepl ( ) throws Exception { bot . viewByPartName ( NAME_REPLVIEW ) . close ( ) ; return this ; } 
public BotUtils quietlyContinuingIfNotInSync ( ) { try { bot . button ( " Continue " ) . click ( ) ; } catch ( WidgetNotFoundException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlyContinuingIfNotInSync: " + e . getMessage ( ) ) ; } catch ( SWTException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlyContinuingIfNotInSync: " + e . getMessage ( ) ) ; } catch ( TimeoutException e ) { Logger . getLogger ( this . getClass ( ) ) . info ( " Caught exception in quietlyContinuingIfNotInSync: " + e . getMessage ( ) ) ; } return this ; } 
public static void cleanClass ( ) throws Exception { bot . closeRepl ( ) . purgeProject ( PROJECT_NAME ) ; 
public void initClass ( ) throws Exception { bot . openJavaPerspective ( ) . createAndWaitForProject ( PROJECT_NAME ) ; } 
public void cleanClass ( ) throws Exception { bot . purgeProject ( PROJECT_NAME ) ; } 
public void cleanClass ( ) throws Exception { bot . closeRepl ( ) . purgeProject ( PROJECT_NAME ) ; 
public void startEventHandlers ( ) { tClojureInvoker . newInvoker ( this , " ccw.core.event-bus " ) . _ ( " start " ) ; } 
public void startEventSubscription ( ) { tClojureInvoker . newInvoker ( this , " ccw.repl.visible-in-all-perspectives " ) . _ ( " start " ) ; } 
public void run ( ) { IWorkbenchWindow window = PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ; if ( window ! = null ) { IWorkbenchPage [ ] pages = window . getPages ( ) ; 
private static String getNextSecondaryId ( ) { synchronized ( SECONDARY_VIEW_IDS ) { String id = SECONDARY_VIEW_IDS . iterator ( ) . next ( ) ; 
public static REPLView connect ( final String url , IConsole console , ILaunch launch , final boolean makeActiveREPL ) throws Exception { String secondaryId ; final REPLView repl = ( REPLView ) PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) . showView ( VIEW_ID , secondaryId = getNextSecondaryId ( ) , IWorkbenchPage . VIEW_ACTIVATE ) ; repl . secondaryId = secondaryId ; repl . console = console ; repl . showConsoleAction . setEnabled ( console ! = null ) ; repl . launch = launch ; if ( repl . configure ( url ) ) { if ( makeActiveREPL ) { 
public void startNamespaces ( ) { tClojureInvoker . newInvoker ( this , " ccw.editors.clojure.code-content-assist " ) . _ ( " start " ) ; } 
public void startNamespaces ( ) { ClojureInvoker.newInvoker(this, "ccw.editors.clojure.code-completion-proposal")._("start"); } 
@Override public void handleEvent ( Event event ) { tSystem . out . println ( " Perspective Opened: " + event . getProperty ( UIEvents . UILabel . LABEL ) ) ; } 
@Override public void handleEvent ( Event event ) { tSystem . out . println ( " Perspective event: " + event ) ; } 
@Override public void handleEvent ( Event event ) { tSystem . out . println ( " MPart Activated: " + event ) ; } 
public Object execute ( ExecutionEvent event ) throws ExecutionException { StartupRecorder.openRecorder(null); return null; } 
public void startREPLServer ( ) { ttry { ClojureInvoker . newInvoker ( this , " ccw.core.launch " ) . __ ( " ccw-nrepl-start-if-necessary " ) ; 
public void startEventHandlers ( ) { tClojureInvoker . newInvoker ( this , " ccw.core.event-bus " ) . __ ( " start " ) ; } 
public void startEventSubscription ( ) { tClojureInvoker . newInvoker ( this , " ccw.repl.visible-in-all-perspectives " ) . __ ( " start " ) ; } 
public void startNamespaces ( ) { ClojureInvoker.newInvoker(this, "ccw.editors.clojure.code-completion-proposal").__("start"); } 
private void stopREPLServer ( ) { ttry { ClojureInvoker . newInvoker ( this , " ccw.core.launch " ) . __ ( " ccw-nrepl-stop " ) ; 
private void initInjections ( BundleContext bundleContext ) { IEclipseContext c = EclipseContextFactory . getServiceContext ( bundleContext ) ; ClojureInvoker . newInvoker ( this , " ccw.editors.clojure.hover-support " ) . __ ( " init-injections " , c ) ; } 
public static String findDeclaringNamespace ( Map tree ) { ttry { treturn ( String ) staticAnalysis . __ ( " find-namespace " , tree ) ; 
private void launchUserPluginsWithinJob ( final MApplication app ) { tJob j = new WorkspaceJob ( " CCW User Plugins launcher " ) { @Override public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { ttry { tBundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; tClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; te4Model . __ ( " application! " , app ) ; tClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; tuserPlugins . __ ( " start-user-plugins " ) ; } catch ( CoreException e ) { treturn CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } treturn Status . OK_STATUS ; } } ; tj . setUser ( false ) ; tj . schedule ( ) ; } 
public IStatus runInWorkspace ( IProgressMonitor monitor ) tthrows CoreException { ttry { tBundle bundle = BundleUtils . loadAndGetBundle ( " ccw.core " ) ; tClojureInvoker e4Model = ClojureInvoker . newInvoker ( bundle , " ccw.e4.model " ) ; te4Model . __ ( " application! " , app ) ; tClojureInvoker userPlugins = ClojureInvoker . newInvoker ( bundle , " ccw.core.user-plugins " ) ; tuserPlugins . __ ( " start-user-plugins " ) ; } catch ( CoreException e ) { treturn CCWPlugin . createErrorStatus ( " Error while loading Counterclockwise User plugins " , e ) ; } treturn Status . OK_STATUS ; } 
protected void editorSaved ( ) { tsuper . editorSaved ( ) ; tupdatePartNameAndDescription ( ) ; teditorSupport . __ ( " editor-saved " , this ) ; } 
private void updateTextBuffer ( String finalText , long offset , long length , String text ) { tboolean firstTime = ( parseState = = null ) ; tparseState = editorSupport . __ ( " updateTextBuffer " , parseState , finalText , offset , length , text ) ; if ( firstTime ) { teditorSupport . __ ( " startWatchParseRef " , parseState , this ) ; 
public Object getParseState ( ) { if ( parseState = = null ) { tString text = getDocument ( ) . get ( ) ; updateTextBuffer ( text , 0 , - 1 , text ) ; } return editorSupport . __ ( " getParseState " , getDocument ( ) . get ( ) , parseState ) ; } 
public boolean isParseTreeBroken ( ) { treturn ( Boolean ) editorSupport . __ ( " brokenParseTree? " , getParseState ( ) ) ; } 
public String findDeclaringNamespace ( ) { treturn ClojureCore . findDeclaringNamespace ( ( Map ) editorSupport . __ ( " getParseTree " , getParseState ( ) ) ) ; } 
@Override public void doubleClicked ( ITextViewer viewer ) { tdoubleClickStrategy . __ ( " double-clicked " , viewer , defaultStrategy ) ; } 
public IRegion getDamageRegion ( ITypedRegion partition , DocumentEvent event , tboolean documentPartitioningChanged ) { treturn ( IRegion ) topLevelFormsDamager . __ ( " getDamageRegion " , tthis , partition , event , documentPartitioningChanged ) ; 
public void customizeDocumentCommand ( IDocument document , tDocumentCommand command ) { tpareditAutoAdjustWhitespacetrategyImpl . __ ( " customizeDocumentCommand " , tthis , document , command ) ; 
public void customizeDocumentCommand ( IDocument document , tDocumentCommand command ) { tpareditAutoEditStrategyImpl . __ ( " customizeDocumentCommand " , tthis , document , command ) ; 
private void refreshInput ( ) { tJob job = new Job ( " Outline browser tree refresh " ) { @Override protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; ttry { tClojureOutlinePage . this . forms = ( List < List > ) outline . __ ( " read-forms " , string ) ; tsetInputInUiThread ( ClojureOutlinePage . this . forms ) ; treturn Status . OK_STATUS ; } catch ( Exception e ) { tthrow new RuntimeException ( e ) ; } } @Override public boolean belongsTo ( Object family ) { treturn REFRESH_OUTLINE_JOB_FAMILY . equals ( family ) ; } } ; tjob . setSystem ( true ) ; tJob . getJobManager ( ) . cancel ( REFRESH_OUTLINE_JOB_FAMILY ) ; tjob . schedule ( 500 ) ; } 
protected IStatus run ( IProgressMonitor monitor ) { tString string = document . get ( ) ; ttry { tClojureOutlinePage . this . forms = ( List < List > ) outline . __ ( " read-forms " , string ) ; 
private ILaunchConfiguration createLeiningenLaunchConfiguration ( IProject project , boolean createInDebugMode ) { launch.__("launch-configuration", configMap); 
public String [ ] getEnvironment ( ILaunchConfiguration configuration ) throws CoreException { treturn ( String [ ] ) support . __ ( " get-environment " , this , configuration ) ; } 
protected IProject [ ] build ( int kind , Map < String , String > args , tIProgressMonitor monitor ) throws CoreException { if ( getProject ( ) = = null ) treturn null ; if ( ! ( kind = = AUTO_BUILD ) & & ! ( kind = = INCREMENTAL_BUILD ) ) treturn null ; if ( projectCljPresentInDelta ( ) ) { } 
private boolean doPerformFinish ( ) { tIProject project = getNewProject ( ) ; ttry { twizard . __ ( performFinish , 
private String removeTrailingSpaces ( String s ) { treturn ( String ) str . __ ( " trimr " , s ) ; } 
public void sendInterrupt ( ) { viewHelpers . __ ( " log " , this , logPanel , " ;; Interrupting... " , inputExprLogType ) ; evalExpression . invoke ( PersistentHashMap . create ( " op " , " interrupt " ) , false ) ; If we were in STDIN mode, switch back to CODE inputAreaMode = InputAreaMode.CODE; stdinViewer.getDocument().set(""); updateInputControls(); } 
public void handleResponse ( Response resp , String expression ) { viewHelpers . __ ( " handle-responses " , this , logPanel , expression , resp . seq ( ) ) ; } 
private void prepareView ( ) throws Exception { 10s timeout for establishing session (somewhat arbitrary atm) sessionId = SafeConnection.safeNewSession(interactive, 10000); evalExpression = (IFn) viewHelpers.__("configure-repl-view", this, logPanel, interactive.client, sessionId); } 
public void dispose ( ) { super . dispose ( ) ; if ( secondaryId ! = null ) { treleaseSecondaryId ( secondaryId ) ; } fSourceViewerDecorationSupport = ( SourceViewerDecorationSupport ) editorSupport . __ ( " disposeSourceViewerDecorationSupport " , tfSourceViewerDecorationSupport ) ; try { if ( interactive ! = null ) interactive . close ( ) ; 
public Object __ ( final String varName ) { treturn ClojureUtils . invoke ( namespace , varName ) ; } 
public Object __ ( final String varName , final Object arg1 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 ) ; } 
public Object __ ( final String varName , final Object arg1 , final Object arg2 , final Object arg3 , final Object arg4 , final Object arg5 ) { treturn ClojureUtils . invoke ( namespace , varName , arg1 , arg2 , arg3 , arg4 , arg5 ) ; } 
private String extractExtension ( List < String > parts ) { tString extension ; tfinal String lastPart = parts . get ( parts . size ( ) - 1 ) ; if ( wizard . __ ( " clojure-editor-extensions " , lastPart ) ! = null ) { textension = parts . remove ( parts . size ( ) - 1 ) ; } else { textension = " clj " ; } treturn extension ; } 
private String content ( String namespace , String extension ) { treturn ( String ) wizard . __ ( " content " , namespace , extension ) ; } 
public String getProgramArguments ( ILaunchConfiguration configuration ) throws CoreException { tString superProgramArguments = super . getProgramArguments ( configuration ) ; if ( isLeiningenConfiguration ( configuration ) ) { tList < IFile > filesToLaunch = LaunchUtils . getFilesToLaunchList ( configuration ) ; tString injectCCWServer = " update-in :dependencies conj \" [ccw/ccw.server \\ \" 0.2.1 \\ \" ] \" " + " -- update-in :injections conj \" (require 'ccw.debug.serverrepl) \" " ; tString injectCiderNrepl = " update-in :plugins conj \" [cider/cider-nrepl \\ \" 0.9.0 \\ \" ] \" " String filesToLaunchArguments = LaunchUtils.getFilesToLaunchAsCommandLineList(configuration, false); 
