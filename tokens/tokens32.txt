public void put ( K key , V value ) { _map . put ( key , new ManagedItem < V > ( value , System . currentTimeMillis ( ) ) ) ; while ( _map . size ( ) > _size ) { _map . remove ( _map . keySet ( ) . iterator ( ) . next ( ) ) ; 
public V get ( K key ) { final ManagedItem < V > item = _map . get ( key ) ; if ( item = = null ) { return null ; } if ( _ttl > - 1 & & System . currentTimeMillis ( ) - item . insertionTime > _ttl ) { _map . remove ( key ) ; return null ; } return item . value ; } 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger.info( "Creating LRUCache with size 200 and TTL 100" ); _missingSessionsCache = new de.javakaffee.web.msm.LRUCache<String, Boolean>( 200, 200 ); 
protected synchronized String generateSessionId ( ) { return super . generateSessionId ( ) + " . " + _memcachedId ; } 
public void expireSession ( String sessionId ) { _logger . info ( " expireSession invoked: " + sessionId ) ; super . expireSession ( sessionId ) ; _memcached . delete ( sessionId ) ; } 
public Session findSession ( String id ) throws IOException { _logger . info ( " findSession invoked: " + id ) ; Session result = super . findSession ( id ) ; if ( result = = null & & _missingSessionsCache . get ( id ) = = null ) { _logger . info ( " No session found, loading from memcached. " ) ; result = loadFromMemcached ( id ) ; if ( result ! = null ) { _logger . info ( " Found session in memcached, storing locally: " + id ) ; add ( result ) ; } else { _missingSessionsCache . put ( id , Boolean . TRUE ) ; } } return result ; } 
public Session createSession ( String sessionId ) { _logger . info ( " createSession invoked: " + sessionId ) ; Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; session . setId ( generateSessionId ( ) ) ; _logger . info ( ToStringBuilder . reflectionToString ( session ) ) ; } sessionCounter + + ; return ( session ) ; 
protected void storeSession ( Session session ) { _memcached . set ( session . getId ( ) , 3600 , session ) ; } 
private Session loadFromMemcached ( String sessionId ) { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( session = = null ) { _logger . warning ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; final String requestedMemcachedId = getMemcachedId ( sessionId ) ; if ( ! _memcachedId . equals ( requestedMemcachedId ) ) { _logger . warning ( " Session " + sessionId + " found in memcached, " + " relocating from " + requestedMemcachedId + " to " + _memcachedId ) ; final int idx = sessionId . lastIndexOf ( '.' ) ; final String newSessionId = idx > - 1 ? sessionId . substring ( 0 , idx + 1 ) + _memcachedId : sessionId + " . " + _memcachedId ; session . setId ( newSessionId ) ; _memcached . delete ( sessionId ) ; storeSession ( session ) ; } } return session ; } 
public void remove ( Session session ) { _logger . info ( " remove invoked " ) ; _memcached . delete ( session . getId ( ) ) ; super . remove ( session ) ; } 
public void addLifecycleListener ( LifecycleListener arg0 ) { lifecycle . addLifecycleListener ( arg0 ) ; } 
public LifecycleListener [ ] findLifecycleListeners ( ) { return lifecycle . findLifecycleListeners ( ) ; } 
public void removeLifecycleListener ( LifecycleListener arg0 ) { lifecycle . removeLifecycleListener ( arg0 ) ; } 
public void start ( ) throws LifecycleException { if ( ! initialized ) init ( ) ; 
public void stop ( ) throws LifecycleException { if ( initialized ) destroy ( ) ; 
protected byte [ ] serialize ( Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } byte[] rv=null; try { ByteArrayOutputStream bos=new ByteArrayOutputStream(); ObjectOutputStream os=new ObjectOutputStream(bos); os.writeObject(o); os.close(); bos.close(); rv=bos.toByteArray(); } catch(IOException e) { throw new IllegalArgumentException("Non-serializable object", e); } return rv; ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; try { bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream( new BufferedOutputStream( bos ) ); } catch ( IOException e ) { if ( bos != null ) { try { bos.close(); } catch ( IOException f ) { } } if ( oos != null ) { try { oos.close(); } catch ( IOException f ) { } } throw new IllegalArgumentException("Non-serializable object", e); } try { ( (StandardSession) o ).writeObjectData( oos ); 
protected Object deserialize ( byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; Loader loader = null ; ClassLoader classLoader = null ; try { bis = new ByteArrayInputStream ( in ) ; if ( _manager . getContainer ( ) ! = null ) loader = _manager . getContainer ( ) . getLoader ( ) ; if ( loader ! = null ) classLoader = loader . getClassLoader ( ) ; if ( classLoader ! = null ) ois = new CustomObjectInputStream ( bis , classLoader ) ; else ois = new ObjectInputStream ( bis ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; if ( bis ! = null ) { try { bis . close ( ) ; } catch ( IOException f ) { } bis = null ; } if ( ois ! = null ) { try { ois . close ( ) ; } catch ( IOException f ) { } ois = null ; } throw new RuntimeException ( " Caught IOException decoding data " , e ) ; } try { 
public void addOp ( Operation op ) { throw new UnsupportedOperationException ( ) ; } 
public void connected ( ) { throw new UnsupportedOperationException ( ) ; } 
public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void fillWriteBuffer ( boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; } 
public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean hasReadOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean hasWriteOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean isActive ( ) { throw new UnsupportedOperationException ( ) ; } 
public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; } 
public void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; } 
public void transitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; } 
public int writeSome ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } 
public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes ) ; } 
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test public void testLRU ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 3 ) ; final String f = " foo " ; final String br = " bar " ; cut . put ( f , br ) ; cut . put ( br , " baz " ) ; Assert . assertArrayEquals ( " invalid order of items, initially it should be insertion ordered " , new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( f ) ; Assert . assertArrayEquals ( " invalid order of items, accessing foo should move it to the end " , new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( br ) ; Assert . assertArrayEquals ( " invalid order of items " , new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( f ) ; Assert . assertArrayEquals ( " invalid order of items, accessing foo should move it to the end " , new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) ; cut . put ( " baz " , " foo " ) ; Assert . assertArrayEquals ( " invalid order of items, last inserted item should be at last position " , new String [ ] { br , f , " baz " } , cut . getKeys ( ) . toArray ( ) ) ; } @Test public void testCacheSize ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; cut . put ( " bar " , " baz " ) ; Assert . assertEquals ( " baz " , cut . get ( " bar " ) ) ; Assert . assertNull ( " old key still existing, unexpected cache size " , cut . get ( " foo " ) ) ; } @Test public void testCacheTTL ( ) throws InterruptedException { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 , 100 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; Thread . sleep ( 101 ) ; Assert . assertNull ( " expired key still existing, unexpected cache size " , cut . get ( " foo " ) ) ; } } 
public void tearDown ( ) throws Exception { } @Test public void testLRU ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 3 ) ; final String f = " foo " ; final String br = " bar " ; cut . put ( f , br ) ; cut . put ( br , " baz " ) ; Assert . assertArrayEquals ( " invalid order of items, initially it should be insertion ordered " , new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( f ) ; Assert . assertArrayEquals ( " invalid order of items, accessing foo should move it to the end " , new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( br ) ; Assert . assertArrayEquals ( " invalid order of items " , new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( f ) ; Assert . assertArrayEquals ( " invalid order of items, accessing foo should move it to the end " , new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) ; cut . put ( " baz " , " foo " ) ; Assert . assertArrayEquals ( " invalid order of items, last inserted item should be at last position " , new String [ ] { br , f , " baz " } , cut . getKeys ( ) . toArray ( ) ) ; } @Test public void testCacheSize ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; cut . put ( " bar " , " baz " ) ; Assert . assertEquals ( " baz " , cut . get ( " bar " ) ) ; Assert . assertNull ( " old key still existing, unexpected cache size " , cut . get ( " foo " ) ) ; } @Test public void testCacheTTL ( ) throws InterruptedException { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 , 100 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; Thread . sleep ( 101 ) ; Assert . assertNull ( " expired key still existing, unexpected cache size " , cut . get ( " foo " ) ) ; } } 
public void testLRU ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 3 ) ; final String f = " foo " ; final String br = " bar " ; cut . put ( f , br ) ; cut . put ( br , " baz " ) ; Assert . assertArrayEquals ( " invalid order of items, initially it should be insertion ordered " , new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( f ) ; Assert . assertArrayEquals ( " invalid order of items, accessing foo should move it to the end " , new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( br ) ; Assert . assertArrayEquals ( " invalid order of items " , new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) ; cut . get ( f ) ; Assert . assertArrayEquals ( " invalid order of items, accessing foo should move it to the end " , new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) ; cut . put ( " baz " , " foo " ) ; Assert . assertArrayEquals ( " invalid order of items, last inserted item should be at last position " , new String [ ] { br , f , " baz " } , cut . getKeys ( ) . toArray ( ) ) ; 
public void testCacheSize ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; cut . put ( " bar " , " baz " ) ; Assert . assertEquals ( " baz " , cut . get ( " bar " ) ) ; Assert . assertNull ( " old key still existing, unexpected cache size " , cut . get ( " foo " ) ) ; } 
public void testCacheTTL ( ) throws InterruptedException { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 , 100 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; Thread . sleep ( 101 ) ; Assert . assertNull ( " expired key still existing, unexpected cache size " , cut . get ( " foo " ) ) ; } 
public Session findSession ( String id ) throws IOException { _logger . info ( " findSession invoked: " + id ) ; Session result = super . findSession ( id ) ; if ( result = = null & & _missingSessionsCache . get ( id ) = = null ) { _logger . info ( " No session found, loading from memcached. " ) ; result = loadFromMemcached ( id ) ; if ( result ! = null ) { _logger . info ( " Found session in memcached, storing locally: " + result . getId ( ) ) ; add ( result ) ; } else { _missingSessionsCache . put ( id , Boolean . TRUE ) ; } } return result ; } 
private Session loadFromMemcached ( String sessionId ) { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( session = = null ) { _logger . warning ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; final int idx = sessionId.lastIndexOf( '.' ); final String newSessionId = idx > -1 ? sessionId.substring( 0, idx + 1 ) + _memcachedId : sessionId + "." + _memcachedId; session.setId( newSessionId ); _memcached.delete( sessionId ); storeSession( session ); } } return session; } 
protected byte [ ] serialize ( Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } byte[] rv=null; try { ByteArrayOutputStream bos=new ByteArrayOutputStream(); ObjectOutputStream os=new ObjectOutputStream(bos); os.writeObject(o); os.close(); bos.close(); rv=bos.toByteArray(); } catch(IOException e) { throw new IllegalArgumentException("Non-serializable object", e); } return rv; ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; try { bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream( bos ); } catch ( IOException e ) { if ( bos != null ) { try { bos.close(); } catch ( IOException f ) { } } if ( oos != null ) { try { oos.close(); } catch ( IOException f ) { } } throw new IllegalArgumentException("Non-serializable object", e); } try { ( (StandardSession) o ).writeObjectData( oos ); 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger.info( "Creating LRUCache with size 200 and TTL 100" ); _missingSessionsCache = new LRUCache<String, Boolean>( 200, 200 ); 
protected synchronized String generateSessionId ( ) { return super . generateSessionId ( ) + " . " + _activeNodeIndex ; } 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger.info( "Creating LRUCache with size 200 and TTL 100" ); _missingSessionsCache = new LRUCache<String, Boolean>( 200, 200 ); 
private Session loadFromMemcached ( String sessionId ) { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( session = = null ) { _logger . warning ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; final String requestedMemcachedId = getMemcachedId ( sessionId ) ; if ( ! _activeNodeIndexAsString . equals ( requestedMemcachedId ) ) { _logger . warning ( " Session " + sessionId + " found in memcached, " + " relocating from " + requestedMemcachedId + " to " + _activeNodeIndexAsString ) ; relocate ( session ) ; } } return session ; } 
private void relocate ( final Session session ) { final String sessionId = session . getId ( ) ; session . setNote ( SessionTrackerValve . RELOCATE , Boolean . TRUE ) ; 
private Session loadFromMemcached ( String sessionId ) { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( session = = null ) { _logger . warning ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; final String requestedMemcachedId = getMemcachedId ( sessionId ) ; if ( !_activeNodeIndexAsString.equals( requestedMemcachedId ) ) { _logger.warning( "Session " + sessionId + " found in memcached," + " relocating from " + requestedMemcachedId + " to " + _activeNodeIndexAsString ); relocate( session ); } } return session; } 
protected void storeSession ( Session session ) { try { _memcached . set ( session . getId ( ) , 3600 , session ) ; 
private Session loadFromMemcached ( String sessionId ) { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( session = = null ) { _logger . warning ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; final String requestedMemcachedId = getMemcachedId( sessionId ); if ( !_activeNodeIndexAsString.equals( requestedMemcachedId ) ) { _logger.warning( "Session " + sessionId + " found in memcached," + " relocating from " + requestedMemcachedId + " to " + _activeNodeIndexAsString ); relocate( session, _activeNodeIndexAsString ); } } return session; } 
private void relocate ( final Session session , String newNodeId , boolean delete ) { final String sessionId = session . getId ( ) ; session . setNote ( SessionTrackerValve . RELOCATE , Boolean . TRUE ) ; 
public void remove ( Session session ) { _logger . info ( " remove invoked, session.rel " + session . getNote ( SessionTrackerValve . RELOCATE ) ) ; try { _memcached . delete ( session . getId ( ) ) ; } catch ( RelocationException e ) { } super . remove ( session ) ; } 
public synchronized Throwable fillInStackTrace ( ) { return null ; } 
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); fail( "We shouldn't reach this" ); } catch( UnavailableNodeException e ) { } } @Test public final void testGetNextNodeId_NodesLeft() { final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>(); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator( nodes ); String nextNodeId = cut.getNextNodeId( "foo.0" ); assertEquals( "1", nextNodeId ); }} 
public void tearDown ( ) throws Exception { } @Test public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); fail( "We shouldn't reach this" ); } catch( UnavailableNodeException e ) { } } @Test public final void testGetNextNodeId_NodesLeft() { final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>(); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator( nodes ); String nextNodeId = cut.getNextNodeId( "foo.0" ); assertEquals( "1", nextNodeId ); }} 
public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); 
public final void testGetNextNodeId_NodesLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes ) ; String nextNodeId = cut . getNextNodeId ( " foo.0 " ) ; assertEquals ( " 1 " , nextNodeId ) ; } 
protected BackupResult backupSession ( Session session ) { try { storeSessionInMemcached ( session ) ; 
private void storeSessionInMemcached ( Session session ) { _memcached . set ( session . getId ( ) , 3600 , session ) ; } 
private void relocate ( final Session session , String newNodeId , boolean delete ) { final String sessionId = session . getId ( ) ; session . setNote ( SessionTrackerValve . RELOCATE , Boolean . TRUE ) ; 
private void setCookie ( Response response , Request request , final Session session ) { final Cookie newCookie = new Cookie ( " JSESSIONID " , session . getId ( ) ) ; newCookie . setMaxAge ( - 1 ) ; newCookie . setPath ( request . getContextPath ( ) ) ; response . addCookie ( newCookie ) ; } 
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { log ( " invoked " ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( " OK: " + request . getSession ( ) . getId ( ) ) ; out . close ( ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; _portTomcat2 = 8889 ; final int port = 21211 ; _map = new PartitionedHashMap < String , byte [ ] > ( " tcp.xml " , getClass ( ) . getSimpleName ( ) ) ; _connector = new MemcachedConnector ( InetAddress . getLocalHost ( ) , port , _map ) ; _connector . setThreadPoolCoreThreads ( 1 ) ; _connector . setThreadPoolMaxThreads ( 5 ) ; _map . start ( ) ; _connector . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) ) , 
public void tearDown ( ) throws Exception { _connector . stop ( ) ; _map . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; } 
public void testTomcatFailover ( ) throws IOException , InterruptedException { final SimpleHttpConnectionManager connectionManager = new SimpleHttpConnectionManager ( true ) ; try { final HttpClient client = new HttpClient ( connectionManager ) ; 
private String makeRequest ( final HttpClient client , int port , String rsessionId ) throws IOException , HttpException { System . out . println ( port + " >>>>>>>>>>>>>>>>>> Starting >>>>>>>>>>>>>>>>>>>> " ) ; String responseSessionId ; final HttpMethod method = new GetMethod ( " http:localhost: " + port + " / " ) ; try { if ( rsessionId ! = null ) { 
private Embedded createCatalina ( final int port , String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; engine . setName ( " engine- " + port ) ; engine . setDefaultHost ( " localhost " ) ; final URL root = new URL ( getClass ( ) . getResource ( " / " ) , " ../resources " ) ; final String docBase = root . getFile ( ) + File . separator + getClass ( ) . getPackage ( ) . getName ( ) . replaceAll ( " \\ . " , File . separator ) ; final Host host = catalina . createHost ( " localhost " , docBase ) ; engine . addChild ( host ) ; final File contextPathFile = new File ( docBase + " / " ) ; contextPathFile . mkdirs ( ) ; final Context context = catalina . createContext ( " / " , " webapp " ) ; final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setActiveNodeIndex ( 0 ) ; context . setManager ( sessionManager ) ; host . addChild ( context ) ; catalina . addEngine ( engine ) ; final Connector connector = catalina . createConnector ( InetAddress . getLocalHost ( ) , port , false ) ; catalina . addConnector ( connector ) ; return catalina ; } 
protected BackupResult backupSession ( Session session ) { _logger . info ( " Storing session in memcached: " + session . getId ( ) ) ; try { storeSessionInMemcached ( session ) ; 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger.info( "Creating LRUCache with size 200 and TTL 100" ); _missingSessionsCache = new LRUCache<String, Boolean>( 200, 100 ); 
private Session loadFromMemcached ( String sessionId ) { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( session = = null ) { _logger . warning ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; } return session ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final int port = 21211 ; _map = new PartitionedHashMap < String , byte [ ] > ( " tcp.xml " , getClass ( ) . getSimpleName ( ) ) ; _connector = new MemcachedConnector ( InetAddress . getLocalHost ( ) , port , _map ) ; _connector . setThreadPoolCoreThreads ( 1 ) ; _connector . setThreadPoolMaxThreads ( 5 ) ; _map . start ( ) ; _connector . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void tearDown ( ) throws Exception { _connector . stop ( ) ; _map . stop ( ) ; _tomcat1 . stop ( ) ; _connectionManager . shutdown ( ) ; } 
public void testSessionAvailableInMemcached ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 50 ) ; assertNotNull ( " Session not available in memcached. " , _memcached . get ( sessionId1 ) ) ; } 
public void testExpiredSessionRemovedFromMemcached ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; assertNull ( " Expired sesion still existing in memcached " , _memcached . get ( sessionId1 ) ) ; } 
public static String makeRequest ( final HttpClient client , int port , String rsessionId ) throws IOException , HttpException { System . out . println ( port + " >>>>>>>>>>>>>>>>>> Starting >>>>>>>>>>>>>>>>>>>> " ) ; String responseSessionId ; final HttpMethod method = new GetMethod ( " http:localhost: " + port + " / " ) ; try { if ( rsessionId ! = null ) { 
public static Embedded createCatalina ( final int port , String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; engine . setName ( " engine- " + port ) ; engine . setDefaultHost ( " localhost " ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../resources " ) ; final String docBase = root . getFile ( ) + File . separator + TestUtils . class . getPackage ( ) . getName ( ) . replaceAll ( " \\ . " , File . separator ) ; final Host host = catalina . createHost ( " localhost " , docBase ) ; engine . addChild ( host ) ; new File ( docBase ) . mkdirs ( ) ; final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setActiveNodeIndex ( 0 ) ; sessionManager . setMaxInactiveInterval ( 1 ) ; 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) final Context context = catalina.createContext( "/", "webapp" ); context.setManager( sessionManager ); context.setBackgroundProcessorDelay( 1 ); host.addChild( context ); catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public void testExpiredSessionRemovedFromMemcached ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; assertNull ( " Expired sesion still existing in memcached " , _memcached . get ( sessionId1 ) ) ; } 
public void testInvalidSessionNotFound ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( " Expired session returned " , sessionId1 , sessionId2 ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final Manager manager = _tomcat1 . getContainer ( ) . getManager ( ) ; if ( manager == null ) { throw new IllegalStateException( "The manager is not existing!" ); } _memcached = new MemcachedClient( new SuffixLocatorConnectionFactory( manager ), Arrays.asList( new InetSocketAddress( "localhost", port ) ) ); _connectionManager = new SimpleHttpConnectionManager( true ); _httpClient = new HttpClient( _connectionManager ); } 
public void tearDown ( ) throws Exception { _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _connectionManager . shutdown ( ) ; } 
private MemCacheDaemon createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon daemon = new MemCacheDaemon ( ) ; final LRUCacheStorageDelegate cacheStorage = new LRUCacheStorageDelegate ( 1000 , 1024 * 1024 , 1024000 ) ; daemon . setCache ( new Cache ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( true ) ; return daemon ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; _portTomcat2 = 8889 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory( _tomcat1.getContainer().getManager() ), 
public void tearDown ( ) throws Exception { _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; } 
public void testConnectDaemon ( ) throws IOException , InterruptedException { _client . set ( " foo " , 3600 , " bar " ) ; Assert . assertEquals ( " bar " , _client . get ( " foo " ) ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public static String makeRequest ( final HttpClient client , int port , String rsessionId ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Starting >>>>>>>>>>>>>>>>>>>>"); String responseSessionId; final HttpMethod method = new GetMethod("http:localhost:"+ port +"/"); try { if ( rsessionId != null ) { 
public static MemCacheDaemon createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon daemon = new MemCacheDaemon ( ) ; final LRUCacheStorageDelegate cacheStorage = new LRUCacheStorageDelegate ( 100000 , 1024 * 1024 , 1024000 ) ; daemon . setCache ( new Cache ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( false ) ; return daemon ; } 
public static Embedded createCatalina ( final int port , String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; engine . setName ( " engine- " + port ) ; engine . setDefaultHost ( " localhost " ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../resources " ) ; final String docBase = root . getFile ( ) + File . separator + TestUtils . class . getPackage ( ) . getName ( ) . replaceAll ( " \\ . " , File . separator ) ; final Host host = catalina . createHost ( " localhost " , docBase ) ; engine . addChild ( host ) ; new File ( docBase ) . mkdirs ( ) ; final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setActiveNodeIndex ( 0 ) ; sessionManager . setMaxInactiveInterval ( 1 ) ; 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) engine.setManager( sessionManager ); final Context context = catalina.createContext( "/", "webapp" ); context.setManager( sessionManager ); context.setBackgroundProcessorDelay( 1 ); host.addChild( context ); catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; _portTomcat2 = 8889 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) ) , 
public void testConnectDaemon ( ) throws IOException , InterruptedException { final Object value = " bar " ; _client . set ( " foo.0 " , 3600 , value ) ; Assert . assertEquals ( value , _client . get ( " foo.0 " ) ) ; } 
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); fail( "We shouldn't reach this" ); } catch( UnavailableNodeException e ) { @Test public final void testLastNodeReachedRestartAtFirst() { final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>(); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator( nodes ); String nextNodeId = cut.getNextNodeId( "foo.1" ); assertEquals( "0", nextNodeId ); }} 
public void tearDown ( ) throws Exception { } @Test public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); fail( "We shouldn't reach this" ); } catch( UnavailableNodeException e ) { @Test public final void testLastNodeReachedRestartAtFirst() { final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>(); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator( nodes ); String nextNodeId = cut.getNextNodeId( "foo.1" ); assertEquals( "0", nextNodeId ); }} 
public final void testLastNodeReachedRestartAtFirst ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes ) ; String nextNodeId = cut . getNextNodeId ( " foo.1 " ) ; assertEquals ( " 0 " , nextNodeId ) ; 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger.info( "Creating LRUCache with size 200 and TTL 100" ); _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 ); 
private boolean isValidSessionIdFormat ( String sessionId ) { return sessionId ! = null & & sessionId . indexOf ( '.' ) > - 1 ; } 
public Session findSession ( String id ) throws IOException { Session result = super . findSession ( id ) ; if ( result = = null & & _missingSessionsCache . get ( id ) = = null ) { result = loadFromMemcached ( id ) ; if ( result ! = null ) { add ( result ) ; } else { _missingSessionsCache . put ( id , Boolean . TRUE ) ; } } return result ; } 
protected BackupResult backupSession ( Session session ) { _logger . info ( " Trying to store session in memcached: " + session . getId ( ) ) ; try { storeSessionInMemcached ( session ) ; 
private void storeSessionInMemcached ( Session session ) { final Future < Boolean > future = _memcached . set ( session . getId ( ) , 3600 , session ) ; try { future . get ( 500 , TimeUnit . MILLISECONDS ) ; 
private Session loadFromMemcached ( String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( session = = null ) { _logger . warning ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; } return session ; } 
public void remove ( Session session ) { _logger . info ( " remove invoked, session.rel " + session . getNote ( SessionTrackerValve . RELOCATE ) + " , id " + session . getId ( ) ) ; try { _memcached . delete ( session . getId ( ) ) ; } catch ( RelocationException e ) { } super . remove ( session ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { final String memcachedNodes = toString ( address1 ) + " " + toString ( address2 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) ) , Arrays . asList ( address1 , address2 ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
private String toString ( final InetSocketAddress address1 ) { return address1 . getHostName ( ) + " : " + address1 . getPort ( ) ; } 
public void tearDown ( ) throws Exception { if ( _daemon1 . isRunning ( ) ) _daemon1 . stop ( ) ; if ( _daemon2 . isRunning ( ) ) _daemon2 . stop ( ) ; _tomcat1 . stop ( ) ; _connectionManager . shutdown ( ) ; } 
public void testRelocateSession ( ) throws HttpException , IOException { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; assertTrue ( " Session stored on unexpected memcached server " , sid1 . endsWith ( " .0 " ) ) ; _daemon1 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertTrue ( " Unexpected SessionId " , sid2 . equals ( sid1 . substring ( 0 , sid1 . indexOf ( " . " ) ) + " .1 " ) ) ; 
public void testRelocateSession ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( " Expired session returned " , sessionId1 , sessionId2 ) ; } 
public void testInvalidSessionId ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , " 12345 " ) ; assertNotNull ( " No session created. " , sessionId1 ) ; assertTrue ( " Invalid session id format " , sessionId1 . indexOf ( '.' ) > - 1 ) ; } 
protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { log ( " invoked " ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( " OK: " + request . getSession ( ) . getId ( ) ) ; 
public static String makeRequest ( final HttpClient client , int port , String rsessionId ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); String responseSessionId; final HttpMethod method = new GetMethod("http:localhost:"+ port +"/"); try { if ( rsessionId != null ) { 
public static Embedded createCatalina ( final int port , String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes ) ; } 
public static Embedded createCatalina ( final int port , int sessionTimeout , String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; engine . setName ( " engine- " + port ) ; engine . setDefaultHost ( " localhost " ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../resources " ) ; final String docBase = root . getFile ( ) + File . separator + TestUtils . class . getPackage ( ) . getName ( ) . replaceAll ( " \\ . " , File . separator ) ; final Host host = catalina . createHost ( " localhost " , docBase ) ; engine . addChild ( host ) ; new File ( docBase ) . mkdirs ( ) ; final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setActiveNodeIndex ( 0 ) ; sessionManager . setMaxInactiveInterval ( sessionTimeout ) ; 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) engine.setManager( sessionManager ); final Context context = catalina.createContext( "/", "webapp" ); context.setManager( sessionManager ); context.setBackgroundProcessorDelay( 1 ); host.addChild( context ); catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger.info( "Creating LRUCache with size 200 and TTL 100" ); _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 ); 
public BackupResult backupSession ( Session session ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { storeSessionInMemcached ( session ) ; 
private void storeSessionInMemcached ( Session session ) { final Future < Boolean > future = _memcached . set ( session . getId ( ) , _memcachedSessionTTL , session ) ; if ( ! _sessionBackupAsync ) { try { 
private Session loadFromMemcached ( String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( _logger . isLoggable ( Level . FINE ) ) { if ( session = = null ) { _logger . info ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; } } return session ; } 
public void remove ( Session session ) { _logger . info ( " remove invoked, session.relocate " + session . getNote ( SessionTrackerValve . RELOCATE ) + " , id " + session . getId ( ) ) ; try { _memcached . delete ( session . getId ( ) ) ; } catch ( RelocationException e ) { } super . remove ( session ) ; } 
private void setCookie ( Response response , Request request , final Session session ) { final Cookie newCookie = new Cookie ( JSESSIONID , session . getId ( ) ) ; newCookie . setMaxAge ( - 1 ) ; newCookie . setPath ( request . getContextPath ( ) ) ; response . addCookie ( newCookie ) ; } 
BackupResult backupSession ( Session session ) ; static enum BackupResult { SUCCESS , FAILURE , RELOCATED } } } 
public void setUp ( ) throws Exception { _sessionBackupServiceControl = mock ( SessionBackupService . class ) ; _service = ( SessionBackupService ) _sessionBackupServiceControl . proxy ( ) ; _sessionTrackerValve = new SessionTrackerValve ( null , _service ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( ( Valve ) _nextValve . proxy ( ) ) ; _requestControl = mock ( Request . class ) ; _request = ( Request ) _requestControl . proxy ( ) ; _responseControl = mock ( Response . class ) ; _response = ( Response ) _responseControl . proxy ( ) ; } 
public void tearDown ( ) throws Exception { _sessionBackupServiceControl . reset ( ) ; _nextValve . reset ( ) ; _requestControl . reset ( ) ; _responseControl . reset ( ) ; } 
public final void testGetSessionInternalNotInvokedWhenNoCookiePresent ( ) throws IOException , ServletException { _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenRequestCookiePresent ( ) throws IOException , ServletException { _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( SessionTrackerValve . JSESSIONID , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( SessionTrackerValve . JSESSIONID , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( SessionTrackerValve . JSESSIONID , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResult . SUCCESS ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testResponseCookieForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( SessionTrackerValve . JSESSIONID , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResult . RELOCATED ) ) ; sessionControl . expects ( once ( ) ) . method ( " getId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getContextPath " ) ; _responseControl . expects ( once ( ) ) . method ( " addCookie " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( sessionId ) ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenRequestedSessionIdPresent ( ) throws IOException , ServletException { _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( SessionTrackerValve . JSESSIONID , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResult . SUCCESS ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testResponseCookieForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResult . RELOCATED ) ) ; sessionControl . expects ( once ( ) ) . method ( " getId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getContextPath " ) ; _responseControl . expects ( once ( ) ) . method ( " addCookie " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( sessionId ) ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger.info( "Creating LRUCache with size 200 and TTL 100" ); _missingSessionsCache = new LRUCache<String, Boolean>( 200, 500 ); 
protected synchronized String generateSessionId ( ) { return _sessionIdFormat . createSessionId ( super . generateSessionId ( ) , _activeNodeIndex ) ; } 
private boolean isValidSessionIdFormat ( String sessionId ) { return _sessionIdFormat . isValid ( sessionId ) ; } 
private void relocate ( final Session session , String newNodeId , boolean delete ) { final String sessionId = session . getId ( ) ; session . setNote ( SessionTrackerValve . RELOCATE , Boolean . TRUE ) ; 
public String createSessionId ( String sessionId , String memcachedId ) { final int idx = sessionId . indexOf ( '.' ) ; if ( idx < 0 ) { return sessionId + " - " + memcachedId ; 
public String createNewSessionId ( String sessionId , String newMemcachedId ) { final int idxDash = sessionId . indexOf ( '-' ) ; if ( idxDash < 0 ) { return sessionId + " - " + newMemcachedId ; } final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot < 0 ) { return sessionId . substring ( 0 , idxDash + 1 ) + newMemcachedId ; 
public boolean isValid ( String sessionId ) { return sessionId ! = null & & _pattern . matcher ( sessionId ) . matches ( ) ; } 
public String extractMemcachedId ( String sessionId ) { final int idxDash = sessionId . indexOf ( '-' ) ; if ( idxDash < 0 ) { return null ; } final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot < 0 ) { return sessionId . substring ( idxDash + 1 ) ; 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes , _sessionIdFormat ) ; } 
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-n.jvm1 " , cut . createSessionId ( " foo.jvm1 " , " " ) ) ; } @Test public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " ) ) ; } @Test public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.jvm1 " ) ) ; } @Test public void testIsValid ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertFalse ( cut . isValid ( " foo " ) ) ; assertFalse ( cut . isValid ( " foo.jvm1-n " ) ) ; assertFalse ( cut . isValid ( " foo.n.jvm1 " ) ) ; assertTrue ( cut . isValid ( " foo-n " ) ) ; assertTrue ( cut . isValid ( " foo-n.jvm1 " ) ) ; } } 
public void tearDown ( ) throws Exception { } @Test public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-n.jvm1 " , cut . createSessionId ( " foo.jvm1 " , " " ) ) ; } @Test public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " ) ) ; } @Test public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.jvm1 " ) ) ; } @Test public void testIsValid ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertFalse ( cut . isValid ( " foo " ) ) ; assertFalse ( cut . isValid ( " foo.jvm1-n " ) ) ; assertFalse ( cut . isValid ( " foo.n.jvm1 " ) ) ; assertTrue ( cut . isValid ( " foo-n " ) ) ; assertTrue ( cut . isValid ( " foo-n.jvm1 " ) ) ; } } 
public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-n.jvm1 " , cut . createSessionId ( " foo.jvm1 " , " " ) ) ; } 
public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " ) ) ; 
public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.jvm1 " ) ) ; } 
public void testIsValid ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertFalse ( cut . isValid ( " foo " ) ) ; assertFalse ( cut . isValid ( " foo.jvm1-n " ) ) ; assertFalse ( cut . isValid ( " foo.n.jvm1 " ) ) ; assertTrue ( cut . isValid ( " foo-n " ) ) ; assertTrue ( cut . isValid ( " foo-n.jvm1 " ) ) ; } 
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes , new SessionIdFormat ( ) ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); fail( "We shouldn't reach this" ); } catch( UnavailableNodeException e ) { @Test public final void testLastNodeReachedRestartAtFirst() { final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>(); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator( nodes, new SessionIdFormat() ); String nextNodeId = cut.getNextNodeId( "foo.1" ); assertEquals( "0", nextNodeId ); }} 
public void tearDown ( ) throws Exception { } @Test public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes , new SessionIdFormat ( ) ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); fail( "We shouldn't reach this" ); } catch( UnavailableNodeException e ) { @Test public final void testLastNodeReachedRestartAtFirst() { final List<MemcachedNode> nodes = new ArrayList<MemcachedNode>(); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); nodes.add( (MemcachedNode) mock( MemcachedNode.class ).proxy() ); final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator( nodes, new SessionIdFormat() ); String nextNodeId = cut.getNextNodeId( "foo.1" ); assertEquals( "0", nextNodeId ); }} 
public final void testGetNextNodeId_NoNodeLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes , new SessionIdFormat ( ) ) ; we use try/catch here, as the expected attribute of the @Test annotation does not do what it should try { cut.getNextNodeId( "foo.0" ); 
public final void testGetNextNodeId_NodesLeft ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes , new SessionIdFormat ( ) ) ; String nextNodeId = cut . getNextNodeId ( " foo.0 " ) ; assertEquals ( " 1 " , nextNodeId ) ; } 
public final void testLastNodeReachedRestartAtFirst ( ) { final List < MemcachedNode > nodes = new ArrayList < MemcachedNode > ( ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; nodes . add ( ( MemcachedNode ) mock ( MemcachedNode . class ) . proxy ( ) ) ; final SuffixBasedNodeLocator cut = new SuffixBasedNodeLocator ( nodes , new SessionIdFormat ( ) ) ; String nextNodeId = cut . getNextNodeId ( " foo.1 " ) ; assertEquals ( " 0 " , nextNodeId ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { final String memcachedNodes = toString ( address1 ) + " " + toString ( address2 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( address1 , address2 ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void testRelocateSession ( ) throws HttpException , IOException { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; assertTrue ( " Session stored on unexpected memcached server " , sid1 . endsWith ( " -0 " ) ) ; _daemon1 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertTrue ( " Unexpected SessionId " , sid2 . equals ( sid1 . substring ( 0 , sid1 . indexOf ( " - " ) ) + " -1 " ) ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void testSessionIdJvmRouteCompatibility ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; assertTrue ( " Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>]. " , sessionId1 . matches ( " [^-.]+-[^.]+( \\ .[ \\ w]+)? " ) ) ; } 
public void testInvalidSessionId ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , " 12345 " ) ; assertNotNull ( " No session created. " , sessionId1 ) ; assertTrue ( " Invalid session id format " , sessionId1 . indexOf ( '-' ) > - 1 ) ; } 
public static Embedded createCatalina ( final int port , String memcachedNodes , String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute ) ; } 
public static Embedded createCatalina ( final int port , int sessionTimeout , String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , sessionTimeout , memcachedNodes , null ) ; } 
public static Embedded createCatalina ( final int port , int sessionTimeout , String memcachedNodes , String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; engine . setName ( " engine- " + port ) ; engine . setDefaultHost ( " localhost " ) ; engine . setJvmRoute ( jvmRoute ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../resources " ) ; final String docBase = root . getFile ( ) + File . separator + TestUtils . class . getPackage ( ) . getName ( ) . replaceAll ( " \\ . " , File . separator ) ; final Host host = catalina . createHost ( " localhost " , docBase ) ; engine . addChild ( host ) ; new File ( docBase ) . mkdirs ( ) ; final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setActiveNodeIndex ( 0 ) ; sessionManager . setMaxInactiveInterval ( sessionTimeout ) ; 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) engine.setManager( sessionManager ); final Context context = catalina.createContext( "/", "webapp" ); context.setManager( sessionManager ); context.setBackgroundProcessorDelay( 1 ); host.addChild( context ); catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; _portTomcat2 = 8889 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { final String memcachedNodes = " localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , new SessionIdFormat ( ) ) , 
public void testConnectDaemon ( ) throws IOException , InterruptedException { final Object value = " bar " ; _client . set ( " foo-0 " , 3600 , value ) ; Assert . assertEquals ( value , _client . get ( " foo-0 " ) ) ; } 
public static void main ( String [ ] args ) { final List < String > nodeIds = new ArrayList < String > ( ) ; final Random random = new Random ( ) ; for ( int i = 0 ; i < 3 ; i + + ) { nodeIds . add ( String . valueOf ( i ) ) ; 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger . info ( " Creating LRUCache with size 200 and TTL 100 " ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; 
protected synchronized String generateSessionId ( ) { return _sessionIdFormat . createSessionId ( super . generateSessionId ( ) , getMemcachedNodeId ( ) ) ; } 
public Session findSession ( String id ) throws IOException { Session result = super . findSession ( id ) ; if ( result = = null & & _missingSessionsCache . get ( id ) = = null ) { result = loadFromMemcached ( id ) ; if ( result ! = null ) { add ( result ) ; } else { _missingSessionsCache . put ( id , Boolean . TRUE ) ; } } return result ; } 
public BackupResult backupSession ( Session session ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { storeSessionInMemcached ( session ) ; 
protected static String getNextNodeId ( final String nodeId , final List < String > nodeIds , Set < String > excludedNodeIds ) { String result = null ; final int origIdx = nodeIds . indexOf ( nodeId ) ; final int nodeIdsSize = nodeIds . size ( ) ; int idx = origIdx ; while ( result = = null & & ! loopFinished ( origIdx , idx , nodeIdsSize ) ) { final int checkIdx = roll ( idx , nodeIdsSize ) ; final String checkNodeId = nodeIds . get ( checkIdx ) ; if ( excludedNodeIds ! = null & & excludedNodeIds . contains ( checkNodeId ) ) { idx = checkIdx ; } else { result = checkNodeId ; } } return result ; } 
private static boolean loopFinished ( final int origIdx , int idx , final int nodeIdsSize ) { return origIdx = = - 1 ? idx + 1 = = nodeIdsSize : roll ( idx , nodeIdsSize ) = = origIdx ; } 
protected static int roll ( int idx , final int size ) { return idx + 1 > = size ? 0 : idx + 1 ; } 
private void storeSessionInMemcached ( Session session ) { final Future < Boolean > future = _memcached . set ( session . getId ( ) , _memcachedSessionTTL , session ) ; if ( ! _sessionBackupAsync ) { try { 
private Session loadFromMemcached ( String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( _logger . isLoggable ( Level . FINE ) ) { if ( session = = null ) { _logger . info ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . info ( " Found session with id " + sessionId ) ; } } return session ; } 
private void relocate ( final Session session , String newNodeId , boolean delete ) { final String sessionId = session . getId ( ) ; session . setNote ( SessionTrackerValve . RELOCATE , Boolean . TRUE ) ; 
public void remove ( Session session ) { _logger . info ( " remove invoked, session.relocate " + session . getNote ( SessionTrackerValve . RELOCATE ) + " , id " + session . getId ( ) ) ; try { _memcached . delete ( session . getId ( ) ) ; } catch ( NodeFailureException e ) { } super . remove ( session ) ; } 
public static Builder node ( String id , InetSocketAddress address ) { return new Builder ( ) . node ( id , address ) ; } 
public Builder node ( String id , InetSocketAddress address ) { final String previous = _address2Ids . put ( address , id ) ; if ( previous ! = null ) { throw new IllegalArgumentException ( " There's already an address bound to id " + previous ) ; } return this ; } 
public NodeIdResolver build ( ) { return new MapBasedResolver ( _address2Ids ) ; } 
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes , _resolver , _sessionIdFormat ) ; } 
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test public final void testRoll ( ) { assertEquals ( 0 , MemcachedBackupSessionManager . roll ( 0 , 1 ) ) ; assertEquals ( 1 , MemcachedBackupSessionManager . roll ( 0 , 2 ) ) ; assertEquals ( 0 , MemcachedBackupSessionManager . roll ( 1 , 2 ) ) ; } @Test public final void testGetNextNodeId_SingleNode ( ) { String actual = MemcachedBackupSessionManager . getNextNodeId ( " n1 " , Arrays . asList ( " n1 " ) , null ) ; assertNull ( " For a sole existing node we cannot get a next node " , actual ) ; } @Test public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final MemcachedBackupSessionManager cut = new MemcachedBackupSessionManager ( ) ; final String nodeId1 = " n1 " ; cut . setNodeIds ( Arrays . asList ( nodeId1 ) ) ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; cut . setFailoverNodeIds ( Arrays . asList ( nodeId2 , nodeId3 ) ) ; String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertEquals ( " The second failover node is not chosen " , nodeId3 , actual ) ; } private Set < String > asSet ( String . . . vals ) { final Set < String > result = new HashSet < String > ( vals . length ) ; for ( String val : vals ) { result . add ( val ) ; } return result ; } } 
public void tearDown ( ) throws Exception { } @Test public final void testRoll ( ) { assertEquals ( 0 , MemcachedBackupSessionManager . roll ( 0 , 1 ) ) ; assertEquals ( 1 , MemcachedBackupSessionManager . roll ( 0 , 2 ) ) ; assertEquals ( 0 , MemcachedBackupSessionManager . roll ( 1 , 2 ) ) ; } @Test public final void testGetNextNodeId_SingleNode ( ) { String actual = MemcachedBackupSessionManager . getNextNodeId ( " n1 " , Arrays . asList ( " n1 " ) , null ) ; assertNull ( " For a sole existing node we cannot get a next node " , actual ) ; } @Test public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final MemcachedBackupSessionManager cut = new MemcachedBackupSessionManager ( ) ; final String nodeId1 = " n1 " ; cut . setNodeIds ( Arrays . asList ( nodeId1 ) ) ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; cut . setFailoverNodeIds ( Arrays . asList ( nodeId2 , nodeId3 ) ) ; String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertEquals ( " The second failover node is not chosen " , nodeId3 , actual ) ; } private Set < String > asSet ( String . . . vals ) { final Set < String > result = new HashSet < String > ( vals . length ) ; for ( String val : vals ) { result . add ( val ) ; } return result ; } } 
public final void testRoll ( ) { assertEquals ( 0 , MemcachedBackupSessionManager . roll ( 0 , 1 ) ) ; assertEquals ( 1 , MemcachedBackupSessionManager . roll ( 0 , 2 ) ) ; assertEquals ( 0 , MemcachedBackupSessionManager . roll ( 1 , 2 ) ) ; } 
public final void testGetNextNodeId_SingleNode ( ) { String actual = MemcachedBackupSessionManager . getNextNodeId ( " n1 " , Arrays . asList ( " n1 " ) , null ) ; assertNull ( " For a sole existing node we cannot get a next node " , actual ) ; } 
public final void testGetNextNodeId_TwoNodes ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; String actual = MemcachedBackupSessionManager . getNextNodeId ( nodeId1 , Arrays . asList ( nodeId1 , nodeId2 ) , null ) ; assertEquals ( nodeId2 , actual ) ; actual = MemcachedBackupSessionManager . getNextNodeId ( nodeId2 , Arrays . asList ( nodeId1 , nodeId2 ) , null ) ; assertEquals ( nodeId1 , actual ) ; } 
public final void testGetNextNodeId_TwoNodes_NoNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; String actual = MemcachedBackupSessionManager . getNextNodeId ( nodeId2 , Arrays . asList ( nodeId1 , nodeId2 ) , asSet ( nodeId1 ) ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_RegularNode_NoRegularNodeLeft ( ) { final MemcachedBackupSessionManager cut = new MemcachedBackupSessionManager ( ) ; final String nodeId1 = " n1 " ; cut . setNodeIds ( Arrays . asList ( nodeId1 ) ) ; final String nodeId2 = " n2 " ; cut . setFailoverNodeIds ( Arrays . asList ( nodeId2 ) ) ; String actual = cut . getNextNodeId ( nodeId1 , null ) ; assertEquals ( " The failover node is not chosen " , nodeId2 , actual ) ; } 
public final void testGetNextNodeId_FailoverNode_RegularNodeLeft ( ) { final MemcachedBackupSessionManager cut = new MemcachedBackupSessionManager ( ) ; final String nodeId1 = " n1 " ; cut . setNodeIds ( Arrays . asList ( nodeId1 ) ) ; final String nodeId2 = " n2 " ; cut . setFailoverNodeIds ( Arrays . asList ( nodeId2 ) ) ; String actual = cut . getNextNodeId ( nodeId2 , null ) ; assertEquals ( " The regular node is not chosen " , nodeId1 , actual ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeLeft ( ) { final MemcachedBackupSessionManager cut = new MemcachedBackupSessionManager ( ) ; final String nodeId1 = " n1 " ; cut . setNodeIds ( Arrays . asList ( nodeId1 ) ) ; final String nodeId2 = " n2 " ; cut . setFailoverNodeIds ( Arrays . asList ( nodeId2 ) ) ; String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final MemcachedBackupSessionManager cut = new MemcachedBackupSessionManager ( ) ; final String nodeId1 = " n1 " ; cut . setNodeIds ( Arrays . asList ( nodeId1 ) ) ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; cut . setFailoverNodeIds ( Arrays . asList ( nodeId2 , nodeId3 ) ) ; String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertEquals ( " The second failover node is not chosen " , nodeId3 , actual ) ; } 
private Set < String > asSet ( String . . . vals ) { final Set < String > result = new HashSet < String > ( vals . length ) ; for ( String val : vals ) { result . add ( val ) ; } return result ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; try { final String memcachedNodes = toString ( _nodeId1 , address1 ) + " " + toString ( _nodeId2 , address2 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , NodeIdResolver . node ( _nodeId1 , address1 ) . node ( _nodeId2 , address2 ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( address1 , address2 ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
private String toString ( final String nodeId , final InetSocketAddress address ) { return nodeId + " : " + address . getHostName ( ) + " : " + address . getPort ( ) ; } 
public void testRelocateSession ( ) throws HttpException , IOException { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , sid1 ) ; _daemon1 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = firstNode . equals ( _nodeId1 ) ? _nodeId2 : _nodeId1 ; assertEquals ( " Unexpected nodeId " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void testConfiguredMemcachedNodeId ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; final String nodeId = sessionId1 . substring ( sessionId1 . indexOf ( '-' ) + 1 , sessionId1 . indexOf ( '.' ) ) ; assertEquals ( " Invalid memcached node id " , _memcachedNodeId , nodeId ) ; } 
public static Embedded createCatalina ( final int port , int sessionTimeout , String memcachedNodes , String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; engine . setName ( " engine- " + port ) ; engine . setDefaultHost ( " localhost " ) ; engine . setJvmRoute ( jvmRoute ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../resources " ) ; final String docBase = root . getFile ( ) + File . separator + TestUtils . class . getPackage ( ) . getName ( ) . replaceAll ( " \\ . " , File . separator ) ; final Host host = catalina . createHost ( " localhost " , docBase ) ; engine . addChild ( host ) ; new File ( docBase ) . mkdirs ( ) ; final MemcachedBackupSessionManager sessionManager = new MemcachedBackupSessionManager ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setMaxInactiveInterval ( sessionTimeout ) ; 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) engine.setManager( sessionManager ); final Context context = catalina.createContext( "/", "webapp" ); context.setManager( sessionManager ); context.setBackgroundProcessorDelay( 1 ); host.addChild( context ); catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; _portTomcat2 = 8889 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; _nodeId = " n1 " ; try { final String memcachedNodes = _nodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , 2 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , 
public void testConnectDaemon ( ) throws IOException , InterruptedException { final Object value = " bar " ; _client . set ( " foo- " + _nodeId , 3600 , value ) ; Assert . assertEquals ( value , _client . get ( " foo- " + _nodeId ) ) ; } 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger . info ( " Creating LRUCache with size 200 and TTL 100 " ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; 
private void storeSessionInMemcached ( Session session ) { final Future < Boolean > future = _memcached . set ( session . getId ( ) , getMaxInactiveInterval ( ) , session ) ; if ( ! _sessionBackupAsync ) { try { 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _logger . info ( " Creating LRUCache with size 200 and TTL 100 " ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; 
public void testRelocateSession ( ) throws HttpException , IOException { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , sid1 ) ; final boolean node1 = firstNode . equals ( _nodeId1 ) ; if ( node1 ) { _daemon1 . stop ( ) ; } else { _daemon2 . stop ( ) ; } final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = node1 ? _nodeId2 : _nodeId1 ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
private void storeSessionInMemcached ( Session session ) throws NodeFailureException { final Future < Boolean > future = _memcached . set ( session . getId ( ) , getMaxInactiveInterval ( ) , session ) ; if ( ! _sessionBackupAsync ) { try { 
private void relocate ( final Session session , String newNodeId ) throws NodeFailureException { final String sessionId = session . getId ( ) ; session . setNote ( SessionTrackerValve . RELOCATE , Boolean . TRUE ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , address1 ) + " " + toString ( _nodeId2 , address2 ) + " " + toString ( _nodeId3 , address3 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , NodeIdResolver . node ( _nodeId1 , address1 ) . node ( _nodeId2 , address2 ) . node ( _nodeId3 , address3 ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( address1 , address2 , address3 ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void tearDown ( ) throws Exception { if ( _daemon1 . isRunning ( ) ) _daemon1 . stop ( ) ; if ( _daemon2 . isRunning ( ) ) _daemon2 . stop ( ) ; if ( _daemon3 . isRunning ( ) ) _daemon3 . stop ( ) ; _tomcat1 . stop ( ) ; _connectionManager . shutdown ( ) ; } 
public void testRelocateSession ( ) throws HttpException , IOException , InterruptedException { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , sid1 ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . nextNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
public void testMultipleMemcachedNodesFailure ( ) throws HttpException , IOException , InterruptedException { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , sid1 ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; info . nextNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . failoverNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
private void startTomcat ( ) throws Throwable { try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + 
public void testRelocateSession ( ) throws Throwable { startTomcat ( ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . nextNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
public void testMultipleMemcachedNodesFailure ( ) throws Throwable { startTomcat ( ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; info . nextNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . failoverNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
public void testAllMemcachedNodesFailure ( ) throws Throwable { startTomcat ( ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertEquals ( " SessionId changed. " , sid1 , sid2 ) ; assertNotNull ( " Session not existing. " , getSessions ( ) . get ( sid2 ) ) ; 
private Map < String , Session > getSessions ( ) throws NoSuchFieldException , IllegalAccessException { final Field field = ManagerBase . class . getDeclaredField ( " sessions " ) ; field . setAccessible ( true ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Session > sessions = ( Map < String , Session > ) field . get ( _tomcat1 . getContainer ( ) . getManager ( ) ) ; return sessions ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void testRelocateSession ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . nextNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
public void testMultipleMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; info . nextNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . failoverNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , 
public void testAllMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertEquals ( " SessionId changed. " , sid1 , sid2 ) ; assertNotNull ( " Session not existing. " , getSessions ( ) . get ( sid2 ) ) ; 
public static Embedded createCatalina ( final int port , int sessionTimeout , String memcachedNodes , String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setMaxInactiveInterval ( sessionTimeout ) ; 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public Session findSession ( String id ) throws IOException { Session result = super . findSession ( id ) ; System . out . println ( " ############ findSession " + id + " , result: " + result ) ; if ( result = = null & & _missingSessionsCache . get ( id ) = = null ) { result = loadFromMemcached ( id ) ; if ( result ! = null ) { add ( result ) ; } else { _missingSessionsCache . put ( id , Boolean . TRUE ) ; } } return result ; } 
public void testRelocateSession ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . nextNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , sid2 ) ; Session session = _tomcat1 . getContainer ( ) . getManager ( ) . findSession ( sid2 ) ; assertFalse ( " Some notes are set: " + toArray ( session . getNoteNames ( ) ) , session . getNoteNames ( ) . hasNext ( ) ) ; 
public void testMultipleMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; info . nextNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . failoverNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , sid2 ) ; Session session = _tomcat1 . getContainer ( ) . getManager ( ) . findSession ( sid2 ) ; assertFalse ( " Some notes are set: " + toArray ( session . getNoteNames ( ) ) , session . getNoteNames ( ) . hasNext ( ) ) ; 
private Set < String > toArray ( Iterator < String > noteNames ) { final Set < String > result = new HashSet < String > ( ) ; while ( noteNames . hasNext ( ) ) { result . add ( noteNames . next ( ) ) ; } return result ; } 
public void testAllMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertEquals ( " SessionId changed. " , sid1 , sid2 ) ; assertNotNull ( " Session not existing. " , getSessions ( ) . get ( sid2 ) ) ; Session session = _tomcat1 . getContainer ( ) . getManager ( ) . findSession ( sid2 ) ; assertFalse ( " Some notes are set: " + toArray ( session . getNoteNames ( ) ) , session . getNoteNames ( ) . hasNext ( ) ) ; 
public V put ( K key , V value ) { synchronized ( _map ) { final ManagedItem < V > previous = _map . put ( key , new ManagedItem < V > ( value , System . currentTimeMillis ( ) ) ) ; 
public V putIfDifferent ( K key , V value ) { synchronized ( _map ) { final ManagedItem < V > item = _map . get ( key ) ; 
public V get ( K key ) { synchronized ( _map ) { final ManagedItem < V > item = _map . get ( key ) ; 
public void action ( ActionCode actionCode , Object param ) { if ( actionCode = = ActionCode . ACTION_COMMIT & & ! _response . isCommitted ( ) ) { beforeCommit ( ) ; } _delegate . action ( actionCode , param ) ; } 
public boolean isNodeAvailable ( K key ) { final ManagedItem < Boolean > item = _map . get ( key ) ; if ( item = = null ) { return updateIsNodeAvailable ( key ) ; 
private boolean isExpired ( final ManagedItem < Boolean > item ) { return _ttl > - 1 & & System . currentTimeMillis ( ) - item . insertionTime > _ttl ; } 
private boolean updateIsNodeAvailable ( K key ) { final Boolean result = Boolean . valueOf ( _cacheLoader . isNodeAvailable ( key ) ) ; _map . put ( key , new ManagedItem < Boolean > ( result , System . currentTimeMillis ( ) ) ) ; return result ; } 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = new NodeAvailabilityCache < String > ( _allNodeIds . size ( ) , 1000 , new CacheLoader < String > ( ) { 
public boolean isNodeAvailable ( String key ) { try { _memcached . get ( _sessionIdFormat . createSessionId ( " ping " , key ) ) ; 
public void expireSession ( String sessionId ) { _logger . fine ( " expireSession invoked: " + sessionId ) ; super . expireSession ( sessionId ) ; _memcached . delete ( sessionId ) ; } 
public Session findSession ( String id ) throws IOException { Session result = super . findSession ( id ) ; if ( result = = null & & _missingSessionsCache . get ( id ) = = null ) { result = loadFromMemcached ( id ) ; if ( result ! = null ) { add ( result ) ; } else { _missingSessionsCache . put ( id , Boolean . TRUE ) ; } } if ( result == null ) { final String relocatedSessionId = _relocatedSessions.get( id ); if ( relocatedSessionId != null ) { result = findSession( relocatedSessionId ); } } return result; } 
public Session createSession ( String sessionId ) { _logger . fine ( " createSession invoked: " + sessionId ) ; Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; session . setId ( generateSessionId ( ) ) ; _logger . fine ( ToStringBuilder . reflectionToString ( session ) ) ; } sessionCounter + + ; return ( session ) ; 
public MemcachedBackupSession createEmptySession ( ) { return new MemcachedBackupSession ( this ) ; } 
public BackupResult backupSession ( Session session ) { if ( _logger . isLoggable ( Level . INFO ) ) { _logger . fine ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { 
public String sessionNeedsRelocate ( final Session session ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ; if ( nodeId ! = null & & ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { final String nextNodeId = getNextNodeId ( nodeId , _nodeAvailabilityCache . getUnavailableNodes ( ) ) ; if ( nextNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( session . getId ( ) , nextNodeId ) ; session . setNote ( RELOCATE_SESSION_ID , newSessionId ) ; return newSessionId ; } else { _logger . warning ( " The node " + nodeId + " is not available and there's no node for relocation left. " ) ; } } return null ; } 
private Session loadFromMemcached ( String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _logger . fine ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _logger . fine ( " Loading session from memcached: " + sessionId ) ; try { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( _logger . isLoggable ( Level . FINE ) ) { if ( session = = null ) { _logger . fine ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . fine ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; return session ; } catch ( NodeFailureException e ) { _logger . warning ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } } return null ; } 
void beforeCommit ( ) { _logger.info( " CommitInterceptingActionHook executing before commit..." ); final Session session = request.getSessionInternal( false ); if ( session != null ) { final String newSessionId = _sessionBackupService.sessionNeedsRelocate( session ); _logger.info( "CommitInterceptingActionHook before commit got new session id: " + newSessionId ); if ( newSessionId != null ) { setSessionIdCookie( response, request, newSessionId ); } } response.getCoyoteResponse().setHook( origHook ); } 
private void setSessionIdCookie ( Response response , Request request , final Session session ) { setSessionIdCookie ( response , request , session . getId ( ) ) ; } 
String sessionNeedsRelocate ( final Session session ) ; BackupResult backupSession ( Session session ) ; static enum BackupResult { SUCCESS , FAILURE , RELOCATED } } } 
public void setUp ( ) throws Throwable { _portTomcat1 = 8088 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void stop ( ) throws LifecycleException { if ( initialized ) { _memcached . shutdown ( ) ; 
public void setUp ( ) throws Exception { _sessionBackupServiceControl = mock ( SessionBackupService . class ) ; _service = ( SessionBackupService ) _sessionBackupServiceControl . proxy ( ) ; _sessionTrackerValve = new SessionTrackerValve ( null , _service ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( ( Valve ) _nextValve . proxy ( ) ) ; _requestControl = mock ( Request . class ) ; _request = ( Request ) _requestControl . proxy ( ) ; _responseControl = mock ( Response . class ) ; _response = ( Response ) _responseControl . proxy ( ) ; _coyoteResponseControl = mock( org.apache.coyote.Response.class ); 
public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenRequestedSessionIdPresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( SessionTrackerValve . JSESSIONID , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResult . SUCCESS ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testResponseCookieForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResult . RELOCATED ) ) ; sessionControl . expects ( once ( ) ) . method ( " getId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getContextPath " ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( sessionId ) ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _portTomcat2 = 18889 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; _nodeId = " n1 " ; try { final String memcachedNodes = _nodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , 2 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , 
public void tearDown ( ) throws Exception { _memcached . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _connectionManager . shutdown ( ) ; } 
public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; } 
public void action ( final ActionCode actionCode , final Object param ) { if ( actionCode = = ActionCode . ACTION_COMMIT & & ! _response . isCommitted ( ) ) { beforeCommit ( ) ; } _delegate . action ( actionCode , param ) ; } 
public V put ( final K key , final V value ) { synchronized ( _map ) { final ManagedItem < V > previous = _map . put ( key , new ManagedItem < V > ( value , System . currentTimeMillis ( ) ) ) ; 
public V putIfDifferent ( final K key , final V value ) { synchronized ( _map ) { final ManagedItem < V > item = _map . get ( key ) ; 
public V get ( final K key ) { synchronized ( _map ) { final ManagedItem < V > item = _map . get ( key ) ; 
public void init ( ) { _logger . info ( " init invoked " ) ; if ( initialized ) return ; super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = new NodeAvailabilityCache < String > ( _allNodeIds . size ( ) , 1000 , new CacheLoader < String > ( ) { 
public boolean isNodeAvailable ( final String key ) { try { _memcached . get ( _sessionIdFormat . createSessionId ( " ping " , key ) ) ; 
private boolean isValidSessionIdFormat ( final String sessionId ) { return _sessionIdFormat . isValid ( sessionId ) ; } 
public void expireSession ( final String sessionId ) { _logger . fine ( " expireSession invoked: " + sessionId ) ; super . expireSession ( sessionId ) ; _memcached . delete ( sessionId ) ; } 
public Session findSession ( final String id ) throws IOException { Session result = super . findSession ( id ) ; if ( result = = null & & _missingSessionsCache . get ( id ) = = null ) { result = loadFromMemcached ( id ) ; if ( result ! = null ) { add ( result ) ; } else { _missingSessionsCache . put ( id , Boolean . TRUE ) ; } } if ( result == null ) { final String relocatedSessionId = _relocatedSessions.get( id ); if ( relocatedSessionId != null ) { result = findSession( relocatedSessionId ); } } return result; } 
public Session createSession ( final String sessionId ) { _logger . fine ( " createSession invoked: " + sessionId ) ; Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; session . setId ( generateSessionId ( ) ) ; _logger . fine ( ToStringBuilder . reflectionToString ( session ) ) ; } sessionCounter + + ; return ( session ) ; 
public BackupResult backupSession ( final Session session ) { if ( _logger . isLoggable ( Level . INFO ) ) { _logger . fine ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { 
public String sessionNeedsRelocate ( final Session session ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ; if ( nodeId ! = null & & ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { final String nextNodeId = getNextNodeId ( nodeId , _nodeAvailabilityCache . getUnavailableNodes ( ) ) ; if ( nextNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( session . getId ( ) , nextNodeId ) ; session . setNote ( RELOCATE_SESSION_ID , newSessionId ) ; return newSessionId ; } else { _logger . warning ( " The node " + nodeId + " is not available and there's no node for relocation left. " ) ; } } return null ; } 
private static boolean loopFinished ( final int origIdx , final int idx , final int nodeIdsSize ) { return origIdx = = - 1 ? idx + 1 = = nodeIdsSize 
protected static int roll ( final int idx , final int size ) { return idx + 1 > = size ? 0 
private void storeSessionInMemcached ( final Session session ) throws NodeFailureException { final Future < Boolean > future = _memcached . set ( session . getId ( ) , getMaxInactiveInterval ( ) , session ) ; if ( ! _sessionBackupAsync ) { try { 
private Session loadFromMemcached ( final String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _logger . fine ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _logger . fine ( " Loading session from memcached: " + sessionId ) ; try { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( _logger . isLoggable ( Level . FINE ) ) { if ( session = = null ) { _logger . fine ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . fine ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; return session ; } catch ( final NodeFailureException e ) { _logger . warning ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } } return null ; } 
public void addLifecycleListener ( final LifecycleListener arg0 ) { _lifecycle . addLifecycleListener ( arg0 ) ; } 
public LifecycleListener [ ] findLifecycleListeners ( ) { return _lifecycle . findLifecycleListeners ( ) ; } 
public void removeLifecycleListener ( final LifecycleListener arg0 ) { _lifecycle . removeLifecycleListener ( arg0 ) ; } 
public boolean isNodeAvailable ( final K key ) { final ManagedItem < Boolean > item = _map . get ( key ) ; if ( item = = null ) { return updateIsNodeAvailable ( key ) ; 
private boolean updateIsNodeAvailable ( final K key ) { final Boolean result = Boolean . valueOf ( _cacheLoader . isNodeAvailable ( key ) ) ; _map . put ( key , new ManagedItem < Boolean > ( result , System . currentTimeMillis ( ) ) ) ; return result ; } 
public static Builder node ( final String id , final InetSocketAddress address ) { return new Builder ( ) . node ( id , address ) ; } 
public Builder node ( final String id , final InetSocketAddress address ) { final String previous = _address2Ids . put ( address , id ) ; if ( previous ! = null ) { throw new IllegalArgumentException ( " There's already an address bound to id " + previous ) ; } return this ; } 
public String createSessionId ( final String sessionId , final String memcachedId ) { final int idx = sessionId . indexOf ( '.' ) ; if ( idx < 0 ) { return sessionId + " - " + memcachedId ; 
public String createNewSessionId ( final String sessionId , final String newMemcachedId ) { final int idxDash = sessionId . indexOf ( '-' ) ; if ( idxDash < 0 ) { return sessionId + " - " + newMemcachedId ; } final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot < 0 ) { return sessionId . substring ( 0 , idxDash + 1 ) + newMemcachedId ; 
public boolean isValid ( final String sessionId ) { return sessionId ! = null & & _pattern . matcher ( sessionId ) . matches ( ) ; } 
public String extractMemcachedId ( final String sessionId ) { final int idxDash = sessionId . indexOf ( '-' ) ; if ( idxDash < 0 ) { return null ; } final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot < 0 ) { return sessionId . substring ( idxDash + 1 ) ; 
protected byte [ ] serialize ( final Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } byte[] rv=null; try { ByteArrayOutputStream bos=new ByteArrayOutputStream(); ObjectOutputStream os=new ObjectOutputStream(bos); os.writeObject(o); os.close(); bos.close(); rv=bos.toByteArray(); } catch(IOException e) { throw new IllegalArgumentException("Non-serializable object", e); } return rv; ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; try { bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream( bos ); } catch ( final IOException e ) { if ( bos != null ) { try { bos.close(); } catch ( final IOException f ) { } } if ( oos != null ) { try { oos.close(); } catch ( final IOException f ) { } } throw new IllegalArgumentException( "Non-serializable object", e ); } try { ( (StandardSession) o ).writeObjectData( oos ); 
protected Object deserialize ( final byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; Loader loader = null ; ClassLoader classLoader = null ; try { bis = new ByteArrayInputStream ( in ) ; if ( _manager . getContainer ( ) ! = null ) loader = _manager . getContainer ( ) . getLoader ( ) ; if ( loader ! = null ) classLoader = loader . getClassLoader ( ) ; if ( classLoader ! = null ) ois = new CustomObjectInputStream ( bis , classLoader ) ; else ois = new ObjectInputStream ( bis ) ; } catch ( final IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; if ( bis ! = null ) { try { bis . close ( ) ; } catch ( final IOException f ) { } bis = null ; } if ( ois ! = null ) { try { ois . close ( ) ; } catch ( final IOException f ) { } ois = null ; } throw new RuntimeException ( " Caught IOException decoding data " , e ) ; } try { 
void beforeCommit ( ) { _logger.info( " CommitInterceptingActionHook executing before commit..." ); final Session session = request.getSessionInternal( false ); if ( session != null ) { final String newSessionId = _sessionBackupService.sessionNeedsRelocate( session ); _logger.info( "CommitInterceptingActionHook before commit got new session id: " + newSessionId ); if ( newSessionId != null ) { setSessionIdCookie( response, request, newSessionId ); } } response.getCoyoteResponse().setHook( origHook ); } 
String sessionNeedsRelocate ( final Session session ) ; static enum BackupResult { SUCCESS , FAILURE , RELOCATED } } } 
BackupResult backupSession ( Session session ) ; static enum BackupResult { SUCCESS , FAILURE , RELOCATED } } } 
public void addOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; } 
public void fillWriteBuffer ( final boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; } 
public void registerChannel ( final SocketChannel ch , final SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; } 
public NodeLocator createLocator ( final List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes , _resolver , _sessionIdFormat ) ; } 
private boolean isExpired ( final ManagedItem < Boolean > item ) { return _ttl > - 1 & & System . currentTimeMillis ( ) - item . _insertionTime > _ttl ; } 
public void init ( ) { _logger . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
private NodeAvailabilityCache < String > createNodeAvailabilityCache ( final long ttlInMillis ) { return new NodeAvailabilityCache < String > ( _allNodeIds . size ( ) , ttlInMillis , new CacheLoader < String > ( ) { 
private void initFailoverNodes ( ) { _failoverNodeIds = new ArrayList < String > ( ) ; if ( _failoverNodes ! = null & & _failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodes = _failoverNodes . split ( " : " ) ; 
private void initHandleNodeDefinitionMatch ( final Matcher matcher , final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids ) { final String nodeId = matcher . group ( 1 ) ; _nodeIds . add ( nodeId ) ; _allNodeIds . add ( nodeId ) ; final String hostname = matcher . group ( 2 ) ; final int port = Integer . parseInt ( matcher . group ( 3 ) ) ; final InetSocketAddress address = new InetSocketAddress ( hostname , port ) ; addresses . add ( address ) ; address2Ids . put ( address , nodeId ) ; } 
private BackupResult handleAndTranslateBackupResult ( final BackupResult backupResult , final Session session ) { switch ( backupResult ) { case SUCCESS : 
public void start ( ) throws LifecycleException { if ( ! initialized ) { init ( ) ; 
protected byte [ ] serialize ( final Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; oos = new ObjectOutputStream ( bos ) ; } catch ( final IOException e ) { closeSilently ( bos ) ; closeSilently ( oos ) ; throw new IllegalArgumentException ( " Non-serializable object " , e ) ; } try { ( ( StandardSession ) o ) . writeObjectData ( oos ) ; 
private void closeSilently ( final OutputStream os ) { if ( os ! = null ) { try { 
private void closeSilently ( final InputStream is ) { if ( is ! = null ) { try { 
protected Object deserialize ( final byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( in ) ; ois = createObjectInputStream ( bis ) ; } catch ( final IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; closeSilently ( bis ) ; closeSilently ( ois ) ; throw new RuntimeException ( " Caught IOException decoding data " , e ) ; } try { final StandardSession session = ( StandardSession ) _manager . createEmptySession ( ) ; 
private void backupSession ( final Request request , final Response response , final Session session ) { final BackupResult result = _sessionBackupService . backupSession ( session ) ; if ( result = = BackupResult . RELOCATED ) { if ( _logger . isLoggable ( Level . FINE ) ) { 
private void logDebugResponseCookie ( final Response response ) { if ( _logger . isLoggable ( Level . FINE ) ) { final Cookie respCookie = getCookie ( response , JSESSIONID ) ; 
public void init ( ) { _logger . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
private void initFailoverNodes ( ) { _failoverNodeIds = new ArrayList < String > ( ) ; if ( _failoverNodes ! = null & & _failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodes = _failoverNodes . split ( " " ) ; 
public Session createSession ( final String sessionId ) { _logger . fine ( " createSession invoked: " + sessionId ) ; Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; session . setId ( generateSessionId ( ) ) ; if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( " Created new session with id " + session . getId ( ) ) ; } } sessionCounter + + ; return ( session ) ; 
private String toString ( final Cookie cookie ) { return new StringBuilder ( cookie . getClass ( ) . getName ( ) ) . append ( " [name= " ) . append ( cookie . getName ( ) ) . append ( " , value= " ) . append ( cookie . getValue ( ) ) . append ( " , domain= " ) . append ( cookie . getDomain ( ) ) . append ( " , path= " ) . append ( cookie . getPath ( ) ) . append ( 
public void init ( ) { _logger . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
public Transcoder < Object > createTranscoder ( final Manager manager ) { return new SessionSerializingTranscoder ( manager ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , new SessionSerializingTranscoderFactory ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void testConfiguredMemcachedNodeId ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; final String nodeId = sessionId1 . substring ( sessionId1 . indexOf ( '-' ) + 1 , sessionId1 . indexOf ( '.' ) ) ; assertEquals ( " Invalid memcached node id " , _memcachedNodeId , nodeId ) ; } 
public void testSessionIdJvmRouteCompatibility ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; assertTrue ( " Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>]. " , sessionId1 . matches ( " [^-.]+-[^.]+( \\ .[ \\ w]+)? " ) ) ; 
public void testExpiredSessionRemovedFromMemcached ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; assertNull ( " Expired sesion still existing in memcached " , _memcached . get ( sessionId1 ) ) ; } 
public void testInvalidSessionNotFound ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( " Expired session returned " , sessionId1 , sessionId2 ) ; } 
public void testRelocateSession ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( " Expired session returned " , sessionId1 , sessionId2 ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _portTomcat2 = 18889 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; _nodeId = " n1 " ; try { final String memcachedNodes = _nodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , 2 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , NodeIdResolver . node ( 
protected byte [ ] serialize ( final Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { _xstream . toXML ( o , bos ) ; 
protected Object deserialize ( final byte [ ] in ) { final ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; try { final StandardSession session = ( StandardSession ) _manager . createEmptySession ( ) ; 
private void closeSilently ( final Closeable stream ) { if ( stream ! = null ) { try { 
public Transcoder < Object > createTranscoder ( final Manager manager ) { return new XStreamTranscoder ( manager ) ; } 
public void testReadValueIntoObject ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final XStreamTranscoder transcoder = new XStreamTranscoder ( manager ) ; final StandardSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; session . setId ( " foo " ) ; session . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; session . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; final long start1 = System . nanoTime ( ) ; transcoder . serialize ( session ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final long start2 = System . nanoTime ( ) ; transcoder . serialize ( session ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start2 ) / 1000 ) ; final long start3 = System . nanoTime ( ) ; final byte [ ] json = transcoder . serialize ( session ) ; final StandardSession readJSONValue = ( StandardSession ) transcoder . deserialize ( json ) ; System . out . println ( " xstream-round took " + ( System . nanoTime ( ) - start3 ) / 1000 ) ; System.out.println( "Have json: " + new String(json) ); assertEquals( readJSONValue, session ); final long start4 = System.nanoTime(); final StandardSession readJavaValue = javaRoundtrip( session, manager ); System.out.println("java-round took " + (System.nanoTime() - start4)/1000); assertEquals( readJavaValue, session ); assertEquals( readJSONValue, readJavaValue ); System.out.println( ToStringBuilder.reflectionToString( session ) ); System.out.println( ToStringBuilder.reflectionToString( readJSONValue ) ); System.out.println( ToStringBuilder.reflectionToString( readJavaValue ) ); 
private Person createPerson ( final String name , final Gender gender , final String . . . emailAddresses ) { final Person person = new Person ( ) ; person . setName ( name ) ; person . setGender ( gender ) ; final HashMap < String , Object > props = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < emailAddresses . length ; i + + ) { final String emailAddress = emailAddresses [ i ] ; props . put ( " email " + i , new Email ( name , emailAddress ) ) ; } person . setProps ( props ) ; return person ; } 
private Field getField ( final Class < ? > clazz , final String name ) throws NoSuchFieldException { final Field field = clazz . getDeclaredField ( name ) ; field . setAccessible ( true ) ; return field ; } 
private void assertEquals ( final Object one , final Object another ) throws Exception { if ( one = = another ) { return ; } if ( one = = null & & another ! = null | | one ! = null & & another = = null ) { Assert . fail ( " One of both is null: " + one + " , " + another ) ; } Assert . assertEquals ( one . getClass ( ) , another . getClass ( ) ) ; if ( one . getClass ( ) . isPrimitive ( ) | | one instanceof String | | Number . class . isAssignableFrom ( one . getClass ( ) ) | | one instanceof Boolean | | one instanceof Map < ? , ? > ) { Assert . assertEquals ( one , another ) ; return ; } Class < ? extends Object > clazz = one . getClass ( ) ; while ( clazz ! = null ) { assertEqualDeclaredFields ( clazz , one , another ) ; 
private StandardSession javaRoundtrip ( final StandardSession session , final MemcachedBackupSessionManager manager ) throws IOException , ClassNotFoundException { final long start1 = System . nanoTime ( ) ; final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; session . writeObjectData ( oos ) ; oos . close ( ) ; bos . close ( ) ; System . out . println ( " java-ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; final ObjectInputStream ois = new ObjectInputStream ( bis ) ; final StandardSession readSession = manager . createEmptySession ( ) ; readSession . readObjectData ( ois ) ; ois . close ( ) ; bis . close ( ) ; return readSession ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _gender = = null ) ? 0 : _gender . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; result = prime * result + ( ( _props = = null ) ? 0 : _props . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final Person other = ( Person ) obj ; if ( _gender = = null ) { if ( other . _gender ! = null ) return false ; } else if ( ! _gender . equals ( other . _gender ) ) return false ; if ( _name = = null ) { if ( other . _name ! = null ) return false ; } else if ( ! _name . equals ( other . _name ) ) return false ; if ( _props = = null ) { if ( other . _props ! = null ) return false ; } else if ( ! _props . equals ( other . _props ) ) return false ; return true ; } 
public String toString ( ) { return " Person [_gender= " + _gender + " , _name= " + _name + " , _props= " + _props + " ] " ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _email = = null ) ? 0 : _email . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final Email other = ( Email ) obj ; if ( _email = = null ) { if ( other . _email ! = null ) return false ; } else if ( ! _email . equals ( other . _email ) ) return false ; if ( _name = = null ) { if ( other . _name ! = null ) return false ; } else if ( ! _name . equals ( other . _name ) ) return false ; return true ; } 
public String toString ( ) { return " Email [_email= " + _email + " , _name= " + _name + " ] " ; } 
protected byte [ ] serialize ( final Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } XMLObjectWriter writer = null ; try { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; 
protected Object deserialize ( final byte [ ] in ) { XMLObjectReader reader = null ; try { final ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; 
private void closeSilently ( final XMLObjectWriter stream ) { if ( stream ! = null ) { try { 
private void closeSilently ( final XMLObjectReader stream ) { if ( stream ! = null ) { try { 
public Transcoder < Object > createTranscoder ( final Manager manager ) { return new JavolutionTranscoder ( manager ) ; } 
public Enum < ? > newInstance ( final Class < Enum < ? > > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { final String value = xml . getAttribute ( " value " , ( String ) null ) ; final String clazzName = xml . getAttribute ( " type " , ( String ) null ) ; try { @SuppressWarnings ( " unchecked " ) 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Enum < ? > object ) throws XMLStreamException { } @Override public void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { System.out.println( "-- have array..."); final Object[] array = (Object[]) obj; output.setAttribute( "type", "array" ); output.setAttribute( "componentType", obj.getClass().getComponentType().getName() ); output.setAttribute("length", array.length); for( final Object item : array ) { output.getStreamWriter().writeStartElement( "item" ); output.add( item ); output.getStreamWriter().writeEndElement(); } } } public static class XMLCollectionFormat extends XMLFormat<Collection<Object>> { @Override public void read( final javolution.xml.XMLFormat.InputElement xml, final Collection<Object> obj ) throws XMLStreamException { while ( xml.hasNext() ) { obj.add( xml.getNext() ); } } @Override public void write( final Collection<Object> obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException { for( final Object item : obj ) { xml.add( item ); } } } } 
public void write ( final Enum < ? > object , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " value " , object . name ( ) ) ; xml . setAttribute ( " type " , object . getClass ( ) . getName ( ) ) ; } 
public Object newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { System . out . println ( " XMLArrayFormat.newinstance invoked " ) ; try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final Object obj ) throws XMLStreamException { final Object [ ] arr = ( Object [ ] ) obj ; int i = 0 ; while ( input . hasNext ( ) ) { arr [ i + + ] = input . getNext ( ) ; 
public void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { System.out.println( "-- have array..."); final Object[] array = (Object[]) obj; output.setAttribute( "type", "array" ); output.setAttribute( "componentType", obj.getClass().getComponentType().getName() ); output.setAttribute("length", array.length); for( final Object item : array ) { output.getStreamWriter().writeStartElement( "item" ); 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; 
public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; 
private AttributesAndElements allFields ( final Class < T > cls ) { final AttributesAndElements result = new AttributesAndElements ( ) ; Class < ? super T > clazz = cls ; while ( clazz ! = null ) { addDeclaredFields ( clazz , result ) ; clazz = clazz . getSuperclass ( ) ; } return result ; } 
void add ( final Field field ) { if ( isAttribute ( field ) ) { attributes . add ( field ) ; 
protected static boolean isAttribute ( final Field field ) { return isAttribute ( field . getType ( ) ) ; } 
protected static boolean isAttribute ( final Class < ? > clazz ) { return clazz . isPrimitive ( ) | | clazz = = String . class | | Number . class . isAssignableFrom ( clazz ) | | clazz . isEnum ( ) ; } 
public void read ( final javolution . xml . XMLFormat . InputElement input , final T obj ) throws XMLStreamException { readAttributes ( input , obj ) ; readElements ( input , obj ) ; } 
private void readElements ( final javolution . xml . XMLFormat . InputElement input , final T obj ) { for ( final Field field : _elements ) { final XMLStreamReader reader = input . getStreamReader ( ) ; 
public void write ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { writeAttributes ( obj , output ) ; writeElements ( obj , output ) ; } 
private void writeAttributes ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) { for ( final Field field : _attributes ) { setAttributeFromField ( obj , field , output ) ; 
private void writeElements ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) { for ( final Field field : _elements ) { writeElement ( obj , field , output ) ; 
private void writeElement ( final T obj , final Field field , final javolution . xml . XMLFormat . OutputElement output ) { try { final Object object = field . get ( obj ) ; 
void testInstantiate ( ) throws InstantiationException , IllegalAccessException , ClassNotFoundException { final Object instance = Class . forName ( " de.javakaffee.web.msm.MemcachedBackupSessionManager$MemcachedBackupSession " ) . newInstance ( ) ; System . out . println ( " got instance: " + instance ) ; System . out . println ( ConcurrentHashMap . class . isAssignableFrom ( Map . class ) ) ; System . out . println ( Map . class . isAssignableFrom ( ConcurrentHashMap . class ) ) ; System . out . println ( Integer . class . isAssignableFrom ( Number . class ) ) ; System . out . println ( Number . class . isAssignableFrom ( Integer . class ) ) ; System . out . println ( String [ ] . class . isArray ( ) ) ; final String [ ] foo = new String [ ] { " foo " } ; System . out . println ( foo . getClass ( ) . getComponentType ( ) ) ; System . out . println ( ( ( String [ ] ) Array . newInstance ( Class . forName ( " java.lang.String " ) , 0 ) ) . length ) ; System . out . println ( Class . forName ( " java.util.Arrays$ArrayList " ) ) ; System . out . println ( Class . forName ( " de.javakaffee.web.msm.serializer.xstream.JavolutionTranscoderTest$Person " ) ) ; 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + Arrays . hashCode ( _bars ) ; result = prime * result + ( ( _bazens = = null ) ? 0 : _bazens . hashCode ( ) ) ; result = prime * result + ( ( _foos = = null ) ? 0 : _foos . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final Foo other = ( Foo ) obj ; if ( ! Arrays . equals ( _bars , other . _bars ) ) return false ; if ( _bazens = = null ) { if ( other . _bazens ! = null ) return false ; } else if ( ! _bazens . equals ( other . _bazens ) ) return false ; if ( _foos = = null ) { if ( other . _foos ! = null ) return false ; } else if ( ! _foos . equals ( other . _foos ) ) return false ; return true ; } 
public void testArrays ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final JavolutionTranscoder transcoder = new JavolutionTranscoder ( manager ) ; final Foo foo = new Foo ( ) ; assertEquals ( transcoder . deserialize ( transcoder . serialize ( foo ) ) , foo ) ; 
public void testCyclicDependencies ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final JavolutionTranscoder transcoder = new JavolutionTranscoder ( manager ) ; final StandardSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; final Person p1 = createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ; final Person p2 = createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ; p1 . addFriend ( p2 ) ; p2 . addFriend ( p1 ) ; session . setAttribute ( " person1 " , p1 ) ; session . setAttribute ( " person2 " , p2 ) ; final byte [ ] bytes = transcoder . serialize ( session ) ; System.out.println( "xml: " + new String( bytes ) ); assertEquals( session, transcoder.deserialize( bytes ) ); 
public void testReadValueIntoObject ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final JavolutionTranscoder transcoder = new JavolutionTranscoder ( manager ) ; final StandardSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; session . setId ( " foo " ) ; session . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; session . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; final long start1 = System . nanoTime ( ) ; transcoder . serialize ( session ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final long start2 = System . nanoTime ( ) ; transcoder . serialize ( session ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start2 ) / 1000 ) ; final long start3 = System . nanoTime ( ) ; final byte [ ] json = transcoder . serialize ( session ) ; final StandardSession readJSONValue = ( StandardSession ) transcoder . deserialize ( json ) ; System . out . println ( " xstream-round took " + ( System . nanoTime ( ) - start3 ) / 1000 ) ; System . out . println ( " Have json: " + readJSONValue . getId ( ) ) ; assertEquals ( readJSONValue , session ) ; final long start4 = System . nanoTime ( ) ; final StandardSession readJavaValue = javaRoundtrip ( session , manager ) ; System . out . println ( " java-round took " + ( System . nanoTime ( ) - start4 ) / 1000 ) ; assertEquals ( readJavaValue , session ) ; assertEquals ( readJSONValue , readJavaValue ) ; System . out . println ( ToStringBuilder . reflectionToString ( session ) ) ; System . out . println ( ToStringBuilder . reflectionToString ( readJSONValue ) ) ; System . out . println ( ToStringBuilder . reflectionToString ( readJavaValue ) ) ; 
public void addFriend ( final Person p ) { _friends . add ( p ) ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _friends = = null ) ? 0 : _friends . hashCode ( ) ) ; result = prime * result + ( ( _gender = = null ) ? 0 : _gender . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; result = prime * result + ( ( _props = = null ) ? 0 : _props . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final Person other = ( Person ) obj ; if ( _friends = = null ) { if ( other . _friends ! = null ) return false ; } else if ( ! flatEquals ( _friends , other . _friends ) ) return false ; if ( _gender = = null ) { if ( other . _gender ! = null ) return false ; } else if ( ! _gender . equals ( other . _gender ) ) return false ; if ( _name = = null ) { if ( other . _name ! = null ) return false ; } else if ( ! _name . equals ( other . _name ) ) return false ; if ( _props = = null ) { if ( other . _props ! = null ) return false ; } else if ( ! _props . equals ( other . _props ) ) return false ; return true ; } 
private boolean flatEquals ( final Collection < ? > c1 , final Collection < ? > c2 ) { return c1 = = c2 | | c1 ! = null & & c2 ! = null & & c1 . size ( ) = = c2 . size ( ) ; } 
public String toString ( ) { return " Person [_friends.size= " + ( _friends = = null ? " <null> " : _friends . size ( ) ) + " , _gender= " + _gender + " , _name= " + _name + " , _props= " + _props + " ] " ; } 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Enum < ? > object ) throws XMLStreamException { } @Override public void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final Object [ ] array = ( Object [ ] ) obj ; output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , obj . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; for ( final Object item : array ) { output . add ( item ) ; } } } public static class XMLCollectionFormat extends XMLFormat < Collection < Object > > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; } } @Override public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; } } } } 
public void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final Object [ ] array = ( Object [ ] ) obj ; output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , obj . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; for ( final Object item : array ) { output . add ( item ) ; 
public void testCollections ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final JavolutionTranscoder transcoder = new JavolutionTranscoder ( manager ) ; final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " foo " , new EntityWithCollections ( ) ) ; assertEquals ( transcoder . deserialize ( transcoder . serialize ( session ) ) , session ) ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final EntityWithCollections other = ( EntityWithCollections ) obj ; if ( ! Arrays . equals ( _bars , other . _bars ) ) return false ; if ( _bazens = = null ) { if ( other . _bazens ! = null ) return false ; } else if ( ! _bazens . equals ( other . _bazens ) ) return false ; if ( _foos = = null ) { if ( other . _foos ! = null ) return false ; } else if ( ! _foos . equals ( other . _foos ) ) return false ; return true ; } 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Enum < ? > object ) throws XMLStreamException { } @Override public void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final Object [ ] array = ( Object [ ] ) obj ; output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , obj . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; for ( final Object item : array ) { output . add ( item ) ; } } } public static class XMLCollectionFormat extends XMLFormat < Collection < Object > > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; } } @Override public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; } } } } 
public Object newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; 
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final JavolutionTranscoder transcoder = new JavolutionTranscoder ( manager ) ; final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no-default constructor " , new ClassWithoutDefaultConstructor ( " foo " ) ) ; assertEquals ( transcoder . deserialize ( transcoder . serialize ( session ) ) , session ) ; } 
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final JavolutionTranscoder transcoder = new JavolutionTranscoder ( manager ) ; final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; final PrivateClass privateClass = new PrivateClass ( ) ; privateClass . foo = " foo " ; session . setAttribute ( " pc " , privateClass ) ; System . out . println ( new String ( transcoder . serialize ( session ) ) ) ; assertEquals ( transcoder . deserialize ( transcoder . serialize ( session ) ) , session ) ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( privateClass = = null ) ? 0 : privateClass . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final PublicClass other = ( PublicClass ) obj ; if ( privateClass = = null ) { if ( other . privateClass ! = null ) return false ; } else if ( ! privateClass . equals ( other . privateClass ) ) return false ; return true ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( foo = = null ) ? 0 : foo . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final PrivateClass other = ( PrivateClass ) obj ; if ( foo = = null ) { if ( other . foo ! = null ) return false ; } else if ( ! foo . equals ( other . foo ) ) return false ; return true ; } 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Enum < ? > object ) throws XMLStreamException { } @Override public void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final Object [ ] array = ( Object [ ] ) obj ; output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , obj . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; for ( final Object item : array ) { output . add ( item ) ; } } } public static class XMLCollectionFormat extends XMLFormat < Collection < Object > > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; } } @Override public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; } } } } 
public T newInstance ( final Class < T > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { try { return _constructor . newInstance ( INITARGS ) ; 
public void testPrivateClassAndClassWithoutDefaultConstructor ( ) throws Exception { final XMLBinding binding = new ReflectionBinding ( getClass ( ) . getClassLoader ( ) ) ; final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final XMLObjectWriter writer = XMLObjectWriter . newInstance ( bos ) ; writer . setBinding ( binding ) ; final SomePackageProtectedClass o = SomePackageProtectedClass . createWithPrivate ( " foo " ) ; writer . write ( o , " item " ) ; writer . flush ( ) ; final byte [ ] bytes = bos . toByteArray ( ) ; System . out . println ( " Have bytes: " + new String ( bytes ) ) ; writer . close ( ) ; final SomePackageProtectedClass read = deserialize( bytes, "item" ); Assert.assertEquals( read, o ); final ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory(); final Constructor<SomePackageProtectedClass> constructor = reflectionFactory.newConstructorForSerialization(SomePackageProtectedClass.class, Object.class.getDeclaredConstructor(new Class[0])); final SomePackageProtectedClass instance = constructor.newInstance(new Object[0]); Assert.assertNotNull( instance ); System.out.println( "Have instance: " + instance ); final String privateClassName = SomePackageProtectedClass.class.getName() + "$SomePrivateClass"; final Class<?> clazz = Class.forName( privateClassName ); final Constructor<Object> c2 = reflectionFactory.newConstructorForSerialization(clazz, Object.class.getDeclaredConstructor(new Class[0])); final Object privateObj = c2.newInstance(new Object[0]); Assert.assertNotNull( privateObj ); System.out.println( "Have instance: " + privateObj ); 
private void assertEquals ( final Object one , final Object another ) throws Exception { if ( one = = another ) { return ; } if ( one = = null & & another ! = null | | one ! = null & & another = = null ) { Assert . fail ( " One of both is null: " + one + " , " + another ) ; } Assert . assertEquals ( one . getClass ( ) , another . getClass ( ) ) ; if ( one . getClass ( ) . isPrimitive ( ) | | one instanceof String | | Number . class . isAssignableFrom ( one . getClass ( ) ) | | one instanceof Boolean | | one instanceof Map < ? , ? > ) { Assert . assertEquals ( one , another ) ; return ; } Class < ? extends Object > clazz = one . getClass ( ) ; while ( clazz ! = null ) { assertEqualDeclaredFields ( clazz , one , another ) ; 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final ClassWithoutDefaultConstructor other = ( ClassWithoutDefaultConstructor ) obj ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( ! value . equals ( other . value ) ) return false ; return true ; } 
public String toString ( ) { return " ClassWithoutDefaultConstructor [value= " + value + " ] " ; } 
protected byte [ ] serialize ( final Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
protected Object deserialize ( final byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( in ) ; 
public void init ( ) { _logger . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
private Session loadFromMemcached ( final String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _logger . fine ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _logger . fine ( " Loading session from memcached: " + sessionId ) ; try { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( _logger . isLoggable ( Level . FINE ) ) { if ( session = = null ) { _logger . fine ( " Session " + sessionId + " not found in memcached. " ) ; } else { _logger . fine ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; return session ; } catch ( final NodeFailureException e ) { _logger . warning ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _logger . warning ( " Could not load session with id " + sessionId + " from memcached: " + e ) ; } } return null ; } 
public void doAfterDeserialization ( ) { if ( listeners = = null ) { listeners = new ArrayList < Object > ( ) ; } if ( notes = = null ) { notes = new Hashtable < Object , Object > ( ) ; 
public T newInstance ( final Class < T > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { final int value = xml . getAttribute ( " value " , 0 ) ; try { return _constructor . newInstance ( value ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @SuppressWarnings( "unchecked" ) @Override public Object[] newInstance( final Class clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final String componentType = input.getAttribute( "componentType", (String)null ); final int length = input.getAttribute( "length", 0 ); return (Object[]) Array.newInstance( Class.forName( componentType, false, _classLoader ) , length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final Object[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute( "type", "array" ); output.setAttribute( "componentType", array.getClass().getComponentType().getName() ); output.setAttribute("length", array.length ); writeElements( array, output ); } public void writeElements( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { for( final Object item : array ) { output.add( item ); } } } public static class XMLByteArrayFormat extends XMLFormat<byte[]> { @Override public byte[] newInstance( final Class<byte[]> clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final int length = input.getAttribute( "length", 0 ); return (byte[]) Array.newInstance( byte.class, length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final byte[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final byte[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute("length", array.length ); for( final byte item : array ) { output.add( item ); } } } public static class XMLCharArrayFormat extends XMLFormat<char[]> { @Override public char[] newInstance( final Class<char[]> clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final int length = input.getAttribute( "length", 0 ); return (char[]) Array.newInstance( char.class, length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final char[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final char[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute("length", array.length ); for( final char item : array ) { output.add( item ); }; } } public static class XMLCollectionFormat extends XMLFormat<Collection<Object>> { @Override public void read( final javolution.xml.XMLFormat.InputElement xml, final Collection<Object> obj ) throws XMLStreamException { while ( xml.hasNext() ) { obj.add( xml.getNext() ); } } @Override public void write( final Collection<Object> obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException { for( final Object item : obj ) { xml.add( item ); } } } } 
public void write ( final T obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " value " , obj . toString ( ) ) ; } 
public T newInstance ( final Class < T > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { final long value = xml . getAttribute ( " value " , 0 ) ; try { return _constructor . newInstance ( value ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @SuppressWarnings( "unchecked" ) @Override public Object[] newInstance( final Class clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final String componentType = input.getAttribute( "componentType", (String)null ); final int length = input.getAttribute( "length", 0 ); return (Object[]) Array.newInstance( Class.forName( componentType, false, _classLoader ) , length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final Object[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute( "type", "array" ); output.setAttribute( "componentType", array.getClass().getComponentType().getName() ); output.setAttribute("length", array.length ); writeElements( array, output ); } public void writeElements( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { for( final Object item : array ) { output.add( item ); } } } public static class XMLByteArrayFormat extends XMLFormat<byte[]> { @Override public byte[] newInstance( final Class<byte[]> clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final int length = input.getAttribute( "length", 0 ); return (byte[]) Array.newInstance( byte.class, length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final byte[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final byte[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute("length", array.length ); for( final byte item : array ) { output.add( item ); } } } public static class XMLCharArrayFormat extends XMLFormat<char[]> { @Override public char[] newInstance( final Class<char[]> clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final int length = input.getAttribute( "length", 0 ); return (char[]) Array.newInstance( char.class, length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final char[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final char[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute("length", array.length ); for( final char item : array ) { output.add( item ); }; } } public static class XMLCollectionFormat extends XMLFormat<Collection<Object>> { @Override public void read( final javolution.xml.XMLFormat.InputElement xml, final Collection<Object> obj ) throws XMLStreamException { while ( xml.hasNext() ) { obj.add( xml.getNext() ); } } @Override public void write( final Collection<Object> obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException { for( final Object item : obj ) { xml.add( item ); } } } } 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Enum < ? > object ) throws XMLStreamException { } @SuppressWarnings ( " unchecked " ) @Override public Object [ ] newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; final int length = input . getAttribute ( " length " , 0 ) ; return ( Object [ ] ) Array . newInstance ( Class . forName ( componentType , false , _classLoader ) , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final Object [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; } public void writeElements ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { for ( final Object item : array ) { output . add ( item ) ; } } } public static class XMLByteArrayFormat extends XMLFormat < byte [ ] > { @Override public byte [ ] newInstance ( final Class < byte [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; return ( byte [ ] ) Array . newInstance ( byte . class , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final byte [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final byte [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final byte item : array ) { output . add ( item ) ; } } } public static class XMLCharArrayFormat extends XMLFormat < char [ ] > { @Override public char [ ] newInstance ( final Class < char [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; return ( char [ ] ) Array . newInstance ( char . class , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final char [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final char [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final char item : array ) { output . add ( item ) ; } ; } } public static class XMLCollectionFormat extends XMLFormat < Collection < Object > > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; } } @Override public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; } } } } 
public final void write ( final T array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , length ( array ) ) ; writeElements ( array , output ) ; } 
protected abstract int length ( final T array ) ; protected abstract void writeElements ( final T array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException ; } public static class XMLArrayFormat extends XMLFormat < Object [ ] > { private final ClassLoader _classLoader ; public XMLArrayFormat ( final ClassLoader classLoader ) { _classLoader = classLoader ; } @SuppressWarnings ( " unchecked " ) @Override public Object [ ] newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; final int length = input . getAttribute ( " length " , 0 ) ; return ( Object [ ] ) Array . newInstance ( Class . forName ( componentType , false , _classLoader ) , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final Object [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; } public void writeElements ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { for ( final Object item : array ) { output . add ( item ) ; } } } public static class XMLByteArrayFormat extends XMLFormat < byte [ ] > { @Override public byte [ ] newInstance ( final Class < byte [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; return ( byte [ ] ) Array . newInstance ( byte . class , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final byte [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final byte [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final byte item : array ) { output . add ( item ) ; } } } public static class XMLCharArrayFormat extends XMLFormat < char [ ] > { @Override public char [ ] newInstance ( final Class < char [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; return ( char [ ] ) Array . newInstance ( char . class , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final char [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final char [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final char item : array ) { output . add ( item ) ; } ; } } public static class XMLCollectionFormat extends XMLFormat < Collection < Object > > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; } } @Override public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; } } } } 
protected abstract void writeElements ( final T array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException ; } public static class XMLArrayFormat extends XMLFormat < Object [ ] > { private final ClassLoader _classLoader ; public XMLArrayFormat ( final ClassLoader classLoader ) { _classLoader = classLoader ; } @SuppressWarnings ( " unchecked " ) @Override public Object [ ] newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; final int length = input . getAttribute ( " length " , 0 ) ; return ( Object [ ] ) Array . newInstance ( Class . forName ( componentType , false , _classLoader ) , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final Object [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; } public void writeElements ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { for ( final Object item : array ) { output . add ( item ) ; } } } public static class XMLByteArrayFormat extends XMLFormat < byte [ ] > { @Override public byte [ ] newInstance ( final Class < byte [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; return ( byte [ ] ) Array . newInstance ( byte . class , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final byte [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final byte [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final byte item : array ) { output . add ( item ) ; } } } public static class XMLCharArrayFormat extends XMLFormat < char [ ] > { @Override public char [ ] newInstance ( final Class < char [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; return ( char [ ] ) Array . newInstance ( char . class , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final char [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final char [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final char item : array ) { output . add ( item ) ; } ; } } public static class XMLCollectionFormat extends XMLFormat < Collection < Object > > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; } } @Override public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; } } } } 
public Object [ ] newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final Object [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; } 
public void writeElements ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { for ( final Object item : array ) { output . add ( item ) ; 
public byte [ ] newInstance ( final Class < byte [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final byte [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final byte [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final byte item : array ) { output . add ( item ) ; 
public char [ ] newInstance ( final Class < char [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final char [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final char [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final char item : array ) { output . add ( item ) ; } ; } 
public short [ ] newInstance ( final Class < short [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final short [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final short [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final short item : array ) { output . add ( item ) ; } ; } 
public int [ ] newInstance ( final Class < int [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final int [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final int [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final int item : array ) { output . add ( item ) ; } ; } 
public long [ ] newInstance ( final Class < long [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final long [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final long [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final long item : array ) { output . add ( item ) ; } ; } 
public float [ ] newInstance ( final Class < float [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final float [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final float [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final float item : array ) { output . add ( item ) ; } ; } 
public double [ ] newInstance ( final Class < double [ ] > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final int length = input . getAttribute ( " length " , 0 ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final double [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; 
public final void write ( final double [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final double item : array ) { output . add ( item ) ; } ; } 
public static void main ( final String [ ] args ) { try { final Constructor < ? > constructor = BigDecimal . class . getConstructor ( int . class ) ; 
protected void beforeTest ( ) { _manager = new MemcachedBackupSessionManager ( ) ; final StandardContext container = new StandardContext ( ) ; _manager . setContainer ( container ) ; final Mock webappLoaderControl = mock ( WebappLoader . class ) ; final WebappLoader webappLoader = ( WebappLoader ) webappLoaderControl . proxy ( ) ; webappLoaderControl . expects ( once ( ) ) . method ( " setContainer " ) . withAnyArguments ( ) ; webappLoaderControl . expects ( atLeastOnce ( ) ) . method ( " getClassLoader " ) . will ( returnValue ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ) ; Assert . assertNotNull ( webappLoader . getClassLoader ( ) , " Webapp Classloader is null. " ) ; _manager . getContainer ( ) . setLoader ( webappLoader ) ; Assert . assertNotNull ( _manager . getContainer ( ) . getLoader ( ) . getClassLoader ( ) , " Classloader is null. " ) ; _transcoder = new JavolutionTranscoder ( _manager ) ; } 
protected Object [ ] [ ] createTypesData ( ) { return new Object [ ] [ ] { { int . class , 42 } , 
public < T > void testTypes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; System . out . println ( " HAve instance: " + instance ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; final byte [ ] serialized = _transcoder . serialize ( session ) ; System . out . println ( new String ( serialized ) ) ; assertDeepEquals ( _transcoder . deserialize ( serialized ) , session ) ; } 
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no-default constructor " , new ClassWithoutDefaultConstructor ( " foo " ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final PrivateClass privateClass = new PrivateClass ( ) ; privateClass . foo = " foo " ; session . setAttribute ( " pc " , privateClass ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testCollections ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " foo " , new EntityWithCollections ( ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testCyclicDependencies ( ) throws Exception { final StandardSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; final Person p1 = createPerson ( " foo bar " , Gender . MALE , 42 , " foo.bar@example.org " , " foo.bar@example.com " ) ; final Person p2 = createPerson ( " bar baz " , Gender . FEMALE , 42 , " bar.baz@example.org " , " bar.baz@example.com " ) ; p1 . addFriend ( p2 ) ; p2 . addFriend ( p1 ) ; session . setAttribute ( " person1 " , p1 ) ; session . setAttribute ( " person2 " , p2 ) ; final byte [ ] bytes = _transcoder . serialize ( session ) ; System.out.println( "xml: " + new String( bytes ) ); assertDeepEquals( session, _transcoder.deserialize( bytes ) ); 
public void testReadValueIntoObject ( ) throws Exception { final StandardSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; session . setId ( " foo " ) ; session . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , 42 , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; session . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , 42 , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; final long start1 = System . nanoTime ( ) ; _transcoder . serialize ( session ) ; System . out . println ( " javolution ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final long start2 = System . nanoTime ( ) ; _transcoder . serialize ( session ) ; System . out . println ( " javolution ser took " + ( System . nanoTime ( ) - start2 ) / 1000 ) ; final long start3 = System . nanoTime ( ) ; final byte [ ] json = _transcoder . serialize ( session ) ; final StandardSession readJSONValue = ( StandardSession ) _transcoder . deserialize ( json ) ; System . out . println ( " javolution-round took " + ( System . nanoTime ( ) - start3 ) / 1000 ) ; System . out . println ( " Have xml: " + readJSONValue . getId ( ) ) ; assertDeepEquals ( readJSONValue , session ) ; final long start4 = System . nanoTime ( ) ; final StandardSession readJavaValue = javaRoundtrip ( session , _manager ) ; System . out . println ( " java-round took " + ( System . nanoTime ( ) - start4 ) / 1000 ) ; assertDeepEquals ( readJavaValue , session ) ; assertDeepEquals ( readJSONValue , readJavaValue ) ; System . out . println ( ToStringBuilder . reflectionToString ( session ) ) ; System . out . println ( ToStringBuilder . reflectionToString ( readJSONValue ) ) ; System . out . println ( ToStringBuilder . reflectionToString ( readJavaValue ) ) ; 
private Person createPerson ( final String name , final Gender gender , final Integer age , final String . . . emailAddresses ) { final Person person = new Person ( ) ; person . setName ( name ) ; person . setGender ( gender ) ; person . setAge ( age ) ; final HashMap < String , Object > props = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < emailAddresses . length ; i + + ) { final String emailAddress = emailAddresses [ i ] ; props . put ( " email " + i , new Email ( name , emailAddress ) ) ; } person . setProps ( props ) ; return person ; } 
public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( _age = = null ) ? 0 : _age . hashCode ( ) ) ; result = prime * result + ( ( _friends = = null ) ? 0 : _friends . size ( ) ) ; result = prime * result + ( ( _gender = = null ) ? 0 : _gender . hashCode ( ) ) ; result = prime * result + ( ( _name = = null ) ? 0 : _name . hashCode ( ) ) ; result = prime * result + ( ( _props = = null ) ? 0 : _props . hashCode ( ) ) ; return result ; } 
public boolean equals ( final Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; final Person other = ( Person ) obj ; if ( _age = = null ) { if ( other . _age ! = null ) return false ; } else if ( ! _age . equals ( other . _age ) ) return false ; if ( _friends = = null ) { if ( other . _friends ! = null ) return false ; } else if ( ! flatEquals ( _friends , other . _friends ) ) return false ; if ( _gender = = null ) { if ( other . _gender ! = null ) return false ; } else if ( ! _gender . equals ( other . _gender ) ) return false ; if ( _name = = null ) { if ( other . _name ! = null ) return false ; } else if ( ! _name . equals ( other . _name ) ) return false ; if ( _props = = null ) { if ( other . _props ! = null ) return false ; } else if ( ! _props . equals ( other . _props ) ) return false ; return true ; } 
public String toString ( ) { return " Person [_age= " + _age + " , _friends.size= " + _friends . size ( ) + " , _gender= " + _gender + " , _name= " + _name + " , _props= " + _props + " ] " ; 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @SuppressWarnings( "unchecked" ) @Override public Object[] newInstance( final Class clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final String componentType = input.getAttribute( "componentType", (String)null ); final int length = input.getAttribute( "length", 0 ); return (Object[]) Array.newInstance( Class.forName( componentType, false, _classLoader ) , length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final Object[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute( "type", "array" ); output.setAttribute( "componentType", array.getClass().getComponentType().getName() ); output.setAttribute("length", array.length ); writeElements( array, output ); } public void writeElements( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { for( final Object item : array ) { output.add( item ); } } } public static class XMLCollectionFormat extends XMLFormat<Collection<Object>> { @Override public void read( final javolution.xml.XMLFormat.InputElement xml, final Collection<Object> obj ) throws XMLStreamException { while ( xml.hasNext() ) { obj.add( xml.getNext() ); } } @Override public void write( final Collection<Object> obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException { for( final Object item : obj ) { xml.add( item ); } } } public static class XMLCalendarFormat extends XMLFormat<Calendar> { @Override public void read( final javolution.xml.XMLFormat.InputElement xml, final Calendar obj ) throws XMLStreamException { } @Override public void write( final Calendar obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException { } } } 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @SuppressWarnings( "unchecked" ) @Override public Object[] newInstance( final Class clazz, final javolution.xml.XMLFormat.InputElement input ) throws XMLStreamException { try { final String componentType = input.getAttribute( "componentType", (String)null ); final int length = input.getAttribute( "length", 0 ); return (Object[]) Array.newInstance( Class.forName( componentType, false, _classLoader ) , length ); } catch ( final Exception e ) { _log.log( Level.SEVERE, "caught exception", e ); throw new XMLStreamException( e ); } } @Override public void read( final javolution.xml.XMLFormat.InputElement input, final Object[] array ) throws XMLStreamException { int i = 0; while ( input.hasNext() ) { array[i++] = input.getNext(); } } @Override public final void write( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute( "type", "array" ); output.setAttribute( "componentType", array.getClass().getComponentType().getName() ); output.setAttribute("length", array.length ); writeElements( array, output ); } public void writeElements( final Object[] array, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { for( final Object item : array ) { output.add( item ); } } } public static class XMLCollectionFormat extends XMLFormat<Collection<Object>> { @Override public void read( final javolution.xml.XMLFormat.InputElement xml, final Collection<Object> obj ) throws XMLStreamException { while ( xml.hasNext() ) { obj.add( xml.getNext() ); } } @Override public void write( final Collection<Object> obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException { for( final Object item : obj ) { xml.add( item ); } } } public static class XMLCalendarFormat extends XMLFormat<Calendar> { @Override public void read( final javolution.xml.XMLFormat.InputElement xml, final Calendar obj ) throws XMLStreamException { } @Override public void write( final Calendar obj, final javolution.xml.XMLFormat.OutputElement xml ) throws XMLStreamException { } } } 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Enum < ? > object ) throws XMLStreamException { } @SuppressWarnings ( " unchecked " ) @Override public Object [ ] newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; final int length = input . getAttribute ( " length " , 0 ) ; return ( Object [ ] ) Array . newInstance ( Class . forName ( componentType , false , _classLoader ) , length ) ; } catch ( final Exception e ) { _log . log ( Level . SEVERE , " caught exception " , e ) ; throw new XMLStreamException ( e ) ; } } @Override public void read ( final javolution . xml . XMLFormat . InputElement input , final Object [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . getNext ( ) ; } } @Override public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; } public void writeElements ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { for ( final Object item : array ) { output . add ( item ) ; } } } public static class XMLCollectionFormat extends XMLFormat < Collection < Object > > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Collection < Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . add ( xml . getNext ( ) ) ; } } @Override public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : obj ) { xml . add ( item ) ; } } } public static class XMLCalendarFormat extends XMLFormat < Calendar > { @Override public void read ( final javolution . xml . XMLFormat . InputElement xml , final Calendar obj ) throws XMLStreamException { } @Override public void write ( final Calendar obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { } } } 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Calendar obj ) throws XMLStreamException { } @Override public void write ( final Calendar obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { } } } 
public void write ( final Calendar obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { } } } 
public Calendar newInstance ( final Class < Calendar > clazz , final javolution . xml . XMLFormat . InputElement arg1 ) throws XMLStreamException { if ( clazz . equals ( GregorianCalendar . class ) ) { return GregorianCalendar . getInstance ( ) ; } throw new IllegalArgumentException ( " Calendar of type " + clazz . getName ( ) + " not yet supported. Please submit an issue so that it will be implemented. " ) ; } 
private TimeZone getTimeZone ( final Calendar obj ) throws XMLStreamException { try { return ( TimeZone ) _zoneField . get ( obj ) ; 
private void addArray ( final Object obj , final String name , final OutputElement output ) throws XMLStreamException { final Class < ? > cls = obj . getClass ( ) ; if ( cls = = int [ ] . class ) { output . add ( ( int [ ] ) obj , name , int [ ] . class ) ; 
public T newInstance ( final Class < T > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return newInstanceFromAttribute ( xml , " value " ) ; } 
public T newInstanceFromAttribute ( final javolution . xml . XMLFormat . InputElement xml , final String name ) throws XMLStreamException { final Object value = getAttribute ( name , xml ) ; try { return _constructor . newInstance ( value ) ; 
protected abstract Object getAttribute ( String name , InputElement xml ) throws XMLStreamException ; @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } }} 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } }} 
public Object getAttribute ( final String name , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return xml . getAttribute ( name , 0 ) ; } 
public Object getAttribute ( final String name , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return xml . getAttribute ( name , 0 L ) ; } 
public < T > void testTypesAsSessionAttributes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; System.out.println(new String(_transcoder.serialize( session ))); assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session ); } 
public < T > void testTypesInContainerClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( MyContainer . class . getSimpleName ( ) , new MyContainer ( ) ) ; System.out.println(new String(_transcoder.serialize( session ))); assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session ); } 
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no-default constructor " , TestClasses . createClassWithoutDefaultConstructor ( " foo " ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " pc " , TestClasses . createPrivateClass ( " foo " ) ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
static Person createPerson ( final String name , final Gender gender , final Integer age , final String . . . emailAddresses ) { final Person person = new Person ( ) ; person . setName ( name ) ; person . setGender ( gender ) ; person . setAge ( age ) ; final HashMap < String , Object > props = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < emailAddresses . length ; i + + ) { final String emailAddress = emailAddresses [ i ] ; props . put ( " email " + i , new Email ( name , emailAddress ) ) ; } person . setProps ( props ) ; return person ; } 
static ClassWithoutDefaultConstructor createClassWithoutDefaultConstructor ( final String string ) { return new ClassWithoutDefaultConstructor ( string ) ; } 
static PrivateClass createPrivateClass ( final String string ) { final PrivateClass result = new PrivateClass ( ) ; result . foo = string ; return result ; } 
public void read ( final javolution . xml . XMLFormat . InputElement input , final byte [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . < Byte > getNext ( ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final char [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . < Character > getNext ( ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final short [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . < Short > getNext ( ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final int [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . < Integer > getNext ( ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final long [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . < Long > getNext ( ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final float [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . < Float > getNext ( ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement input , final double [ ] array ) throws XMLStreamException { int i = 0 ; while ( input . hasNext ( ) ) { array [ i + + ] = input . < Double > getNext ( ) ; 
protected static boolean isAttribute ( final Class < ? > clazz ) { return clazz . isPrimitive ( ) | | clazz . isEnum ( ) 
static boolean isNumberFormat ( final Class < ? > clazz ) { return Number . class . isAssignableFrom ( clazz ) ; } 
protected void beforeTest ( ) { _manager = new MemcachedBackupSessionManager ( ) ; final StandardContext container = new StandardContext ( ) ; _manager . setContainer ( container ) ; final Mock webappLoaderControl = mock ( WebappLoader . class ) ; final WebappLoader webappLoader = ( WebappLoader ) webappLoaderControl . proxy ( ) ; webappLoaderControl . expects ( once ( ) ) . method ( " setContainer " ) . withAnyArguments ( ) ; webappLoaderControl . expects ( atLeastOnce ( ) ) . method ( " getClassLoader " ) . will ( returnValue ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ) ; Assert . assertNotNull ( webappLoader . getClassLoader ( ) , " Webapp Classloader is null. " ) ; _manager . getContainer ( ) . setLoader ( webappLoader ) ; Assert . assertNotNull ( _manager . getContainer ( ) . getLoader ( ) . getClassLoader ( ) , " Classloader is null. " ) ; _transcoder = new JavolutionTranscoder ( _manager ) ; } 
protected Object [ ] [ ] createSharedObjectIdentityProviderData ( ) { return new Object [ ] [ ] { { AtomicInteger . class . getSimpleName ( ) , new AtomicInteger ( 42 ) } , { Email . class . getSimpleName ( ) , new Email ( " foo bar " , " foo.bar@example.com " ) } } ; 
public < T > void testSharedObjectIdentity_CounterHolder ( ) throws Exception { final AtomicInteger sharedObject = new AtomicInteger ( 42 ) ; final CounterHolder holder1 = new CounterHolder ( sharedObject ) ; final CounterHolder holder2 = new CounterHolder ( sharedObject ) ; final CounterHolderArray holderHolder = new CounterHolderArray ( holder1 , holder2 ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " hh " , holderHolder ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; final CounterHolderArray hhd = ( CounterHolderArray ) deserialized . getAttribute ( " hh " ) ; Assert . assertTrue ( hhd . holders [ 0 ] . item = = hhd . holders [ 1 ] . item ) ; 
public < T > void testSharedObjectIdentityWithArray ( final String name , final T sharedObject ) throws Exception { final Holder < T > holder1 = new Holder < T > ( sharedObject ) ; final Holder < T > holder2 = new Holder < T > ( sharedObject ) ; @SuppressWarnings ( " unchecked " ) final HolderArray < T > holderHolder = new HolderArray < T > ( holder1 , holder2 ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( name , holderHolder ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; @SuppressWarnings ( " unchecked " ) final HolderArray < T > hhd = ( HolderArray < T > ) deserialized . getAttribute ( name ) ; Assert . assertTrue ( hhd . holders [ 0 ] . item = = hhd . holders [ 1 ] . item ) ; 
public < T > void testSharedObjectIdentity ( final String name , final T sharedObject ) throws Exception { final Holder < T > holder1 = new Holder < T > ( sharedObject ) ; final Holder < T > holder2 = new Holder < T > ( sharedObject ) ; @SuppressWarnings ( " unchecked " ) final HolderList < T > holderHolder = new HolderList < T > ( new ArrayList < Holder < T > > ( Arrays . asList ( holder1 , holder2 ) ) ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( name , holderHolder ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; @SuppressWarnings ( " unchecked " ) final HolderList < T > hhd = ( HolderList < T > ) deserialized . getAttribute ( name ) ; Assert . assertTrue ( hhd . holders . get ( 0 ) . item = = hhd . holders . get ( 1 ) . item ) ; 
protected Object [ ] [ ] createTypesAsSessionAttributesData ( ) { return new Object [ ] [ ] { { int . class , 42 } , { long . class , 42 } , { String . class , " 42 " } , { Long . class , new Long ( 42 ) } , { Integer . class , new Integer ( 42 ) } , { Character . class , new Character ( 'c' ) } , 
public < T > void testTypesAsSessionAttributes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; System.out.println(new String(_transcoder.serialize( session ))); assertDeepEquals( _transcoder.deserialize( _transcoder.serialize( session ) ), session ); } 
public void testTypesInContainerClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( MyContainer . class . getSimpleName ( ) , new MyContainer ( ) ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no-default constructor " , TestClasses . createClassWithoutDefaultConstructor ( " foo " ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " pc " , TestClasses . createPrivateClass ( " foo " ) ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testCollections ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " foo " , new EntityWithCollections ( ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
public void testCyclicDependencies ( ) throws Exception { final StandardSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; final Person p1 = createPerson ( " foo bar " , Gender . MALE , 42 , " foo.bar@example.org " , " foo.bar@example.com " ) ; final Person p2 = createPerson ( " bar baz " , Gender . FEMALE , 42 , " bar.baz@example.org " , " bar.baz@example.com " ) ; p1 . addFriend ( p2 ) ; p2 . addFriend ( p1 ) ; session . setAttribute ( " person1 " , p1 ) ; session . setAttribute ( " person2 " , p2 ) ; final byte [ ] bytes = _transcoder . serialize ( session ) ; System.out.println( "xml: " + new String( bytes ) ); assertDeepEquals( session, _transcoder.deserialize( bytes ) ); 
public void testReadValueIntoObject ( ) throws Exception { final StandardSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; session . setId ( " foo " ) ; session . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , 42 , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; session . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , 42 , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; final long start1 = System . nanoTime ( ) ; _transcoder . serialize ( session ) ; System . out . println ( " javolution ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final long start2 = System . nanoTime ( ) ; _transcoder . serialize ( session ) ; System . out . println ( " javolution ser took " + ( System . nanoTime ( ) - start2 ) / 1000 ) ; final long start3 = System . nanoTime ( ) ; final byte [ ] json = _transcoder . serialize ( session ) ; final StandardSession readJSONValue = ( StandardSession ) _transcoder . deserialize ( json ) ; System . out . println ( " javolution-round took " + ( System . nanoTime ( ) - start3 ) / 1000 ) ; System . out . println ( " Have xml: " + readJSONValue . getId ( ) ) ; assertDeepEquals ( readJSONValue , session ) ; final long start4 = System . nanoTime ( ) ; final StandardSession readJavaValue = javaRoundtrip ( session , _manager ) ; System . out . println ( " java-round took " + ( System . nanoTime ( ) - start4 ) / 1000 ) ; assertDeepEquals ( readJavaValue , session ) ; assertDeepEquals ( readJSONValue , readJavaValue ) ; System . out . println ( ToStringBuilder . reflectionToString ( session ) ) ; System . out . println ( ToStringBuilder . reflectionToString ( readJSONValue ) ) ; System . out . println ( ToStringBuilder . reflectionToString ( readJavaValue ) ) ; 
private StandardSession javaRoundtrip ( final StandardSession session , final MemcachedBackupSessionManager manager ) throws IOException , ClassNotFoundException { final long start1 = System . nanoTime ( ) ; final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; session . writeObjectData ( oos ) ; oos . close ( ) ; bos . close ( ) ; System . out . println ( " java-ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; final ObjectInputStream ois = new ObjectInputStream ( bis ) ; final StandardSession readSession = manager . createEmptySession ( ) ; readSession . readObjectData ( ois ) ; ois . close ( ) ; bis . close ( ) ; return readSession ; } 
private NodeAvailabilityCache < String > createNodeAvailabilityCache ( final long ttlInMillis ) { return new NodeAvailabilityCache < String > ( _allNodeIds . size ( ) , ttlInMillis , new CacheLoader < String > ( ) { 
void add ( final Field field ) { if ( isAttribute ( field ) ) { final Class < ? > fieldType = field . getType ( ) ; 
protected static boolean isAttribute ( final Class < ? > clazz ) { return clazz . isPrimitive ( ) | | clazz . isEnum ( ) | | clazz = = String . class | | clazz = = Boolean . class | | clazz = = Integer . class | | clazz = = Long . class | | clazz = = Short . class | | clazz = = Double . class | | clazz = = Float . class 
private void readElements ( final javolution . xml . XMLFormat . InputElement input , final T obj ) { for ( final FieldHandler fieldHandler : _elements ) { final XMLStreamReader reader = input . getStreamReader ( ) ; 
private void writeAttributes ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) { for ( final AttributeHandler handler : _attributes ) { try { 
private void writeElements ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) { for ( final FieldHandler fieldHandler : _elements ) { fieldHandler . writeElement ( obj , output ) ; 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getBoolean ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getInt ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getLong ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getFloat ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getDouble ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getByte ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getChar ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { output . setAttribute ( _field . getName ( ) , _field . getShort ( obj ) ) ; } 
void writeAttribute ( final Object obj , final XMLFormat . OutputElement output ) throws IllegalArgumentException , XMLStreamException , IllegalAccessException { final Object object = _field . get ( obj ) ; if ( object ! = null ) { add ( object , output ) ; 
void add ( final Object object , final OutputElement output ) throws XMLStreamException { output . setAttribute ( _field . getName ( ) , object . toString ( ) ) ; } 
void add ( final Object object , final OutputElement output ) throws XMLStreamException { output . setAttribute ( _field . getName ( ) , ( ( Enum < ? > ) object ) . name ( ) ) ; } 
protected abstract Object getAttribute ( String name , InputElement xml ) throws XMLStreamException ; @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } } ============== Field handler ====================================== static abstract class FieldHandler { protected final Field _field; public FieldHandler( final Field field ) { _field = field; } void writeElement( final Object obj, final XMLFormat.OutputElement output ) { try { final Object object = _field.get( obj ); if ( object != null ) { add( object, output ); } } catch ( final Exception e ) { LOG.log( Level.SEVERE, "Could not write element for field.", e ); } } abstract void add( Object object, XMLFormat.OutputElement output ) throws XMLStreamException; } static final class ArrayFieldHandler extends FieldHandler { public ArrayFieldHandler( final Field field ) { super( field ); } @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { final String name = _field.getName(); final Class<?> cls = object.getClass(); if ( cls == int[].class ) { output.add( (int[]) object, name, int[].class ); } else if ( cls == long[].class ) { output.add( (long[]) object, name, long[].class ); } else if ( cls == short[].class ) { output.add( (short[]) object, name, short[].class ); } else if ( cls == float[].class ) { output.add( (float[]) object, name, float[].class ); } else if ( cls == double[].class ) { output.add( (double[]) object, name, double[].class ); } else if ( cls == char[].class ) { output.add( (char[]) object, name, char[].class ); } else if ( cls == byte[].class ) { output.add( (byte[]) object, name, byte[].class ); } else { output.add( (Object[]) object, name, Object[].class ); } } } static final class CollectionFieldHandler extends FieldHandler { public CollectionFieldHandler( final Field field ) { super( field ); } @SuppressWarnings( "unchecked" ) @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.add( (Collection<?>) object, _field.getName(), (Class<Collection<?>>) object.getClass() ); } } static final class MapFieldHandler extends FieldHandler { public MapFieldHandler( final Field field ) { super( field ); } @SuppressWarnings( "unchecked" ) @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.add( (Map<?, ?>) object, _field.getName(), (Class<Map<?, ?>>) object.getClass() ); } } static final class DefaultFieldHandler extends FieldHandler { public DefaultFieldHandler( final Field field ) { super( field ); } @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.add( object, _field.getName() ); } }} 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } } ============== Field handler ====================================== static abstract class FieldHandler { protected final Field _field; public FieldHandler( final Field field ) { _field = field; } void writeElement( final Object obj, final XMLFormat.OutputElement output ) { try { final Object object = _field.get( obj ); if ( object != null ) { add( object, output ); } } catch ( final Exception e ) { LOG.log( Level.SEVERE, "Could not write element for field.", e ); } } abstract void add( Object object, XMLFormat.OutputElement output ) throws XMLStreamException; } static final class ArrayFieldHandler extends FieldHandler { public ArrayFieldHandler( final Field field ) { super( field ); } @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { final String name = _field.getName(); final Class<?> cls = object.getClass(); if ( cls == int[].class ) { output.add( (int[]) object, name, int[].class ); } else if ( cls == long[].class ) { output.add( (long[]) object, name, long[].class ); } else if ( cls == short[].class ) { output.add( (short[]) object, name, short[].class ); } else if ( cls == float[].class ) { output.add( (float[]) object, name, float[].class ); } else if ( cls == double[].class ) { output.add( (double[]) object, name, double[].class ); } else if ( cls == char[].class ) { output.add( (char[]) object, name, char[].class ); } else if ( cls == byte[].class ) { output.add( (byte[]) object, name, byte[].class ); } else { output.add( (Object[]) object, name, Object[].class ); } } } static final class CollectionFieldHandler extends FieldHandler { public CollectionFieldHandler( final Field field ) { super( field ); } @SuppressWarnings( "unchecked" ) @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.add( (Collection<?>) object, _field.getName(), (Class<Collection<?>>) object.getClass() ); } } static final class MapFieldHandler extends FieldHandler { public MapFieldHandler( final Field field ) { super( field ); } @SuppressWarnings( "unchecked" ) @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.add( (Map<?, ?>) object, _field.getName(), (Class<Map<?, ?>>) object.getClass() ); } } static final class DefaultFieldHandler extends FieldHandler { public DefaultFieldHandler( final Field field ) { super( field ); } @Override void add( final Object object, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.add( object, _field.getName() ); } }} 
void writeElement ( final Object obj , final XMLFormat . OutputElement output ) { try { final Object object = _field . get ( obj ) ; 
abstract void add ( Object object , XMLFormat . OutputElement output ) throws XMLStreamException ; } static final class ArrayFieldHandler extends FieldHandler { public ArrayFieldHandler ( final Field field ) { super ( field ) ; } @Override void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final String name = _field . getName ( ) ; final Class < ? > cls = object . getClass ( ) ; if ( cls = = int [ ] . class ) { output . add ( ( int [ ] ) object , name , int [ ] . class ) ; } else if ( cls = = long [ ] . class ) { output . add ( ( long [ ] ) object , name , long [ ] . class ) ; } else if ( cls = = short [ ] . class ) { output . add ( ( short [ ] ) object , name , short [ ] . class ) ; } else if ( cls = = float [ ] . class ) { output . add ( ( float [ ] ) object , name , float [ ] . class ) ; } else if ( cls = = double [ ] . class ) { output . add ( ( double [ ] ) object , name , double [ ] . class ) ; } else if ( cls = = char [ ] . class ) { output . add ( ( char [ ] ) object , name , char [ ] . class ) ; } else if ( cls = = byte [ ] . class ) { output . add ( ( byte [ ] ) object , name , byte [ ] . class ) ; } else { output . add ( ( Object [ ] ) object , name , Object [ ] . class ) ; } } } static final class CollectionFieldHandler extends FieldHandler { public CollectionFieldHandler ( final Field field ) { super ( field ) ; } @SuppressWarnings ( " unchecked " ) @Override void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . add ( ( Collection < ? > ) object , _field . getName ( ) , ( Class < Collection < ? > > ) object . getClass ( ) ) ; } } static final class MapFieldHandler extends FieldHandler { public MapFieldHandler ( final Field field ) { super ( field ) ; } @SuppressWarnings ( " unchecked " ) @Override void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . add ( ( Map < ? , ? > ) object , _field . getName ( ) , ( Class < Map < ? , ? > > ) object . getClass ( ) ) ; } } static final class DefaultFieldHandler extends FieldHandler { public DefaultFieldHandler ( final Field field ) { super ( field ) ; } @Override void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . add ( object , _field . getName ( ) ) ; } } } 
void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final String name = _field . getName ( ) ; final Class < ? > cls = object . getClass ( ) ; if ( cls = = int [ ] . class ) { output . add ( ( int [ ] ) object , name , int [ ] . class ) ; 
void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . add ( ( Collection < ? > ) object , _field . getName ( ) , ( Class < Collection < ? > > ) object . getClass ( ) ) ; } 
void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . add ( ( Map < ? , ? > ) object , _field . getName ( ) , ( Class < Map < ? , ? > > ) object . getClass ( ) ) ; } 
void add ( final Object object , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . add ( object , _field . getName ( ) ) ; } 
protected byte [ ] serialize ( final Object o ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } XMLObjectWriter writer = null ; try { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; 
protected void writeClass ( final Class cls , final XMLStreamWriter writer , final boolean useAttributes ) throws XMLStreamException { if ( useAttributes ) { writer . writeAttribute ( " class " , cls . getName ( ) ) ; 
protected Class readClass ( final XMLStreamReader reader , final boolean useAttributes ) throws XMLStreamException { final CharArray className = useAttributes ? reader . getAttributeValue ( null , " class " ) : reader . getLocalName ( ) ; try { return Class . forName ( className . toString ( ) , true , _classLoader ) ; 
public XMLFormat < ? > getFormat ( final Class cls ) throws XMLStreamException { XMLFormat < ? > xmlFormat = _formats . get ( cls ) ; if ( xmlFormat ! = null ) { return xmlFormat ; } if ( cls . isPrimitive ( ) | | cls = = String . class 
public Enum < ? > newInstance ( final Class < Enum < ? > > clazz , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { final String value = xml . getAttribute ( " value " ) . toString ( ) ; final String clazzName = xml . getAttribute ( " type " ) . toString ( ) ; try { @SuppressWarnings ( " unchecked " ) 
public Object [ ] newInstance ( final Class clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { try { final String componentType = input . getAttribute ( " componentType " , ( String ) null ) ; 
public final void write ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " type " , " array " ) ; output . setAttribute ( " componentType " , array . getClass ( ) . getComponentType ( ) . getName ( ) ) ; output . setAttribute ( " length " , array . length ) ; writeElements ( array , output ) ; } 
public void writeElements ( final Object [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { for ( final Object item : array ) { output . add ( item ) ; 
public Calendar newInstance ( final Class < Calendar > clazz , final javolution . xml . XMLFormat . InputElement arg1 ) throws XMLStreamException { if ( clazz . equals ( GregorianCalendar . class ) ) { return GregorianCalendar . getInstance ( ) ; } throw new IllegalArgumentException ( " Calendar of type " + clazz . getName ( ) + " not yet supported. Please submit an issue so that it will be implemented. " ) ; 
private void readElements ( final javolution . xml . XMLFormat . InputElement input , final T obj ) { for ( final Field field : _elements ) { try { 
private void writeElements ( final T obj , final javolution . xml . XMLFormat . OutputElement output ) { for ( final Field field : _elements ) { try { 
private String getAttribute ( final InputElement input , final String name , final String defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? value . toString ( ) : defaultValue ; } 
private Boolean getAttribute ( final InputElement input , final String name , final Boolean defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Boolean . valueOf ( value . toBoolean ( ) ) : defaultValue ; } 
private Integer getAttribute ( final InputElement input , final String name , final Integer defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Integer . valueOf ( value . toInt ( ) ) : defaultValue ; } 
private Long getAttribute ( final InputElement input , final String name , final Long defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Long . valueOf ( value . toLong ( ) ) : defaultValue ; } 
private Short getAttribute ( final InputElement input , final String name , final Short defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Short . valueOf ( TypeFormat . parseShort ( value ) ) : defaultValue ; } 
private Float getAttribute ( final InputElement input , final String name , final Float defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Float . valueOf ( value . toFloat ( ) ) : defaultValue ; } 
private Double getAttribute ( final InputElement input , final String name , final Double defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Double . valueOf ( value . toDouble ( ) ) : defaultValue ; } 
private Byte getAttribute ( final InputElement input , final String name , final Byte defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; return value ! = null ? Byte . valueOf ( TypeFormat . parseByte ( value ) ) : defaultValue ; } 
private Character getAttribute ( final InputElement input , final String name , final Character defaultValue ) throws XMLStreamException { final CharArray value = input . getAttribute ( name ) ; if ( value ! = null ) { if ( value . length ( ) > 1 ) { throw new XMLStreamException ( " The attribute ' " + name + " ' of type Character has illegal value (length > 1): " + value ) ; } return Character . valueOf ( value . charAt ( 0 ) ) ; } return defaultValue ; } 
protected abstract Object getAttribute ( String name , InputElement xml ) throws XMLStreamException ; @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } }} 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } }} 
public final void write ( final byte [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final byte item : array ) { output . add ( item ) ; 
public final void write ( final char [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final char item : array ) { output . add ( item ) ; 
public final void write ( final short [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final short item : array ) { output . add ( item ) ; 
public final void write ( final int [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final int item : array ) { output . add ( item ) ; 
public final void write ( final long [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final long item : array ) { output . add ( item ) ; 
public final void write ( final float [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final float item : array ) { output . add ( item ) ; 
public final void write ( final double [ ] array , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " length " , array . length ) ; for ( final double item : array ) { output . add ( item ) ; 
public void testInnerClass ( ) throws Exception { final Container container = TestClasses . createContainer ( " some content " ) ; assertDeepEquals ( deserialize ( serialize ( container ) ) , container ) ; } 
protected Object [ ] [ ] createTypesAsSessionAttributesData ( ) { return new Object [ ] [ ] { { int . class , 42 } , { long . class , 42 } , { Boolean . class , Boolean . TRUE } , { String . class , " 42 " } , { Long . class , new Long ( 42 ) } , { Integer . class , new Integer ( 42 ) } , { Character . class , new Character ( 'c' ) } , 
public < T > void testTypesAsSessionAttributes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; final byte [ ] bytes = _transcoder . serialize ( session ) ; System . out . println ( new String ( bytes ) ) ; assertDeepEquals ( _transcoder . deserialize ( bytes ) , session ) ; } 
public void testTypesInContainerClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( MyContainer . class . getSimpleName ( ) , new MyContainer ( ) ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; assertDeepEquals ( _transcoder . deserialize ( _transcoder . serialize ( session ) ) , session ) ; } 
private void assertDeepEquals ( final Object one , final Object another ) throws Exception { assertDeepEquals ( one , another , new IdentityHashMap < Object , Object > ( ) ) ; } 
static Person createPerson ( final String name , final Gender gender , final String . . . emailAddresses ) { final Person person = new Person ( ) ; person . setName ( name ) ; person . setGender ( gender ) ; if ( emailAddresses ! = null ) { final HashMap < String , Object > props = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < emailAddresses . length ; i + + ) { final String emailAddress = emailAddresses [ i ] ; props . put ( " email " + i , new Email ( name , emailAddress ) ) ; } person . setProps ( props ) ; } return person ; } 
static Container createContainer ( final String bodyContent ) { return new Container ( bodyContent ) ; } 
public String toString ( ) { return " Person [_age= " + _age + " , _friends.size= " + _friends . size ( ) + " , _gender= " + _gender + " , _name= " + _name + " , _props= " + _props + " ] " ; 
protected void writeClass ( Class cls , final XMLStreamWriter writer , final boolean useAttributes ) throws XMLStreamException { if ( Proxy . isProxyClass ( cls ) ) { cls = Proxy . class ; } if ( useAttributes ) { writer . writeAttribute ( " class " , cls . getName ( ) ) ; 
public Object newInstance ( final Class < Object > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final InvocationHandler invocationHandler = input . get ( " handler " ) ; final Class < ? > [ ] interfaces = getInterfaces ( input ) ; return Proxy . newProxyInstance ( _classLoader , interfaces , invocationHandler ) ; } 
private Class < ? > [ ] getInterfaces ( final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final String [ ] interfaceNames = input . get ( " interfaces " ) ; if ( interfaceNames ! = null ) { try { final Class < ? > [ ] interfaces = new Class < ? > [ interfaceNames . length ] ; for ( int i = 0 ; i < interfaceNames . length ; i + + ) { interfaces [ i ] = Class . forName ( interfaceNames [ i ] , true , _classLoader ) ; } return interfaces ; } catch ( final ClassNotFoundException e ) { throw new XMLStreamException ( e ) ; } } return new Class < ? > [ 0 ] ; } 
public final void write ( final Object obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { final InvocationHandler invocationHandler = Proxy . getInvocationHandler ( obj ) ; output . add ( invocationHandler , " handler " ) ; final String [ ] interfaceNames = getInterfaceNames ( obj ) ; output . add ( interfaceNames , " interfaces " ) ; } 
public void testProxy ( ) throws Exception { final SomeInterface bean = TestClasses . createProxy ( ) ; final byte [ ] bytes = serialize ( bean ) ; System . out . println ( new String ( bytes ) ) ; assertDeepEquals ( deserialize ( bytes ) , bean ) ; } 
protected Object [ ] [ ] createTypesAsSessionAttributesData ( ) { return new Object [ ] [ ] { { int . class , 42 } , { long . class , 42 } , 
static SomeInterface createProxy ( ) { return ( SomeInterface ) Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , new Class < ? > [ ] { SomeInterface . class , Serializable . class } , 
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { if ( _target = = null ) { _target = _targetClazz . newInstance ( ) ; } return method . invoke ( _target , args ) ; } 
protected abstract Object getAttribute ( String name , InputElement xml ) throws XMLStreamException ; @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } }} 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final T obj ) throws XMLStreamException { nothing to do... } @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } }} 
public void write ( final T obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " value " , obj . longValue ( ) ) ; } 
public void init ( ) { _logger . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
Transcoder < Object > createTranscoder ( Manager manager ) ; void setCopyCollectionsForSerialization ( boolean copyCollectionsForSerialization ) ; } 
void setCopyCollectionsForSerialization ( boolean copyCollectionsForSerialization ) ; } 
public void init ( ) { _logger . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
Transcoder < Object > createTranscoder ( Manager manager ) ; void setCopyCollectionsForSerialization ( boolean copyCollectionsForSerialization ) ; } 
public Transcoder < Object > createTranscoder ( final Manager manager ) { return new JavolutionTranscoder ( manager , _copyCollectionsForSerialization ) ; } 
public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { for ( final Object item : _copyForWrite ? new ArrayList < Object > ( obj ) : obj ) { xml . add ( item ) ; 
public void read ( final javolution . xml . XMLFormat . InputElement xml , final Map < Object , Object > obj ) throws XMLStreamException { while ( xml . hasNext ( ) ) { obj . put ( xml . get ( " k " ) , xml . get ( " v " ) ) ; 
public void write ( final Map < Object , Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { final Set < Entry < Object , Object > > entrySet = _copyForWrite ? new LinkedHashMap < Object , Object > ( obj ) . entrySet ( ) : obj . entrySet ( ) ; for ( final Map . Entry < Object , Object > entry : entrySet ) { xml . add ( entry . getKey ( ) , " k " ) ; 
protected void beforeTest ( ) { _manager = new MemcachedBackupSessionManager ( ) ; final StandardContext container = new StandardContext ( ) ; _manager . setContainer ( container ) ; final Mock webappLoaderControl = mock ( WebappLoader . class ) ; final WebappLoader webappLoader = ( WebappLoader ) webappLoaderControl . proxy ( ) ; webappLoaderControl . expects ( once ( ) ) . method ( " setContainer " ) . withAnyArguments ( ) ; webappLoaderControl . expects ( atLeastOnce ( ) ) . method ( " getClassLoader " ) . will ( returnValue ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ) ; Assert . assertNotNull ( webappLoader . getClassLoader ( ) , " Webapp Classloader is null. " ) ; _manager . getContainer ( ) . setLoader ( webappLoader ) ; Assert . assertNotNull ( _manager . getContainer ( ) . getLoader ( ) . getClassLoader ( ) , " Classloader is null. " ) ; _transcoder = new JavolutionTranscoder ( _manager , true ) ; } 
public void init ( ) { _logger . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
private void initMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids ) { try { log . info ( " Starting with transcoder factory " + _transcoderFactoryClass . getName ( ) ) ; 
Transcoder < Object > createTranscoder ( Manager manager ) ; void setCopyCollectionsForSerialization ( boolean copyCollectionsForSerialization ) ; } 
public Transcoder < Object > createTranscoder ( final Manager manager ) { return new JavaSerializationTranscoder ( manager ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( _tomcat1 . getContainer ( ) . getManager ( ) , NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , new JavaSerializationTranscoderFactory ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void testJavaUtilCollectionsEmptyList ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyList " , Collections . < String > emptyList ( ) ) ; session . setAttribute ( " arrayList " , new ArrayList < String > ( ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; } 
public void testJavaUtilCollectionsEmptyMap ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyMap " , Collections . < String , String > emptyMap ( ) ) ; session . setAttribute ( " hashMap " , new HashMap < String , String > ( ) ) ; System . out . println ( new String ( _transcoder . serialize ( session ) ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; } 
public void testJavaUtilLists ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyList " , Collections . < String > emptyList ( ) ) ; session . setAttribute ( " arrayList " , new ArrayList < String > ( ) ) ; session . setAttribute ( " arraysAsList " , Arrays . asList ( " foo " , " bar " ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; } 
public void testJavaUtilCollectionsUnmodifiable ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableList ( new ArrayList < String > ( Arrays . asList ( " foo " , " bar " ) ) ) ) ; final HashMap < String , String > m = new HashMap < String , String > ( ) ; m . put ( " foo " , " bar " ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableMap ( m ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; } 
protected Object deserialize ( final byte [ ] in ) { getLogger().info( "Loading serialized:" + new String( in ) ); XMLObjectReader reader = null; try { final ByteArrayInputStream bis = new ByteArrayInputStream( in ); 
Transcoder < Object > createTranscoder ( Manager manager ) ; void setCustomConverterClassNames ( String [ ] customConverterClassNames ) ; } 
void setCopyCollectionsForSerialization ( boolean copyCollectionsForSerialization ) ; void setCustomConverterClassNames ( String [ ] customConverterClassNames ) ; } 
public Transcoder < Object > createTranscoder ( final Manager manager ) { final XMLFormat < ? > [ ] customFormats = loadCustomFormats ( manager ) ; return new JavolutionTranscoder ( manager , _copyCollectionsForSerialization , customFormats ) ; } 
private XMLFormat < ? > [ ] loadCustomFormats ( final Manager manager ) { if ( _customConverterClassNames = = null | | _customConverterClassNames . length = = 0 ) { return null ; } final XMLFormat < ? > [ ] customFormats = new XMLFormat < ? > [ _customConverterClassNames . length ] ; final Loader loader = manager . getContainer ( ) . getLoader ( ) ; for ( int i = 0 ; i < _customConverterClassNames . length ; i + + ) { final String className = _customConverterClassNames [ i ] ; try { final XMLFormat < ? > xmlFormat = Class . forName ( className , true , loader . getClassLoader ( ) ) . asSubclass ( XMLFormat . class ) . newInstance ( ) ; customFormats [ i ] = xmlFormat ; } catch ( final Exception e ) { throw new RuntimeException ( " Could not load custom xml format " + className , e ) ; } } return customFormats ; } 
protected void beforeTest ( ) { _manager = new MemcachedBackupSessionManager ( ) ; final StandardContext container = new StandardContext ( ) ; _manager . setContainer ( container ) ; final Mock webappLoaderControl = mock ( WebappLoader . class ) ; final WebappLoader webappLoader = ( WebappLoader ) webappLoaderControl . proxy ( ) ; webappLoaderControl . expects ( once ( ) ) . method ( " setContainer " ) . withAnyArguments ( ) ; webappLoaderControl . expects ( atLeastOnce ( ) ) . method ( " getClassLoader " ) . will ( returnValue ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ) ; Assert . assertNotNull ( webappLoader . getClassLoader ( ) , " Webapp Classloader is null. " ) ; _manager . getContainer ( ) . setLoader ( webappLoader ) ; Assert . assertNotNull ( _manager . getContainer ( ) . getLoader ( ) . getClassLoader ( ) , " Classloader is null. " ) ; _transcoder = new JavolutionTranscoder ( _manager , true , null ) ; } 
public DateTime newInstance ( final Class < DateTime > cls , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final String string = input . getAttribute ( " datetime " ) . toString ( ) ; return FORMAT . parseDateTime ( string ) ; } 
public void read ( final javolution . xml . XMLFormat . InputElement input , final DateTime obj ) throws XMLStreamException { nothing to do } @Override public void write( final DateTime obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute( "datetime", obj.toString( FORMAT ) ); }} 
public void write ( final DateTime obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( " datetime " , obj . toString ( FORMAT ) ) ; } 
public DateTime newInstance ( final Class < DateTime > cls , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final String string = input . getAttribute ( ATTRIBUTE_NAME ) . toString ( ) ; return FORMAT . parseDateTime ( string ) ; } 
public void read ( final javolution . xml . XMLFormat . InputElement input , final DateTime obj ) throws XMLStreamException { nothing to do } @Override public void write( final DateTime obj, final javolution.xml.XMLFormat.OutputElement output ) throws XMLStreamException { output.setAttribute( ATTRIBUTE_NAME, obj.toString( FORMAT ) ); }} 
public void write ( final DateTime obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { output . setAttribute ( ATTRIBUTE_NAME , obj . toString ( FORMAT ) ) ; } 
public DateTime newInstance ( final Class < DateTime > cls , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final long millis = input . getAttribute ( MILLIS ) . toLong ( ) ; final Chronology chronology = readChronology ( input ) ; final DateTimeZone tz = readTimeZone ( input ) ; return new DateTime ( millis , chronology . withZone ( tz ) ) ; } 
private Chronology readChronology ( final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final CharArray chronologyId = input . getAttribute ( CHRONOLOGY ) ; return IdentifiableChronology . valueOfId ( chronologyId ! = null ? chronologyId . toString ( ) : null ) ; } 
private DateTimeZone readTimeZone ( final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final CharArray tz = input . getAttribute ( TIME_ZONE ) ; return tz ! = null ? DateTimeZone . forID ( tz . toString ( ) ) : DateTimeZone . getDefault ( ) ; } 
public static Chronology valueOfId ( String id ) throws IllegalArgumentException { if ( id = = null ) { return ISO . _chronology ; } for ( final IdentifiableChronology item : values ( ) ) { if ( id . equals ( item . _id ) ) { return item . _chronology ; } } throw new IllegalArgumentException ( " No chronology found for id " + id ) ; } 
protected void beforeTest ( ) { _binding = new ReflectionBinding ( getClass ( ) . getClassLoader ( ) , false , new JodaDateTimeFormat ( ) ) ; } 
protected Object [ ] [ ] createTimeZoneProviderData ( ) { return new Object [ ] [ ] { { null } , 
public void testWriteDateTimeWithTimeZone ( final DateTimeZone timeZone ) throws XMLStreamException { final DateTime dateTime = new DateTime ( 0 , timeZone ) ; final byte [ ] serialized = serialize ( dateTime , _binding ) ; final DateTime deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized , dateTime ) ; } 
protected Object [ ] [ ] createChronologyProviderData ( ) { return new Object [ ] [ ] { { null } , 
public void testWriteDateTimeWithChronology ( final Chronology chronology ) throws XMLStreamException { final DateTime dateTime = new DateTime ( 0 , chronology ) ; final byte [ ] serialized = serialize ( dateTime , _binding ) ; final DateTime deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized , dateTime ) ; } 
protected byte [ ] serialize ( final Object o , final XMLBinding binding ) { if ( o = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } XMLObjectWriter writer = null ; try { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; 
protected < T > T deserialize ( final byte [ ] in , final XMLBinding binding ) { XMLObjectReader reader = null ; try { final ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; 
public void testXMLSerializableSupport ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final String attributeName = " myxmlserializable " ; session . setAttribute ( attributeName , new MyXMLSerializable ( Runtime . getRuntime ( ) ) ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; final MyXMLSerializable myXMLSerializable = ( MyXMLSerializable ) deserialized . getSession ( ) . getAttribute ( attributeName ) ; Assert . assertNotNull ( myXMLSerializable . getRuntime ( ) , " Transient field runtime should be initialized by XMLFormat " + " used due to implementation of XMLSerializable. " ) ; 
public MyXMLSerializable newInstance ( final Class < MyXMLSerializable > cls , final InputElement xml ) throws XMLStreamException { return new MyXMLSerializable ( Runtime . getRuntime ( ) ) ; } 
public Currency newInstance ( final Class < Currency > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return Currency . getInstance ( xml . getAttribute ( " code " , " " ) ) ; } 
public void write ( Currency currency , OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " code " , currency . getCurrencyCode ( ) ) ; } 
public Currency newInstance ( final Class < Currency > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { return Currency . getInstance ( xml . getAttribute ( " code " , " " ) ) ; } 
public void write ( final Currency currency , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " code " , currency . getCurrencyCode ( ) ) ; } 
public void testCurrency ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final Currency orig = Currency . getInstance ( " EUR " ) ; session . setAttribute ( " currency1 " , orig ) ; session . setAttribute ( " currency2 " , orig ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; Check that the transient field defaultFractionDigits is initialized correctly (that was the bug) final Currency currency1 = (Currency) deserialized.getSession().getAttribute( "currency1" ); Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() ); Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() ); Check that for each currency code there's only a single currency instance this check is useful for the case that the currency format is not handled by the reference resolver Assert.assertTrue( currency1 == deserialized.getSession().getAttribute( "currency2" ) ); } 
public void testCurrency ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final Currency orig = Currency . getInstance ( " EUR " ) ; session . setAttribute ( " currency1 " , orig ) ; session . setAttribute ( " currency2 " , orig ) ; final MemcachedBackupSession deserialized = ( MemcachedBackupSession ) _transcoder . deserialize ( _transcoder . serialize ( session ) ) ; assertDeepEquals ( deserialized , session ) ; Check that the transient field defaultFractionDigits is initialized correctly (that was the bug) final Currency currency1 = (Currency) deserialized.getSession().getAttribute( "currency1" ); Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() ); Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() ); 
public void init ( ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; 
public void expireSession ( final String sessionId ) { _log . debug ( " expireSession invoked: " + sessionId ) ; super . expireSession ( sessionId ) ; _memcached . delete ( sessionId ) ; } 
public Session createSession ( final String sessionId ) { _log . debug ( " createSession invoked: " + sessionId ) ; Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; session . setId ( generateSessionId ( ) ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Created new session with id " + session . getId ( ) ) ; } } sessionCounter + + ; return ( session ) ; 
public BackupResult backupSession ( final Session session ) { if ( _log . isInfoEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { 
public String sessionNeedsRelocate ( final Session session ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ; if ( nodeId ! = null & & ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { final String nextNodeId = getNextNodeId ( nodeId , _nodeAvailabilityCache . getUnavailableNodes ( ) ) ; if ( nextNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( session . getId ( ) , nextNodeId ) ; session . setNote ( RELOCATE_SESSION_ID , newSessionId ) ; return newSessionId ; } else { _log . warn ( " The node " + nodeId + " is not available and there's no node for relocation left. " ) ; } } return null ; } 
private Session loadFromMemcached ( final String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _log . debug ( " Loading session from memcached: " + sessionId ) ; try { final Session session = ( Session ) _memcached . get ( sessionId ) ; if ( _log . isDebugEnabled ( ) ) { if ( session = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; return session ; } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached: " + e ) ; } } return null ; } 
private void backupSession ( final Request request , final Response response , final Session session ) { final BackupResult result = _sessionBackupService . backupSession ( session ) ; if ( result = = BackupResult . RELOCATED ) { if ( _log . isDebugEnabled ( ) ) { 
private void logDebugResponseCookie ( final Response response ) { if ( _log . isDebugEnabled ( ) ) { final Cookie respCookie = getCookie ( response , JSESSIONID ) ; 
private void initMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids ) { try { _memcached = 
private TranscoderFactory createTranscoderFactory ( ) throws InstantiationException , IllegalAccessException { log . info ( " Starting with transcoder factory " + _transcoderFactoryClass . getName ( ) ) ; final TranscoderFactory transcoderFactory = _transcoderFactoryClass . newInstance ( ) ; transcoderFactory . setCopyCollectionsForSerialization ( _copyCollectionsForSerialization ) ; if ( _customConverterClassNames ! = null ) { _log . info ( " Loading custom converter classes " + _customConverterClassNames ) ; transcoderFactory . setCustomConverterClassNames ( _customConverterClassNames . split ( " , " ) ) ; } return transcoderFactory ; } 
public BackupResult backupSession ( final Session session ) { if ( _log . isInfoEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { 
protected boolean isValidInternal ( ) { return super . isValid ; } 
public static byte [ ] intToByteArray ( final int value ) { final byte [ ] b = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i + + ) { final int offset = ( b . length - 1 - i ) * 8 ; b [ i ] = ( byte ) ( ( value > > > offset ) & 0xFF ) ; System . out . println ( " have byte " + b [ i ] ) ; } return b ; } 
public static byte [ ] longToByteArray ( final long value ) { final byte [ ] b = new byte [ 8 ] ; for ( int i = 0 ; i < 8 ; i + + ) { final int offset = ( b . length - 1 - i ) * 8 ; b [ i ] = ( byte ) ( ( value > > > offset ) & 0xFF ) ; System . out . println ( " have byte " + b [ i ] ) ; } return b ; } 
public static void main ( final String [ ] args ) throws UnsupportedEncodingException { System . out . println ( " 42 as byte[]: " + intToByteArray ( Integer . MAX_VALUE ) ) ; System . out . println ( " 42 as byte[]: " + Integer . toBinaryString ( Integer . MAX_VALUE ) ) ; System . out . println ( " date: " + new Date ( Integer . MAX_VALUE ) . toString ( ) ) ; System . out . println ( " diff: " + ( System . currentTimeMillis ( ) - Integer . MAX_VALUE ) ) ; System . out . println ( " length of foo.getBytes, foobar.getBytes: " + " foo " . getBytes ( ) . length + " , " + " foobar " . getBytes ( ) . length ) ; final int = 100000 ; final String tmpl = " 1264468503706abcdefg " ; long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < ; i + + ) { new String ( tmpl ) . getBytes ( " UTF-8 " ) ; } System . out . println ( " String.getBytes took " + ( System . currentTimeMillis ( ) - start ) + " msec. " ) ; final Charset charset = Charset . forName ( " UTF-8 " ) ; start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < ; i + + ) { charset . encode ( new String ( tmpl ) ) ; } System . out . println ( " Charset.encode took " + ( System . currentTimeMillis ( ) - start ) + " msec. " ) ; start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < ; i + + ) { getBytesFast ( new String ( tmpl ) ) ; } System . out . println ( " getBytesFast took " + ( System . currentTimeMillis ( ) - start ) + " msec. " ) ; 
static byte [ ] serialize ( final MemcachedBackupSession session ) { byte [ ] idData = null ; try { idData = session . getIdInternal ( ) . getBytes ( " UTF-8 " ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } final int dataLength = 2 short value that stores the dataLength + NUM_BYTES bytes that store all session attributes but the id + idData.length; the number of bytes for the id final byte[] data = new byte[dataLength]; int idx = 0; idx = encodeNum( dataLength, data, idx, 2 ); idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 ); idx = encodeBoolean( session.isNewInternal(), data, idx ); idx = encodeBoolean( session.isValidInternal(), data, idx ); idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 ); copy( idData, data, idx ); return data; } 
static MemcachedBackupSession deserialize ( final byte [ ] data ) { final MemcachedBackupSession result = new MemcachedBackupSession ( ) ; final short dataLength = ( short ) decodeNum ( data , 0 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 2 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 10 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 18 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 22 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 23 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 24 , 8 ) ) ; final int currentIdx = 32 ; 24 + 8 final int idLength = dataLength - currentIdx; result.setIdInternal( decodeString( data, 32, idLength ) ); return result; } 
public byte [ ] encodeNum ( final long l , final int maxBytes ) { final byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { final int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } return rv ; } 
public static int encodeNum ( final long num , final byte [ ] data , final int beginIndex , final int maxBytes ) { for ( int i = 0 ; i < maxBytes ; i + + ) { final int pos = maxBytes - i - 1 ; the position of the byte in the number final int idx = beginIndex + pos; the index in the data array data[idx] = (byte) ( ( num >> ( 8 * i ) ) & 0xff ); } return beginIndex + maxBytes; } 
public long decodeLong ( final byte [ ] b ) { long rv = 0 ; for ( final byte i : b ) { rv = ( rv < < 8 ) | ( i < 0 ? 256 + i : i ) ; } return rv ; } 
public static long decodeNum ( final byte [ ] data , final int beginIndex , final int numBytes ) { long result = 0 ; for ( int i = 0 ; i < numBytes ; i + + ) { final byte b = data [ beginIndex + i ] ; result = ( result < < 8 ) | ( b < 0 ? 256 + b : b ) ; } return result ; } 
public int decodeInt ( final byte [ ] in ) { assert in . length < = 4 : " Too long to be an int ( " + in . length + " ) bytes " ; return ( int ) decodeLong ( in ) ; } 
public byte decodeByte ( final byte [ ] in ) { assert in . length < = 1 : " Too long for a byte " ; byte rv = 0 ; if ( in . length = = 1 ) { rv = in [ 0 ] ; } return rv ; } 
public byte [ ] encodeBoolean ( final boolean b ) { final byte [ ] rv = new byte [ 1 ] ; rv [ 0 ] = ( byte ) ( b ? '1' : '0' ) ; return rv ; } 
public static int encodeBoolean ( final boolean b , final byte [ ] data , final int index ) { data [ index ] = ( byte ) ( b ? '1' : '0' ) ; return index + 1 ; } 
public static boolean decodeBoolean ( final byte [ ] in , final int index ) { return in [ index ] = = '1' ; } 
protected byte [ ] encodeString ( final String in ) { try { return in . getBytes ( " UTF-8 " ) ; 
protected String decodeString ( final byte [ ] data ) { try { return data ! = null 
protected static String decodeString ( final byte [ ] data , final int beginIndex , final int length ) { try { final byte [ ] idData = new byte [ length ] ; 
protected static void copy ( final byte [ ] src , final byte [ ] dest , final int destBeginIndex ) { System . arraycopy ( src , 0 , dest , destBeginIndex , src . length ) ; } 
public static void setup ( ) { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( "Webapp Classloader is null.", webappLoader.getClassLoader() ); _manager.getContainer().setLoader( webappLoader ); _manager.init(); 
public void testCopy ( ) { final byte [ ] dest = new byte [ 10 ] ; TranscoderService . copy ( new byte [ ] { '1' , '2' , '3' } , dest , 5 ) ; Assert.assert 
public void testSerialized ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final byte [ ] data = TranscoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserialize ( data ) ; Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; 
public BackupResult backupSession ( ) { if ( _log . isInfoEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + _session . getId ( ) ) ; } try { 
private BackupResult handleAndTranslateBackupResult ( final BackupResult backupResult ) { switch ( backupResult ) { case SUCCESS : 
public String sessionNeedsRelocate ( ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; if ( nodeId ! = null & & ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { final String nextNodeId = getNextNodeId ( nodeId , _nodeAvailabilityCache . getUnavailableNodes ( ) ) ; if ( nextNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( _session . getId ( ) , nextNodeId ) ; _relocateSessionId = newSessionId ; return newSessionId ; } else { _log . warn ( " The node " + nodeId + " is not available and there's no node for relocation left. " ) ; } } return null ; } 
private BackupResult failover ( final Set < String > testedNodes , final String targetNodeId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; testedNodes . add ( nodeId ) ; final BackupResult backupResult = backupSession ( ) ; return backupResult ; } 
private void storeSessionInMemcached ( ) throws NodeFailureException { final Future < Boolean > future = _memcached . set ( _session . getId ( ) , _session . getMaxInactiveInterval ( ) , _session ) ; if ( ! _sessionBackupAsync ) { try { 
public String sessionNeedsRelocate ( final Session session ) { final BackupSessionTask task = getOrCreateBackupSessionTask ( ( MemcachedBackupSession ) session ) ; return task . sessionNeedsRelocate ( ) ; } 
public BackupResult backupSession ( final Session session ) { if ( _log . isInfoEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } final BackupSessionTask task = getOrCreateBackupSessionTask ( ( MemcachedBackupSession ) session ) ; return task . backupSession ( ) ; } 
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test public final void testRoll ( ) { assertEquals ( 0 , BackupSessionTask . roll ( 0 , 1 ) ) ; assertEquals ( 1 , BackupSessionTask . roll ( 0 , 2 ) ) ; assertEquals ( 0 , BackupSessionTask . roll ( 1 , 2 ) ) ; } @Test public final void testGetNextNodeId_SingleNode ( ) { final String actual = BackupSessionTask . getNextNodeId ( " n1 " , Arrays . asList ( " n1 " ) , null ) ; assertNull ( " For a sole existing node we cannot get a next node " , actual ) ; } @Test public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertEquals ( " The second failover node is not chosen " , nodeId3 , actual ) ; } private Set < String > asSet ( final String . . . vals ) { final Set < String > result = new HashSet < String > ( vals . length ) ; for ( final String val : vals ) { result . add ( val ) ; } return result ; } } 
public void tearDown ( ) throws Exception { } @Test public final void testRoll ( ) { assertEquals ( 0 , BackupSessionTask . roll ( 0 , 1 ) ) ; assertEquals ( 1 , BackupSessionTask . roll ( 0 , 2 ) ) ; assertEquals ( 0 , BackupSessionTask . roll ( 1 , 2 ) ) ; } @Test public final void testGetNextNodeId_SingleNode ( ) { final String actual = BackupSessionTask . getNextNodeId ( " n1 " , Arrays . asList ( " n1 " ) , null ) ; assertNull ( " For a sole existing node we cannot get a next node " , actual ) ; } @Test public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertEquals ( " The second failover node is not chosen " , nodeId3 , actual ) ; } private Set < String > asSet ( final String . . . vals ) { final Set < String > result = new HashSet < String > ( vals . length ) ; for ( final String val : vals ) { result . add ( val ) ; } return result ; } } 
public final void testRoll ( ) { assertEquals ( 0 , BackupSessionTask . roll ( 0 , 1 ) ) ; assertEquals ( 1 , BackupSessionTask . roll ( 0 , 2 ) ) ; assertEquals ( 0 , BackupSessionTask . roll ( 1 , 2 ) ) ; } 
public final void testGetNextNodeId_SingleNode ( ) { final String actual = BackupSessionTask . getNextNodeId ( " n1 " , Arrays . asList ( " n1 " ) , null ) ; assertNull ( " For a sole existing node we cannot get a next node " , actual ) ; } 
public final void testGetNextNodeId_TwoNodes ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; String actual = BackupSessionTask . getNextNodeId ( nodeId1 , Arrays . asList ( nodeId1 , nodeId2 ) , null ) ; assertEquals ( nodeId2 , actual ) ; actual = BackupSessionTask . getNextNodeId ( nodeId2 , Arrays . asList ( nodeId1 , nodeId2 ) , null ) ; assertEquals ( nodeId1 , actual ) ; } 
public final void testGetNextNodeId_TwoNodes_NoNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String actual = BackupSessionTask . getNextNodeId ( nodeId2 , Arrays . asList ( nodeId1 , nodeId2 ) , asSet ( nodeId1 ) ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_RegularNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getNextNodeId ( nodeId1 , null ) ; assertEquals ( " The failover node is not chosen " , nodeId2 , actual ) ; } 
public final void testGetNextNodeId_FailoverNode_RegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getNextNodeId ( nodeId2 , null ) ; assertEquals ( " The regular node is not chosen " , nodeId1 , actual ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertEquals ( " The second failover node is not chosen " , nodeId3 , actual ) ; } 
private Set < String > asSet ( final String . . . vals ) { final Set < String > result = new HashSet < String > ( vals . length ) ; for ( final String val : vals ) { result . add ( val ) ; } return result ; } 
public BackupResult backupSession ( final byte [ ] data , final byte [ ] attributesData ) { if ( _log . isInfoEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + _session . getId ( ) ) ; } try { 
private BackupResultStatus handleAndTranslateFailoverBackupResult ( final BackupResultStatus backupResult ) { switch ( backupResult ) { case SUCCESS : 
public boolean sessionCookieWasRelocated ( ) { return _relocateSessionId ! = null ; } 
private BackupResult failover ( final Set < String > testedNodes , final String targetNodeId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; testedNodes . add ( nodeId ) ; final BackupResult backupResult = backupSession ( data , attributesData ) ; return backupResult ; } 
private void storeSessionInMemcached ( final byte [ ] data ) throws NodeFailureException { final Future < Boolean > future = _memcached . set ( _session . getId ( ) , _session . getMaxInactiveInterval ( ) , data ) ; if ( ! _sessionBackupAsync ) { try { 
public byte [ ] serialize ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { if ( attributes = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
private void writeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes , final ObjectOutputStream oos ) throws IOException { Accumulate the names of serializable and non-serializable attributes final String keys[] = attributes.keySet().toArray( EMPTY_ARRAY ); final List<String> saveNames = new ArrayList<String>(); final List<Object> saveValues = new ArrayList<Object>(); for ( int i = 0; i < keys.length; i++ ) { final Object value = attributes.get( keys[i] ); if ( value == null ) { continue; } else if ( ( value instanceof Serializable ) && ( !session.exclude( keys[i] ) ) ) { saveNames.add( keys[i] ); saveValues.add( value ); } else { session.removeAttributeInternal( keys[i], true ); } } Serialize the attribute count and the Serializable attributes final int n = saveNames.size(); oos.writeObject( new Integer( n ) ); for ( int i = 0; i < n; i++ ) { oos.writeObject( saveNames.get( i ) ); 
public Map < String , Object > deserialize ( final byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( in ) ; 
public SessionAttributesTranscoder createTranscoder ( final Manager manager ) { return new JavaSerializationTranscoder ( manager ) ; } 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; _transcoderService = createTranscoderService ( ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + _nodeIds + " and failover node ids " + _failoverNodeIds ) ; 
private TranscoderService createTranscoderService ( ) { final TranscoderFactory transcoderFactory ; try { transcoderFactory = createTranscoderFactory ( ) ; } catch ( final Exception e ) { throw new RuntimeException ( " Could not create transcoder factory. " , e ) ; } return new TranscoderService ( transcoderFactory . createTranscoder ( this ) ) ; } 
private MemcachedClient createMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids ) { try { return new MemcachedClient ( new SuffixLocatorConnectionFactory ( new MapBasedResolver ( address2Ids ) , _sessionIdFormat ) , addresses ) ; 
public BackupResultStatus backupSession ( final Session session ) { if ( _log . isInfoEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } final MemcachedBackupSession backupSession = ( MemcachedBackupSession ) session ; final BackupSessionTask task = getOrCreateBackupSessionTask ( backupSession ) ; final Map < String , Object > attributes = backupSession . getAttributesInternal ( ) ; final byte [ ] attributesData = _transcoderService . serializeAttributes ( backupSession , attributes ) ; final int hashCode = Arrays . hashCode ( attributesData ) ; if ( backupSession . getDataHashCode ( ) ! = hashCode | | task . sessionCookieWasRelocated ( ) ) { 
private Session loadFromMemcached ( final String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _log . debug ( " Loading session from memcached: " + sessionId ) ; try { final byte [ ] data = ( byte [ ] ) _memcached . get ( sessionId ) ; if ( _log . isDebugEnabled ( ) ) { if ( data = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; final MemcachedBackupSession session ; if ( data ! = null ) { final DeserializationResult deserializationResult = TranscoderService . deserializeSessionFields ( data ) ; final byte [ ] attributesData = deserializationResult . getAttributesData ( ) ; final Map < String , Object > attributes = _transcoderService . deserializeAttributes ( attributesData ) ; session = deserializationResult . getSession ( ) ; session . setAttributesInternal ( attributes ) ; session . setDataHashCode ( Arrays . hashCode ( attributesData ) ) ; session . setManager ( this ) ; session . doAfterDeserialization ( ) ; } else { session = null ; } return session ; } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
public void removeAttributeInternal ( final String name , final boolean notify ) { super . removeAttributeInternal ( name , notify ) ; } 
protected boolean exclude ( final String name ) { return super . exclude ( name ) ; } 
byte [ ] serialize ( final MemcachedBackupSession session , final Map < String , Object > attributes ) ; Map < String , Object > deserialize ( final byte [ ] data ) ; } 
private void backupSession ( final Request request , final Response response , final Session session ) { final BackupResultStatus result = _sessionBackupService . backupSession ( session ) ; if ( result = = BackupResultStatus . RELOCATED ) { if ( _log . isDebugEnabled ( ) ) { 
String sessionNeedsRelocate ( final Session session ) ; SKIPPED } } } 
BackupResultStatus backupSession ( Session session ) ; SKIPPED } } } 
SessionAttributesTranscoder createTranscoder ( Manager manager ) ; void setCustomConverterClassNames ( String [ ] customConverterClassNames ) ; } 
public static void main ( final String [ ] args ) throws UnsupportedEncodingException { System . out . println ( " 42 as byte[]: " + Integer . toBinaryString ( Integer . MAX_VALUE ) ) ; System . out . println ( " date: " + new Date ( Integer . MAX_VALUE ) . toString ( ) ) ; System . out . println ( " diff: " + ( System . currentTimeMillis ( ) - Integer . MAX_VALUE ) ) ; System . out . println ( " length of foo.getBytes, foobar.getBytes: " + " foo " . getBytes ( ) . length + " , " + " foobar " . getBytes ( ) . length ) ; 
public byte [ ] serialize ( final MemcachedBackupSession session ) { final byte [ ] attributesData = serializeAttributes ( session , session . getAttributesInternal ( ) ) ; return serialize ( session , attributesData ) ; } 
public MemcachedBackupSession deserialize ( final byte [ ] data ) { final DeserializationResult deserializationResult = deserializeSessionFields ( data ) ; final Map < String , Object > attributes = _attributesTranscoder . deserialize ( deserializationResult . getAttributesData ( ) ) ; final MemcachedBackupSession result = deserializationResult . getSession ( ) ; result . setAttributesInternal ( attributes ) ; return result ; } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { return _attributesTranscoder . serialize ( session , attributes ) ; } 
public Map < String , Object > deserializeAttributes ( final byte [ ] data ) { return _attributesTranscoder . deserialize ( data ) ; } 
public byte [ ] serialize ( final MemcachedBackupSession session , final byte [ ] attributesData ) { final byte [ ] sessionData = serializeSessionFields ( session ) ; final byte [ ] result = new byte [ sessionData . length + attributesData . length ] ; System . arraycopy ( sessionData , 0 , result , 0 , sessionData . length ) ; System . arraycopy ( attributesData , 0 , result , sessionData . length , attributesData . length ) ; return result ; } 
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session ) { byte [ ] idData = null ; try { idData = session . getIdInternal ( ) . getBytes ( " UTF-8 " ) ; } catch ( final UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } final int sessionFieldsDataLength = 2 short value that stores the dataLength + NUM_BYTES bytes that store all session attributes but the id + idData.length; the number of bytes for the id final byte[] data = new byte[sessionFieldsDataLength]; int idx = 0; idx = encodeNum( sessionFieldsDataLength, data, idx, 2 ); idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 ); idx = encodeBoolean( session.isNewInternal(), data, idx ); idx = encodeBoolean( session.isValidInternal(), data, idx ); idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 ); copy( idData, data, idx ); return data; } 
static DeserializationResult deserializeSessionFields ( final byte [ ] data ) { final MemcachedBackupSession result = new MemcachedBackupSession ( ) ; final short sessionFieldsDataLength = ( short ) decodeNum ( data , 0 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 2 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 10 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 18 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 22 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 23 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 24 , 8 ) ) ; final int currentIdx = 32 ; 24 + 8 final int idLength = sessionFieldsDataLength - currentIdx; result.setIdInternal( decodeString( data, 32, idLength ) ); final byte[] attributesData = new byte[ data.length - sessionFieldsDataLength ]; System.arraycopy( data, sessionFieldsDataLength, attributesData, 0, data.length - sessionFieldsDataLength ); return new DeserializationResult( result, attributesData ); } 
private static int encodeNum ( final long num , final byte [ ] data , final int beginIndex , final int maxBytes ) { for ( int i = 0 ; i < maxBytes ; i + + ) { final int pos = maxBytes - i - 1 ; the position of the byte in the number final int idx = beginIndex + pos; the index in the data array data[idx] = (byte) ( ( num >> ( 8 * i ) ) & 0xff ); } return beginIndex + maxBytes; } 
private static long decodeNum ( final byte [ ] data , final int beginIndex , final int numBytes ) { long result = 0 ; for ( int i = 0 ; i < numBytes ; i + + ) { final byte b = data [ beginIndex + i ] ; result = ( result < < 8 ) | ( b < 0 ? 256 + b : b ) ; } return result ; } 
private static int encodeBoolean ( final boolean b , final byte [ ] data , final int index ) { data [ index ] = ( byte ) ( b ? '1' : '0' ) ; return index + 1 ; } 
private static boolean decodeBoolean ( final byte [ ] in , final int index ) { return in [ index ] = = '1' ; } 
private static String decodeString ( final byte [ ] data , final int beginIndex , final int length ) { try { final byte [ ] idData = new byte [ length ] ; 
public void setup ( ) throws Exception { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( "Webapp Classloader is null.", webappLoader.getClassLoader() ); _manager.getContainer().setLoader( webappLoader ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.init( _memcachedMock ); 
public void testOnlySendModifiedSessions ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; session . setAttribute ( " foo " , " bar " ) ; session . setAttribute ( " bar " , " baz " ) ; _manager . backupSession ( session ) ; verify ( _memcachedMock , times ( 2 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; _manager . backupSession ( session ) ; verify ( _memcachedMock , times ( 2 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResultStatus . SUCCESS ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testResponseCookieForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResultStatus . RELOCATED ) ) ; sessionControl . expects ( once ( ) ) . method ( " getId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getContextPath " ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( sessionId ) ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } 
private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , port ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { LOG . info ( " invoked " ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( " id= " + request . getSession ( ) . getId ( ) ) ; final HttpSession session = request . getSession ( false ) ; if ( session ! = null ) { final Enumeration < ? > attributeNames = session . getAttributeNames ( ) ; 
protected void doPost ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { LOG . info ( " invoked " ) ; final PrintWriter out = response . getWriter ( ) ; final HttpSession session = request . getSession ( ) ; out . println ( " OK: " + session . getId ( ) ) ; @SuppressWarnings ( " unchecked " ) final Enumeration < String > names = request . getParameterNames ( ) ; while ( names . hasMoreElements ( ) ) { final String name = names . nextElement ( ) ; 
public static String makeRequest ( final HttpClient client , final int port , final String rsessionId ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); String responseSessionId; final HttpMethod method = new GetMethod("http:localhost:"+ port +"/"); try { if ( rsessionId != null ) { 
public static Response get ( final HttpClient client , final int port , final String rsessionId ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); String responseSessionId; final HttpMethod method = new GetMethod("http:localhost:"+ port +"/"); try { if ( rsessionId != null ) { 
public static String post ( final HttpClient client , final int port , final String rsessionId , final String paramName , final String paramValue ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); String responseSessionId; final PostMethod method = new PostMethod("http:localhost:"+ port +"/"); try { if ( rsessionId != null ) { 
public static Embedded createCatalina ( final int port , final String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes ) ; } 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute ) ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , sessionTimeout , memcachedNodes , null ) ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final Engine engine = catalina . createEngine ( ) ; sessionManager . setMemcachedNodes ( memcachedNodes ) ; sessionManager . setMaxInactiveInterval ( sessionTimeout ) ; 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
String get ( final String key ) { return _keyValues . get ( key ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _portTomcat2 = 18889 ; final int port = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , port ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; _nodeId = " n1 " ; try { final String memcachedNodes = _nodeId + " :localhost: " + port ; _tomcat1 = createCatalina ( _portTomcat1 , 2 , memcachedNodes ) ; _tomcat1 . start ( ) ; _tomcat2 = createCatalina ( _portTomcat2 , memcachedNodes ) ; _tomcat2 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( 
public void testLoadedSessionOnlySentIfModified ( ) throws IOException , InterruptedException { final SimpleHttpConnectionManager connectionManager = new SimpleHttpConnectionManager ( true ) ; try { final HttpClient client = new HttpClient ( connectionManager ) ; 
public byte [ ] serialize ( MemcachedBackupSession session , Map < String , Object > attributes ) { if ( attributes = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } XMLObjectWriter writer = null ; try { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; 
public Map < String , Object > deserialize ( final byte [ ] in ) { getLogger().info( "Loading serialized:" + new String( in ) ); XMLObjectReader reader = null; try { final ByteArrayInputStream bis = new ByteArrayInputStream( in ); 
public SessionAttributesTranscoder createTranscoder ( final Manager manager ) { final XMLFormat < ? > [ ] customFormats = loadCustomFormats ( manager ) ; return new JavolutionTranscoder ( manager , _copyCollectionsForSerialization , customFormats ) ; } 
public void testCurrency ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final Currency orig = Currency . getInstance ( " EUR " ) ; session . setAttribute ( " currency1 " , orig ) ; session . setAttribute ( " currency2 " , orig ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; Check that the transient field defaultFractionDigits is initialized correctly (that was the bug) final Currency currency1 = (Currency) deserialized.get( "currency1" ); Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() ); Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() ); 
public void testXMLSerializableSupport ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final String attributeName = " myxmlserializable " ; session . setAttribute ( attributeName , new MyXMLSerializable ( Runtime . getRuntime ( ) ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; final MyXMLSerializable myXMLSerializable = ( MyXMLSerializable ) deserialized . get ( attributeName ) ; Assert . assertNotNull ( myXMLSerializable . getRuntime ( ) , " Transient field runtime should be initialized by XMLFormat " + " used due to implementation of XMLSerializable. " ) ; 
public void testJavaUtilCollectionsUnmodifiable ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableList ( new ArrayList < String > ( Arrays . asList ( " foo " , " bar " ) ) ) ) ; final HashMap < String , String > m = new HashMap < String , String > ( ) ; m . put ( " foo " , " bar " ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableMap ( m ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testJavaUtilLists ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyList " , Collections . < String > emptyList ( ) ) ; session . setAttribute ( " arrayList " , new ArrayList < String > ( ) ) ; session . setAttribute ( " arraysAsList " , Arrays . asList ( " foo " , " bar " ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testJavaUtilCollectionsEmptyMap ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyMap " , Collections . < String , String > emptyMap ( ) ) ; session . setAttribute ( " hashMap " , new HashMap < String , String > ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testProxy ( ) throws Exception { final SomeInterface bean = TestClasses . createProxy ( ) ; final byte [ ] bytes = serialize ( bean ) ; assertDeepEquals ( deserialize ( bytes ) , bean ) ; } 
public < T > void testSharedObjectIdentity_CounterHolder ( ) throws Exception { final AtomicInteger sharedObject = new AtomicInteger ( 42 ) ; final CounterHolder holder1 = new CounterHolder ( sharedObject ) ; final CounterHolder holder2 = new CounterHolder ( sharedObject ) ; final CounterHolderArray holderHolder = new CounterHolderArray ( holder1 , holder2 ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " hh " , holderHolder ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; final CounterHolderArray hhd = ( CounterHolderArray ) deserialized . get ( " hh " ) ; Assert . assertTrue ( hhd . holders [ 0 ] . item = = hhd . holders [ 1 ] . item ) ; 
public < T > void testSharedObjectIdentityWithArray ( final String name , final T sharedObject ) throws Exception { final Holder < T > holder1 = new Holder < T > ( sharedObject ) ; final Holder < T > holder2 = new Holder < T > ( sharedObject ) ; @SuppressWarnings ( " unchecked " ) final HolderArray < T > holderHolder = new HolderArray < T > ( holder1 , holder2 ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( name , holderHolder ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; @SuppressWarnings ( " unchecked " ) final HolderArray < T > hhd = ( HolderArray < T > ) deserialized . get ( name ) ; Assert . assertTrue ( hhd . holders [ 0 ] . item = = hhd . holders [ 1 ] . item ) ; 
public < T > void testSharedObjectIdentity ( final String name , final T sharedObject ) throws Exception { final Holder < T > holder1 = new Holder < T > ( sharedObject ) ; final Holder < T > holder2 = new Holder < T > ( sharedObject ) ; @SuppressWarnings ( " unchecked " ) final HolderList < T > holderHolder = new HolderList < T > ( new ArrayList < Holder < T > > ( Arrays . asList ( holder1 , holder2 ) ) ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( name , holderHolder ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; @SuppressWarnings ( " unchecked " ) final HolderList < T > hhd = ( HolderList < T > ) deserialized . get ( name ) ; Assert . assertTrue ( hhd . holders . get ( 0 ) . item = = hhd . holders . get ( 1 ) . item ) ; 
public < T > void testTypesAsSessionAttributes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; final byte [ ] bytes = _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ; assertDeepEquals ( _transcoder . deserialize ( bytes ) , session . getAttributesInternal ( ) ) ; } 
public void testTypesInContainerClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( MyContainer . class . getSimpleName ( ) , new MyContainer ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no-default constructor " , TestClasses . createClassWithoutDefaultConstructor ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " pc " , TestClasses . createPrivateClass ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testCollections ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " foo " , new EntityWithCollections ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserialize ( _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testCyclicDependencies ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; final Person p1 = createPerson ( " foo bar " , Gender . MALE , 42 , " foo.bar@example.org " , " foo.bar@example.com " ) ; final Person p2 = createPerson ( " bar baz " , Gender . FEMALE , 42 , " bar.baz@example.org " , " bar.baz@example.com " ) ; p1 . addFriend ( p2 ) ; p2 . addFriend ( p1 ) ; session . setAttribute ( " person1 " , p1 ) ; session . setAttribute ( " person2 " , p2 ) ; final byte [ ] bytes = _transcoder . serialize ( session , session . getAttributesInternal ( ) ) ; assertDeepEquals ( session . getAttributesInternal ( ) , _transcoder . deserialize ( bytes ) ) ; 
public byte [ ] serialize ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { if ( attributes = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { _xstream . toXML ( attributes , bos ) ; 
public Map < String , Object > deserialize ( final byte [ ] in ) { final ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; try { @SuppressWarnings ( " unchecked " ) 
public SessionAttributesTranscoder createTranscoder ( final Manager manager ) { return new XStreamTranscoder ( ) ; } 
public void testReadValueIntoObject ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final XStreamTranscoder transcoder = new XStreamTranscoder ( ) ; final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; session . setId ( " foo " ) ; session . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; session . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; final long start1 = System . nanoTime ( ) ; transcoder . serialize ( session , session . getAttributesInternal ( ) ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final long start2 = System . nanoTime ( ) ; transcoder . serialize ( session , session . getAttributesInternal ( ) ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start2 ) / 1000 ) ; final long start3 = System . nanoTime ( ) ; final byte [ ] json = transcoder . serialize ( session , session . getAttributesInternal ( ) ) ; final Map < String , Object > readValue = ( Map < String , Object > ) transcoder . deserialize ( json ) ; System . out . println ( " xstream-round took " + ( System . nanoTime ( ) - start3 ) / 1000 ) ; System.out.println( "Have json: " + new String(json) ); assertEquals( readValue, session.getAttributesInternal() ); 
public boolean isSuccess ( ) { return _status = = BackupResultStatus . SUCCESS ; } 
public boolean isRelocated ( ) { return _status = = BackupResultStatus . RELOCATED ; } 
public BackupResultStatus backupSession ( final Session session ) { if ( _log . isInfoEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } final MemcachedBackupSession backupSession = ( MemcachedBackupSession ) session ; if ( result ! = BackupResultStatus . FAILURE ) { backupSession . storeThisAccessedTimeFromLastBackupCheck ( ) ; } return result ; 
public void storeThisAccessedTimeFromLastBackupCheck ( ) { _thisAccessedTimeFromLastBackupCheck = super . thisAccessedTime ; } 
public boolean wasAccessedSinceLastBackupCheck ( ) { return _thisAccessedTimeFromLastBackupCheck ! = super . thisAccessedTime ; } 
public void testOnlySendModifiedSessions ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . backupSession ( session ) ; verify ( _memcachedMock , times ( 2 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; 
public void testOnlyHashAttributesOfAccessedSessions ( ) { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; _manager . backupSession ( session ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; _manager . backupSession ( session ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public BackupResultStatus backupSession ( final Session session ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + session . getId ( ) ) ; } final MemcachedBackupSession backupSession = ( MemcachedBackupSession ) session ; if ( result ! = BackupResultStatus . FAILURE ) { backupSession . storeThisAccessedTimeFromLastBackupCheck ( ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Finished for session id " + session . getId ( ) + " , returning status " + result ) ; } return result ; 
private boolean sessionCookieWasRelocated ( final MemcachedBackupSession backupSession ) { return backupSession . getBackupTask ( ) ! = null & & backupSession . getBackupTask ( ) . sessionCookieWasRelocated ( ) ; 
public BackupResult doBackupSession ( final byte [ ] data , final byte [ ] attributesData ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + _session . getId ( ) ) ; } try { 
public String determineSessionIdForBackup ( ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; if ( nodeId ! = null & & ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { final String nextNodeId = getNextNodeId ( nodeId , _nodeAvailabilityCache . getUnavailableNodes ( ) ) ; if ( nextNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( _session . getId ( ) , nextNodeId ) ; _relocateSessionIdForBackup = newSessionId ; return newSessionId ; } else { _log . warn ( " The node " + nodeId + " is not available and there's no node for relocation left. " ) ; } } return null ; } 
private boolean sessionWouldBeRelocated ( ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; return nodeId ! = null & & ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ; } 
private boolean sessionCookieWasRelocated ( ) { return _relocateSessionIdForBackup ! = null ; } 
private BackupResult failover ( final Set < String > testedNodes , final String targetNodeId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; testedNodes . add ( nodeId ) ; final BackupResult backupResult = doBackupSession ( data , attributesData ) ; return backupResult ; } 
public String determineSessionIdForBackup ( final Session session ) { final BackupSessionTask task = getOrCreateBackupSessionTask ( ( MemcachedBackupSession ) session ) ; final String sessionNeedsRelocate = task . determineSessionIdForBackup ( ) ; _log . info ( " [ " + Thread . currentThread ( ) . getName ( ) + " ] Returning session id for relocate: " + sessionNeedsRelocate ) ; return sessionNeedsRelocate ; } 
public BackupResultStatus backupSession ( final Session session ) { return getOrCreateBackupSessionTask ( ( MemcachedBackupSession ) session ) . backupSession ( session ) ; 
void beforeCommit ( ) { _logger.info( " CommitInterceptingActionHook executing before commit..." ); final Session session = request.getSessionInternal( false ); if ( session != null ) { final String newSessionId = _sessionBackupService.determineSessionIdForBackup( session ); _logger.info( "CommitInterceptingActionHook before commit got new session id: " + newSessionId ); if ( newSessionId != null ) { setSessionIdCookie( response, request, newSessionId ); } } response.getCoyoteResponse().setHook( origHook ); } 
String determineSessionIdForBackup ( final Session session ) ; SKIPPED } } } 
BackupResultStatus backupSession ( Session session ) ; SKIPPED } } } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void tearDown ( ) throws Exception { if ( _daemon1 . isRunning ( ) ) { _daemon1 . stop ( ) ; } if ( _daemon2 . isRunning ( ) ) { _daemon2 . stop ( ) ; } if ( _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _connectionManager . shutdown ( ) ; } 
public void testRelocateSession ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . nextNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , sid2 ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertNotNull ( " Session not found by new id " + sid2 , session ) ; assertFalse ( " Some notes are set: " + toArray ( session . getNoteNames ( ) ) , session . getNoteNames ( ) . hasNext ( ) ) ; 
public void testMultipleMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; info . nextNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . failoverNodeId ; assertEquals ( " Unexpected nodeId. " , expectedNode , secondNode ) ; assertEquals ( " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , sid2 ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertFalse ( " Some notes are set: " + toArray ( session . getNoteNames ( ) ) , session . getNoteNames ( ) . hasNext ( ) ) ; 
private Set < String > toArray ( final Iterator < String > noteNames ) { final Set < String > result = new HashSet < String > ( ) ; while ( noteNames . hasNext ( ) ) { result . add ( noteNames . next ( ) ) ; } return result ; } 
public void testAllMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertEquals ( " SessionId changed. " , sid1 , sid2 ) ; assertNotNull ( " Session " + sid1 + " not existing. " , getSessions ( ) . get ( sid1 ) ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertFalse ( " Some notes are set: " + toArray ( session . getNoteNames ( ) ) , session . getNoteNames ( ) . hasNext ( ) ) ; 
public static MemCacheDaemon < ? > createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon < LocalCacheElement > daemon = new MemCacheDaemon < LocalCacheElement > ( ) ; final ConcurrentLinkedHashMap < String , LocalCacheElement > cacheStorage = ConcurrentLinkedHashMap . create ( EvictionPolicy . LRU , 100000 , 1024 * 1024 ) ; daemon . setCache ( new CacheImpl ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( true ) ; return daemon ; } 
public static MemCacheDaemon < ? > createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon < LocalCacheElement > daemon = new MemCacheDaemon < LocalCacheElement > ( ) ; final ConcurrentLinkedHashMap < String , LocalCacheElement > cacheStorage = ConcurrentLinkedHashMap . create ( EvictionPolicy . LRU , 100000 , 1024 * 1024 ) ; daemon . setCache ( new CacheImpl ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( false ) ; return daemon ; } 
public void updateExpiration ( ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Updating expiration time for session " + _session . getId ( ) ) ; } _session . setExpirationUpdateRunning ( true ) ; try { final Map < String , Object > attributes = _session . getAttributesInternal ( ) ; 
public BackupResultStatus backupSession ( ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + _session . getId ( ) ) ; } _session . setBackupRunning ( true ) ; try { 
private BackupResult doBackupSession ( final byte [ ] data , final byte [ ] attributesData ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + _session . getId ( ) ) ; } try { 
private void storeSessionInMemcached ( final byte [ ] data ) throws NodeFailureException { final int expirationTime = _session . getMemcachedExpirationTimeToSet ( ) ; final Future < Boolean > future = _memcached . set ( _session . getId ( ) , expirationTime , data ) ; if ( ! _sessionBackupAsync ) { try { 
public String determineSessionIdForBackup ( final Session session ) { return getOrCreateBackupSessionTask ( ( MemcachedBackupSession ) session ) . determineSessionIdForBackup ( ) ; } 
public BackupResultStatus backupSession ( final Session session ) { return getOrCreateBackupSessionTask ( ( MemcachedBackupSession ) session ) . backupSession ( ) ; 
public void backgroundProcess ( ) { updateExpirationInMemcached ( ) ; super . backgroundProcess ( ) ; } 
private void updateExpirationInMemcached ( ) { final Session [ ] sessions = findSessions ( ) ; final int delay = getContainer ( ) . getBackgroundProcessorDelay ( ) ; for ( final Session s : sessions ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) s ; 
boolean wasAccessedSinceLastBackup ( ) { return super . thisAccessedTime > _lastBackupTimestamp ; } 
void storeThisAccessedTimeFromLastBackupCheck ( ) { _thisAccessedTimeFromLastBackupCheck = super . thisAccessedTime ; } 
boolean wasAccessedSinceLastBackupCheck ( ) { return _thisAccessedTimeFromLastBackupCheck ! = super . thisAccessedTime ; } 
boolean isExpirationUpdateRunning ( ) { return _expirationUpdateRunning ; } 
public void tearDown ( ) throws Exception { _memcached . shutdown ( ) ; _tomcat1 . stop ( ) ; _connectionManager . shutdown ( ) ; _daemon . stop ( ) ; } 
public void testExpiredSessionRemovedFromMemcached ( ) throws IOException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) ) + 100 ; Thread . sleep ( timeout ) ; assertNull ( " Expired sesion still existing in memcached " , _memcached . get ( sessionId1 ) ) ; } 
public void testRelocateSession ( ) throws IOException , InterruptedException { FIXME implementation does not match docs final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( "No session created.", sessionId1 ); Thread.sleep( 2100 ); final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 ); assertNotSame( "Expired session returned", sessionId1, sessionId2 ); } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( ) throws Exception { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( "No session created.", sessionId1 ); assertNotNull( "Session not available in memcached.", _memcached.get( sessionId1 ) ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 1000 ); +1000 just to be sure that we're >4 secs assertNull( "Session not expired in memcached.", _memcached.get( sessionId1 ) ); 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( ) throws Exception { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( "No session created.", sessionId1 ); assertNotNull( "Session not available in memcached.", _memcached.get( sessionId1 ) ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 200 ); assertNull( "Session not expired in memcached.", _memcached.get( sessionId1 ) ); 
boolean wasAccessedSinceLastBackup ( ) { return super . thisAccessedTime > _lastBackupTimestamp ; } 
void storeThisAccessedTimeFromLastBackupCheck ( ) { _thisAccessedTimeFromLastBackupCheck = super . thisAccessedTime ; } 
boolean wasAccessedSinceLastBackupCheck ( ) { return _thisAccessedTimeFromLastBackupCheck ! = super . thisAccessedTime ; } 
public void doAfterDeserialization ( ) { if ( listeners = = null ) { listeners = new ArrayList < Object > ( ) ; } if ( notes = = null ) { notes = new Hashtable < Object , Object > ( ) ; 
public void removeAttributeInternal ( final String name , final boolean notify ) { super . removeAttributeInternal ( name , notify ) ; } 
protected boolean exclude ( final String name ) { return super . exclude ( name ) ; } 
private static boolean equals ( final Object one , final Object another ) { return one = = null & & another = = null | | one ! = null & & one . equals ( another ) ; } 
private Session loadFromMemcached ( final String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _log . debug ( " Loading session from memcached: " + sessionId ) ; try { final byte [ ] data = ( byte [ ] ) _memcached . get ( sessionId ) ; if ( _log . isDebugEnabled ( ) ) { if ( data = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; final MemcachedBackupSession session ; if ( data ! = null ) { final DeserializationResult deserializationResult = TranscoderService . deserializeSessionFields ( data , getContainer ( ) . getRealm ( ) ) ; final byte [ ] attributesData = deserializationResult . getAttributesData ( ) ; final Map < String , Object > attributes = _transcoderService . deserializeAttributes ( attributesData ) ; session = deserializationResult . getSession ( ) ; session . setAttributesInternal ( attributes ) ; session . setDataHashCode ( Arrays . hashCode ( attributesData ) ) ; session . setManager ( this ) ; session . doAfterDeserialization ( ) ; } else { session = null ; } return session ; } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
public MemcachedBackupSession deserialize ( final byte [ ] data , final Realm realm ) { final DeserializationResult deserializationResult = deserializeSessionFields ( data , realm ) ; final Map < String , Object > attributes = _attributesTranscoder . deserialize ( deserializationResult . getAttributesData ( ) ) ; final MemcachedBackupSession result = deserializationResult . getSession ( ) ; result . setAttributesInternal ( attributes ) ; return result ; } 
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session ) { final byte [ ] idData = serializeId ( session . getIdInternal ( ) ) ; final byte [ ] principalData = session . getPrincipal ( ) ! = null ? serializePrincipal ( session . getPrincipal ( ) ) : null ; final int principalDataLength = principalData ! = null ? principalData . length : 0 ; final int sessionFieldsDataLength = 2 short value that stores the dataLength + NUM_BYTES bytes that store all session attributes but the id + 2 short value that stores the idData length + idData.length the number of bytes for the id + 2 short value for the authType + 2 short value that stores the principalData length + principalDataLength; the number of bytes for the principal final byte[] data = new byte[sessionFieldsDataLength]; int idx = 0; idx = encodeNum( sessionFieldsDataLength, data, idx, 2 ); idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 ); idx = encodeBoolean( session.isNewInternal(), data, idx ); idx = encodeBoolean( session.isValidInternal(), data, idx ); idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( idData.length, data, idx, 2 ); idx = copy( idData, data, idx ); idx = encodeNum( AuthType.valueOfValue( session.getAuthType() ).getId(), data, idx, 2 ); idx = encodeNum( principalDataLength, data, idx, 2 ); copy( principalData, data, idx ); return data; } 
static DeserializationResult deserializeSessionFields ( final byte [ ] data , final Realm realm ) { final MemcachedBackupSession result = new MemcachedBackupSession ( ) ; final short sessionFieldsDataLength = ( short ) decodeNum ( data , 0 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 2 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 10 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 18 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 22 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 23 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 24 , 8 ) ) ; final short idLength = ( short ) decodeNum ( data , 32 , 2 ) ; result . setIdInternal ( decodeString ( data , 34 , idLength ) ) ; final short authTypeId = ( short ) decodeNum ( data , 34 + idLength , 2 ) ; result . setAuthType ( AuthType . valueOfId ( authTypeId ) . getValue ( ) ) ; final int currentIdx = 34 + idLength + 2 ; final short principalDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( principalDataLength > 0 ) { final byte [ ] principalData = new byte [ principalDataLength ] ; System . arraycopy ( data , currentIdx + 2 , principalData , 0 , principalDataLength ) ; result . setPrincipal ( deserializePrincipal ( principalData , realm ) ) ; } final byte [ ] attributesData = new byte [ data . length - sessionFieldsDataLength ] ; System . arraycopy ( data , sessionFieldsDataLength , attributesData , 0 , data . length - sessionFieldsDataLength ) ; return new DeserializationResult ( result , attributesData ) ; } 
private static byte [ ] serializeId ( final String id ) { try { return id . getBytes ( " UTF-8 " ) ; 
private static byte [ ] serializePrincipal ( final Principal principal ) { ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
private static Principal deserializePrincipal ( final byte [ ] data , final Realm realm ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( data ) ; 
protected static int copy ( final byte [ ] src , final byte [ ] dest , final int destBeginIndex ) { if ( src = = null ) { return destBeginIndex ; } System . arraycopy ( src , 0 , dest , destBeginIndex , src . length ) ; return destBeginIndex + src . length ; } 
private static void closeSilently ( final OutputStream os ) { if ( os ! = null ) { try { 
private static void closeSilently ( final InputStream is ) { if ( is ! = null ) { try { 
static AuthType valueOfId ( final short id ) { for ( final AuthType authType : values ( ) ) { if ( id = = authType . _id ) { return authType ; } } throw new IllegalArgumentException ( " No AuthType found for id " + id ) ; } 
static AuthType valueOfValue ( final String value ) { for ( final AuthType authType : values ( ) ) { if ( value = = null & & authType . _value = = null | | value ! = null & & value . equals ( authType . _value ) ) { return authType ; } } throw new IllegalArgumentException ( " No AuthType found for value " + value ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager . getContainer ( ) . getRealm ( ) ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionFieldsWithAuthenticatedPrincipal ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final Realm realm = _manager . getContainer ( ) . getRealm ( ) ; session . setAuthType ( Constants . FORM_METHOD ) ; session . setPrincipal ( new GenericPrincipal ( realm , " foo " , " bar " ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , realm ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager . getContainer ( ) . getRealm ( ) ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager . getContainer ( ) . getRealm ( ) ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } 
private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; Assert . assertEquals ( session . getAuthType ( ) , deserialized . getAuthType ( ) ) ; assertDeepEquals ( session . getPrincipal ( ) , deserialized . getPrincipal ( ) ) ; } 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final PrintWriter out = response . getWriter ( ) ; out . print ( " <html><head /><body> " + " <h1>Login</h1> " + 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final HttpSession session = request . getSession ( false ) ; LOG . info ( " invoked " ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + request . getSession ( ) . getId ( ) ) ; final HttpSession session = request.getSession( false ); if ( session != null ) { final Enumeration<?> attributeNames = session.getAttributeNames(); 
public static Response get ( final HttpClient client , final int port , final String rsessionId ) throws IOException , HttpException { return get ( client , port , null , rsessionId ) ; } 
public static Response get ( final HttpClient client , final int port , final String rsessionId , final Credentials credentials ) throws IOException , HttpException { return get ( client , port , null , rsessionId , credentials ) ; } 
public static Response get ( final HttpClient client , final int port , final String path , final String rsessionId ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null ) ; } 
public static Response get ( final HttpClient client , final int port , final String path , final String rsessionId , final Credentials credentials ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:localhost:"+ port +"/"; final String url = baseUri + ( path != null ? path : "" ); final HttpMethod method = new GetMethod( url ); try { if ( rsessionId != null ) { 
private static Response readResponse ( final String rsessionId , final HttpMethod method ) throws IOException { final String responseSessionId = getSessionIdFromResponse ( method ) ; System.out.println( "response cookie: " + responseSessionId ); final String bodyAsString = method.getResponseBodyAsString(); final String[] lines = bodyAsString.split( "\r" ); final Map<String, String> keyValues = new LinkedHashMap<String, String>(); for ( final String line : lines ) { final String[] keyValue = line.split( "=" ); if ( keyValue.length > 0 ) { keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null ); } } final Response response = new Response( responseSessionId == null ? rsessionId : responseSessionId, keyValues ); return response; } 
public static Response post ( final HttpClient client , final int port , final String rsessionId , final String paramName , final String paramValue ) throws IOException , HttpException { final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( paramName , paramValue ) ; return post ( client , port , null , rsessionId , params ) ; } 
public static Response post ( final HttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:localhost:"+ port +"/"; final String url = baseUri + ( path != null ? path : "" ); final PostMethod method = new PostMethod( url ); try { if ( rsessionId != null ) { 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , null , loginType ) ; } 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , null ) ; } 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , loginType ) ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , sessionTimeout , memcachedNodes , null , null ) ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) catalina.addEngine( engine ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
private static SecurityConstraint createSecurityConstraint ( final String pattern , final String role ) { final SecurityConstraint constraint = new SecurityConstraint ( ) ; final SecurityCollection securityCollection = new SecurityCollection ( ) ; securityCollection . addPattern ( pattern ) ; constraint . addCollection ( securityCollection ) ; if ( role ! = null ) { constraint . addAuthRole ( role ) ; } return constraint ; } 
private static MemoryUserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } 
public static void assertDeepEquals ( final Object one , final Object another ) { assertDeepEquals ( one , another , new IdentityHashMap < Object , Object > ( ) ) ; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( NODE_ID , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( address ) ) ; _connectionManager = new SimpleHttpConnectionManager ( true ) ; _httpClient = new HttpClient ( _connectionManager ) ; } 
private Embedded startTomcat ( final int port ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , null ) ; } 
private Embedded startTomcat ( final int port , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = createCatalina ( port , MEMCACHED_NODES , loginType ) ; tomcat . start ( ) ; return tomcat ; } 
public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _connectionManager . shutdown ( ) ; } 
public void testTomcatFailover ( ) throws IOException , InterruptedException { final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value ) . getSessionId ( ) ; final Object session = _client . get ( sessionId1 ) ; Assert . assertNotNull ( " Session not found in memcached: " + sessionId1 , session ) ; final Response response = get ( _httpClient , TC_PORT_2 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; Assert . assertEquals ( sessionId1 , sessionId2 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; Thread . sleep ( 10 ) ; 
public void testLoadedSessionOnlySentIfModified ( ) throws IOException , InterruptedException { post ( _httpClient , TC_PORT_2 , sessionId1 , " bar " , " baz " ) ; Assert . assertEquals ( 2 , _daemon . getCache ( ) . getSetCmds ( ) ) ; Thread . sleep ( 10 ) ; 
public void testSerializationOfAuthStuffWithFormAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , LoginType . FORM ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; 
public void testSerializationOfAuthStuffWithBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , LoginType . BASIC ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; 
protected MemcachedBackupSession deserialize ( final byte [ ] in ) { return _sessionTranscoder . deserialize ( in ) ; } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { if ( attributes = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
public Map < String , Object > deserializeAttributes ( final byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( in ) ; 
public SessionTranscoder createSessionTranscoder ( final Manager manager ) { return new JavaSessionSerializationTranscoder ( manager ) ; } 
protected MemcachedBackupSession deserialize ( final byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( in ) ; 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; _transcoderService = createTranscoderService ( ) ; final SessionTranscoder sessionTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _upgradeSupportTranscoder = new DelegatingSerializingTranscoder ( sessionTranscoder ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + _nodeIds + " and failover node ids " + _failoverNodeIds ) ; 
private TranscoderService createTranscoderService ( ) { return new TranscoderService ( getTranscoderFactory ( ) . createTranscoder ( this ) ) ; } 
protected Session loadFromMemcached ( final String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _log . debug ( " Loading session from memcached: " + sessionId ) ; try { final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; if ( _log . isDebugEnabled ( ) ) { if ( object = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; if ( object instanceof MemcachedBackupSession ) { return ( Session ) object ; } else { return deserialize ( ( byte [ ] ) object ) ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
private MemcachedBackupSession deserialize ( final byte [ ] data ) { if ( data = = null ) { return null ; } try { final DeserializationResult deserializationResult = TranscoderService . deserializeSessionFields ( data , getContainer ( ) . getRealm ( ) ) ; 
byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) ; Map < String , Object > deserializeAttributes ( final byte [ ] data ) ; } 
SessionAttributesTranscoder createTranscoder ( Manager manager ) ; void setCustomConverterClassNames ( String [ ] customConverterClassNames ) ; } 
SessionTranscoder createSessionTranscoder ( Manager manager ) ; void setCustomConverterClassNames ( String [ ] customConverterClassNames ) ; } 
public MemcachedBackupSession deserialize ( final byte [ ] data , final Realm realm ) { final DeserializationResult deserializationResult = deserializeSessionFields ( data , realm ) ; final Map < String , Object > attributes = _attributesTranscoder . deserializeAttributes ( deserializationResult . getAttributesData ( ) ) ; final MemcachedBackupSession result = deserializationResult . getSession ( ) ; result . setAttributesInternal ( attributes ) ; return result ; } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { return _attributesTranscoder . serializeAttributes ( session , attributes ) ; } 
public Map < String , Object > deserializeAttributes ( final byte [ ] data ) { return _attributesTranscoder . deserializeAttributes ( data ) ; } 
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session ) { final byte [ ] idData = serializeId ( session . getIdInternal ( ) ) ; final byte [ ] principalData = session . getPrincipal ( ) ! = null ? serializePrincipal ( session . getPrincipal ( ) ) : null ; final int principalDataLength = principalData ! = null ? principalData . length : 0 ; final int sessionFieldsDataLength = 2 short value for the version the following might change with other versions, refactoring needed then + 2 short value that stores the dataLength + NUM_BYTES bytes that store all session attributes but the id + 2 short value that stores the idData length + idData.length the number of bytes for the id + 2 short value for the authType + 2 short value that stores the principalData length + principalDataLength; the number of bytes for the principal final byte[] data = new byte[sessionFieldsDataLength]; int idx = 0; idx = encodeNum( CURRENT_VERSION, data, idx, 2 ); idx = encodeNum( sessionFieldsDataLength, data, idx, 2 ); idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 ); idx = encodeBoolean( session.isNewInternal(), data, idx ); idx = encodeBoolean( session.isValidInternal(), data, idx ); idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( idData.length, data, idx, 2 ); idx = copy( idData, data, idx ); idx = encodeNum( AuthType.valueOfValue( session.getAuthType() ).getId(), data, idx, 2 ); idx = encodeNum( principalDataLength, data, idx, 2 ); copy( principalData, data, idx ); return data; } 
static DeserializationResult deserializeSessionFields ( final byte [ ] data , final Realm realm ) throws InvalidVersionException { final MemcachedBackupSession result = new MemcachedBackupSession ( ) ; final short version = ( short ) decodeNum ( data , 0 , 2 ) ; if ( version ! = CURRENT_VERSION ) { throw new InvalidVersionException ( " The version " + version + " does not match the current version " + CURRENT_VERSION , version ) ; } final short sessionFieldsDataLength = ( short ) decodeNum ( data , 2 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 4 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 12 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 20 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 24 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 25 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 26 , 8 ) ) ; final short idLength = ( short ) decodeNum ( data , 34 , 2 ) ; result . setIdInternal ( decodeString ( data , 36 , idLength ) ) ; final short authTypeId = ( short ) decodeNum ( data , 36 + idLength , 2 ) ; result . setAuthType ( AuthType . valueOfId ( authTypeId ) . getValue ( ) ) ; final int currentIdx = 36 + idLength + 2 ; final short principalDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( principalDataLength > 0 ) { final byte [ ] principalData = new byte [ principalDataLength ] ; System . arraycopy ( data , currentIdx + 2 , principalData , 0 , principalDataLength ) ; result . setPrincipal ( deserializePrincipal ( principalData , realm ) ) ; } final byte [ ] attributesData = new byte [ data . length - sessionFieldsDataLength ] ; System . arraycopy ( data , sessionFieldsDataLength , attributesData , 0 , data . length - sessionFieldsDataLength ) ; return new DeserializationResult ( result , attributesData ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public void tearDown ( ) throws Exception { _memcached . shutdown ( ) ; _tomcat1 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _daemon . stop ( ) ; } 
public void testConfiguredMemcachedNodeId ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; final String nodeId = sessionId1 . substring ( sessionId1 . indexOf ( '-' ) + 1 , sessionId1 . indexOf ( '.' ) ) ; assertEquals ( " Invalid memcached node id " , _memcachedNodeId , nodeId ) ; } 
public void testSessionIdJvmRouteCompatibility ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; assertTrue ( " Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>]. " , sessionId1 . matches ( " [^-.]+-[^.]+( \\ .[ \\ w]+)? " ) ) ; 
public void testInvalidSessionId ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , " 12345 " ) ; assertNotNull ( " No session created. " , sessionId1 ) ; assertTrue ( " Invalid session id format " , sessionId1 . indexOf ( '-' ) > - 1 ) ; } 
public void testSessionAvailableInMemcached ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 50 ) ; assertNotNull ( " Session not available in memcached. " , _memcached . get ( sessionId1 ) ) ; } 
public void testExpiredSessionRemovedFromMemcached ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) ) + 100 ; Thread . sleep ( timeout ) ; assertNull ( " Expired sesion still existing in memcached " , _memcached . get ( sessionId1 ) ) ; } 
public void testInvalidSessionNotFound ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sessionId1 ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( " Expired session returned " , sessionId1 , sessionId2 ) ; } 
public void testRelocateSession ( ) throws IOException , InterruptedException , HttpException { FIXME implementation does not match docs final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( "No session created.", sessionId1 ); Thread.sleep( 2100 ); final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 ); assertNotSame( "Expired session returned", sessionId1, sessionId2 ); } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( ) throws Exception { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( "No session created.", sessionId1 ); assertNotNull( "Session not available in memcached.", _memcached.get( sessionId1 ) ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNull( "Session not expired in memcached.", _memcached.get( sessionId1 ) ); 
public void testLoadFromMemcachedOldSessionSerializationFormat ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Session session = manager . createSession ( null ) ; final SessionTranscoder oldSessionTranscoder = manager . getTranscoderFactory ( ) . createSessionTranscoder ( manager ) ; final Future < Boolean > future = _memcached . set ( session . getId ( ) , session . getMaxInactiveInterval ( ) , session , oldSessionTranscoder ) ; assertTrue ( future . get ( ) ) ; final Session loadedFromMemcached = manager . loadFromMemcached ( session . getId ( ) ) ; assertNotNull ( loadedFromMemcached ) ; assertDeepEquals ( session , loadedFromMemcached ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _httpClient = new DefaultHttpClient ( ) ; } 
public void tearDown ( ) throws Exception { if ( _daemon1 . isRunning ( ) ) { _daemon1 . stop ( ) ; } if ( _daemon2 . isRunning ( ) ) { _daemon2 . stop ( ) ; } if ( _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } 
private Map < String , Session > getSessions ( ) throws NoSuchFieldException , IllegalAccessException { final Field field = ManagerBase . class . getDeclaredField ( " sessions " ) ; field . setAccessible ( true ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Session > sessions = ( Map < String , Session > ) field . get ( getManager ( _tomcat1 ) ) ; return sessions ; } 
public static Response get ( final DefaultHttpClient client , final int port , final String rsessionId ) throws IOException , HttpException { return get ( client , port , null , rsessionId ) ; } 
public static Response get ( final DefaultHttpClient client , final int port , final String rsessionId , final Credentials credentials ) throws IOException , HttpException { return get ( client , port , null , rsessionId , credentials ) ; } 
public static Response get ( final DefaultHttpClient client , final int port , final String path , final String rsessionId ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null ) ; } 
private static HttpResponse executeRequestWithAuth ( final DefaultHttpClient client , final HttpGet method , final Credentials credentials ) throws IOException , ClientProtocolException { client . getCredentialsProvider ( ) . setCredentials ( AuthScope . ANY , credentials ) ; final BasicHttpContext localcontext = new BasicHttpContext ( ) ; Generate BASIC scheme object and stick it to the local execution context final BasicScheme basicAuth = new BasicScheme(); localcontext.setAttribute( "preemptive-auth", basicAuth ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); return client.execute( method, localcontext ); } 
private static Response readResponse ( final String rsessionId , final HttpResponse response ) throws IOException { final String responseSessionId = getSessionIdFromResponse ( response ) ; System.out.println( "response cookie: " + responseSessionId ); final Map<String, String> keyValues = new LinkedHashMap<String, String>(); BufferedReader reader = null; try { reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) ); String line = null; while ( ( line = reader.readLine() ) != null ) { final String[] keyValue = line.split( "=" ); if ( keyValue.length > 0 ) { keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null ); } } } finally { reader.close(); } return new Response( responseSessionId == null ? rsessionId : responseSessionId, keyValues ); } 
public static Response post ( final DefaultHttpClient client , final int port , final String rsessionId , final String paramName , final String paramValue ) throws IOException , HttpException { final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( paramName , paramValue ) ; return post ( client , port , null , rsessionId , params ) ; } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:"+ DEFAULT_HOST +":"+ port + CONTEXT_PATH; final String url = baseUri + ( path != null ? path : "" ); final HttpPost method = new HttpPost( url ); if ( rsessionId != null ) { method.setHeader( "Cookie", "JSESSIONID=" + rsessionId ); } method.setEntity( createFormEntity( params ) ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); final HttpResponse response = client.execute( method ); final int statusCode = response.getStatusLine().getStatusCode(); if ( statusCode == 302 ) { return redirect( response, client, port, rsessionId, baseUri ); } if ( statusCode != 200 ) { throw new RuntimeException( "GET did not return status 200, but " + response.getStatusLine() ); } return readResponse( rsessionId, response ); } 
private static Response redirect ( final HttpResponse response , final DefaultHttpClient client , final int port , final String rsessionId , final String baseUri ) throws IOException , HttpException { final String location = response . getFirstHeader ( " Location " ) . getValue ( ) ; if ( ! location . startsWith ( baseUri ) ) { throw new RuntimeException ( " There's s.th. wrong, the location header should start with the base URI " + baseUri + " . The location header: " + location ) ; } final String redirectPath = location . substring ( baseUri . length ( ) , location . length ( ) ) ; return get ( client , port , redirectPath , rsessionId ) ; } 
private static UrlEncodedFormEntity createFormEntity ( final Map < String , String > params ) throws UnsupportedEncodingException { final List < NameValuePair > parameters = new ArrayList < NameValuePair > ( ) ; for ( final Map . Entry < String , String > param : params . entrySet ( ) ) { parameters . add ( new BasicNameValuePair ( param . getKey ( ) , param . getValue ( ) ) ) ; } final UrlEncodedFormEntity entity = new UrlEncodedFormEntity ( parameters , HTTP . UTF_8 ) ; return entity ; } 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , null , loginType , DEFAULT_TRANSCODER_FACTORY ) ; } 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , null , DEFAULT_TRANSCODER_FACTORY ) ; } 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , null , transcoderFactoryClassName ) ; } 
public static Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , loginType , DEFAULT_TRANSCODER_FACTORY ) ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , sessionTimeout , memcachedNodes , null , null , DEFAULT_TRANSCODER_FACTORY ) ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( NODE_ID , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } 
public void testTomcatFailover ( ) throws IOException , InterruptedException , HttpException { final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value ) . getSessionId ( ) ; final Object session = _client . get ( sessionId1 ) ; Assert . assertNotNull ( " Session not found in memcached: " + sessionId1 , session ) ; final Response response = get ( _httpClient , TC_PORT_2 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; Assert . assertEquals ( sessionId1 , sessionId2 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; Thread . sleep ( 10 ) ; 
public void testLoadedSessionOnlySentIfModified ( ) throws IOException , InterruptedException , HttpException { post ( _httpClient , TC_PORT_2 , sessionId1 , " bar " , " baz " ) ; Assert . assertEquals ( 2 , _daemon . getCache ( ) . getSetCmds ( ) ) ; Thread . sleep ( 10 ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { return doSerialize ( attributes , " attributes " ) ; } 
protected byte [ ] serialize ( final Object session ) { return doSerialize ( session , " session " ) ; } 
private byte [ ] doSerialize ( final Object object , final String name ) { if ( object = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } XMLObjectWriter writer = null ; try { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; 
public Map < String , Object > deserializeAttributes ( final byte [ ] in ) { return doDeserialize ( in , " attributes " ) ; } 
protected MemcachedBackupSession deserialize ( byte [ ] in ) { final MemcachedBackupSession result = doDeserialize ( in , " session " ) ; result . setManager ( _manager ) ; result . doAfterDeserialization ( ) ; return result ; } 
private < T > T doDeserialize ( final byte [ ] in , String name ) { getLogger().info( "Loading serialized:" + new String( in ) ); XMLObjectReader reader = null; try { final ByteArrayInputStream bis = new ByteArrayInputStream( in ); 
public SessionAttributesTranscoder createTranscoder ( final Manager manager ) { return getTranscoder ( manager ) ; } 
public SessionTranscoder createSessionTranscoder ( final Manager manager ) { return getTranscoder ( manager ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " , JavolutionTranscoderFactory . class . getName ( ) ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public void testLoadFromMemcachedOldSessionSerializationFormat ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Session session = manager . createSession ( null ) ; final SessionTranscoder oldSessionTranscoder = manager . getTranscoderFactory ( ) . createSessionTranscoder ( manager ) ; Future < Boolean > future = _memcached . set ( session . getId ( ) , session . getMaxInactiveInterval ( ) , session , oldSessionTranscoder ) ; Assert . assertTrue ( future . get ( ) ) ; final Session loadedFromMemcached = manager . loadFromMemcached ( session . getId ( ) ) ; Assert . assertNotNull ( loadedFromMemcached ) ; Assert . assertNotNull ( loadedFromMemcached . getManager ( ) ) ; Assert . assertNotNull ( loadedFromMemcached . getNoteNames ( ) ) ; assertDeepEquals ( session , loadedFromMemcached ) ; } 
public void testCurrency ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final Currency orig = Currency . getInstance ( " EUR " ) ; session . setAttribute ( " currency1 " , orig ) ; session . setAttribute ( " currency2 " , orig ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; Check that the transient field defaultFractionDigits is initialized correctly (that was the bug) final Currency currency1 = (Currency) deserialized.get( "currency1" ); Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() ); Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() ); 
public void testXMLSerializableSupport ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final String attributeName = " myxmlserializable " ; session . setAttribute ( attributeName , new MyXMLSerializable ( Runtime . getRuntime ( ) ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; final MyXMLSerializable myXMLSerializable = ( MyXMLSerializable ) deserialized . get ( attributeName ) ; Assert . assertNotNull ( myXMLSerializable . getRuntime ( ) , " Transient field runtime should be initialized by XMLFormat " + " used due to implementation of XMLSerializable. " ) ; 
public void testJavaUtilCollectionsUnmodifiable ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableList ( new ArrayList < String > ( Arrays . asList ( " foo " , " bar " ) ) ) ) ; final HashMap < String , String > m = new HashMap < String , String > ( ) ; m . put ( " foo " , " bar " ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableMap ( m ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testJavaUtilLists ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyList " , Collections . < String > emptyList ( ) ) ; session . setAttribute ( " arrayList " , new ArrayList < String > ( ) ) ; session . setAttribute ( " arraysAsList " , Arrays . asList ( " foo " , " bar " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testJavaUtilCollectionsEmptyMap ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyMap " , Collections . < String , String > emptyMap ( ) ) ; session . setAttribute ( " hashMap " , new HashMap < String , String > ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public < T > void testSharedObjectIdentity_CounterHolder ( ) throws Exception { final AtomicInteger sharedObject = new AtomicInteger ( 42 ) ; final CounterHolder holder1 = new CounterHolder ( sharedObject ) ; final CounterHolder holder2 = new CounterHolder ( sharedObject ) ; final CounterHolderArray holderHolder = new CounterHolderArray ( holder1 , holder2 ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " hh " , holderHolder ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; final CounterHolderArray hhd = ( CounterHolderArray ) deserialized . get ( " hh " ) ; Assert . assertTrue ( hhd . holders [ 0 ] . item = = hhd . holders [ 1 ] . item ) ; 
public < T > void testSharedObjectIdentityWithArray ( final String name , final T sharedObject ) throws Exception { final Holder < T > holder1 = new Holder < T > ( sharedObject ) ; final Holder < T > holder2 = new Holder < T > ( sharedObject ) ; @SuppressWarnings ( " unchecked " ) final HolderArray < T > holderHolder = new HolderArray < T > ( holder1 , holder2 ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( name , holderHolder ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; @SuppressWarnings ( " unchecked " ) final HolderArray < T > hhd = ( HolderArray < T > ) deserialized . get ( name ) ; Assert . assertTrue ( hhd . holders [ 0 ] . item = = hhd . holders [ 1 ] . item ) ; 
public < T > void testSharedObjectIdentity ( final String name , final T sharedObject ) throws Exception { final Holder < T > holder1 = new Holder < T > ( sharedObject ) ; final Holder < T > holder2 = new Holder < T > ( sharedObject ) ; @SuppressWarnings ( " unchecked " ) final HolderList < T > holderHolder = new HolderList < T > ( new ArrayList < Holder < T > > ( Arrays . asList ( holder1 , holder2 ) ) ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( name , holderHolder ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; @SuppressWarnings ( " unchecked " ) final HolderList < T > hhd = ( HolderList < T > ) deserialized . get ( name ) ; Assert . assertTrue ( hhd . holders . get ( 0 ) . item = = hhd . holders . get ( 1 ) . item ) ; 
public < T > void testTypesAsSessionAttributes ( final Class < T > type , final T instance ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( type . getSimpleName ( ) , instance ) ; final byte [ ] bytes = _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; assertDeepEquals ( _transcoder . deserializeAttributes ( bytes ) , session . getAttributesInternal ( ) ) ; } 
public void testTypesInContainerClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( MyContainer . class . getSimpleName ( ) , new MyContainer ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testClassWithoutDefaultConstructor ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " no-default constructor " , TestClasses . createClassWithoutDefaultConstructor ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testPrivateClass ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " pc " , TestClasses . createPrivateClass ( " foo " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testCollections ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " foo " , new EntityWithCollections ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testCyclicDependencies ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; final Person p1 = createPerson ( " foo bar " , Gender . MALE , 42 , " foo.bar@example.org " , " foo.bar@example.com " ) ; final Person p2 = createPerson ( " bar baz " , Gender . FEMALE , 42 , " bar.baz@example.org " , " bar.baz@example.com " ) ; p1 . addFriend ( p2 ) ; p2 . addFriend ( p1 ) ; session . setAttribute ( " person1 " , p1 ) ; session . setAttribute ( " person2 " , p2 ) ; final byte [ ] bytes = _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; assertDeepEquals ( session . getAttributesInternal ( ) , _transcoder . deserializeAttributes ( bytes ) ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { return doSerialize ( attributes ) ; 
private byte [ ] doSerialize ( final Object object ) { if ( object = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { _xstream . toXML ( object , bos ) ; 
public Map < String , Object > deserializeAttributes ( final byte [ ] in ) { final ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; try { @SuppressWarnings ( " unchecked " ) 
protected byte [ ] serialize ( final Object o ) { return doSerialize ( o ) ; } 
protected MemcachedBackupSession deserialize ( final byte [ ] in ) { final ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; try { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createEmptySession ( ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " , XStreamTranscoderFactory . class . getName ( ) ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public void testLoadFromMemcachedOldSessionSerializationFormat ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Session session = manager . createSession ( null ) ; final SessionTranscoder oldSessionTranscoder = manager . getTranscoderFactory ( ) . createSessionTranscoder ( manager ) ; Future < Boolean > future = _memcached . set ( session . getId ( ) , session . getMaxInactiveInterval ( ) , session , oldSessionTranscoder ) ; Assert . assertTrue ( future . get ( ) ) ; final Session loadedFromMemcached = manager . loadFromMemcached ( session . getId ( ) ) ; Assert . assertNotNull ( loadedFromMemcached ) ; assertDeepEquals ( session , loadedFromMemcached ) ; } 
public void testReadValueIntoObject ( ) throws Exception { final MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( new StandardContext ( ) ) ; final XStreamTranscoder transcoder = new XStreamTranscoder ( manager ) ; final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; getField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; session . setMaxInactiveInterval ( 600 ) ; session . setId ( " foo " ) ; session . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; session . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; final long start1 = System . nanoTime ( ) ; transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; final long start2 = System . nanoTime ( ) ; transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; System . out . println ( " xstream-ser took " + ( System . nanoTime ( ) - start2 ) / 1000 ) ; final long start3 = System . nanoTime ( ) ; final byte [ ] json = transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; final Map < String , Object > readValue = ( Map < String , Object > ) transcoder . deserializeAttributes ( json ) ; System . out . println ( " xstream-round took " + ( System . nanoTime ( ) - start3 ) / 1000 ) ; System.out.println( "Have json: " + new String(json) ); assertEquals( readValue, session.getAttributesInternal() ); 
public final void testGetNextNodeId_SingleNode ( ) { final String actual = BackupSessionTask . getNextNodeId ( " n1 " , Arrays . asList ( " n1 " ) , null ) ; assertNull ( actual , " For a sole existing node we cannot get a next node " ) ; } 
public final void testGetNextNodeId_RegularNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getNextNodeId ( nodeId1 , null ) ; assertEquals ( nodeId2 , actual , " The failover node is not chosen " ) ; } 
public final void testGetNextNodeId_FailoverNode_RegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getNextNodeId ( nodeId2 , null ) ; assertEquals ( nodeId1 , actual , " The regular node is not chosen " ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final BackupSessionTask cut = new BackupSessionTask ( Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getNextNodeId ( nodeId2 , asSet ( nodeId1 ) ) ; assertEquals ( nodeId3 , actual , " The second failover node is not chosen " ) ; } 
public void testLRU ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 3 ) ; final String f = " foo " ; final String br = " bar " ; cut . put ( f , br ) ; cut . put ( br , " baz " ) ; Assert . assertTrue ( Arrays . equals ( new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) , " invalid order of items, initially it should be insertion ordered " ) ; cut . get ( f ) ; Assert . assertTrue ( Arrays . equals ( new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) , " invalid order of items, accessing foo should move it to the end " ) ; cut . get ( br ) ; Assert . assertTrue ( Arrays . equals ( new String [ ] { f , br } , cut . getKeys ( ) . toArray ( ) ) , " invalid order of items " ) ; cut . get ( f ) ; Assert . assertTrue ( Arrays . equals ( new String [ ] { br , f } , cut . getKeys ( ) . toArray ( ) ) , " invalid order of items, accessing foo should move it to the end " ) ; cut . put ( " baz " , " foo " ) ; Assert . assertTrue ( Arrays . equals ( new String [ ] { br , f , " baz " } , cut . getKeys ( ) . toArray ( ) ) , " invalid order of items, last inserted item should be at last position " ) ; 
public void testCacheSize ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; cut . put ( " bar " , " baz " ) ; Assert . assertEquals ( " baz " , cut . get ( " bar " ) ) ; Assert . assertNull ( cut . get ( " foo " ) , " old key still existing, unexpected cache size " ) ; } 
public void testCacheTTL ( ) throws InterruptedException { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 , 100 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; Thread . sleep ( 101 ) ; Assert . assertNull ( cut . get ( " foo " ) , " expired key still existing, unexpected cache size " ) ; } 
public void setup ( ) throws Exception { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.init( _memcachedMock ); 
public void testConfiguredMemcachedNodeId ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final String nodeId = sessionId1 . substring ( sessionId1 . indexOf ( '-' ) + 1 , sessionId1 . indexOf ( '.' ) ) ; assertEquals ( _memcachedNodeId , nodeId , " Invalid memcached node id " ) ; } 
public void testSessionIdJvmRouteCompatibility ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertTrue ( sessionId1 . matches ( " [^-.]+-[^.]+( \\ .[ \\ w]+)? " ) , " Invalid session format, must be <sid>-<memcachedId>[.<jvmRoute>]. " ) ; 
public void testInvalidSessionId ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , " 12345 " ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertTrue ( sessionId1 . indexOf ( '-' ) > - 1 , " Invalid session id format " ) ; } 
public void testSessionAvailableInMemcached ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId1 ) , " Session not available in memcached. " ) ; } 
public void testExpiredSessionRemovedFromMemcached ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) ) + 100 ; Thread . sleep ( timeout ) ; assertNull ( _memcached . get ( sessionId1 ) , " Expired sesion still existing in memcached " ) ; } 
public void testInvalidSessionNotFound ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId1 , sessionId2 , " Expired session returned " ) ; } 
public void testRelocateSession ( ) throws IOException , InterruptedException , HttpException { FIXME implementation does not match docs final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); Thread.sleep( 2100 ); final String sessionId2 = makeRequest( _httpClient, _portTomcat1, sessionId1 ); assertNotSame( sessionId1, sessionId2, "Expired session returned" ); } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( ) throws Exception { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 1000 ); +1000 just to be sure that we're >4 secs assertNull( _memcached.get( sessionId1 ), "Session not expired in memcached." ); 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( ) throws Exception { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNull( _memcached.get( sessionId1 ), "Session not expired in memcached." ); 
public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " ) ) ; 
public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.jvm1 " ) ) ; } 
public void testIsValid ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertFalse ( cut . isValid ( " foo " ) ) ; assertFalse ( cut . isValid ( " foo.jvm1-n " ) ) ; assertFalse ( cut . isValid ( " foo.n.jvm1 " ) ) ; assertTrue ( cut . isValid ( " foo-n " ) ) ; assertTrue ( cut . isValid ( " foo-n.jvm1 " ) ) ; } 
public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenRequestedSessionIdPresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testGetSessionInternalInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( SessionTrackerValve . JSESSIONID , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( " foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResultStatus . SUCCESS ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testResponseCookieForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResultStatus . RELOCATED ) ) ; sessionControl . expects ( once ( ) ) . method ( " getId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getContextPath " ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( sessionId ) ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public static void setup ( ) { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _manager.init(); 
public void testRelocateSession ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . nextNodeId ; assertEquals ( expectedNode , secondNode , " Unexpected nodeId. " ) ; assertEquals ( sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , sid2 , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertNotNull ( session , " Session not found by new id " + sid2 ) ; assertFalse ( session . getNoteNames ( ) . hasNext ( ) , " Some notes are set: " + toArray ( session . getNoteNames ( ) ) ) ; 
public void testMultipleMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = sid1 . substring ( sid1 . lastIndexOf ( '-' ) + 1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; info . nextNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = sid2 . substring ( sid2 . lastIndexOf ( '-' ) + 1 ) ; final String expectedNode = info . failoverNodeId ; assertEquals ( expectedNode , secondNode , " Unexpected nodeId. " ) ; assertEquals ( sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , sid2 , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertFalse ( session . getNoteNames ( ) . hasNext ( ) , " Some notes are set: " + toArray ( session . getNoteNames ( ) ) ) ; 
public void testAllMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertEquals ( sid1 , sid2 , " SessionId changed. " ) ; assertNotNull ( getSessions ( ) . get ( sid1 ) , " Session " + sid1 + " not existing. " ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertFalse ( session . getNoteNames ( ) . hasNext ( ) , " Some notes are set: " + toArray ( session . getNoteNames ( ) ) ) ; 
protected Session loadFromMemcached ( final String sessionId ) { if ( ! isValidSessionIdFormat ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _log . debug ( " Loading session from memcached: " + sessionId ) ; try { final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; if ( _log . isDebugEnabled ( ) ) { if ( object = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeAvailabilityCache . setNodeAvailable ( nodeId , true ) ; if ( object instanceof MemcachedBackupSession ) { return ( Session ) object ; } else { return _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeAvailabilityCache . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
public MemcachedBackupSession deserialize ( final byte [ ] data , final Realm realm , final Manager manager ) { if ( data = = null ) { return null ; } try { final DeserializationResult deserializationResult = TranscoderService . deserializeSessionFields ( data , realm ) ; 
public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager . getContainer ( ) . getRealm ( ) ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager . getContainer ( ) . getRealm ( ) , _manager ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager . getContainer ( ) . getRealm ( ) , _manager ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeAvailabilityCache = createNodeAvailabilityCache ( 1000 ) ; _transcoderService = createTranscoderService ( ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + _nodeIds + " and failover node ids " + _failoverNodeIds ) ; 
public void updateExpiration ( ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Updating expiration time for session " + _session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( ) ) { return ; } _session . setExpirationUpdateRunning ( true ) ; try { final Map < String , Object > attributes = _session . getAttributesInternal ( ) ; 
public BackupResultStatus backupSession ( ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + _session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( ) ) { return BackupResultStatus . FAILURE ; } _session . setBackupRunning ( true ) ; try { 
private boolean hasMemcachedIdSet ( ) { return _sessionIdFormat . isValid ( _session . getId ( ) ) ; } 
public String determineSessionIdForBackup ( ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; if ( nodeId ! = null & & ! _nodeIdService . isNodeAvailable ( nodeId ) ) { final String nextNodeId = _nodeIdService . getAvailableNodeId ( nodeId ) ; if ( nextNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( _session . getId ( ) , nextNodeId ) ; _relocateSessionIdForBackup = newSessionId ; return newSessionId ; } else { _log . warn ( " The node " + nodeId + " is not available and there's no node for relocation left. " ) ; } } return null ; } 
private boolean sessionWouldBeRelocated ( ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( _session . getId ( ) ) ; return nodeId ! = null & & ! _nodeIdService . isNodeAvailable ( nodeId ) ; } 
private BackupResult failover ( final String targetNodeId ) { final BackupResult backupResult = doBackupSession ( data , attributesData ) ; return backupResult ; } 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeIdService = new NodeIdService ( createNodeAvailabilityCache ( allNodeIds . size ( ) , 1000 ) , nodeIds , failoverNodeIds ) ; _transcoderService = createTranscoderService ( ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + nodeIds + " and failover node ids " + failoverNodeIds ) ; 
private NodeAvailabilityCache < String > createNodeAvailabilityCache ( final int size , final long ttlInMillis ) { return new NodeAvailabilityCache < String > ( size , ttlInMillis , new CacheLoader < String > ( ) { 
private List < String > initFailoverNodes ( final List < String > nodeIds ) { final List < String > failoverNodeIds = new ArrayList < String > ( ) ; if ( _failoverNodes ! = null & & _failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodes = _failoverNodes . split ( " " ) ; for ( final String failoverNode : failoverNodes ) { final String nodeId = failoverNode . trim ( ) ; if ( ! nodeIds . remove ( nodeId ) ) { throw new IllegalArgumentException ( " Invalid failover node id " + nodeId + " : " + " not existing in memcachedNodes ' " + _memcachedNodes + " '. " ) ; } failoverNodeIds . add ( nodeId ) ; } } return failoverNodeIds ; } 
private void initHandleNodeDefinitionMatch ( final Matcher matcher , final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final List < String > nodeIds , final Set < String > allNodeIds ) { final String nodeId = matcher . group ( 1 ) ; nodeIds . add ( nodeId ) ; allNodeIds . add ( nodeId ) ; final String hostname = matcher . group ( 2 ) ; final int port = Integer . parseInt ( matcher . group ( 3 ) ) ; final InetSocketAddress address = new InetSocketAddress ( hostname , port ) ; addresses . add ( address ) ; address2Ids . put ( address , nodeId ) ; } 
protected synchronized String generateSessionId ( ) { return _sessionIdFormat . createSessionId ( super . generateSessionId ( ) , _nodeIdService . getMemcachedNodeId ( ) ) ; } 
public void expireSession ( final String sessionId ) { _log . debug ( " expireSession invoked: " + sessionId ) ; super . expireSession ( sessionId ) ; if ( _sessionIdFormat . isValid ( sessionId ) ) { _memcached . delete ( sessionId ) ; 
protected Session loadFromMemcached ( final String sessionId ) { if ( ! _sessionIdFormat . isValid ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _log . debug ( " Loading session from memcached: " + sessionId ) ; try { final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; if ( _log . isDebugEnabled ( ) ) { if ( object = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object instanceof MemcachedBackupSession ) { return ( Session ) object ; } else { return _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
public boolean isNodeAvailable ( final String nodeId ) { return _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ; } 
public String createSessionId ( final String sessionId , final String memcachedId ) { if ( memcachedId = = null ) { return sessionId ; } final int idx = sessionId . indexOf ( '.' ) ; if ( idx < 0 ) { return sessionId + " - " + memcachedId ; 
public void testSetNodeAvailability ( ) { final String nodeId1 = " n1 " ; final CacheLoader < String > cacheLoader = new CacheLoader < String > ( ) { @Override public boolean isNodeAvailable ( final String key ) { return true ; } } ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , Arrays . asList ( nodeId1 ) , Collections . < String > emptyList ( ) ) ; Assert . assertTrue ( cut . isNodeAvailable ( nodeId1 ) ) ; cut . setNodeAvailable ( nodeId1 , false ) ; Assert . assertFalse ( cut . isNodeAvailable ( nodeId1 ) ) ; cut . setNodeAvailable ( nodeId1 , true ) ; Assert . assertTrue ( cut . isNodeAvailable ( nodeId1 ) ) ; 
public boolean isNodeAvailable ( final String key ) { return true ; } 
public final void testGetNextNodeId_SingleNode ( ) { final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , Arrays . asList ( " n1 " ) , null ) ; final String actual = cut . getAvailableNodeId ( " n1 " ) ; assertNull ( actual , " For a sole existing node we cannot get a next node " ) ; } 
public final void testGetNextNodeId_TwoNodes ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , Arrays . asList ( nodeId1 , nodeId2 ) , null ) ; String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual ) ; actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual ) ; } 
public final void testGetNextNodeId_TwoNodes_NoNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( Arrays . asList ( nodeId1 ) ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , Arrays . asList ( nodeId1 , nodeId2 ) , null ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_RegularNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual , " The failover node is not chosen " ) ; } 
public final void testGetNextNodeId_FailoverNode_RegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual , " The regular node is not chosen " ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , Arrays . asList ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId3 , actual , " The second failover node is not chosen " ) ; } 
private NodeAvailabilityCache < String > createNodeAvailabilityCache ( final String . . . unavailableNodes ) { final List < String > unavailable = unavailableNodes ! = null ? Arrays . asList ( unavailableNodes ) : null ; return new NodeAvailabilityCache < String > ( 10 , 100 , new DummyCacheLoader ( unavailable ) ) ; } 
public boolean isNodeAvailable ( final String key ) { return _unavailable = = null | | ! _unavailable . contains ( key ) ; } 
public void testRelocateSession ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; Thread . sleep ( 50 ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = extractNodeId ( sid2 ) ; assertNotSame ( secondNode , firstNode , " First node again selected " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + secondNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertNotNull ( session , " Session not found by new id " + sid2 ) ; assertFalse ( session . getNoteNames ( ) . hasNext ( ) , " Some notes are set: " + toArray ( session . getNoteNames ( ) ) ) ; 
public void testMultipleMemcachedNodesFailure ( ) throws Throwable { final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; LOG . debug ( " Have firstNode " + firstNode ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; final Map . Entry < String , MemCacheDaemon < ? > > otherNodeWithId = info . otherNode ( ) ; otherNodeWithId . getValue ( ) . stop ( ) ; LOG . debug ( " Stopping otherNode " + otherNodeWithId . getKey ( ) ) ; Thread . sleep ( 1000 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = extractNodeId ( sid2 ) ; LOG . debug ( " Have secondNode " + secondNode ) ; final String expectedNode = info . otherNodeExcept ( otherNodeWithId . getKey ( ) ) . getKey ( ) ; assertEquals ( secondNode , expectedNode , " Unexpected nodeId: " + secondNode + " . " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertFalse ( session . getNoteNames ( ) . hasNext ( ) , " Some notes are set: " + toArray ( session . getNoteNames ( ) ) ) ; 
public void testCookieNotSetWhenAllMemcachedsDownIssue40 ( ) throws IOException , HttpException { _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertNull ( nodeId , " NodeId should be null, but is " + nodeId + " . " ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
public void testCookieNotSetWhenRegularMemcachedDownIssue40 ( ) throws Exception { _daemon2 . stop ( ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertEquals ( nodeId , _nodeId1 ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
private Map < String , MemCacheDaemon < ? > > asMap ( final String nodeId1 , final MemCacheDaemon < ? > daemon1 , final String nodeId2 , final MemCacheDaemon < ? > daemon2 ) { final Map < String , MemCacheDaemon < ? > > result = new HashMap < String , MemCacheDaemon < ? > > ( 2 ) ; result . put ( nodeId1 , daemon1 ) ; result . put ( nodeId2 , daemon2 ) ; return result ; } 
public Entry < String , MemCacheDaemon < ? > > otherNode ( ) { return otherNodes . entrySet ( ) . iterator ( ) . next ( ) ; } 
private static Response readResponse ( final String rsessionId , final HttpResponse response ) throws IOException { final String responseSessionId = getSessionIdFromResponse ( response ) ; System.out.println( "response cookie: " + responseSessionId ); final Map<String, String> keyValues = new LinkedHashMap<String, String>(); BufferedReader reader = null; try { reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) ); String line = null; while ( ( line = reader.readLine() ) != null ) { final String[] keyValue = line.split( "=" ); if ( keyValue.length > 0 ) { keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null ); } } } finally { reader.close(); } return new Response( responseSessionId == null ? rsessionId : responseSessionId, responseSessionId, keyValues ); } 
public static MemCacheDaemon < ? extends CacheElement > createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon < LocalCacheElement > daemon = new MemCacheDaemon < LocalCacheElement > ( ) ; final ConcurrentLinkedHashMap < String , LocalCacheElement > cacheStorage = ConcurrentLinkedHashMap . create ( EvictionPolicy . LRU , 100000 , 1024 * 1024 ) ; daemon . setCache ( new CacheImpl ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( false ) ; return daemon ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setSessionBackupAsync( false ); sessionManager.setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public static String extractNodeId ( final String sessionId ) { final int idx = sessionId . lastIndexOf ( '-' ) ; return idx > - 1 ? sessionId . substring ( idx + 1 ) : null ; } 
private List < String > initFailoverNodes ( final List < String > nodeIds ) { final List < String > failoverNodeIds = new ArrayList < String > ( ) ; if ( _failoverNodes ! = null & & _failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodes = _failoverNodes . split ( " |, " ) ; for ( final String failoverNode : failoverNodes ) { final String nodeId = failoverNode . trim ( ) ; if ( ! nodeIds . remove ( nodeId ) ) { throw new IllegalArgumentException ( " Invalid failover node id " + nodeId + " : " + " not existing in memcachedNodes ' " + _memcachedNodes + " '. " ) ; } failoverNodeIds . add ( nodeId ) ; } } return failoverNodeIds ; } 
public void testConfigurationFormatMemcachedNodesFeature44 ( ) { _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _manager . init ( ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _manager . init ( ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _manager . init ( ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testConfigurationFormatFailoverNodesFeature44 ( ) { _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _manager . setFailoverNodes ( " n1 " ) ; _manager . init ( ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _manager . setFailoverNodes ( " n1 n2 " ) ; _manager . init ( ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _manager . setFailoverNodes ( " n1,n2 " ) ; _manager . init ( ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public BackupResultStatus backupSession ( ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + _session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( ) ) { _statistics . requestWithBackupFailure ( ) ; return BackupResultStatus . FAILURE ; } _session . setBackupRunning ( true ) ; try { 
private byte [ ] serializeAttributes ( final Map < String , Object > attributes ) { final long start = System . currentTimeMillis ( ) ; final byte [ ] attributesData = _transcoderService . serializeAttributes ( _session , attributes ) ; _statistics . getAttributesSerializationProbe ( ) . registerSince ( start ) ; return attributesData ; } 
private BackupResult failover ( final String targetNodeId ) { final BackupResult backupResult = doBackupSession ( data , attributesData ) ; return backupResult ; } 
private void storeSessionInMemcached ( final byte [ ] data ) throws NodeFailureException { final int expirationTime = _session . getMemcachedExpirationTimeToSet ( ) ; final long start = System . currentTimeMillis ( ) ; try { final Future < Boolean > future = _memcached . set ( _session . getId ( ) , expirationTime , data ) ; 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _nodeIdService = new NodeIdService ( createNodeAvailabilityCache ( allNodeIds . size ( ) , 1000 ) , nodeIds , failoverNodeIds ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + nodeIds + " and failover node ids " + failoverNodeIds ) ; 
private TranscoderService createTranscoderService ( final Statistics statistics ) { return new TranscoderService ( getTranscoderFactory ( ) . createTranscoder ( this ) ) ; } 
private MemcachedClient createMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { try { return new MemcachedClient ( new SuffixLocatorConnectionFactory ( 
protected Session loadFromMemcached ( final String sessionId ) { if ( ! _sessionIdFormat . isValid ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { _log . debug ( " Loading session from memcached: " + sessionId ) ; try { final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; if ( _log . isDebugEnabled ( ) ) { if ( object = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object instanceof MemcachedBackupSession ) { _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; return ( Session ) object ; } else { final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; if ( object ! = null ) { _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; } return result ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
private void backupSession ( final Request request , final Response response ) { final Session session = request . getRequestedSessionId ( ) ! = null | | getCookie ( response , JSESSIONID ) ! = null ? request . getSessionInternal ( false ) : null ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Have a session: " + ( session ! = null ) ) ; } if ( session ! = null ) { 
public static Statistics create ( final boolean enabled ) { return enabled ? new Statistics ( ) : DISABLED_STATS ; } 
public void requestWithoutSession ( ) { _numRequestsWithoutSession . incrementAndGet ( ) ; } 
public void requestWithSession ( ) { _numRequestsWithSession . incrementAndGet ( ) ; } 
public void requestWithBackup ( ) { _numRequestsWithBackup . incrementAndGet ( ) ; } 
public void requestWithBackupRelocation ( ) { _numRequestsWithBackupRelocation . incrementAndGet ( ) ; } 
public void requestWithBackupFailure ( ) { _numRequestsWithBackupFailure . incrementAndGet ( ) ; } 
public void requestWithoutSessionAccess ( ) { _numRequestsWithoutSessionAccess . incrementAndGet ( ) ; } 
public void requestWithoutSessionModification ( ) { _numRequestsWithoutSessionModification . incrementAndGet ( ) ; } 
public void sessionLoadedFromMemcached ( ) { _numSessionsLoadedFromMemcached . incrementAndGet ( ) ; } 
public void registerSince ( final long startInMillis ) { register ( System . currentTimeMillis ( ) - startInMillis ) ; } 
public void register ( final long value ) { if ( value < _min | | _first ) { _min = value ; } if ( value > _max | | _first ) { _max = value ; } _avg = ( _avg * _count . get ( ) + value ) / _count . incrementAndGet ( ) ; _first = false ; } 
public boolean asyncDecode ( final CachedData cachedData ) { return _delegate . asyncDecode ( cachedData ) ; } 
public Object decode ( final CachedData cachedData ) { return _delegate . decode ( cachedData ) ; } 
public CachedData encode ( final Object object ) { final CachedData result = _delegate . encode ( object ) ; _statistics . getCachedDataSizeProbe ( ) . register ( result . getData ( ) . length ) ; return result ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public void setUp ( ) throws Exception { _sessionBackupServiceControl = mock ( SessionBackupService . class ) ; _service = ( SessionBackupService ) _sessionBackupServiceControl . proxy ( ) ; _sessionTrackerValve = new SessionTrackerValve ( null , _service , Statistics . create ( ) ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( ( Valve ) _nextValve . proxy ( ) ) ; _requestControl = mock ( Request . class ) ; _request = ( Request ) _requestControl . proxy ( ) ; _responseControl = mock ( Response . class ) ; _response = ( Response ) _responseControl . proxy ( ) ; } 
public Object [ ] [ ] createStatisticMethodNames ( ) { return new Object [ ] [ ] { { " getRequestsWithBackup " , " requestWithBackup " } , 
public void testCounts ( final String getterMethod , final String updateMethod ) throws Exception { final Statistics cut = Statistics . create ( ) ; final Method getMethod = Statistics . class . getMethod ( getterMethod ) ; assertEquals ( ( ( Long ) getMethod . invoke ( cut ) ) . longValue ( ) , 0 ) ; Statistics . class . getMethod ( updateMethod ) . invoke ( cut ) ; assertEquals ( ( ( Long ) getMethod . invoke ( cut ) ) . longValue ( ) , 1 ) ; } 
public void testDisabledRequestWithBackup ( ) { final Statistics cut = Statistics . create ( false ) ; assertEquals ( cut . getRequestsWithBackup ( ) , 0 ) ; cut . requestWithBackup ( ) ; assertEquals ( cut . getRequestsWithBackup ( ) , 0 ) ; } 
public void testMinMaxAvgProbe ( ) { final MinMaxAvgProbe cut = new MinMaxAvgProbe ( ) ; assertValues ( cut , 0 , 0 , 0 , 0 ) ; cut . register ( 1 ) ; assertValues ( cut , 1 , 1 , 1 , 1 ) ; cut . register ( 1 ) ; assertValues ( cut , 2 , 1 , 1 , 1 ) ; cut . register ( 4 ) ; assertValues ( cut , 3 , 1 , 4 , 2 ) ; cut . register ( 0 ) ; assertValues ( cut , 4 , 0 , 4 , 1.5 ) ; } 
private void assertValues ( final MinMaxAvgProbe cut , final int count , final int min , final int max , final double avg ) { assertEquals ( cut . getCount ( ) , count ) ; assertEquals ( cut . getMin ( ) , min ) ; assertEquals ( cut . getMax ( ) , max ) ; assertEquals ( cut . getAvg ( ) , avg ) ; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( NODE_ID , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " , JavolutionTranscoderFactory . class . getName ( ) ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " , XStreamTranscoderFactory . class . getName ( ) ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public final void testResponseCookieForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCoyoteResponse " ) . will ( returnValue ( new org . apache . coyote . Response ( ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) ) . will ( returnValue ( BackupResultStatus . RELOCATED ) ) ; sessionControl . expects ( once ( ) ) . method ( " getId " ) . will ( returnValue ( sessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getContext " ) . will ( returnValue ( new StandardContext ( ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " isSecure " ) . will ( returnValue ( false ) ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( sessionId ) ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public BackupResultStatus backupSession ( final boolean sessionRelocationRequired ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + _session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( ) ) { _statistics . requestWithBackupFailure ( ) ; return BackupResultStatus . FAILURE ; } _session . setBackupRunning ( true ) ; try { 
public String changeSessionIdIfRelocationRequired ( final String requestedSessionId ) { try { final MemcachedBackupSession session = ( MemcachedBackupSession ) super . findSession ( requestedSessionId ) ; if ( session ! = null & & session . isValid ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ; if ( nodeId ! = null & & ! _nodeIdService . isNodeAvailable ( nodeId ) ) { final String nextNodeId = _nodeIdService . getAvailableNodeId ( nodeId ) ; if ( nextNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( session . getId ( ) , nextNodeId ) ; _log . debug ( " Session needs to be relocated, setting new id on session... " ) ; session . setIdForRelocate ( newSessionId ) ; return newSessionId ; } else { _log . warn ( " The node " + nodeId + " is not available and there's no node for relocation left. " ) ; } } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
public BackupResultStatus backupSession ( final Session session , final boolean sessionRelocationRequired ) { return getOrCreateBackupSessionTask ( ( MemcachedBackupSession ) session ) . backupSession ( sessionRelocationRequired ) ; 
private void backupSession ( final Request request , final Response response , final boolean sessionRelocationRequired ) { final Session session = request . getRequestedSessionId ( ) ! = null | | getCookie ( response , JSESSIONID ) ! = null ? request . getSessionInternal ( false ) : null ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Have a session: " + ( session ! = null ) ) ; } if ( session ! = null ) { 
String changeSessionIdIfRelocationRequired ( final String requestedSessionId ) ; SKIPPED } } } 
BackupResultStatus backupSession ( Session session , boolean sessionRelocationRequired ) ; SKIPPED } } } 
public void testOnlySendModifiedSessions ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . backupSession ( session , false ) ; verify ( _memcachedMock , times ( 2 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; 
public void testOnlyHashAttributesOfAccessedSessions ( ) { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testInvalidSessionNotFound ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId1 , sessionId2 , " Expired session returned. " ) ; } 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; final String sessionId = " foo " ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdIfRelocationRequired " ) . with ( eq ( sessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( false ) ) . will ( returnValue ( BackupResultStatus . SUCCESS ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdIfRelocationRequired " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " setRequestedSessionId " ) . with ( eq ( newSessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " isRequestedSessionIdFromCookie " ) . will ( returnValue ( true ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getContext " ) . will ( returnValue ( new StandardContext ( ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " isSecure " ) . will ( returnValue ( false ) ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( newSessionId ) ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( true ) ) . will ( returnValue ( BackupResultStatus . SUCCESS ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public String changeSessionIdIfRelocationRequired ( final String requestedSessionId ) { try { final MemcachedBackupSession session = ( MemcachedBackupSession ) super . findSession ( requestedSessionId ) ; if ( session ! = null & & session . isValid ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ; final String newNodeId = getNewNodeIdIfUnavailable ( nodeId ) ; if ( newNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( session . getId ( ) , newNodeId ) ; _log . debug ( " Session needs to be relocated, setting new id on session... " ) ; session . setIdForRelocate ( newSessionId ) ; return newSessionId ; } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
public String createNewSessionId ( final String sessionId , final String newMemcachedId ) { final int idxDash = sessionId . indexOf ( '-' ) ; final int idxDot = sessionId . indexOf ( '.' ) ; final String sessionIdWithNewMemcachedId ; if ( idxDash < 0 ) { final String plainSessionId = idxDot < 0 ? sessionId : sessionId . substring ( 0 , idxDot ) ; sessionIdWithNewMemcachedId = plainSessionId + " - " + newMemcachedId ; } else { sessionIdWithNewMemcachedId = sessionId . substring ( 0 , idxDash + 1 ) + newMemcachedId ; } return idxDot < 0 ? sessionIdWithNewMemcachedId : sessionIdWithNewMemcachedId + sessionId . substring ( idxDot ) ; } 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; manager . setMaxInactiveInterval ( 5 ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) Thread.sleep( 2000 ); final String newSessionId = manager.changeSessionIdIfRelocationRequired( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo.jvm1 " , " m " ) ) ; 
public void updateExpiration ( final MemcachedBackupSession session ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Updating expiration time for session " + session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( session ) ) { return ; } session . setExpirationUpdateRunning ( true ) ; try { final Map < String , Object > attributes = session . getAttributesInternal ( ) ; 
public BackupResultStatus backupSession ( final MemcachedBackupSession session , final boolean sessionRelocationRequired ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( session ) ) { _statistics . requestWithBackupFailure ( ) ; return BackupResultStatus . FAILURE ; } session . setBackupRunning ( true ) ; try { 
private byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { final long start = System . currentTimeMillis ( ) ; final byte [ ] attributesData = _transcoderService . serializeAttributes ( session , attributes ) ; _statistics . getAttributesSerializationProbe ( ) . registerSince ( start ) ; return attributesData ; } 
private boolean hasMemcachedIdSet ( final MemcachedBackupSession session ) { return _sessionIdFormat . isValid ( session . getId ( ) ) ; } 
private BackupResult doBackupSession ( final MemcachedBackupSession session , final byte [ ] data , final byte [ ] attributesData ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { 
private BackupResultStatus handleAndTranslateFailoverBackupResult ( final MemcachedBackupSession session , final BackupResultStatus backupResult ) { switch ( backupResult ) { case SUCCESS : 
private void storeSessionInMemcached ( final MemcachedBackupSession session , final byte [ ] data ) throws NodeFailureException { final int expirationTime = session . getMemcachedExpirationTimeToSet ( ) ; final long start = System . currentTimeMillis ( ) ; try { final Future < Boolean > future = _memcached . set ( session . getId ( ) , expirationTime , data ) ; 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionTask ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
private MemcachedConfig createMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final List < String > nodeIds = new ArrayList < String > ( ) ; final Matcher matcher = NODE_PATTERN . matcher ( memcachedNodes ) ; final List < InetSocketAddress > addresses = new ArrayList < InetSocketAddress > ( ) ; final Map < InetSocketAddress , String > address2Ids = new HashMap < InetSocketAddress , String > ( ) ; while ( matcher . find ( ) ) { initHandleNodeDefinitionMatch ( matcher , addresses , address2Ids , nodeIds ) ; } final List < String > failoverNodeIds = initFailoverNodes ( failoverNodes , nodeIds ) ; if ( nodeIds . isEmpty ( ) ) { throw new IllegalArgumentException ( " All nodes are also configured as failover nodes, " + " this is a configuration failure. In this case, you probably want to leave out the failoverNodes. " ) ; } return new MemcachedConfig ( memcachedNodes , failoverNodes , nodeIds , failoverNodeIds , addresses , address2Ids ) ; } 
private NodeAvailabilityCache < String > createNodeAvailabilityCache ( final int size , final long ttlInMillis , final MemcachedClient memcachedClient ) { return new NodeAvailabilityCache < String > ( size , ttlInMillis , new CacheLoader < String > ( ) { 
public boolean isNodeAvailable ( final String key ) { try { memcachedClient . get ( _sessionIdFormat . createSessionId ( " ping " , key ) ) ; 
private List < String > initFailoverNodes ( final String failoverNodes , final List < String > nodeIds ) { final List < String > failoverNodeIds = new ArrayList < String > ( ) ; if ( failoverNodes ! = null & & failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodesArray = failoverNodes . split ( " |, " ) ; for ( final String failoverNode : failoverNodesArray ) { final String nodeId = failoverNode . trim ( ) ; if ( ! nodeIds . remove ( nodeId ) ) { throw new IllegalArgumentException ( " Invalid failover node id " + nodeId + " : " + " not existing in memcachedNodes ' " + nodeIds + " '. " ) ; } failoverNodeIds . add ( nodeId ) ; } } return failoverNodeIds ; } 
private void initHandleNodeDefinitionMatch ( final Matcher matcher , final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final List < String > nodeIds ) { final String nodeId = matcher . group ( 1 ) ; nodeIds . add ( nodeId ) ; final String hostname = matcher . group ( 2 ) ; final int port = Integer . parseInt ( matcher . group ( 3 ) ) ; final InetSocketAddress address = new InetSocketAddress ( hostname , port ) ; addresses . add ( address ) ; address2Ids . put ( address , nodeId ) ; } 
public BackupResultStatus backupSession ( final Session session , final boolean sessionRelocationRequired ) { return _backupSessionService . backupSession ( ( MemcachedBackupSession ) session , sessionRelocationRequired ) ; 
private MemcachedConfig reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { _memcached . shutdown ( ) ; _memcached = memcachedClient ; _nodeIdService = nodeIdService ; _backupSessionService = backupSessionService ; return config ; } 
public void testCookieNotSetWhenRegularMemcachedDownIssue40 ( ) throws Exception { _daemon2 . stop ( ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertEquals ( nodeId , _nodeId1 ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
public void testReconfigureMemcachedNodesAtRuntimeFeature46 ( ) throws Exception { final Response response2 = get ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( response2 . getSessionId ( ) , sessionId1 ) ; final String sessionId2 = response2 . getResponseSessionId ( ) ; assertNotNull ( sessionId2 ) ; assertEquals ( extractNodeId ( sessionId2 ) , _nodeId3 ) ; 
public void testReconfigureFailoverNodesAtRuntimeFeature46 ( ) throws Exception { getManager ( _tomcat1 ) . setFailoverNodes ( _nodeId1 + " " + _nodeId2 ) ; we need to use another http client, otherwise there's no response cookie. final Response response2 = get( new DefaultHttpClient(), _portTomcat1, null ); final String sessionId2 = response2.getSessionId(); assertNotNull( sessionId2 ); assertEquals( extractNodeId( sessionId2 ), _nodeId3 ); 
private void restartTomcat ( final String memcachedNodes , final String failoverNodes ) throws Exception { _tomcat1 . stop ( ) ; Thread . sleep ( 500 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; getManager ( _tomcat1 ) . setFailoverNodes ( failoverNodes ) ; _tomcat1 . start ( ) ; } 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final HttpSession session = request . getSession ( false ) ; LOG . info ( " invoked " ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + request . getSession ( ) . getId ( ) ) ; System . out . println ( " request.getSession().getId(): " + request . getSession ( ) . getId ( ) ) ; final HttpSession session = request.getSession( false ); if ( session != null ) { final Enumeration<?> attributeNames = session.getAttributeNames(); 
boolean attributesAccessedSinceLastBackup ( ) { return _attributesAccessed ; } 
public void backupFinished ( ) { _authenticationChanged = false ; _attributesAccessed = false ; } 
public void requestWithoutAttributesAccess ( ) { _numRequestsWithoutAttributesAccess . incrementAndGet ( ) ; } 
public void testOnlyHashAttributesOfAccessedAttributes ( ) { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . endAccess ( ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . getAttribute ( " foo " ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; _manager . backupSession ( session , false ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public Session createSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } if ( _maxActiveSessions > = 0 & & sessions . size ( ) > = _maxActiveSessions ) { _rejectedSessions + + ; throw new IllegalStateException ( sm . getString ( " standardManager.createSession.ise " ) ) ; } Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; session . setId ( generateSessionId ( ) ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Created new session with id " + session . getId ( ) ) ; } } sessionCounter + + ; return ( session ) ; 
public Session createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } if ( _maxActiveSessions > = 0 & & sessions . size ( ) > = _maxActiveSessions ) { _rejectedSessions + + ; throw new IllegalStateException ( sm . getString ( " standardManager.createSession.ise " ) ) ; } Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; if ( sessionId = = null | | ! isNodeAvailableForSessionId ( sessionId ) ) { sessionId = generateSessionId ( ) ; } session . setId ( sessionId ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Created new session with id " + session . getId ( ) ) ; } } sessionCounter + + ; return session ; 
private boolean isNodeAvailableForSessionId ( final String sessionId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; return nodeId ! = null & & _nodeIdService . isNodeAvailable ( nodeId ) ; } 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
private MemcachedConfig reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { _memcached . shutdown ( ) ; _memcached = memcachedClient ; _nodeIdService = nodeIdService ; _backupSessionService = backupSessionService ; return config ; } 
public void shutdown ( ) throws InterruptedException { _executorService . shutdown ( ) ; } 
public BackupResultStatus backupSession ( final MemcachedBackupSession session , final boolean sessionRelocationRequired ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + session . getId ( ) ) ; } final long start = System . currentTimeMillis ( ) ; try { 
private BackupSessionTask createBackupSessionTask ( final MemcachedBackupSession session , final boolean sessionRelocationRequired ) { return new BackupSessionTask ( session , sessionRelocationRequired , 
public boolean awaitTermination ( final long timeout , final TimeUnit unit ) throws InterruptedException { return true ; } 
public < T > List < Future < T > > invokeAll ( final Collection < ? extends Callable < T > > tasks ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; } 
public < T > List < Future < T > > invokeAll ( final Collection < ? extends Callable < T > > tasks , final long timeout , final TimeUnit unit ) throws InterruptedException { throw new UnsupportedOperationException ( ) ; } 
public < T > T invokeAny ( final Collection < ? extends Callable < T > > tasks ) throws InterruptedException , ExecutionException { throw new UnsupportedOperationException ( ) ; } 
public < T > T invokeAny ( final Collection < ? extends Callable < T > > tasks , final long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { throw new UnsupportedOperationException ( ) ; } 
public List < Runnable > shutdownNow ( ) { shutdown ( ) ; return null ; } 
public < T > Future < T > submit ( final Callable < T > task ) { try { return new SimpleFuture < T > ( task . call ( ) ) ; 
public Future < ? > submit ( final Runnable task ) { try { task . run ( ) ; 
public < T > Future < T > submit ( final Runnable task , final T result ) { try { task . run ( ) ; 
public void execute ( final Runnable command ) { command . run ( ) ; } 
public boolean cancel ( final boolean mayInterruptIfRunning ) { return true ; } 
public T get ( ) throws InterruptedException , ExecutionException { if ( _e ! = null ) { throw _e ; } return _result ; } 
public T get ( final long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( _e ! = null ) { throw _e ; } return _result ; } 
public BackupResultStatus call ( ) throws Exception { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + _session . getId ( ) ) ; } _session . setBackupRunning ( true ) ; try { 
BackupResult doBackupSession ( final MemcachedBackupSession session , final byte [ ] data , final byte [ ] attributesData ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { 
public void stop ( ) throws LifecycleException { if ( initialized ) { try { 
public Future < BackupResultStatus > backupSession ( final MemcachedBackupSession session , final boolean sessionRelocationRequired ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + session . getId ( ) ) ; } final long start = System . currentTimeMillis ( ) ; try { 
public Future < BackupResultStatus > backupSession ( final Session session , final boolean sessionRelocationRequired ) { return _backupSessionService . backupSession ( ( MemcachedBackupSession ) session , sessionRelocationRequired ) ; 
String changeSessionIdIfRelocationRequired ( final String requestedSessionId ) ; SKIPPED } } } 
Future < BackupResultStatus > backupSession ( Session session , boolean sessionRelocationRequired ) ; SKIPPED } } } 
public void testOnlySendModifiedSessions ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . backupSession ( session , false ) . get ( ) ; verify ( _memcachedMock , times ( 2 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; 
public void testOnlyHashAttributesOfAccessedAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . endAccess ( ) ; _manager . backupSession ( session , false ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . getAttribute ( " foo " ) ; _manager . backupSession ( session , false ) . get ( ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; _manager . backupSession ( session , false ) . get ( ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; manager . setMaxInactiveInterval ( 5 ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) Thread.sleep( 2500 ); final String newSessionId = manager.changeSessionIdIfRelocationRequired( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; final String sessionId = " foo " ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdIfRelocationRequired " ) . with ( eq ( sessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( false ) ) . will ( returnValue ( new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdIfRelocationRequired " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " setRequestedSessionId " ) . with ( eq ( newSessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " isRequestedSessionIdFromCookie " ) . will ( returnValue ( true ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getContext " ) . will ( returnValue ( new StandardContext ( ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " isSecure " ) . will ( returnValue ( false ) ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( newSessionId ) ) ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( true ) ) . will ( returnValue ( new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public void testReconfigureMemcachedNodesAtRuntimeFeature46 ( ) throws Exception { final Response response2 = get ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( response2 . getSessionId ( ) , sessionId1 ) ; final String sessionId2 = response2 . getResponseSessionId ( ) ; assertNotNull ( sessionId2 ) ; assertEquals ( extractNodeId ( sessionId2 ) , _nodeId3 ) ; 
private boolean updateIsNodeAvailable ( final K key ) { final Boolean result = Boolean . valueOf ( _cacheLoader . isNodeAvailable ( key ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " CacheLoader returned node availability ' " + result + " ' for node ' " + key + " '. " ) ; } _map . put ( key , new ManagedItem < Boolean > ( result , System . currentTimeMillis ( ) ) ) ; return result ; } 
public String createSessionId ( final String sessionId , final String memcachedId ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Creating new session id with orig id ' " + sessionId + " ' and memcached id ' " + memcachedId + " '. " ) ; } if ( memcachedId = = null ) { return sessionId ; } final int idx = sessionId . indexOf ( '.' ) ; if ( idx < 0 ) { return sessionId + " - " + memcachedId ; 
static AddCookieInteralStrategy createFor ( final Context context ) { try { final Method getUseHttpOnly = Context . class . getMethod ( " getUseHttpOnly " ) ; 
private static AddCookieInteralStrategy createUseHttpOnlyStrategy ( final Method getUseHttpOnly , final Context context ) { try { final boolean useHttpOnly = ( ( Boolean ) getUseHttpOnly . invoke ( context ) ) . booleanValue ( ) ; 
abstract void addCookieInternal ( Cookie newCookie , Response response ) ; @Override void addCookieInternal ( final Cookie newCookie , final Response response ) { response . addCookieInternal ( newCookie , _useHttpOnly ) ; } } } 
void addCookieInternal ( final Cookie newCookie , final Response response ) { response . addCookieInternal ( newCookie ) ; } 
void addCookieInternal ( final Cookie newCookie , final Response response ) { response . addCookieInternal ( newCookie , _useHttpOnly ) ; } 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
protected Session loadFromMemcached ( final String sessionId ) { if ( ! _sessionIdFormat . isValid ( sessionId ) ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } try { final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; if ( _log . isDebugEnabled ( ) ) { if ( object = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object instanceof MemcachedBackupSession ) { _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; return ( Session ) object ; } else { final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; if ( object ! = null ) { _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; } return result ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
public void setUp ( ) throws Exception { _sessionBackupServiceControl = mock ( SessionBackupService . class ) ; _service = ( SessionBackupService ) _sessionBackupServiceControl . proxy ( ) ; _sessionTrackerValve = new SessionTrackerValve ( null , new StandardContext ( ) , _service , Statistics . create ( ) ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( ( Valve ) _nextValve . proxy ( ) ) ; _requestControl = mock ( Request . class ) ; _request = ( Request ) _requestControl . proxy ( ) ; _responseControl = mock ( Response . class ) ; _response = ( Response ) _responseControl . proxy ( ) ; } 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdIfRelocationRequired " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " setRequestedSessionId " ) . with ( eq ( newSessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " isRequestedSessionIdFromCookie " ) . will ( returnValue ( true ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getContext " ) . will ( returnValue ( new StandardContext ( ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " isSecure " ) . will ( returnValue ( false ) ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( newSessionId ) ) ) , eq ( false ) ) ; default value in StandardContext.useHttpOnly _nextValve.expects( once() ).method( "invoke" ); _requestControl.expects( once() ).method( "getSessionInternal" ).with( eq( false ) ) .will( returnValue( session ) ); _sessionBackupServiceControl.expects( once() ).method( "backupSession" ).with( eq( session ), eq( true ) ) .will( returnValue( new SimpleFuture<BackupResultStatus>( BackupResultStatus.SUCCESS ) ) ); _sessionTrackerValve.invoke( _request, _response ); 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { LOG . info ( " + starting... " ) ; final HttpSession session = request . getSession ( ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + session . getId ( ) ) ; final HttpSession session = request.getSession( false ); if ( session != null ) { final Enumeration<?> attributeNames = session.getAttributeNames(); while ( attributeNames.hasMoreElements() ) { final String name = attributeNames.nextElement().toString(); final Object value = session.getAttribute( name ); out.println( name + "=" + value ); } } LOG.info( " - finished." ); 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setSessionBackupAsync( false ); sessionManager.setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( InetAddress.getLocalHost(), port, false ); catalina.addConnector( connector ); return catalina; } 
public void testSerializationOfAuthStuffWithFormAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; 
public void testSerializationOfAuthStuffWithBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; 
private Map < Object , Object > newInstanceFromPublicConstructor ( final Class < Map < Object , Object > > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { try { Constructor < ? > [ ] constructors = cls . getConstructors ( ) ; for ( Constructor < ? > constructor : constructors ) { Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length = = 0 ) { return ( Map < Object , Object > ) constructor . newInstance ( ) ; } else if ( parameterTypes . length = = 1 & & parameterTypes [ 0 ] = = int . class ) { return ( Map < Object , Object > ) constructor . newInstance ( xml . getAttribute ( " size " ) . toInt ( ) ) ; } } if ( LOG . isDebugEnabled ( ) & & constructors . length > 0 ) { LOG . debug ( " No suitable constructor found for map " + cls + " , available constructors: " + Arrays . asList ( constructors ) ) ; } } catch ( SecurityException e ) { ignore } catch ( IllegalArgumentException e ) { throw new XMLStreamException( e ); not expected } catch ( InstantiationException e ) { throw new XMLStreamException( e ); not expected } catch ( IllegalAccessException e ) { throw new XMLStreamException( e ); not expected } catch ( InvocationTargetException e ) { ignore - constructor threw exception LOG.info( "Tried to invoke int constructor on " + cls.getName() + ", this threw an exception.", e.getTargetException() ); } return null; } 
public void write ( final Map < Object , Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " size " , obj . size ( ) ) ; final Set < Entry < Object , Object > > entrySet = _copyForWrite ? new LinkedHashMap < Object , Object > ( obj ) . entrySet ( ) : obj . entrySet ( ) ; for ( final Map . Entry < Object , Object > entry : entrySet ) { xml . add ( entry . getKey ( ) , " k " ) ; 
public void testMapWithIntConstructorOnly ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final HashMapWithIntConstructorOnly map = new HashMapWithIntConstructorOnly ( 5 ) ; session . setAttribute ( " map " , map ) ; System . out . println ( new String ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; assertDeepEquals ( deserialized . get ( " map " ) , map ) ; 
private static < T > T newInstanceFromPublicConstructor ( final Class < T > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { try { Constructor < ? > [ ] constructors = cls . getConstructors ( ) ; for ( Constructor < ? > constructor : constructors ) { Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length = = 0 ) { return ( T ) constructor . newInstance ( ) ; } else if ( parameterTypes . length = = 1 & & parameterTypes [ 0 ] = = int . class ) { return ( T ) constructor . newInstance ( xml . getAttribute ( " size " ) . toInt ( ) ) ; } } if ( LOG . isDebugEnabled ( ) & & constructors . length > 0 ) { LOG . debug ( " No suitable constructor found for map " + cls + " , available constructors: " + Arrays . asList ( constructors ) ) ; } } catch ( SecurityException e ) { ignore } catch ( IllegalArgumentException e ) { throw new XMLStreamException( e ); not expected } catch ( InstantiationException e ) { throw new XMLStreamException( e ); not expected } catch ( IllegalAccessException e ) { throw new XMLStreamException( e ); not expected } catch ( InvocationTargetException e ) { ignore - constructor threw exception LOG.info( "Tried to invoke int constructor on " + cls.getName() + ", this threw an exception.", e.getTargetException() ); } return null; } 
public void write ( final Collection < Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( SIZE , obj . size ( ) ) ; for ( final Object item : _copyForWrite ? new ArrayList < Object > ( obj ) : obj ) { xml . add ( item ) ; 
public void write ( final Map < Object , Object > obj , final javolution . xml . XMLFormat . OutputElement xml ) throws XMLStreamException { xml . setAttribute ( SIZE , obj . size ( ) ) ; final Set < Entry < Object , Object > > entrySet = _copyForWrite ? new LinkedHashMap < Object , Object > ( obj ) . entrySet ( ) : obj . entrySet ( ) ; for ( final Map . Entry < Object , Object > entry : entrySet ) { xml . add ( entry . getKey ( ) , " k " ) ; 
private static < T > T newInstanceFromPublicConstructor ( final Class < T > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { try { final Constructor < ? > [ ] constructors = cls . getConstructors ( ) ; for ( final Constructor < ? > constructor : constructors ) { final Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length = = 0 ) { return ( T ) constructor . newInstance ( ) ; } else if ( parameterTypes . length = = 1 & & parameterTypes [ 0 ] = = int . class ) { return ( T ) constructor . newInstance ( xml . getAttribute ( SIZE ) . toInt ( ) ) ; } } if ( LOG . isDebugEnabled ( ) & & constructors . length > 0 ) { LOG . debug ( " No suitable constructor found for map " + cls + " , available constructors: " + Arrays . asList ( constructors ) ) ; } } catch ( final SecurityException e ) { ignore } catch ( final IllegalArgumentException e ) { throw new XMLStreamException( e ); not expected } catch ( final InstantiationException e ) { throw new XMLStreamException( e ); not expected } catch ( final IllegalAccessException e ) { throw new XMLStreamException( e ); not expected } catch ( final InvocationTargetException e ) { ignore - constructor threw exception LOG.info( "Tried to invoke int constructor on " + cls.getName() + ", this threw an exception.", e.getTargetException() ); } return null; } 
public StringBuilder newInstance ( final Class < StringBuilder > cls , final InputElement xml ) throws XMLStreamException { return new StringBuilder ( xml . getAttribute ( " val " ) ) ; } 
public void read ( final InputElement xml , final StringBuilder obj ) throws XMLStreamException { nothing todo } @Override public void write( final StringBuilder obj, final OutputElement xml ) throws XMLStreamException { xml.setAttribute( "val", obj.toString() ); } }; public static final XMLFormat<StringBuffer> STRING_BUFFER_FORMAT = new XMLFormat<StringBuffer>( StringBuffer.class ) { public StringBuffer newInstance( final Class<StringBuffer> cls, final InputElement xml ) throws XMLStreamException { return new StringBuffer( xml.getAttribute( "val" ) ); } @Override public void read( final InputElement xml, final StringBuffer obj ) throws XMLStreamException { nothing todo } @Override public void write( final StringBuffer obj, final OutputElement xml ) throws XMLStreamException { xml.setAttribute( "val", obj.toString() ); } };} 
public void write ( final StringBuilder obj , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " val " , obj . toString ( ) ) ; } 
public StringBuffer newInstance ( final Class < StringBuffer > cls , final InputElement xml ) throws XMLStreamException { return new StringBuffer ( xml . getAttribute ( " val " ) ) ; } 
public void read ( final InputElement xml , final StringBuffer obj ) throws XMLStreamException { nothing todo } @Override public void write( final StringBuffer obj, final OutputElement xml ) throws XMLStreamException { xml.setAttribute( "val", obj.toString() ); } };} 
public void write ( final StringBuffer obj , final OutputElement xml ) throws XMLStreamException { xml . setAttribute ( " val " , obj . toString ( ) ) ; } 
public void testStringBufferAndStringBuilderFormat ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " stringbuffer " , new StringBuffer ( " <string n&buffer/> " ) ) ; session . setAttribute ( " stringbuilder " , new StringBuilder ( " <string n&buffer/> " ) ) ; System . out . println ( new String ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; 
public void testMapWithIntConstructorOnly ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final HashMapWithIntConstructorOnly map = new HashMapWithIntConstructorOnly ( 5 ) ; session . setAttribute ( " map " , map ) ; System . out . println ( new String ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; assertDeepEquals ( deserialized . get ( " map " ) , map ) ; 
public void testCurrency ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final Currency orig = Currency . getInstance ( " EUR " ) ; session . setAttribute ( " currency1 " , orig ) ; session . setAttribute ( " currency2 " , orig ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; Check that the transient field defaultFractionDigits is initialized correctly (that was the bug) final Currency currency1 = (Currency) deserialized.get( "currency1" ); Assert.assertEquals( currency1.getCurrencyCode(), orig.getCurrencyCode() ); Assert.assertEquals( currency1.getDefaultFractionDigits(), orig.getDefaultFractionDigits() ); 
public void testXMLSerializableSupport ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; final String attributeName = " myxmlserializable " ; session . setAttribute ( attributeName , new MyXMLSerializable ( Runtime . getRuntime ( ) ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; final MyXMLSerializable myXMLSerializable = ( MyXMLSerializable ) deserialized . get ( attributeName ) ; Assert . assertNotNull ( myXMLSerializable . getRuntime ( ) , " Transient field runtime should be initialized by XMLFormat " + " used due to implementation of XMLSerializable. " ) ; 
public void testJavaUtilCollectionsUnmodifiable ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableList ( new ArrayList < String > ( Arrays . asList ( " foo " , " bar " ) ) ) ) ; final HashMap < String , String > m = new HashMap < String , String > ( ) ; m . put ( " foo " , " bar " ) ; session . setAttribute ( " unmodifiableList " , Collections . unmodifiableMap ( m ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testJavaUtilLists ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyList " , Collections . < String > emptyList ( ) ) ; session . setAttribute ( " arrayList " , new ArrayList < String > ( ) ) ; session . setAttribute ( " arraysAsList " , Arrays . asList ( " foo " , " bar " ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public void testJavaUtilCollectionsEmptyMap ( ) throws Exception { final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " emptyMap " , Collections . < String , String > emptyMap ( ) ) ; session . setAttribute ( " hashMap " , new HashMap < String , String > ( ) ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; } 
public < T > void testSharedObjectIdentity_CounterHolder ( ) throws Exception { final AtomicInteger sharedObject = new AtomicInteger ( 42 ) ; final CounterHolder holder1 = new CounterHolder ( sharedObject ) ; final CounterHolder holder2 = new CounterHolder ( sharedObject ) ; final CounterHolderArray holderHolder = new CounterHolderArray ( holder1 , holder2 ) ; final MemcachedBackupSession session = _manager . createEmptySession ( ) ; session . setValid ( true ) ; session . setAttribute ( " hh " , holderHolder ) ; final Map < String , Object > deserialized = _transcoder . deserializeAttributes ( _transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ) ; assertDeepEquals ( deserialized , session . getAttributesInternal ( ) ) ; final CounterHolderArray hhd = ( CounterHolderArray ) deserialized . get ( " hh " ) ; Assert . assertTrue ( hhd . holders [ 0 ] . item = = hhd . holders [ 1 ] . item ) ; 
private TranscoderFactory createTranscoderFactory ( ) throws InstantiationException , IllegalAccessException { log . info ( " Starting with transcoder factory " + _transcoderFactoryClass . getName ( ) ) ; final TranscoderFactory transcoderFactory = _transcoderFactoryClass . newInstance ( ) ; transcoderFactory . setCopyCollectionsForSerialization ( _copyCollectionsForSerialization ) ; if ( _customConverterClassNames ! = null ) { _log . info ( " Loading custom converter classes " + _customConverterClassNames ) ; transcoderFactory . setCustomConverterClassNames ( _customConverterClassNames . split ( " , \\ s* " ) ) ; } return transcoderFactory ; } 
public boolean canConvert ( final Class < ? > cls ) { return canSerialize ( cls ) | | canDeserialize ( cls ) ; } 
private boolean canDeserialize ( final Class < ? > cls ) { return cls = = CGLibProxyMarker . class ; } 
private boolean canSerialize ( final Class < ? > cls ) { return Enhancer . isEnhanced ( cls ) & & cls . getName ( ) . indexOf ( DEFAULT_NAMING_MARKER ) > 0 ; } 
public Object newInstance ( final Class < Object > cls , final InputElement xml ) throws XMLStreamException { final Class < ? > superclass ; try { superclass = Class . forName ( xml . getAttribute ( SUPERCLASS ) . toString ( ) ) ; } catch ( final ClassNotFoundException e ) { throw new XMLStreamException ( e ) ; } final ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; final Class < ? > [ ] interfaces = getInterfaces ( xml , INTERFACES , classLoader ) ; final Callback [ ] callbacks = xml . get ( CALLBACKS ) ; return createProxy ( superclass , interfaces , callbacks ) ; } 
private Object createProxy ( final Class < ? > targetClass , final Class < ? > [ ] interfaces , final Callback [ ] callbacks ) { final Enhancer e = new Enhancer ( ) ; e . setInterfaces ( interfaces ) ; e . setSuperclass ( targetClass ) ; e . setCallbacks ( callbacks ) ; return e . create ( ) ; } 
public void read ( final InputElement arg0 , final Object arg1 ) throws XMLStreamException { nothing to do... } @Override public void write( final Object obj, final OutputElement xml ) throws XMLStreamException { final Class<?> superclass = obj.getClass().getSuperclass(); xml.setAttribute( SUPERCLASS, superclass.getName() ); final String[] interfaceNames = getInterfaceNames( obj ); xml.add( interfaceNames, INTERFACES ); final Callback[] callbacks = ((Factory)obj).getCallbacks(); xml.add( callbacks, CALLBACKS ); }} 
public void write ( final Object obj , final OutputElement xml ) throws XMLStreamException { final Class < ? > superclass = obj . getClass ( ) . getSuperclass ( ) ; xml . setAttribute ( SUPERCLASS , superclass . getName ( ) ) ; final String [ ] interfaceNames = getInterfaceNames ( obj ) ; xml . add ( interfaceNames , INTERFACES ) ; final Callback [ ] callbacks = ( ( Factory ) obj ) . getCallbacks ( ) ; xml . add ( callbacks , CALLBACKS ) ; } 
protected void beforeTest ( ) { _binding = new ReflectionBinding ( getClass ( ) . getClassLoader ( ) , false , new CGLibProxyFormat ( ) ) ; } 
public void testCGLibProxy ( ) throws XMLStreamException { final ClassToProxy proxy = createProxy ( new ClassToProxy ( ) ) ; proxy . setValue ( " foo " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final ClassToProxy deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . getValue ( ) , proxy . getValue ( ) ) ; } 
public void testCGLibProxyForExistingFormat ( ) throws XMLStreamException { final Map < String , String > proxy = createProxy ( new HashMap < String , String > ( ) ) ; proxy . put ( " foo " , " bar " ) ; Assert . assertEquals ( proxy . get ( " foo " ) , " bar " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final Map < String , String > deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . get ( " foo " ) , proxy . get ( " foo " ) ) ; } 
public String getClassName ( final String prefix , final String source , final Object key , final Predicate names ) { return super . getClassName ( " MSM_ " + prefix , source , key , names ) ; } 
public Object invoke ( final Object obj , final Method method , final Object [ ] args ) throws Throwable { return method . invoke ( _delegate , args ) ; } 
public boolean canConvert ( final Class < ? > cls ) { return cls = = DateTime . class ; } 
protected MemcachedBackupSession deserialize ( final byte [ ] in ) { final MemcachedBackupSession result = doDeserialize ( in , " session " ) ; result . setManager ( _manager ) ; result . doAfterDeserialization ( ) ; return result ; } 
private < T > T doDeserialize ( final byte [ ] in , final String name ) { getLogger().info( "Loading serialized:" + new String( in ) ); XMLObjectReader reader = null; try { final ByteArrayInputStream bis = new ByteArrayInputStream( in ); 
private CustomXMLFormat < ? > [ ] loadCustomFormats ( final Manager manager ) { if ( _customConverterClassNames = = null | | _customConverterClassNames . length = = 0 ) { return null ; } final CustomXMLFormat < ? > [ ] customFormats = new CustomXMLFormat < ? > [ _customConverterClassNames . length ] ; final Loader loader = manager . getContainer ( ) . getLoader ( ) ; for ( int i = 0 ; i < _customConverterClassNames . length ; i + + ) { final String className = _customConverterClassNames [ i ] ; try { final CustomXMLFormat < ? > xmlFormat = Class . forName ( className , true , loader . getClassLoader ( ) ) . asSubclass ( CustomXMLFormat . class ) . newInstance ( ) ; customFormats [ i ] = xmlFormat ; } catch ( final Exception e ) { throw new RuntimeException ( " Could not load custom xml format " + className , e ) ; } } return customFormats ; } 
protected Class readClass ( final XMLStreamReader reader , final boolean useAttributes ) throws XMLStreamException { final CharArray className = useAttributes ? reader . getAttributeValue ( null , CLASS ) : reader . getLocalName ( ) ; try { return Class . forName ( className . toString ( ) , true , _classLoader ) ; 
private static < T > T newInstanceFromPublicConstructor ( final Class < T > cls , final javolution . xml . XMLFormat . InputElement xml ) throws XMLStreamException { try { final Constructor < ? > [ ] constructors = cls . getConstructors ( ) ; for ( final Constructor < ? > constructor : constructors ) { final Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length = = 0 ) { return ( T ) constructor . newInstance ( ) ; } else if ( parameterTypes . length = = 1 & & parameterTypes [ 0 ] = = int . class ) { final CharArray size = xml . getAttribute ( SIZE ) ; if ( size ! = null ) { return ( T ) constructor . newInstance ( size . toInt ( ) ) ; } } } if ( LOG . isDebugEnabled ( ) & & constructors . length > 0 ) { LOG . debug ( " No suitable constructor found for map " + cls + " , available constructors: " + Arrays . asList ( constructors ) ) ; } } catch ( final SecurityException e ) { ignore } catch ( final IllegalArgumentException e ) { throw new XMLStreamException( e ); not expected } catch ( final InstantiationException e ) { throw new XMLStreamException( e ); not expected } catch ( final IllegalAccessException e ) { throw new XMLStreamException( e ); not expected } catch ( final InvocationTargetException e ) { ignore - constructor threw exception LOG.info( "Tried to invoke int constructor on " + cls.getName() + ", this threw an exception.", e.getTargetException() ); } return null; } 
public Object newInstance ( final Class < Object > clazz , final javolution . xml . XMLFormat . InputElement input ) throws XMLStreamException { final InvocationHandler invocationHandler = input . get ( " handler " ) ; final Class < ? > [ ] interfaces = getInterfaces ( input , " interfaces " , _classLoader ) ; return Proxy . newProxyInstance ( _classLoader , interfaces , invocationHandler ) ; } 
public static Class < ? > [ ] getInterfaces ( final javolution . xml . XMLFormat . InputElement input , final String elementName , final ClassLoader classLoader ) throws XMLStreamException { final String [ ] interfaceNames = input . get ( elementName ) ; if ( interfaceNames ! = null ) { try { final Class < ? > [ ] interfaces = new Class < ? > [ interfaceNames . length ] ; for ( int i = 0 ; i < interfaceNames . length ; i + + ) { interfaces [ i ] = Class . forName ( interfaceNames [ i ] , true , classLoader ) ; } return interfaces ; } catch ( final ClassNotFoundException e ) { throw new XMLStreamException ( e ) ; } } return new Class < ? > [ 0 ] ; } 
public Future < BackupResultStatus > backupSession ( final MemcachedBackupSession session , final boolean sessionIdChanged ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + session . getId ( ) ) ; } final long start = System . currentTimeMillis ( ) ; try { 
private BackupSessionTask createBackupSessionTask ( final MemcachedBackupSession session , final boolean sessionIdChanged ) { return new BackupSessionTask ( session , sessionIdChanged , 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
public Session findSession ( final String id ) throws IOException { Session result = super . findSession ( id ) ; if ( result = = null ) { result = loadFromMemcached ( id ) ; if ( result ! = null ) { add ( result ) ; } } if ( result == null ) { final String relocatedSessionId = _relocatedSessions.get( id ); if ( relocatedSessionId != null ) { result = findSession( relocatedSessionId ); } } return result; } 
public Session createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; Session session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; if ( session ! = null ) { add ( session ) ; } } if ( session = = null ) { session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( this . maxInactiveInterval ) ; if ( sessionId = = null | | ! isNodeAvailableForSessionId ( sessionId ) ) { sessionId = generateSessionId ( ) ; } session . setId ( sessionId ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Created new session with id " + session . getId ( ) ) ; } } sessionCounter + + ; return session ; 
private void checkMaxActiveSessions ( ) { if ( _maxActiveSessions > = 0 & & sessions . size ( ) > = _maxActiveSessions ) { _rejectedSessions + + ; 
public String changeSessionIdOnTomcatFailover ( final String requestedSessionId ) { final String localJvmRoute = getJvmRoute ( ) ; if ( localJvmRoute ! = null & & ! localJvmRoute . equals ( _sessionIdFormat . extractJvmRoute ( requestedSessionId ) ) ) { final MemcachedBackupSession session = loadFromMemcached ( requestedSessionId ) ; if ( session ! = null ) { checking valid() can expire() the session! if ( session.isValid() ) { return handleSessionTakeOver( session ); } } } return null; } 
private String handleSessionTakeOver ( final MemcachedBackupSession session ) { checkMaxActiveSessions ( ) ; final String origSessionId = session . getIdInternal ( ) ; final String newSessionId = _sessionIdFormat . changeJvmRoute ( session . getIdInternal ( ) , getJvmRoute ( ) ) ; session . setIdInternal ( newSessionId ) ; add ( session ) ; deleteFromMemcached ( origSessionId ) ; _statistics . requestWithTomcatFailover ( ) ; return newSessionId ; 
private void deleteFromMemcached ( final String sessionId ) { _log . debug ( " Deleting session from memcached: " + sessionId ) ; try { _memcached . delete ( sessionId ) ; 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { final MemcachedBackupSession session = ( MemcachedBackupSession ) super . findSession ( requestedSessionId ) ; if ( session ! = null & & session . isValid ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ; final String newNodeId = getNewNodeIdIfUnavailable ( nodeId ) ; if ( newNodeId ! = null ) { final String newSessionId = _sessionIdFormat . createNewSessionId ( session . getId ( ) , newNodeId ) ; _log . debug ( " Session needs to be relocated, setting new id on session... " ) ; session . setIdForRelocate ( newSessionId ) ; _statistics . requestWithMemcachedFailover ( ) ; return newSessionId ; } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
public Future < BackupResultStatus > backupSession ( final Session session , final boolean sessionIdChanged ) { return _backupSessionService . backupSession ( ( MemcachedBackupSession ) session , sessionIdChanged ) ; 
protected MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( ! _sessionIdFormat . isValid ( sessionId ) | | _missingSessionsCache . get ( sessionId ) ! = null ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } try { final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; if ( _log . isDebugEnabled ( ) ) { if ( object = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { final MemcachedBackupSession result ; if ( object instanceof MemcachedBackupSession ) { result = ( MemcachedBackupSession ) object ; } else { result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; } _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
public String changeJvmRoute ( final String sessionId , final String newJvmRoute ) { return stripJvmRoute ( sessionId ) + " . " + newJvmRoute ; } 
public String extractJvmRoute ( final String sessionId ) { final int idxDot = sessionId . indexOf ( '.' ) ; return idxDot < 0 ? null : sessionId . substring ( idxDot + 1 ) ; } 
public String stripJvmRoute ( final String sessionId ) { final int idxDot = sessionId . indexOf ( '.' ) ; return idxDot < 0 ? sessionId : sessionId . substring ( 0 , idxDot ) ; } 
private void backupSession ( final Request request , final Response response , final boolean sessionIdChanged ) { final Session session = request . getRequestedSessionId ( ) ! = null | | getCookie ( response , JSESSIONID ) ! = null ? request . getSessionInternal ( false ) : null ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Have a session: " + ( session ! = null ) ) ; } if ( session ! = null ) { 
String changeSessionIdOnTomcatFailover ( final String requestedSessionId ) ; SKIPPED } } } 
String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) ; SKIPPED } } } 
Future < BackupResultStatus > backupSession ( Session session , boolean sessionIdChanged ) ; SKIPPED } } } 
public void requestWithTomcatFailover ( ) { _numRequestsWithTomcatFailover . incrementAndGet ( ) ; } 
public void requestWithMemcachedFailover ( ) { _numRequestsWithMemcachedFailover . incrementAndGet ( ) ; } 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; manager . setMaxInactiveInterval ( 5 ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) Thread.sleep( 2500 ); final String newSessionId = manager.changeSessionIdOnMemcachedFailover( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; final String sessionId = " foo " ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( false ) ) . will ( returnValue ( new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " setRequestedSessionId " ) . with ( eq ( newSessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " isRequestedSessionIdFromCookie " ) . will ( returnValue ( true ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getContext " ) . will ( returnValue ( new StandardContext ( ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " isSecure " ) . will ( returnValue ( false ) ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( SessionTrackerValve . JSESSIONID ) ) , hasProperty ( " value " , eq ( newSessionId ) ) ) , eq ( false ) ) ; default value in StandardContext.useHttpOnly _nextValve.expects( once() ).method( "invoke" ); _requestControl.expects( once() ).method( "getSessionInternal" ).with( eq( false ) ) .will( returnValue( session ) ); _sessionBackupServiceControl.expects( once() ).method( "backupSession" ).with( eq( session ), eq( true ) ) .will( returnValue( new SimpleFuture<BackupResultStatus>( BackupResultStatus.SUCCESS ) ) ); _sessionTrackerValve.invoke( _request, _response ); 
public void setUp ( ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( NODE_ID , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , jvmRoute , null ) ; } 
private Embedded startTomcat ( final int port , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; return tomcat ; } 
public void testTomcatFailover ( ) throws IOException , InterruptedException , HttpException { final SessionIdFormat format = new SessionIdFormat ( ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final Object session = _client . get ( sessionId1 ) ; assertNotNull ( session , " Session not found in memcached: " + sessionId1 ) ; final Response response = get ( _httpClient , TC_PORT_2 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; assertNull ( _client . get ( sessionId1 ) ) ; assertNotNull ( _client . get ( sessionId2 ) ) ; assertEquals ( format . stripJvmRoute ( sessionId1 ) , format . stripJvmRoute ( sessionId2 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; Thread . sleep ( 10 ) ; 
public void testLoadedSessionOnlySentIfModified ( ) throws IOException , InterruptedException , HttpException { post ( _httpClient , TC_PORT_2 , sessionId1 , " bar " , " baz " ) ; assertEquals ( 3 , _daemon . getCache ( ) . getSetCmds ( ) ) ; Thread . sleep ( 10 ) ; 
public void testSerializationOfAuthStuffWithFormAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; 
public void testSerializationOfAuthStuffWithBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; 
private MemcachedClient createMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { try { final ConnectionFactory connectionFactory = createConnectionFactory ( address2Ids , statistics ) ; 
private ConnectionFactory createConnectionFactory ( final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { final MapBasedResolver resolver = new MapBasedResolver ( address2Ids ) ; if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { return new SuffixLocatorBinaryConnectionFactory ( resolver , _sessionIdFormat , statistics ) ; } return new SuffixLocatorConnectionFactory ( resolver , _sessionIdFormat , statistics ) ; } 
public MemcachedNode createMemcachedNode ( final SocketAddress sa , final SocketChannel c , final int bufSize ) { return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , 
public Session findSession ( final String id ) throws IOException { StandardSession result = ( StandardSession ) super . findSession ( id ) ; if ( result = = null ) { result = loadFromMemcached ( id ) ; checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { addValidLoadedSession( result ); } } if ( result == null ) { final String relocatedSessionId = _relocatedSessions.get( id ); if ( relocatedSessionId != null ) { result = findSession( relocatedSessionId ); } } return result; } 
private void addValidLoadedSession ( final StandardSession session ) { make sure the listeners know about it. (as done by PersistentManagerBase) session.tellNew(); add( session ); session.activate(); endAccess() to ensure timeouts happen correctly. access() to keep access count correct or it will end up negative session.access(); session.endAccess(); } 
public Session createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; StandardSession session = null ; if ( sessionId ! = null ) { session = loadFromMemcached ( sessionId ) ; checking valid() would expire() the session if it's not valid! if ( session != null && session.isValid() ) { addValidLoadedSession( session ); } } if ( session == null ) { session = createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( this.maxInactiveInterval ); if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) { sessionId = generateSessionId(); } session.setId( sessionId ); if ( _log.isDebugEnabled() ) { _log.debug( "Created new session with id " + session.getId() ); } } sessionCounter++; return session; 
public String changeSessionIdOnTomcatFailover ( final String requestedSessionId ) { final String localJvmRoute = getJvmRoute ( ) ; if ( localJvmRoute ! = null & & ! localJvmRoute . equals ( _sessionIdFormat . extractJvmRoute ( requestedSessionId ) ) ) { final MemcachedBackupSession session = loadFromMemcached ( requestedSessionId ) ; checking valid() can expire() the session! if ( session != null && session.isValid() ) { return handleSessionTakeOver( session ); } } return null; } 
private String handleSessionTakeOver ( final MemcachedBackupSession session ) { checkMaxActiveSessions ( ) ; final String origSessionId = session . getIdInternal ( ) ; final String newSessionId = _sessionIdFormat . changeJvmRoute ( session . getIdInternal ( ) , getJvmRoute ( ) ) ; session . setIdInternal ( newSessionId ) ; addValidLoadedSession ( session ) ; deleteFromMemcached ( origSessionId ) ; _statistics . requestWithTomcatFailover ( ) ; return newSessionId ; 
public void sessionDidActivate ( final HttpSessionEvent se ) { _sessionDidActivate = se . getSession ( ) . getId ( ) ; } 
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { final MemcachedBackupSessionManager manager1 = getManager ( _tomcat1 ) ; final MemcachedBackupSessionManager manager2 = getManager ( _tomcat2 ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( format . stripJvmRoute ( sessionId2 ) , format . stripJvmRoute ( sessionId1 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public void testHttpSessionActivationListenersNotifiedOnLoadWithoutJvmRoute ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , null ) ; _tomcat2 = startTomcat ( TC_PORT_2 , null ) ; final MemcachedBackupSessionManager manager1 = getManager ( _tomcat1 ) ; final MemcachedBackupSessionManager manager2 = getManager ( _tomcat2 ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNull ( format . extractJvmRoute ( sessionId1 ) ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public Map < String , Object > deserializeAttributes ( final byte [ ] in ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Reading serialized data: " + new String ( in ) ) ; } return doDeserialize ( in , " attributes " ) ; } 
public static void main ( String [ ] args ) throws InterruptedException { Thread.sleep( 1000 ); MemcachedBackupSessionManager manager = createManager(); benchmark( manager, new JavaSerializationTranscoder() ); recover(); benchmark( manager, new JavolutionTranscoder( Thread.currentThread().getContextClassLoader(), false ) ); recover(); benchmark( manager, new KryoTranscoder() ); Thread.sleep( Integer.MAX_VALUE ); } 
private static void recover ( ) throws InterruptedException { Thread . sleep ( 200 ) ; System . gc ( ) ; Thread . sleep ( 200 ) ; } 
private static void benchmark ( MemcachedBackupSessionManager manager , SessionAttributesTranscoder transcoder ) { TranscoderService transcoderService = new TranscoderService ( transcoder ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789abcdefghijk987654321 " ) ; long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { transcoderService . serialize ( createSession ( manager , " 123456789abcdefghijk987654321 " ) ) ; } System . out . println ( " -- " + transcoder . getClass ( ) . getSimpleName ( ) + " -- " ) ; System . out . println ( " Serializing " + 1000 + " sessions took " + ( System . currentTimeMillis ( ) - start ) + " msec. " + " nserialized size is " + transcoderService . serialize ( session ) . length + " bytes. " ) ; 
private static MemcachedBackupSession createSession ( MemcachedBackupSessionManager manager , String id ) { final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; session . setAttribute ( " stringbuffer " , new StringBuffer ( " <string n&buffer/> " ) ) ; session . setAttribute ( " stringbuilder " , new StringBuilder ( " <string n&buffer/> " ) ) ; session . setAttribute ( " persons " , createPersons ( 100 ) ) ; session . setAttribute ( " mycontainer " , new TestClasses . MyContainer ( ) ) ; session . setAttribute ( " component " , new Component ( " root " ) . addChild ( new Component ( " child1 " ) . addChild ( new Component ( " child1-1 " ) ) . addChild ( new Component ( " child1-2 " ) ) ) . addChild ( new Component ( " child2 " ) . addChild ( new Component ( " child2-1 " ) ) . addChild ( new Component ( " child2-2 " ) ) ) ) ; return session ; } 
private static Person [ ] createPersons ( final int countPersons ) { Person [ ] persons = new Person [ countPersons ] ; for ( int i = 0 ; i < countPersons ; i + + ) { final Calendar dateOfBirth = Calendar . getInstance ( ) ; dateOfBirth . set ( Calendar . YEAR , dateOfBirth . get ( Calendar . YEAR ) - 42 ) ; Person person = TestClasses . createPerson ( " Firstname " + i + " Lastname " + i , i % 2 = = 0 ? Gender . FEMALE : Gender . MALE , dateOfBirth , " email " + i + " -1@example.org " , " email " + i + " -2@example.org " , " email " + i + " -3@example.org " ) ; person . addAddress ( new Address ( " route66 " , " 123456 " , " sincity " , " sincountry " ) ) ; if ( i > 0 ) { person . addFriend ( persons [ i - 1 ] ) ; } persons [ i ] = person ; } return persons ; } 
static Person createPerson ( final String name , final Gender gender , final String . . . emailAddresses ) { return createPerson ( name , gender , ( Integer ) null , emailAddresses ) ; } 
static Person createPerson ( final String name , final Gender gender , final Calendar dateOfBirth , final String . . . emailAddresses ) { int age = Calendar . getInstance ( ) . get ( Calendar . YEAR ) - dateOfBirth . get ( Calendar . YEAR ) ; Person result = createPerson ( name , gender , age , emailAddresses ) ; result . setDateOfBirth ( dateOfBirth ) ; return result ; } 
public void addAddress ( final Address a ) { _addresses . add ( a ) ; } 
public Component addChild ( Component child ) { child . setParent ( this ) ; _children . add ( child ) ; return this ; } 
public String toString ( ) { return " Component [_children= " + _children + " , _name= " + _name + " , _parent= " + _parent + " ] " ; } 
private TranscoderFactory createTranscoderFactory ( ) throws InstantiationException , IllegalAccessException , ClassNotFoundException { log . info ( " Starting with transcoder factory " + _transcoderFactoryClassName ) ; final ClassLoader classLoader = getContainer ( ) . getLoader ( ) . getClassLoader ( ) ; final Class < ? extends TranscoderFactory > transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , classLoader ) . asSubclass ( TranscoderFactory . class ) ; final TranscoderFactory transcoderFactory = transcoderFactoryClass . newInstance ( ) ; transcoderFactory . setCopyCollectionsForSerialization ( _copyCollectionsForSerialization ) ; if ( _customConverterClassNames ! = null ) { _log . info ( " Found configured custom converter classes, setting on transcoder factory: " + _customConverterClassNames ) ; transcoderFactory . setCustomConverterClassNames ( _customConverterClassNames . split ( " , \\ s* " ) ) ; } return transcoderFactory ; } 
public Serializer newSerializer ( final Class < ? > type ) { if ( CGLibProxySerializer . canSerialize ( type ) ) { return new CGLibProxySerializer ( _kryo ) ; } return null ; } 
public void customize ( final Kryo kryo ) { kryo . register ( CGLibProxySerializer . CGLibProxyMarker . class , new CGLibProxySerializer ( kryo ) ) ; } 
public void customize ( final Kryo kryo ) { kryo . register ( DateTime . class , new JodaDateTimeSerializer ( ) ) ; } 
private Pair < Kryo , SerializerFactory [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Pair<KryoCustomization[], SerializerFactory[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Pair.create( kryo, pair.b ); } 
public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } 
private Serializer loadCustomSerializer ( final Class < ? > clazz ) { if ( _serializerFactories ! = null ) { for ( int i = 0 ; i < _serializerFactories . length ; i + + ) { final Serializer serializer = _serializerFactories [ i ] . newSerializer ( clazz ) ; if ( serializer ! = null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading custom serializer " + serializer . getClass ( ) . getName ( ) + " for class " + clazz ) ; } return serializer ; } } } return null ; } 
private Serializer loadCopyCollectionSerializer ( final Class < ? > clazz ) { if ( Collection . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateCollectionSerializer for class " + clazz ) ; } return new CopyForIterateCollectionSerializer ( _kryo ) ; } if ( Map . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateMapSerializer for class " + clazz ) ; } return new CopyForIterateMapSerializer ( _kryo ) ; } return null ; } 
public Map < String , Object > deserializeAttributes ( final byte [ ] data ) { return new ObjectBuffer ( _kryo ) . readObject ( data , ConcurrentHashMap . class ) ; } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { return new ObjectBuffer ( _kryo , 50 * 1024 , 1000 * 1024 ) . writeObject ( attributes ) ; } 
protected MemcachedBackupSession deserialize ( final byte [ ] in ) { throw new UnsupportedOperationException ( " Session deserialization not implemented. " ) ; } 
private Pair < KryoCustomization [ ] , SerializerFactory [ ] > loadCustomConverter ( final String [ ] customConverterClassNames , final ClassLoader classLoader , final Kryo kryo ) { if ( customConverterClassNames = = null | | customConverterClassNames . length = = 0 ) { return Pair . empty ( ) ; } final List < KryoCustomization > customizations = new ArrayList < KryoCustomization > ( ) ; final List < SerializerFactory > serializerFactories = new ArrayList < SerializerFactory > ( ) ; final ClassLoader loader = classLoader ! = null ? classLoader : Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( int i = 0 ; i < customConverterClassNames . length ; i + + ) { final String element = customConverterClassNames [ i ] ; try { processElement ( element , customizations , serializerFactories , kryo , loader ) ; } catch ( final Exception e ) { LOG . error ( " Could not instantiate " + element + " , omitting this KryoCustomization/SerializerFactory. " , e ) ; throw new RuntimeException ( " Could not load serializer " + element , e ) ; } } final KryoCustomization [ ] customizationsArray = customizations . toArray ( new KryoCustomization [ customizations . size ( ) ] ) ; final SerializerFactory [ ] serializerFactoriesArray = serializerFactories . toArray ( new SerializerFactory [ serializerFactories . size ( ) ] ) ; return Pair . create ( customizationsArray , serializerFactoriesArray ) ; } 
private void processElement ( final String element , final List < KryoCustomization > customizations , final List < SerializerFactory > serializerFactories , final Kryo kryo , final ClassLoader loader ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { final Class < ? > clazz = Class . forName ( element , true , loader ) ; if ( KryoCustomization . class . isAssignableFrom ( clazz ) ) { LOG . info ( " Loading KryoCustomization " + element ) ; 
private static < T > T createInstance ( final Class < ? extends T > clazz , final Kryo kryo ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException { try { final Constructor < ? extends T > constructor = clazz . getConstructor ( Kryo . class ) ; 
public static < A , B > Pair < A , B > create ( final A a , final B b ) { return new Pair < A , B > ( a , b ) ; } 
public static < A , B > Pair < A , B > empty ( ) { return ( Pair < A , B > ) EMPTY ; } 
public void customize ( final Kryo kryo ) { kryo . register ( MiniMap . class , new MiniMapSerializer ( kryo ) ) ; } 
private Pair < Kryo , SerializerFactory [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Pair<KryoCustomization[], SerializerFactory[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Pair.create( kryo, pair.b ); } 
public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { return new ObjectBuffer ( _kryo , _initialBufferSize , _maxBufferSize ) . writeObject ( attributes ) ; } 
public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; } 
public void insertOp ( final Operation arg0 ) { throw new UnsupportedOperationException ( ) ; } 
public void setupForAuth ( ) { throw new UnsupportedOperationException ( ) ; } 
public MemcachedNode createMemcachedNode ( final SocketAddress sa , final SocketChannel c , final int bufSize ) { final boolean doAuth = false ; return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , 
private Pair < Kryo , SerializerFactory [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Pair<KryoCustomization[], SerializerFactory[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Pair.create( kryo, pair.b ); } 
public Serializer newSerializer ( final Class < ? > type ) { final Serializer serializer = _childListSerializerFactory . newSerializer ( type ) ; if ( serializer ! = null ) { return serializer ; } return null ; } 
public void customize ( final Kryo kryo ) { new WicketMiniMapRegistration ( ) . customize ( kryo ) ; } 
protected MemcachedClient createMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { return null ; } 
protected NodeAvailabilityCache < String > createNodeAvailabilityCache ( final int size , final long ttlInMillis , final MemcachedClient memcachedClient ) { return new NodeAvailabilityCache < String > ( size , ttlInMillis , new CacheLoader < String > ( ) { @Override 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResultStatus> backupSession( final Session session, final boolean sessionIdChanged ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesInternal() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.getAttributesSerializationProbe().registerSince( startSerialization ); _statistics.getCachedDataSizeProbe().register( data.length ); return new SimpleFuture<BackupResultStatus>( BackupResultStatus.SUCCESS ); } @Override public Session findSession( final String id ) throws IOException { final Session result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _log.info( "Deserializing session data for session " + id ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _statistics.getLoadFromMemcachedProbe().registerSince( startDeserialization ); } } return result; } protected MemcachedBackupSession loadFromMemcached( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { }} 
public Future < BackupResultStatus > backupSession ( final Session session , final boolean sessionIdChanged ) { _log . info ( " Serializing session data for session " + session . getIdInternal ( ) ) ; final long startSerialization = System . currentTimeMillis ( ) ; final byte [ ] data = _transcoderService . serializeAttributes ( ( MemcachedBackupSession ) session , ( ( MemcachedBackupSession ) session ) . getAttributesInternal ( ) ) ; _log . info ( String . format ( " Serializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) data . length / 1000 , session . getIdInternal ( ) , System . currentTimeMillis ( ) - startSerialization ) ) ; _sessionData . put ( session . getIdInternal ( ) , data ) ; _statistics . getAttributesSerializationProbe ( ) . registerSince ( startSerialization ) ; _statistics . getCachedDataSizeProbe ( ) . register ( data . length ) ; return new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ; } 
public Session findSession ( final String id ) throws IOException { final Session result = super . findSession ( id ) ; if ( result ! = null ) { final byte [ ] data = _sessionData . remove ( id ) ; if ( data ! = null ) { _log . info ( " Deserializing session data for session " + id ) ; final long startDeserialization = System . currentTimeMillis ( ) ; try { _transcoderService . deserializeAttributes ( data ) ; } catch ( final Exception e ) { _log . warn ( " Could not deserialize session data. " , e ) ; } _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( startDeserialization ) ; } } return result ; } 
protected MemcachedBackupSession loadFromMemcached ( final String sessionId ) { return null ; } 
protected MemcachedClient createMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { try { final ConnectionFactory connectionFactory = createConnectionFactory ( address2Ids , statistics ) ; 
protected NodeAvailabilityCache < String > createNodeAvailabilityCache ( final int size , final long ttlInMillis , final MemcachedClient memcachedClient ) { return new NodeAvailabilityCache < String > ( size , ttlInMillis , new CacheLoader < String > ( ) { 
public void expireSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " expireSession invoked: " + sessionId ) ; } super . expireSession ( sessionId ) ; deleteFromMemcached ( sessionId ) ; } 
protected void deleteFromMemcached ( final String sessionId ) { if ( _sessionIdFormat . isValid ( sessionId ) ) { if ( _log . isDebugEnabled ( ) ) { 
public Future < BackupResultStatus > backupSession ( final Session session , final boolean sessionIdChanged ) { return _backupSessionService . backupSession ( ( MemcachedBackupSession ) session , sessionIdChanged ) ; } 
private MemcachedConfig reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( _memcached ! = null ) { _memcached . shutdown ( ) ; } _memcached = memcachedClient ; _nodeIdService = nodeIdService ; _backupSessionService = backupSessionService ; return config ; } 
protected void updateExpirationInMemcached ( ) { final Session [ ] sessions = findSessions ( ) ; final int delay = getContainer ( ) . getBackgroundProcessorDelay ( ) ; for ( final Session s : sessions ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) s ; 
public Serializer newSerializer ( final Class < ? > type ) { if ( Component . class . isAssignableFrom ( type ) ) { return new ReferenceFieldSerializerReflectionFactorySupport ( _kryo , type ) ; } return null ; } 
public Serializer newSerializer ( final Class < ? > type ) { Serializer serializer ; if ( ( serializer = _childListSerializerFactory . newSerializer ( type ) ) ! = null ) { return serializer ; } if ( ( serializer = _componentSerializerFactory . newSerializer ( type ) ) ! = null ) { return serializer ; } return null ; } 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResultStatus> backupSession( final Session session, final boolean sessionIdChanged ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesInternal() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.getAttributesSerializationProbe().registerSince( startSerialization ); _statistics.getCachedDataSizeProbe().register( data.length ); return new SimpleFuture<BackupResultStatus>( BackupResultStatus.SUCCESS ); } @Override public Session findSession( final String id ) throws IOException { final Session result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } protected MemcachedBackupSession loadFromMemcached( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.getLoadFromMemcachedProbe().registerSince( startDeserialization ); return null; } }} 
public Session findSession ( final String id ) throws IOException { final Session result = super . findSession ( id ) ; if ( result ! = null ) { final byte [ ] data = _sessionData . remove ( id ) ; if ( data ! = null ) { _executorService . submit ( new SessionDeserialization ( id , data ) ) ; } } return result ; } 
protected void updateExpirationInMemcached ( ) { } private final class SessionDeserialization implements Callable < Void > { private final String _id ; private final byte [ ] _data ; private SessionDeserialization ( final String id , final byte [ ] data ) { _id = id ; _data = data ; } @Override public Void call ( ) throws Exception { _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s (asynchronously). " , ( double ) _data . length / 1000 , _id ) ) ; final long startDeserialization = System . currentTimeMillis ( ) ; try { _transcoderService . deserializeAttributes ( _data ) ; } catch ( final Exception e ) { _log . warn ( " Could not deserialize session data. " , e ) ; } _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) _data . length / 1000 , _id , System . currentTimeMillis ( ) - startDeserialization ) ) ; _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( startDeserialization ) ; return null ; } } } 
public Void call ( ) throws Exception { _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s (asynchronously). " , ( double ) _data . length / 1000 , _id ) ) ; final long startDeserialization = System . currentTimeMillis ( ) ; try { _transcoderService . deserializeAttributes ( _data ) ; } catch ( final Exception e ) { _log . warn ( " Could not deserialize session data. " , e ) ; } _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) _data . length / 1000 , _id , System . currentTimeMillis ( ) - startDeserialization ) ) ; _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( startDeserialization ) ; return null ; } 
public static void main ( final String [ ] args ) throws InterruptedException { Thread.sleep( 1000 ); final MemcachedBackupSessionManager manager = createManager(); benchmark( manager, 10, 20, 2 ); 
private static void benchmark ( final MemcachedBackupSessionManager manager , final int rounds , final int countPersons , final int nodesPerEdge ) throws InterruptedException { final Stats javaSerStats = new Stats ( ) ; final Stats javaDeSerStats = new Stats ( ) ; benchmark ( manager , new JavaSerializationTranscoder ( ) , javaSerStats , javaDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; final Stats javolutionSerStats = new Stats ( ) ; final Stats javolutionDeSerStats = new Stats ( ) ; benchmark ( manager , new JavolutionTranscoder ( Thread . currentThread ( ) . getContextClassLoader ( ) , false ) , javolutionSerStats , javolutionDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; final Stats kryoSerStats = new Stats ( ) ; final Stats kryoDeSerStats = new Stats ( ) ; benchmark ( manager , new KryoTranscoder ( ) , kryoSerStats , kryoDeSerStats , rounds , countPersons , nodesPerEdge ) ; System . out . println ( " Serialization,Size,Ser-Min,Ser-Avg,Ser-Max,Deser-Min,Deser-Avg,Deser-Max " ) ; System . out . println ( toCSV ( " Java " , javaSerStats , javaDeSerStats ) ) ; System . out . println ( toCSV ( " Javolution " , javolutionSerStats , javolutionDeSerStats ) ) ; System . out . println ( toCSV ( " Kryo " , kryoSerStats , kryoDeSerStats ) ) ; } 
private static String toCSV ( final String name , final Stats serStats , final Stats deSerStats ) { return name + " , " + serStats . size + " , " + minAvgMax ( serStats ) + " , " + minAvgMax ( deSerStats ) ; } 
private static String minAvgMax ( final Stats stats ) { return stats . min + " , " + stats . avg + " , " + stats . max ; } 
private static void benchmark ( final MemcachedBackupSessionManager manager , final SessionAttributesTranscoder transcoder , final Stats serializationStats , final Stats deserializationStats , final int rounds , final int countPersons , final int nodesPerEdge ) throws InterruptedException { System . out . println ( " Running benchmark for " + transcoder . getClass ( ) . getSimpleName ( ) + " ... " + " (rounds: " + rounds + " , persons: " + countPersons + " , nodes: " + ( ( int ) Math . pow ( nodesPerEdge , nodesPerEdge ) + nodesPerEdge + 1 ) + " ) " ) ; final TranscoderService transcoderService = new TranscoderService ( transcoder ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789abcdefghijk987654321 " , countPersons , nodesPerEdge ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final int size = data . length ; for ( int r = 0 ; r < rounds ; r + + ) { final long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 1000 ; i + + ) { transcoderService . serialize ( session ) ; } serializationStats . registerSince ( start ) ; serializationStats . setSize ( size ) ; } System . gc ( ) ; Thread . sleep ( 100 ) ; deserialization for( int r = 0; r < rounds; r++ ) { final long start = System.currentTimeMillis(); 
private static MemcachedBackupSession createSession ( final MemcachedBackupSessionManager manager , final String id , final int countPersons , final int countNodesPerEdge ) { final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; session . setAttribute ( " stringbuffer " , new StringBuffer ( " <string n&buffer/> " ) ) ; session . setAttribute ( " stringbuilder " , new StringBuilder ( " <string n&buffer/> " ) ) ; session . setAttribute ( " persons " , createPersons ( countPersons ) ) ; session . setAttribute ( " mycontainer " , new TestClasses . MyContainer ( ) ) ; session . setAttribute ( " component " , createComponents ( countNodesPerEdge ) ) ; return session ; } 
private static Component createComponents ( final int countNodesPerEdge ) { final Component root = new Component ( " root " ) ; for ( int i = 0 ; i < countNodesPerEdge ; i + + ) { final Component node = new Component ( " child " + i ) ; addChildren ( node , countNodesPerEdge ) ; root . addChild ( node ) ; } return root ; } 
private static void addChildren ( final Component node , final int count ) { for ( int i = 0 ; i < count ; i + + ) { node . addChild ( new Component ( node . getName ( ) + " - " + i ) ) ; 
private static Person [ ] createPersons ( final int countPersons ) { final Person [ ] persons = new Person [ countPersons ] ; for ( int i = 0 ; i < countPersons ; i + + ) { final Calendar dateOfBirth = Calendar . getInstance ( ) ; dateOfBirth . set ( Calendar . YEAR , dateOfBirth . get ( Calendar . YEAR ) - 42 ) ; final Person person = TestClasses . createPerson ( " Firstname " + i + " Lastname " + i , i % 2 = = 0 ? Gender . FEMALE : Gender . MALE , dateOfBirth , " email " + i + " -1@example.org " , " email " + i + " -2@example.org " , " email " + i + " -3@example.org " ) ; person . addAddress ( new Address ( " route66 " , " 123456 " , " sincity " , " sincountry " ) ) ; if ( i > 0 ) { person . addFriend ( persons [ i - 1 ] ) ; } persons [ i ] = person ; } return persons ; } 
public void register ( final long value ) { if ( value < min | | _first ) { min = value ; } if ( value > max | | _first ) { max = value ; } avg = ( avg * _count . get ( ) + value ) / _count . incrementAndGet ( ) ; _first = false ; } 
static Person createPerson ( final String name , final Gender gender , final Calendar dateOfBirth , final String . . . emailAddresses ) { final int age = Calendar . getInstance ( ) . get ( Calendar . YEAR ) - dateOfBirth . get ( Calendar . YEAR ) ; final Person result = createPerson ( name , gender , age , emailAddresses ) ; result . setDateOfBirth ( dateOfBirth ) ; return result ; } 
public Component addChild ( final Component child ) { child . setParent ( this ) ; _children . add ( child ) ; return this ; } 
public Component addChildren ( final Collection < Component > children ) { for ( final Component child : children ) { child . setParent ( this ) ; _children . add ( child ) ; } return this ; } 
public static void main ( final String [ ] args ) throws InterruptedException { Thread.sleep( 1000 ); final MemcachedBackupSessionManager manager = createManager(); benchmark( manager, 10, 10, 2 ); 
private static void benchmark ( final MemcachedBackupSessionManager manager , final SessionAttributesTranscoder transcoder , final Stats serializationStats , final Stats deserializationStats , final int rounds , final int countPersons , final int nodesPerEdge ) throws InterruptedException { System . out . println ( " Running benchmark for " + transcoder . getClass ( ) . getSimpleName ( ) + " ... " + " (rounds: " + rounds + " , persons: " + countPersons + " , nodes: " + ( ( int ) Math . pow ( nodesPerEdge , nodesPerEdge ) + nodesPerEdge + 1 ) + " ) " ) ; final TranscoderService transcoderService = new TranscoderService ( transcoder ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789abcdefghijk987654321 " , countPersons , nodesPerEdge ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final int size = data . length ; for ( int r = 0 ; r < rounds ; r + + ) { final long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 500 ; i + + ) { transcoderService . serialize ( session ) ; } serializationStats . registerSince ( start ) ; serializationStats . setSize ( size ) ; } System . gc ( ) ; Thread . sleep ( 100 ) ; deserialization for( int r = 0; r < rounds; r++ ) { final long start = System.currentTimeMillis(); 
static Person createPerson ( final String name , final Gender gender , final Calendar dateOfBirth , final String . . . emailAddresses ) { final int age = dateOfBirth = = null ? - 1 : Calendar . getInstance ( ) . get ( Calendar . YEAR ) - dateOfBirth . get ( Calendar . YEAR ) ; final Person result = createPerson ( name , gender , age , emailAddresses ) ; result . setDateOfBirth ( dateOfBirth ) ; return result ; } 
private Pair < Kryo , SerializerFactory [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Pair<KryoCustomization[], SerializerFactory[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Pair.create( kryo, pair.b ); } 
private TranscoderFactory createTranscoderFactory ( ) throws InstantiationException , IllegalAccessException , ClassNotFoundException { _log . info ( " Creating transcoder factory " + _transcoderFactoryClassName ) ; final Class < ? extends TranscoderFactory > transcoderFactoryClass = loadTranscoderFactoryClass ( ) ; final TranscoderFactory transcoderFactory = transcoderFactoryClass . newInstance ( ) ; transcoderFactory . setCopyCollectionsForSerialization ( _copyCollectionsForSerialization ) ; if ( _customConverterClassNames ! = null ) { _log . info ( " Found configured custom converter classes, setting on transcoder factory: " + _customConverterClassNames ) ; transcoderFactory . setCustomConverterClassNames ( _customConverterClassNames . split ( " , \\ s* " ) ) ; } return transcoderFactory ; } 
private Class < ? extends TranscoderFactory > loadTranscoderFactoryClass ( ) throws ClassNotFoundException { Class < ? extends TranscoderFactory > transcoderFactoryClass ; final ClassLoader classLoader = getContainer ( ) . getLoader ( ) . getClassLoader ( ) ; try { _log . debug ( " Loading transcoder factory class " + _transcoderFactoryClassName + " using classloader " + classLoader ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , classLoader ) . asSubclass ( TranscoderFactory . class ) ; } catch ( final ClassNotFoundException e ) { _log . info ( " Could not load transcoderfactory class with classloader " + classLoader + " , trying " + getClass ( ) . getClassLoader ( ) ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , getClass ( ) . getClassLoader ( ) ) . asSubclass ( TranscoderFactory . class ) ; } return transcoderFactoryClass ; } 
private Pair < Kryo , SerializerFactory [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Pair<KryoCustomization[], SerializerFactory[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Pair.create( kryo, pair.b ); } 
public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } 
private Serializer loadCopyCollectionSerializer ( final Class < ? > clazz , final Kryo kryo ) { if ( Collection . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateCollectionSerializer for class " + clazz ) ; } return new CopyForIterateCollectionSerializer ( kryo ) ; } if ( Map . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateMapSerializer for class " + clazz ) ; } return new CopyForIterateMapSerializer ( kryo ) ; } return null ; } 
protected void beforeTest ( ) { _sessionFactory = new AnnotationConfiguration ( ) . addAnnotatedClass ( Person . class ) 
public void testDeserializeHibernateCollection ( ) { final MemcachedBackupSessionManager manager = createManager ( ) ; final Set < Animal > animals = new HashSet < Animal > ( Arrays . asList ( new Animal ( " cat " ) ) ) ; final Person person = new Person ( " foo bar " , animals ) ; final Long personId = createPerson ( person ) ; final Person foundPerson = findPerson ( personId ) ; LOG . info ( " person: " + person . toString ( ) ) ; LOG . info ( " found: " + foundPerson . toString ( ) ) ; TestUtils . assertDeepEquals ( person , foundPerson ) ; final TranscoderService transcoderService = new TranscoderService ( createTranscoder ( manager ) ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789 " ) ; session . setAttribute ( " person " , foundPerson ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , null , manager ) ; final Person deserializedPerson = ( Person ) deserialized . getAttribute ( " person " ) ; TestUtils . assertDeepEquals ( foundPerson , deserializedPerson ) ; 
private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } 
public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } 
private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } 
public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } 
public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } 
public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } 
< T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; 
private static MemcachedBackupSession createSession ( final MemcachedBackupSessionManager manager , final String id ) { final MemcachedBackupSession session = manager . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; return session ; } 
protected SessionAttributesTranscoder createTranscoder ( final MemcachedBackupSessionManager manager ) { return new JavaSerializationTranscoder ( manager ) ; } 
public Serializer newSerializer ( final Class < ? > type ) { if ( AbstractPersistentCollection . class . isAssignableFrom ( type ) ) { return new FieldSerializer ( _kryo , type ) ; } return null ; } 
protected KryoTranscoder createTranscoder ( final MemcachedBackupSessionManager manager ) { final String [ ] customConverter = new String [ ] { HibernateCollectionsSerializerFactory . class . getName ( ) } ; final KryoTranscoder result = new KryoTranscoder ( getClass ( ) . getClassLoader ( ) , customConverter , false ) ; return result ; } 
public boolean canConvert ( final Class < ? > cls ) { return AbstractPersistentCollection . class . isAssignableFrom ( cls ) ; } 
public void read ( final XMLFormat . InputElement input , final AbstractPersistentCollection obj ) throws XMLStreamException { getFormat ( obj . getClass ( ) ) . read ( input , obj ) ; } 
public void write ( final AbstractPersistentCollection obj , final javolution . xml . XMLFormat . OutputElement output ) throws XMLStreamException { getFormat ( obj . getClass ( ) ) . write ( obj , output ) ; } 
protected JavolutionTranscoder createTranscoder ( final MemcachedBackupSessionManager manager ) { return new JavolutionTranscoder ( manager , false , new HibernateCollectionsXMLFormat ( ) ) ; } 
private Pair < Kryo , SerializerFactory [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this ) ; } return super . newSerializer ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Pair<KryoCustomization[], SerializerFactory[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Pair.create( kryo, pair.b ); } 
public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this ) ; } return super . newSerializer ( clazz ) ; } 
private Pair < Kryo , SerializerFactory [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Pair<KryoCustomization[], SerializerFactory[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Pair.create( kryo, pair.b ); } 
public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } 
public Serializer newSerializer ( final Class < ? > type ) { if ( Component . class . isAssignableFrom ( type ) ) { final ReferenceFieldSerializerReflectionFactorySupport result = new ReferenceFieldSerializerReflectionFactorySupport ( _kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; } return null ; } 
public boolean handleUnregisteredClass ( final Class < ? > type ) { if ( CGLibProxySerializer . canSerialize ( type ) ) { _kryo . putRegisteredClass ( type , _kryo . getRegisteredClass ( CGLibProxySerializer . CGLibProxyMarker . class ) ) ; return true ; } return false ; } 
private Triple < Kryo , SerializerFactory [ ] , UnregisteredClassHandler [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( " unchecked " ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } @SuppressWarnings ( " unchecked " ) @Override protected void handleUnregisteredClass ( final Class clazz ) { if ( _unregisteredClassHandlers ! = null ) { for ( int i = 0 ; i < _unregisteredClassHandlers . length ; i + + ) { final boolean handled = _unregisteredClassHandlers [ i ] . handleUnregisteredClass ( clazz ) ; if ( handled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " UnregisteredClassHandler " + _unregisteredClassHandlers [ i ] . getClass ( ) . getName ( ) + " handled class " + clazz ) ; } return ; } } } super . handleUnregisteredClass ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Triple.create( kryo, pair.b, pair.c ); } 
protected void handleUnregisteredClass ( final Class clazz ) { if ( _unregisteredClassHandlers ! = null ) { for ( int i = 0 ; i < _unregisteredClassHandlers . length ; i + + ) { final boolean handled = _unregisteredClassHandlers [ i ] . handleUnregisteredClass ( clazz ) ; if ( handled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " UnregisteredClassHandler " + _unregisteredClassHandlers [ i ] . getClass ( ) . getName ( ) + " handled class " + clazz ) ; } return ; } } } super . handleUnregisteredClass ( clazz ) ; } 
private Triple < KryoCustomization [ ] , SerializerFactory [ ] , UnregisteredClassHandler [ ] > loadCustomConverter ( final String [ ] customConverterClassNames , final ClassLoader classLoader , final Kryo kryo ) { if ( customConverterClassNames = = null | | customConverterClassNames . length = = 0 ) { return Triple . empty ( ) ; } final List < KryoCustomization > customizations = new ArrayList < KryoCustomization > ( ) ; final List < SerializerFactory > serializerFactories = new ArrayList < SerializerFactory > ( ) ; final List < UnregisteredClassHandler > unregisteredClassHandlers = new ArrayList < UnregisteredClassHandler > ( ) ; final ClassLoader loader = classLoader ! = null ? classLoader : Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( int i = 0 ; i < customConverterClassNames . length ; i + + ) { final String element = customConverterClassNames [ i ] ; try { processElement ( element , customizations , serializerFactories , unregisteredClassHandlers , kryo , loader ) ; } catch ( final Exception e ) { LOG . error ( " Could not instantiate " + element + " , omitting this KryoCustomization/SerializerFactory. " , e ) ; throw new RuntimeException ( " Could not load serializer " + element , e ) ; } } final KryoCustomization [ ] customizationsArray = customizations . toArray ( new KryoCustomization [ customizations . size ( ) ] ) ; final SerializerFactory [ ] serializerFactoriesArray = serializerFactories . toArray ( new SerializerFactory [ serializerFactories . size ( ) ] ) ; final UnregisteredClassHandler [ ] unregisteredClassHandlersArray = unregisteredClassHandlers . toArray ( new UnregisteredClassHandler [ unregisteredClassHandlers . size ( ) ] ) ; return Triple . create ( customizationsArray , serializerFactoriesArray , unregisteredClassHandlersArray ) ; } 
private void processElement ( final String element , final List < KryoCustomization > customizations , final List < SerializerFactory > serializerFactories , final List < UnregisteredClassHandler > unregisteredClassHandlers , final Kryo kryo , final ClassLoader loader ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { final Class < ? > clazz = Class . forName ( element , true , loader ) ; if ( KryoCustomization . class . isAssignableFrom ( clazz ) ) { LOG . info ( " Loading KryoCustomization " + element ) ; final KryoCustomization customization = createInstance ( clazz . asSubclass ( KryoCustomization . class ) , kryo ) ; customizations . add ( customization ) ; if ( customization instanceof SerializerFactory ) { serializerFactories . add ( ( SerializerFactory ) customization ) ; } } if ( SerializerFactory . class . isAssignableFrom ( clazz ) ) { LOG . info ( " Loading SerializerFactory " + element ) ; final SerializerFactory factory = createInstance ( clazz . asSubclass ( SerializerFactory . class ) , kryo ) ; serializerFactories . add ( factory ) ; } if ( UnregisteredClassHandler . class . isAssignableFrom ( clazz ) ) { LOG . info ( " Loading UnregisteredClassHandler " + element ) ; 
public static < A , B , C > Triple < A , B , C > create ( final A a , final B b , final C c ) { return new Triple < A , B , C > ( a , b , c ) ; } 
public static < A , B , C > Triple < A , B , C > empty ( ) { return ( Triple < A , B , C > ) EMPTY ; } 
public boolean handleUnregisteredClass ( final Class < ? > type ) { if ( CGLibProxySerializer . canSerialize ( type ) ) { _kryo . register ( type , _kryo . getRegisteredClass ( CGLibProxySerializer . CGLibProxyMarker . class ) ) ; return true ; } return false ; } 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setSessionBackupAsync( false ); sessionManager.setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); catalina.addConnector( connector ); return catalina; } 
public void testCGLibProxy ( ) throws XMLStreamException { final ClassToProxy proxy = createProxy ( new ClassToProxy ( ) ) ; proxy . setValue ( " foo " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final ClassToProxy deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . getValue ( ) , proxy . getValue ( ) ) ; } 
public void testCGLibProxyForExistingFormat ( ) throws XMLStreamException { final Map < String , String > proxy = createProxy ( new HashMap < String , String > ( ) ) ; proxy . put ( " foo " , " bar " ) ; Assert . assertEquals ( proxy . get ( " foo " ) , " bar " ) ; final byte [ ] serialized = serialize ( proxy , _binding ) ; System . out . println ( new String ( serialized ) ) ; final Map < String , String > deserialized = deserialize ( serialized , _binding ) ; Assert . assertEquals ( deserialized . get ( " foo " ) , proxy . get ( " foo " ) ) ; } 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
public Future < BackupResultStatus > backupSession ( final Session session , final boolean sessionIdChanged ) { if ( ! _enabled . get ( ) ) { return new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SKIPPED ) ; } return _backupSessionService . backupSession ( ( MemcachedBackupSession ) session , sessionIdChanged ) ; } 
protected MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( ! _enabled . get ( ) | | ! _sessionIdFormat . isValid ( sessionId ) | | _missingSessionsCache . get ( sessionId ) ! = null ) { return null ; } final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } try { final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; if ( _log . isDebugEnabled ( ) ) { if ( object = = null ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } else { _log . debug ( " Found session with id " + sessionId ) ; } } _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { final MemcachedBackupSession result ; if ( object instanceof MemcachedBackupSession ) { result = ( MemcachedBackupSession ) object ; } else { result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; } _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; } } return null ; } 
protected void updateExpirationInMemcached ( ) { if ( _enabled . get ( ) ) { final Session [ ] sessions = findSessions ( ) ; 
public String createNewSessionId ( final String sessionId , final String newMemcachedId ) { final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot ! = - 1 ) { final String plainSessionId = sessionId . substring ( 0 , idxDot ) ; 
private String appendOrReplaceMemcachedId ( final String sessionId , final String newMemcachedId ) { final int idxDash = sessionId . indexOf ( '-' ) ; if ( idxDash < 0 ) { return sessionId + " - " + newMemcachedId ; 
public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-n.jvm1 " , cut . createSessionId ( " foo.jvm1 " , " " ) ) ; assertEquals ( " foo-n.j-v-m1 " , cut . createSessionId ( " foo.j-v-m1 " , " " ) ) ; } 
public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo.jvm1 " , " m " ) ) ; assertEquals ( " foo-m.j-v-m1 " , cut . createNewSessionId ( " foo.j-v-m1 " , " m " ) ) ; 
public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.jvm1 " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.j-v-m1 " ) ) ; } 
public void testIsValid ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertFalse ( cut . isValid ( " foo " ) ) ; assertFalse ( cut . isValid ( " foo.jvm1-n " ) ) ; assertFalse ( cut . isValid ( " foo.n.jvm1 " ) ) ; assertFalse ( cut . isValid ( " foo.n.j-v-m1 " ) ) ; assertTrue ( cut . isValid ( " foo-n " ) ) ; assertTrue ( cut . isValid ( " foo-n.jvm1 " ) ) ; assertTrue ( cut . isValid ( " foo-n.j-v-m1 " ) ) ; } 
public void setUp ( ) throws Exception { _sessionBackupServiceControl = mock ( SessionBackupService . class ) ; _service = ( SessionBackupService ) _sessionBackupServiceControl . proxy ( ) ; _sessionTrackerValve = new SessionTrackerValve ( null , new StandardContext ( ) , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( ( Valve ) _nextValve . proxy ( ) ) ; _requestControl = mock ( Request . class ) ; _request = ( Request ) _requestControl . proxy ( ) ; _responseControl = mock ( Response . class ) ; _response = ( Response ) _responseControl . proxy ( ) ; } 
protected MemcachedClient createMemcachedClient ( final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } try { final ConnectionFactory connectionFactory = createConnectionFactory ( address2Ids , statistics ) ; 
protected void deleteFromMemcached ( final String sessionId ) { if ( _enabled . get ( ) & & _sessionIdFormat . isValid ( sessionId ) ) { if ( _log . isDebugEnabled ( ) ) { 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private MemcachedClient createMemcachedClient ( final InetSocketAddress address ) throws IOException , InterruptedException { final MemcachedClient result = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void testExpiredSessionRemovedFromMemcached ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; waitForSessionExpiration ( ) ; assertNull ( _memcached . get ( sessionId1 ) , " Expired session still existing in memcached " ) ; } 
public void testDisableMsmAtRuntime ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { disable msm, shutdown our server and our client getManager( _tomcat1 ).setEnabled( false ); _memcached.shutdown(); _daemon.stop(); checkSessionFunctionalityWithMsmDisabled(); } 
public void testStartMsmDisabled ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { shutdown our server and our client _memcached.shutdown(); _daemon.stop(); start a new tomcat with msm initially disabled _tomcat1.stop(); Thread.sleep( 500 ); final String memcachedNodes = _memcachedNodeId + ":localhost:" + _memcachedPort; _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, "app1" ); getManager( _tomcat1 ).setEnabled( false ); _tomcat1.start(); LOG.info( "Waiting, check logs to see if the client causes any 'Connection refused' logging..." ); Thread.sleep( 1000 ); some basic tests for session functionality checkSessionFunctionalityWithMsmDisabled(); start memcached, client and reenable msm _daemon.start(); _memcached = createMemcachedClient( new InetSocketAddress( "localhost", _memcachedPort ) ); getManager( _tomcat1 ).setEnabled( true ); Wait a little bit, so that msm's memcached client can connect and is ready when test starts Thread.sleep( 100 ); memcached based stuff should work again final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), "memcached node id missing with msm switched to enabled" ); Thread.sleep( 50 ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); waitForSessionExpiration(); assertNull( _memcached.get( sessionId1 ), "Expired session still existing in memcached" ); 
private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id, even with msm disabled. " ) ; waitForSessionExpiration ( ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed. " ) ; } 
private void waitForSessionExpiration ( ) throws InterruptedException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) ) + 100 ; Thread . sleep ( timeout ) ; } 
public void testExtractMemcachedId ( ) throws InterruptedException { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.jvm1 " ) ) ; assertEquals ( " " , cut . extractMemcachedId ( " foo-n.j-v-m1 " ) ) ; assertEquals ( null , cut . extractMemcachedId ( " foo.j-v-m1 " ) ) ; } 
public static void main ( final String [ ] args ) throws InterruptedException { Thread.sleep( 1000 ); final MemcachedBackupSessionManager manager = createManager(); some warmup final int warmupCycles = 100000; warmup( manager, new JavaSerializationTranscoder(), warmupCycles, 100, 3 ); warmup( manager, new JavolutionTranscoder( Thread.currentThread().getContextClassLoader(), false ), warmupCycles, 100, 3 ); warmup( manager, new KryoTranscoder(), warmupCycles, 100, 3 ); recover(); benchmark( manager, 10, 500, 4 ); 
private static void benchmark ( final MemcachedBackupSessionManager manager , final SessionAttributesTranscoder transcoder , final Stats serializationStats , final Stats deserializationStats , final int rounds , final int countPersons , final int nodesPerEdge ) throws InterruptedException { System . out . println ( " Running benchmark for " + transcoder . getClass ( ) . getSimpleName ( ) + " ... " + " (rounds: " + rounds + " , persons: " + countPersons + " , nodes: " + ( ( int ) Math . pow ( nodesPerEdge , nodesPerEdge ) + nodesPerEdge + 1 ) + " ) " ) ; final TranscoderService transcoderService = new TranscoderService ( transcoder ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789abcdefghijk987654321 " , countPersons , nodesPerEdge ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final int size = data . length ; for ( int r = 0 ; r < rounds ; r + + ) { final long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < 500 ; i + + ) { transcoderService . serialize ( session ) ; } serializationStats . registerSince ( start ) ; serializationStats . setSize ( size ) ; } System . gc ( ) ; Thread . sleep ( 100 ) ; deserialization for( int r = 0; r < rounds; r++ ) { final long start = System.currentTimeMillis(); 
private static void warmup ( final MemcachedBackupSessionManager manager , final SessionAttributesTranscoder transcoder , final int loops , final int countPersons , final int nodesPerEdge ) throws InterruptedException { final TranscoderService transcoderService = new TranscoderService ( transcoder ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789abcdefghijk987654321 " , countPersons , nodesPerEdge ) ; System . out . print ( " Performing warmup for serialization using " + transcoder . getClass ( ) . getSimpleName ( ) + " ... " ) ; final long serWarmupStart = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < loops ; i + + ) transcoderService . serialize ( session ) ; System . out . println ( " ( " + ( System . currentTimeMillis ( ) - serWarmupStart ) + " ms) " ) ; System . out . print ( " Performing warmup for deserialization... " ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final long deserWarmupStart = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < loops ; i + + ) transcoderService . deserialize ( data , null , null ) ; System . out . println ( " ( " + ( System . currentTimeMillis ( ) - deserWarmupStart ) + " ms) " ) ; 
private void backupSession ( final Request request , final Response response , final boolean sessionIdChanged ) { final Session session = request . getRequestedSessionId ( ) ! = null | | getCookie ( response , _sessionCookieName ) ! = null ? request . getSessionInternal ( false ) : null ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Have a session: " + ( session ! = null ) ) ; } if ( session ! = null ) { 
private void logDebugResponseCookie ( final Response response ) { if ( _log . isDebugEnabled ( ) ) { final Cookie respCookie = getCookie ( response , _sessionCookieName ) ; 
public final void testSessionCookieName ( ) throws IOException , ServletException { final StandardContext context = new StandardContext ( ) ; context . setSessionCookieName ( " foo " ) ; SessionTrackerValve cut = new SessionTrackerValve ( null , context , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; assertEquals ( " foo " , cut . getSessionCookieName ( ) ) ; context . setSessionCookieName ( null ) ; cut = new SessionTrackerValve ( null , context , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; assertEquals ( Globals . SESSION_COOKIE_NAME , cut . getSessionCookieName ( ) ) ; } 
public final void testGetSessionInternalInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " setRequestedSessionId " ) . with ( eq ( newSessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " isRequestedSessionIdFromCookie " ) . will ( returnValue ( true ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getContext " ) . will ( returnValue ( new StandardContext ( ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " isSecure " ) . will ( returnValue ( false ) ) ; _responseControl . expects ( once ( ) ) . method ( " addCookieInternal " ) . with ( and ( hasProperty ( " name " , eq ( _sessionTrackerValve . getSessionCookieName ( ) ) ) , hasProperty ( " value " , eq ( newSessionId ) ) ) , eq ( false ) ) ; default value in StandardContext.useHttpOnly _nextValve.expects( once() ).method( "invoke" ); _requestControl.expects( once() ).method( "getSessionInternal" ).with( eq( false ) ) .will( returnValue( session ) ); _sessionBackupServiceControl.expects( once() ).method( "backupSession" ).with( eq( session ), eq( true ) ) .will( returnValue( new SimpleFuture<BackupResultStatus>( BackupResultStatus.SUCCESS ) ) ); _sessionTrackerValve.invoke( _request, _response ); 
private void verifyMocks ( ) { _sessionBackupServiceControl . verify ( ) ; _nextValve . verify ( ) ; _requestControl . verify ( ) ; _responseControl . verify ( ) ; } 
public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; } 
public final void testGetSessionInternalInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getCookies " ) . will ( returnValue ( new Cookie [ ] { new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) } ) ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; final String sessionId = " foo " ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( false ) ) . will ( returnValue ( new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " changeSessionId " ) . with ( eq ( newSessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( true ) ) . will ( returnValue ( new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
public void backupFinished ( ) { _authenticationChanged = false ; _attributesAccessed = false ; _sessionIdChanged = false ; } 
public void changeSessionId ( final Session session ) { e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation so that session backup won't be omitted we must store this event super.changeSessionId( session ); ((MemcachedBackupSession)session).setSessionIdChanged( true ); } 
public Future < BackupResultStatus > backupSession ( final Session session , final boolean sessionIdChanged ) { if ( ! _enabled . get ( ) ) { return new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SKIPPED ) ; } final MemcachedBackupSession msmSession = ( MemcachedBackupSession ) session ; return _backupSessionService . backupSession ( msmSession , sessionIdChanged | | msmSession . isSessionIdChanged ( ) ) ; } 
public void testChangeSessionId ( ) throws InterruptedException , ExecutionException , TimeoutException { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false ) . get ( ) ; final String oldSessionId = session . getId ( ) ; _manager . changeSessionId ( session ) ; on session backup we specify sessionIdChanged as false as we're not aware of this fact _manager.backupSession( session, false ); remove session with old id and add it with the new id verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) ); verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() ); 
public void shutdown ( ) throws InterruptedException { _executorService . shutdown ( ) ; if ( _nonStickySessionBackupExecutor ! = null ) { _nonStickySessionBackupExecutor . shutdown ( ) ; 
public void updateExpiration ( final MemcachedBackupSession session ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Updating expiration time for session " + session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( session ) ) { return ; } session . setExpirationUpdateRunning ( true ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; try { final Map < String , Object > attributes = session . getAttributesInternal ( ) ; 
public Future < BackupResult > backupSession ( final MemcachedBackupSession session , final boolean force ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + session . getId ( ) ) ; } final long start = System . currentTimeMillis ( ) ; try { 
private BackupSessionTask createBackupSessionTask ( final MemcachedBackupSession session , final boolean force ) { return new BackupSessionTask ( session , force , 
private void releaseLock ( @Nonnull final MemcachedBackupSession session ) { if ( session . isLocked ( ) ) { try { 
public BackupResult call ( ) throws Exception { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Starting for session id " + _session . getId ( ) ) ; } _session . setBackupRunning ( true ) ; try { 
protected MemcachedClient createMemcachedClient ( final NodeIdList nodeIds , final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { return null ; } 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestURI ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesInternal() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.getAttributesSerializationProbe().registerSince( startSerialization ); _statistics.getCachedDataSizeProbe().register( data.length ); return new SimpleFuture<BackupResult>( new BackupResult( BackupResultStatus.SUCCESS ) ); } @Override public Session findSession( final String id ) throws IOException { final Session result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.getLoadFromMemcachedProbe().registerSince( startDeserialization ); return null; } }} 
public Future < BackupResult > backupSession ( final Session session , final boolean sessionIdChanged , final String requestURI ) { _log . info ( " Serializing session data for session " + session . getIdInternal ( ) ) ; final long startSerialization = System . currentTimeMillis ( ) ; final byte [ ] data = _transcoderService . serializeAttributes ( ( MemcachedBackupSession ) session , ( ( MemcachedBackupSession ) session ) . getAttributesInternal ( ) ) ; _log . info ( String . format ( " Serializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) data . length / 1000 , session . getIdInternal ( ) , System . currentTimeMillis ( ) - startSerialization ) ) ; _sessionData . put ( session . getIdInternal ( ) , data ) ; _statistics . getAttributesSerializationProbe ( ) . registerSince ( startSerialization ) ; _statistics . getCachedDataSizeProbe ( ) . register ( data . length ) ; return new SimpleFuture < BackupResult > ( new BackupResult ( BackupResultStatus . SUCCESS ) ) ; } 
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { return null ; } 
public V remove ( final K key ) { synchronized ( _map ) { final ManagedItem < V > removed = _map . remove ( key ) ; 
public boolean containsKey ( final K key ) { synchronized ( _map ) { return _map . containsKey ( key ) ; 
public int compare ( final Entry < K , ManagedItem < V > > o1 , final Entry < K , ManagedItem < V > > o2 ) { return comparator . compare ( o1 . getValue ( ) . _value , o2 . getValue ( ) . _value ) ; } 
public < T > T [ ] toArray ( final T [ ] a ) { throw new UnsupportedOperationException ( " Not implemented. " ) ; } 
public E get ( final int index ) { return a [ index ] . getKey ( ) ; } 
public E set ( final int index , final E element ) { throw new UnsupportedOperationException ( " Not implemented. " ) ; } 
public boolean contains ( final Object o ) { return indexOf ( o ) ! = - 1 ; } 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final MemcachedClient memcached , @Nonnull final MemcachedBackupSessionManager manager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : return new LockingStrategyAll ( memcached , missingSessionsCache ) ; 
protected LockStatus lock ( final String sessionId ) { return lock ( sessionId , LOCK_TIMEOUT , TimeUnit . MILLISECONDS ) ; } 
protected LockStatus lock ( final String sessionId , final long timeout , final TimeUnit timeUnit ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Locking session " + sessionId ) ; } try { acquireLock ( sessionId , LOCK_RETRY_INTERVAL , LOCK_MAX_RETRY_INTERVAL , timeUnit . toMillis ( timeout ) , System . currentTimeMillis ( ) ) ; 
protected void acquireLock ( @Nonnull final String sessionId , final long retryInterval , final long maxRetryInterval , final long timeout , final long start ) throws InterruptedException , ExecutionException , TimeoutException { final Future < Boolean > result = _memcached . add ( _sessionIdFormat . createLockName ( sessionId ) , 5 , LOCK_VALUE ) ; if ( result . get ( ) . booleanValue ( ) ) { if ( _log . isDebugEnabled ( ) ) { 
protected void checkTimeoutAndWait ( @Nonnull final String sessionId , final long retryInterval , final long maxRetryInterval , final long timeout , final long start ) throws TimeoutException , InterruptedException { if ( System . currentTimeMillis ( ) > = start + timeout ) { throw new TimeoutException ( " Reached timeout when trying to aquire lock for session " + sessionId ) ; } final long timeToWait = min ( retryInterval , maxRetryInterval ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Could not aquire lock for session " + sessionId + " , waiting " + timeToWait + " millis now... " ) ; } sleep ( timeToWait ) ; } 
protected void releaseLock ( @Nonnull final String sessionId ) { try { if ( _log . isDebugEnabled ( ) ) { 
protected void onAfterBackupSession ( @Nonnull final MemcachedBackupSession session , final boolean backupWasForced , @Nonnull final Future < BackupResult > result , @Nonnull final String requestId , @Nonnull final BackupSessionService backupSessionService ) { if ( ! backupWasForced ) { pingSessionIfBackupWasSkipped ( session , result , backupSessionService ) ; } final byte [ ] data = encode ( session . getMaxInactiveInterval ( ) , session . getLastAccessedTimeInternal ( ) , session . getThisAccessedTimeInternal ( ) ) ; final String key = createValidityInfoKeyName ( session . getIdInternal ( ) ) ; _memcached . set ( key , session . getMaxInactiveInterval ( ) , data ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Stored session validity info for session " + session . getIdInternal ( ) ) ; } store backup in secondary memcached final String backupKey = _sessionIdFormat.createBackupKey( key ); _memcached.set( backupKey, session.getMaxInactiveInterval(), data ); 
protected final boolean isContainerSessionLookup ( ) { return _requestsThreadLocal . get ( ) = = null ; } 
protected SessionValidityInfo loadSessionValidityInfo ( @Nonnull final String id ) { final byte [ ] validityInfo = ( byte [ ] ) _memcached . get ( createValidityInfoKeyName ( id ) ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; } 
protected SessionValidityInfo loadBackupSessionValidityInfo ( @Nonnull final String id ) { final String key = createValidityInfoKeyName ( id ) ; final String backupKey = _sessionIdFormat . createBackupKey ( key ) ; final byte [ ] validityInfo = ( byte [ ] ) _memcached . get ( backupKey ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; } 
protected void onAfterLoadFromMemcached ( @Nonnull final MemcachedBackupSession session , @Nullable final LockStatus lockStatus ) { session . setLockStatus ( lockStatus ) ; final SessionValidityInfo info = loadSessionValidityInfo ( session . getIdInternal ( ) ) ; if ( info ! = null ) { session . setLastAccessedTimeInternal ( info . getLastAccessedTime ( ) ) ; 
protected void onAfterDeleteFromMemcached ( @Nonnull final String sessionId ) { _memcached . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; final String validityInfoKey = createValidityInfoKeyName ( sessionId ) ; _memcached . delete ( validityInfoKey ) ; _memcached . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; } 
protected final void onRequestStart ( final Request request ) { _requestsThreadLocal . set ( request ) ; } 
protected final void onRequestFinished ( ) { _requestsThreadLocal . set ( null ) ; } 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( session . getIdInternal ( ) , session . getMaxInactiveInterval ( ) , 1 ) ; try { _log . debug ( " Got ping result " + touchResult . get ( ) ) ; 
protected LockStatus onBeforeLoadFromMemcached ( @Nonnull final String sessionId ) throws InterruptedException , ExecutionException { return lock ( sessionId ) ; } 
protected LockStatus onBeforeLoadFromMemcached ( @Nonnull final String sessionId ) throws InterruptedException , ExecutionException { return LockStatus . LOCK_NOT_REQUIRED ; } 
public void recycle ( ) { super . recycle ( ) ; _dataHashCode = 0 ; _expirationUpdateRunning = false ; _backupRunning = false ; _lockStatus = null ; } 
boolean wasAccessedSinceLastBackup ( ) { return super . thisAccessedTime > _lastBackupTime ; } 
public void backupFailed ( ) { _lastBackupTime = _previousLastBackupTime ; } 
public synchronized boolean isLocked ( ) { return _lockStatus = = LockStatus . LOCKED ; } 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = new SessionTrackerValve ( _requestUriIgnorePattern , ( Context ) getContainer ( ) , this , _statistics , _enabled ) ; getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics , _sticky ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
private MemcachedConfig createMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final List < String > nodeIds = new ArrayList < String > ( ) ; final Matcher matcher = NODE_PATTERN . matcher ( memcachedNodes ) ; final List < InetSocketAddress > addresses = new ArrayList < InetSocketAddress > ( ) ; final Map < InetSocketAddress , String > address2Ids = new HashMap < InetSocketAddress , String > ( ) ; while ( matcher . find ( ) ) { initHandleNodeDefinitionMatch ( matcher , addresses , address2Ids , nodeIds ) ; } final List < String > failoverNodeIds = initFailoverNodes ( failoverNodes , nodeIds ) ; if ( nodeIds . isEmpty ( ) ) { throw new IllegalArgumentException ( " All nodes are also configured as failover nodes, " + " this is a configuration failure. In this case, you probably want to leave out the failoverNodes. " ) ; } return new MemcachedConfig ( memcachedNodes , failoverNodes , new NodeIdList ( nodeIds ) , failoverNodeIds , addresses , address2Ids ) ; } 
protected MemcachedClient createMemcachedClient ( final NodeIdList nodeIds , final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } try { final ConnectionFactory connectionFactory = createConnectionFactory ( nodeIds , address2Ids , statistics ) ; 
private ConnectionFactory createConnectionFactory ( final NodeIdList nodeIds , final Map < InetSocketAddress , String > address2Ids , final Statistics statistics ) { final MapBasedResolver resolver = new MapBasedResolver ( address2Ids ) ; if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { return new SuffixLocatorBinaryConnectionFactory ( nodeIds , resolver , _sessionIdFormat , statistics ) ; } return new SuffixLocatorConnectionFactory ( nodeIds , resolver , _sessionIdFormat , statistics ) ; } 
public Session findSession ( final String id ) throws IOException { MemcachedBackupSession result = ( MemcachedBackupSession ) super . findSession ( id ) ; if ( result = = null & & canHitMemcached ( id ) ) { when the request comes from the container, it's from CoyoteAdapter.postParseRequest if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) { we can return just null as the requestedSessionId will still be set on the request. return null; } else load the session from memcached result = loadFromMemcached( id ); checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { addValidLoadedSession( result ); } } return result; } 
public Session createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; StandardSession session = null ; if ( sessionId ! = null ) { session = loadFromMemcachedWithCheck ( sessionId ) ; checking valid() would expire() the session if it's not valid! if ( session != null && session.isValid() ) { addValidLoadedSession( session ); } } if ( session == null ) { session = createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( this.maxInactiveInterval ); if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) { sessionId = generateSessionId(); } session.setId( sessionId ); if ( _log.isDebugEnabled() ) { _log.debug( "Created new session with id " + session.getId() ); } } sessionCounter++; return session; 
public MemcachedBackupSession createEmptySession ( ) { final MemcachedBackupSession result = new MemcachedBackupSession ( this ) ; result . setSticky ( _sticky ) ; return result ; } 
public String changeSessionIdOnTomcatFailover ( final String requestedSessionId ) { if ( ! _sticky ) { return null ; } final String localJvmRoute = getJvmRoute ( ) ; if ( localJvmRoute ! = null & & ! localJvmRoute . equals ( _sessionIdFormat . extractJvmRoute ( requestedSessionId ) ) ) { final MemcachedBackupSession session = loadFromMemcachedWithCheck ( requestedSessionId ) ; checking valid() can expire() the session! if ( session != null && session.isValid() ) { return handleSessionTakeOver( session ); } } return null; } 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { if ( _sticky ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _nodeIdService . isNodeAvailable ( nodeId ) ) { return null ; } final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId , nodeId ) ; if ( backupSession ! = null ) { addValidLoadedSession ( backupSession ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId , @Nonnull final String nodeId ) { final String nextNodeId = _nodeIdService . getNextNodeId ( nodeId ) ; if ( ! _nodeIdService . isNodeAvailable ( nextNodeId ) ) { _log . info ( " Node " + nodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( _sessionIdFormat . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , getContainer ( ) . getRealm ( ) , this ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; _log . debug ( " Session needs to be relocated, setting new id on session... " ) ; final String newSessionId = _sessionIdFormat . createNewSessionId ( requestedSessionId , nextNodeId ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
public Future < BackupResult > backupSession ( final Session session , final boolean sessionIdChanged , final String requestId ) { if ( ! _enabled . get ( ) ) { return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } final MemcachedBackupSession msmSession = ( MemcachedBackupSession ) session ; final boolean force = sessionIdChanged | | msmSession . isSessionIdChanged ( ) | | ! _sticky & & ( msmSession . getSecondsSinceLastBackup ( ) > = session . getMaxInactiveInterval ( ) ) ; final Future < BackupResult > result = _backupSessionService . backupSession ( msmSession , force ) ; if ( ! _sticky ) { remove ( session , false ) ; _lockingStrategy . onAfterBackupSession ( msmSession , force , result , requestId , _backupSessionService ) ; } return result ; } 
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { if ( ! canHitMemcached ( sessionId ) ) { return null ; } return loadFromMemcached ( sessionId ) ; } 
private boolean canHitMemcached ( @Nonnull final String sessionId ) { return _enabled . get ( ) & & _sessionIdFormat . isValid ( sessionId ) & & _missingSessionsCache . get ( sessionId ) = = null ; } 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { final MemcachedBackupSession result ; if ( object instanceof MemcachedBackupSession ) { result = ( MemcachedBackupSession ) object ; } else { result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; } if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } } return null ; } 
public void remove ( final Session session ) { remove ( session , session . getNote ( NODE_FAILURE ) ! = Boolean . TRUE ) ; } 
private void remove ( final Session session , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked, removeFromMemcached: " + removeFromMemcached + " , id: " + session . getId ( ) ) ; } if ( removeFromMemcached ) { deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session ) ; } 
private MemcachedConfig reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( _memcached ! = null ) { _memcached . shutdown ( ) ; } _memcached = memcachedClient ; _nodeIdService = nodeIdService ; _backupSessionService = backupSessionService ; initNonStickyLockingMode ( ) ; return config ; } 
public void setEnabled ( final boolean enabled ) throws IllegalStateException { if ( ! enabled & & ! _sticky ) { throw new IllegalStateException ( " Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before. " ) ; } if ( _enabled . compareAndSet ( ! enabled , enabled ) ) { reloadMemcachedConfig ( _memcachedNodes , _failoverNodes ) ; 
private void initNonStickyLockingMode ( ) { if ( _sticky ) { setLockingMode ( null , null ) ; return ; } Pattern uriPattern = null ; LockingMode lockingMode = null ; if ( _lockingMode ! = null ) { if ( _lockingMode . startsWith ( " uriPattern: " ) ) { lockingMode = LockingMode . URI_PATTERN ; uriPattern = Pattern . compile ( _lockingMode . substring ( " uriPattern: " . length ( ) ) ) ; } else { lockingMode = LockingMode . valueOf ( _lockingMode . toUpperCase ( ) ) ; } } if ( lockingMode = = null ) { lockingMode = LockingMode . NONE ; } setLockingMode ( lockingMode , uriPattern ) ; } 
protected void updateExpirationInMemcached ( ) { if ( _enabled . get ( ) & & _sticky ) { final Session [ ] sessions = findSessions ( ) ; 
public static NodeIdList create ( @Nonnull final String . . . nodeIds ) { return new NodeIdList ( nodeIds ) ; } 
public int compare ( final AtomicLong o1 , final AtomicLong o2 ) { final long val1 = o1 . longValue ( ) ; final long val2 = o2 . longValue ( ) ; return val1 < val2 ? - 1 : ( val1 = = val2 ? 0 : 1 ) ; } 
public boolean readOnlyRequest ( final String requestId ) { if ( ! _blacklist . containsKey ( requestId ) ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Registering readonly request: " + requestId ) ; } incrementOrPut ( _readOnlyRequests , requestId ) ; return true ; } return false ; } 
public void modifyingRequest ( final String requestId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Registering modifying request: " + requestId ) ; } incrementOrPut ( _blacklist , requestId ) ; _readOnlyRequests . remove ( requestId ) ; } 
public boolean isReadOnlyRequest ( final String requestId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Asked for readonly request: " + requestId + " ( " + _readOnlyRequests . containsKey ( requestId ) + " ) " ) ; } TODO: add some threshold return _readOnlyRequests.containsKey( requestId ); } 
private void incrementOrPut ( final LRUCache < String , AtomicLong > cache , final String requestURI ) { final AtomicLong count = cache . get ( requestURI ) ; if ( count ! = null ) { count . incrementAndGet ( ) ; 
public String createSessionId ( @Nonnull final String sessionId , @Nullable final String memcachedId ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Creating new session id with orig id ' " + sessionId + " ' and memcached id ' " + memcachedId + " '. " ) ; } if ( memcachedId = = null ) { return sessionId ; } final int idx = sessionId . indexOf ( '.' ) ; if ( idx < 0 ) { return sessionId + " - " + memcachedId ; 
public String createNewSessionId ( @Nonnull final String sessionId , @Nonnull final String newMemcachedId ) { final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot ! = - 1 ) { final String plainSessionId = sessionId . substring ( 0 , idxDot ) ; 
private String appendOrReplaceMemcachedId ( @Nonnull final String sessionId , @Nonnull final String newMemcachedId ) { final int idxDash = sessionId . indexOf ( '-' ) ; if ( idxDash < 0 ) { return sessionId + " - " + newMemcachedId ; 
public String changeJvmRoute ( @Nonnull final String sessionId , @Nonnull final String newJvmRoute ) { return stripJvmRoute ( sessionId ) + " . " + newJvmRoute ; } 
public boolean isValid ( @Nullable final String sessionId ) { return sessionId ! = null & & _pattern . matcher ( sessionId ) . matches ( ) ; } 
public String extractMemcachedId ( @Nonnull final String sessionId ) { final int idxDash = sessionId . indexOf ( '-' ) ; if ( idxDash < 0 ) { return null ; } final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot < 0 ) { return sessionId . substring ( idxDash + 1 ) ; 
public String extractJvmRoute ( @Nonnull final String sessionId ) { final int idxDot = sessionId . indexOf ( '.' ) ; return idxDot < 0 ? null : sessionId . substring ( idxDot + 1 ) ; } 
public String stripJvmRoute ( @Nonnull final String sessionId ) { final int idxDot = sessionId . indexOf ( '.' ) ; return idxDot < 0 ? sessionId : sessionId . substring ( 0 , idxDot ) ; } 
public String createLockName ( @Nonnull final String sessionId ) { if ( sessionId = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null. " ) ; } return " lock: " + sessionId ; } 
public String createBackupKey ( @Nonnull final String origKey ) { if ( origKey = = null ) { throw new IllegalArgumentException ( " The origKey must not be null. " ) ; } return BACKUP_PREFIX + origKey ; } 
public boolean isBackupKey ( @Nonnull final String key ) { return key . startsWith ( BACKUP_PREFIX ) ; } 
private void resetRequestThreadLocal ( ) { if ( _lockingStrategy ! = null ) { _lockingStrategy . onRequestFinished ( ) ; 
private void storeRequestThreadLocal ( @Nonnull final Request request ) { if ( _lockingStrategy ! = null ) { _lockingStrategy . onRequestStart ( request ) ; 
private void backupSession ( final Request request , final Response response , final boolean sessionIdChanged ) { final Session session = request . getRequestedSessionId ( ) ! = null | | getCookie ( response , _sessionCookieName ) ! = null ? request . getSessionInternal ( false ) : null ; if ( session ! = null ) { _statistics . requestWithSession ( ) ; 
public static String createValidityInfoKeyName ( @Nonnull final String sessionId ) { if ( sessionId = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null. " ) ; } return " validity: " + sessionId ; } 
public static byte [ ] encode ( final long maxInactiveInterval , final long lastAccessedTime , final long thisAccessedTime ) { int idx = 0 ; final byte [ ] data = new byte [ 4 + 2 * 8 ] ; encodeNum ( maxInactiveInterval , data , idx , 4 ) ; encodeNum ( lastAccessedTime , data , idx + = 4 , 8 ) ; encodeNum ( thisAccessedTime , data , idx + = 8 , 8 ) ; return data ; } 
public static SessionValidityInfo decode ( @Nonnull final byte [ ] data ) { int idx = 0 ; final int maxInactiveInterval = ( int ) decodeNum ( data , idx , 4 ) ; final long lastAccessedTime = decodeNum ( data , idx + = 4 , 8 ) ; final long thisAccessedTime = decodeNum ( data , idx + = 8 , 8 ) ; return new SessionValidityInfo ( maxInactiveInterval , lastAccessedTime , thisAccessedTime ) ; } 
public boolean isValid ( ) { final long timeNow = System . currentTimeMillis ( ) ; final int timeIdle = ( int ) ( ( timeNow - _thisAccessedTime ) / 1000L ) ; return timeIdle < _maxInactiveInterval ; } 
public NodeLocator createLocator ( final List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes , _nodeIds , _resolver , _sessionIdFormat ) ; } 
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session ) { final byte [ ] idData = serializeId ( session . getIdInternal ( ) ) ; final byte [ ] principalData = session . getPrincipal ( ) ! = null ? serializePrincipal ( session . getPrincipal ( ) ) : null ; final int principalDataLength = principalData ! = null ? principalData . length : 0 ; final int sessionFieldsDataLength = 2 short value for the version the following might change with other versions, refactoring needed then + 2 short value that stores the dataLength + NUM_BYTES bytes that store all session attributes but the id + 2 short value that stores the idData length + idData.length the number of bytes for the id + 2 short value for the authType + 2 short value that stores the principalData length + principalDataLength; the number of bytes for the principal final byte[] data = new byte[sessionFieldsDataLength]; int idx = 0; idx = encodeNum( CURRENT_VERSION, data, idx, 2 ); idx = encodeNum( sessionFieldsDataLength, data, idx, 2 ); idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 ); idx = encodeBoolean( session.isNewInternal(), data, idx ); idx = encodeBoolean( session.isValidInternal(), data, idx ); idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastBackupTime(), data, idx, 8 ); idx = encodeNum( idData.length, data, idx, 2 ); idx = copy( idData, data, idx ); idx = encodeNum( AuthType.valueOfValue( session.getAuthType() ).getId(), data, idx, 2 ); idx = encodeNum( principalDataLength, data, idx, 2 ); copy( principalData, data, idx ); return data; } 
static DeserializationResult deserializeSessionFields ( final byte [ ] data , final Realm realm ) throws InvalidVersionException { final MemcachedBackupSession result = new MemcachedBackupSession ( ) ; final short version = ( short ) decodeNum ( data , 0 , 2 ) ; if ( version ! = CURRENT_VERSION ) { throw new InvalidVersionException ( " The version " + version + " does not match the current version " + CURRENT_VERSION , version ) ; } final short sessionFieldsDataLength = ( short ) decodeNum ( data , 2 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 4 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 12 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 20 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 24 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 25 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 26 , 8 ) ) ; result . setLastBackupTime ( decodeNum ( data , 34 , 8 ) ) ; final short idLength = ( short ) decodeNum ( data , 42 , 2 ) ; result . setIdInternal ( decodeString ( data , 44 , idLength ) ) ; final short authTypeId = ( short ) decodeNum ( data , 44 + idLength , 2 ) ; result . setAuthType ( AuthType . valueOfId ( authTypeId ) . getValue ( ) ) ; final int currentIdx = 44 + idLength + 2 ; final short principalDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( principalDataLength > 0 ) { final byte [ ] principalData = new byte [ principalDataLength ] ; System . arraycopy ( data , currentIdx + 2 , principalData , 0 , principalDataLength ) ; result . setPrincipal ( deserializePrincipal ( principalData , realm ) ) ; } final byte [ ] attributesData = new byte [ data . length - sessionFieldsDataLength ] ; System . arraycopy ( data , sessionFieldsDataLength , attributesData , 0 , data . length - sessionFieldsDataLength ) ; return new DeserializationResult ( result , attributesData ) ; } 
public static long decodeNum ( final byte [ ] data , final int beginIndex , final int numBytes ) { long result = 0 ; for ( int i = 0 ; i < numBytes ; i + + ) { final byte b = data [ beginIndex + i ] ; result = ( result < < 8 ) | ( b < 0 ? 256 + b : b ) ; } return result ; } 
public void testRemove ( ) { final LRUCache < String , String > cut = new LRUCache < String , String > ( 3 ) ; cut . put ( " foo " , " bar " ) ; assertTrue ( cut . containsKey ( " foo " ) ) ; assertEquals ( cut . remove ( " foo " ) , " bar " ) ; assertFalse ( cut . containsKey ( " foo " ) ) ; } 
public void testGetKeysSortedByValue ( ) { final LRUCache < String , Integer > cut = new LRUCache < String , Integer > ( 3 ) ; final String f = " foo " ; final String br = " bar " ; cut . put ( f , 1 ) ; cut . put ( br , 2 ) ; final Comparator < Integer > c = new Comparator < Integer > ( ) { @Override public int compare ( final Integer o1 , final Integer o2 ) { return o1 . compareTo ( o2 ) ; } } ; Assert . assertTrue ( Arrays . equals ( new String [ ] { f , br } , cut . getKeysSortedByValue ( c ) . toArray ( ) ) , " invalid order of items, the keys are not order by their values " ) ; cut . put ( f , 3 ) ; Assert . assertTrue ( Arrays . equals ( new String [ ] { br , f } , cut . getKeysSortedByValue ( c ) . toArray ( ) ) , " invalid order of items, the keys are not order by their values " ) ; 
public int compare ( final Integer o1 , final Integer o2 ) { return o1 . compareTo ( o2 ) ; } 
public void setup ( ) throws Exception { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _manager . setSticky ( true ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.init( _memcachedMock ); 
public void testConfigurationFormatMemcachedNodesFeature44 ( ) { _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _manager . init ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _manager . init ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _manager . init ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testConfigurationFormatFailoverNodesFeature44 ( ) { _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _manager . setFailoverNodes ( " n1 " ) ; _manager . init ( _memcachedMock ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _manager . setFailoverNodes ( " n1 n2 " ) ; _manager . init ( _memcachedMock ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _manager . setFailoverNodes ( " n1,n2 " ) ; _manager . init ( _memcachedMock ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testOnlySendModifiedSessions ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . backupSession ( session , false , null ) . get ( ) ; verify ( _memcachedMock , times ( 2 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; 
public void testOnlyHashAttributesOfAccessedAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . endAccess ( ) ; _manager . backupSession ( session , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . getAttribute ( " foo " ) ; _manager . backupSession ( session , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; _manager . backupSession ( session , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testChangeSessionId ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , TimeoutException { _manager . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _manager . setLockingMode ( LockingMode . NONE , null ) ; } final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false , " foo " ) . get ( ) ; final String oldSessionId = session . getId ( ) ; _manager . changeSessionId ( session ) ; on session backup we specify sessionIdChanged as false as we're not aware of this fact _manager.backupSession( session, false, "foo" ); remove session with old id and add it with the new id verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) ); verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() ); if ( !stickyness.isSticky() ) { check validity info 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private MemcachedClient createMemcachedClient ( final InetSocketAddress address ) throws IOException , InterruptedException { final MemcachedClient result = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdList . create ( _memcachedNodeId ) , NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void testInvalidSessionId ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , " 12345 " ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertTrue ( sessionId1 . indexOf ( '-' ) > - 1 , " Invalid session id format " ) ; } 
public void testSessionAvailableInMemcached ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId1 ) , " Session not available in memcached. " ) ; } 
public void testExpiredSessionRemovedFromMemcached ( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; waitForSessionExpiration ( sessionAffinity . isSticky ( ) ) ; assertNull ( _memcached . get ( sessionId1 ) , " Expired session still existing in memcached " ) ; } 
public void testInvalidSessionNotFound ( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId1 , sessionId2 , " Expired session returned. " ) ; } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( final SessionAffinityMode stickyness ) throws Exception { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; manager . setSticky ( stickyness . isSticky ( ) ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); +1000 just to be sure that we're >4 secs assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( final SessionAffinityMode stickyness ) throws Exception { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; manager . setSticky ( stickyness . isSticky ( ) ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testLoadFromMemcachedOldSessionSerializationFormat ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Session session = manager . createSession ( null ) ; final SessionTranscoder oldSessionTranscoder = manager . getTranscoderFactory ( ) . createSessionTranscoder ( manager ) ; final Future < Boolean > future = _memcached . set ( session . getId ( ) , session . getMaxInactiveInterval ( ) , session , oldSessionTranscoder ) ; assertTrue ( future . get ( ) ) ; final Session loadedFromMemcached = manager . loadFromMemcachedWithCheck ( session . getId ( ) ) ; assertNotNull ( loadedFromMemcached ) ; assertDeepEquals ( session , loadedFromMemcached ) ; } 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setSticky ( true ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) Thread.sleep( 4000 ); final String newSessionId = manager.changeSessionIdOnMemcachedFailover( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
public void testDisableMsmAtRuntime ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; manager . setSticky ( true ) ; disable msm, shutdown our server and our client manager.setEnabled( false ); _memcached.shutdown(); _daemon.stop(); checkSessionFunctionalityWithMsmDisabled(); } 
public void testStartMsmDisabled ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { shutdown our server and our client _memcached.shutdown(); _daemon.stop(); start a new tomcat with msm initially disabled _tomcat1.stop(); Thread.sleep( 500 ); final String memcachedNodes = _memcachedNodeId + ":localhost:" + _memcachedPort; _tomcat1 = createCatalina( _portTomcat1, memcachedNodes, "app1" ); final MemcachedBackupSessionManager manager = getManager( _tomcat1 ); manager.setSticky( true ); manager.setEnabled( false ); _tomcat1.start(); LOG.info( "Waiting, check logs to see if the client causes any 'Connection refused' logging..." ); Thread.sleep( 1000 ); some basic tests for session functionality checkSessionFunctionalityWithMsmDisabled(); start memcached, client and reenable msm _daemon.start(); _memcached = createMemcachedClient( new InetSocketAddress( "localhost", _memcachedPort ) ); manager.setEnabled( true ); Wait a little bit, so that msm's memcached client can connect and is ready when test starts Thread.sleep( 100 ); memcached based stuff should work again final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), "memcached node id missing with msm switched to enabled" ); Thread.sleep( 50 ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); waitForSessionExpiration( true ); assertNull( _memcached.get( sessionId1 ), "Expired session still existing in memcached" ); 
private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( getManager ( _tomcat1 ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id, even with msm disabled. " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed. " ) ; } 
private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; assertEquals ( manager . isSticky ( ) , sticky ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; } 
public void testSetNodeAvailability ( ) { final String nodeId1 = " n1 " ; final CacheLoader < String > cacheLoader = new CacheLoader < String > ( ) { @Override public boolean isNodeAvailable ( final String key ) { return true ; } } ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( nodeId1 ) , Collections . < String > emptyList ( ) ) ; Assert . assertTrue ( cut . isNodeAvailable ( nodeId1 ) ) ; cut . setNodeAvailable ( nodeId1 , false ) ; Assert . assertFalse ( cut . isNodeAvailable ( nodeId1 ) ) ; cut . setNodeAvailable ( nodeId1 , true ) ; Assert . assertTrue ( cut . isNodeAvailable ( nodeId1 ) ) ; 
public final void testGetNextNodeId_SingleNode ( ) { final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( " n1 " ) , null ) ; final String actual = cut . getAvailableNodeId ( " n1 " ) ; assertNull ( actual , " For a sole existing node we cannot get a next node " ) ; } 
public final void testGetNextNodeId_TwoNodes ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( null ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( nodeId1 , nodeId2 ) , null ) ; String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual ) ; actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual ) ; } 
public final void testGetNextNodeId_TwoNodes_NoNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final CacheLoader < String > cacheLoader = new DummyCacheLoader ( Arrays . asList ( nodeId1 ) ) ; final NodeIdService cut = new NodeIdService ( new NodeAvailabilityCache < String > ( 10 , 100 , cacheLoader ) , NodeIdList . create ( nodeId1 , nodeId2 ) , null ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_RegularNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId1 ) ; assertEquals ( nodeId2 , actual , " The failover node is not chosen " ) ; } 
public final void testGetNextNodeId_FailoverNode_RegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId1 , actual , " The regular node is not chosen " ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertNull ( actual ) ; } 
public final void testGetNextNodeId_FailoverNode_NoRegularNodeButAnotherFailoverNodeLeft ( ) { final String nodeId1 = " n1 " ; final String nodeId2 = " n2 " ; final String nodeId3 = " n3 " ; final NodeIdService cut = new NodeIdService ( createNodeAvailabilityCache ( nodeId1 ) , NodeIdList . create ( nodeId1 ) , Arrays . asList ( nodeId2 , nodeId3 ) ) ; final String actual = cut . getAvailableNodeId ( nodeId2 ) ; assertEquals ( nodeId3 , actual , " The second failover node is not chosen " ) ; } 
public void testRegisterReadOnlyAndModifyingRequests ( ) { final ReadOnlyRequestsCache cut = new ReadOnlyRequestsCache ( ) ; track a request as readonly and check that it's returned cut.readOnlyRequest( "foo" ); readOnlyRequestsShouldContain( cut, "foo", true ); track the same request as modifying, it should not longer be there cut.modifyingRequest( "foo" ); readOnlyRequestsShouldContain( cut, "foo", false ); track another request as modifying cut.modifyingRequest( "bar" ); readOnlyRequestsShouldContain( cut, "bar", false ); after tracking the same request as readonly it should also not be returned as readonly cut.readOnlyRequest( "bar" ); readOnlyRequestsShouldContain( cut, "bar", false ); 
public void testGetReadOnlyRequestsByFrequency ( ) { final ReadOnlyRequestsCache cut = new ReadOnlyRequestsCache ( ) ; track a request as readonly and check that it's returned cut.readOnlyRequest( "foo" ); cut.readOnlyRequest( "bar" ); cut.readOnlyRequest( "bar" ); assertTrue( Arrays.equals( new String[] { "foo", "bar" }, cut.getReadOnlyRequestsByFrequency().toArray() ) ); cut.readOnlyRequest( "foo" ); cut.readOnlyRequest( "foo" ); assertTrue( Arrays.equals( new String[] { "bar", "foo" }, cut.getReadOnlyRequestsByFrequency().toArray() ) ); 
private void readOnlyRequestsShouldContain ( final ReadOnlyRequestsCache cut , final String key , final boolean shouldBeContained ) { assertEquals ( cut . isReadOnlyRequest ( key ) , shouldBeContained ) ; assertEquals ( cut . getReadOnlyRequests ( ) . contains ( key ) , shouldBeContained ) ; assertEquals ( cut . getReadOnlyRequestsByFrequency ( ) . contains ( key ) , shouldBeContained ) ; } 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final Session session = ( Session ) mock ( Session . class ) . proxy ( ) ; final String sessionId = " foo " ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestURI " ) . will ( returnValue ( " /foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getMethod " ) . will ( returnValue ( " GET " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getQueryString " ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( false ) , ANYTHING ) . will ( returnValue ( new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final Mock sessionControl = mock ( Session . class ) ; final Session session = ( Session ) sessionControl . proxy ( ) ; final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " changeSessionId " ) . with ( eq ( newSessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getSessionInternal " ) . with ( eq ( false ) ) . will ( returnValue ( session ) ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestURI " ) . will ( returnValue ( " /foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getMethod " ) . will ( returnValue ( " GET " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getQueryString " ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( session ) , eq ( true ) , ANYTHING ) . will ( returnValue ( new SimpleFuture < BackupResultStatus > ( BackupResultStatus . SUCCESS ) ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
public void testDecodeEncodedData ( ) { final byte [ ] encoded = SessionValidityInfo . encode ( 23 , 42 , 4711 ) ; final SessionValidityInfo decoded = SessionValidityInfo . decode ( encoded ) ; assertEquals ( decoded . getMaxInactiveInterval ( ) , 23 ) ; assertEquals ( decoded . getLastAccessedTime ( ) , 42 ) ; assertEquals ( decoded . getThisAccessedTime ( ) , 4711 ) ; } 
public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager . getContainer ( ) . getRealm ( ) ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionFieldsWithAuthenticatedPrincipal ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final Realm realm = _manager . getContainer ( ) . getRealm ( ) ; session . setAuthType ( Constants . FORM_METHOD ) ; session . setPrincipal ( new GenericPrincipal ( realm , " foo " , " bar " ) ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , realm ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager . getContainer ( ) . getRealm ( ) , _manager ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager . getContainer ( ) . getRealm ( ) , _manager ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } 
private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastBackupTime ( ) , deserialized . getLastBackupTime ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; Assert . assertEquals ( session . getAuthType ( ) , deserialized . getAuthType ( ) ) ; assertDeepEquals ( session . getPrincipal ( ) , deserialized . getPrincipal ( ) ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _httpClient = new DefaultHttpClient ( ) ; } 
public void testRelocateSession ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = extractNodeId ( sid2 ) ; assertNotSame ( secondNode , firstNode , " First node again selected " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + secondNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; we must get the same session back assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( sid2 )[0], "The session should exist in memcached." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
public void testMultipleMemcachedNodesFailure ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; final Map . Entry < String , MemCacheDaemon < ? > > otherNodeWithId = info . otherNode ( ) ; otherNodeWithId . getValue ( ) . stop ( ) ; Thread . sleep ( 300 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = extractNodeId ( sid2 ) ; LOG . debug ( " Have secondNode " + secondNode ) ; final String expectedNode = info . otherNodeExcept ( otherNodeWithId . getKey ( ) ) . getKey ( ) ; assertEquals ( secondNode , expectedNode , " Unexpected nodeId: " + secondNode + " . " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; we must get the same session back assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( sid2 )[0], "The session should exist in memcached." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
public void testAllMemcachedNodesFailure ( ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( true ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; assertEquals ( sid1 , sid2 , " SessionId changed. " ) ; assertNotNull ( getSessions ( ) . get ( sid1 ) , " Session " + sid1 + " not existing. " ) ; final Session session = getManager ( _tomcat1 ) . findSession ( sid2 ) ; assertFalse ( session . getNoteNames ( ) . hasNext ( ) , " Some notes are set: " + toArray ( session . getNoteNames ( ) ) ) ; 
public void testCookieNotSetWhenAllMemcachedsDownIssue40 ( ) throws IOException , HttpException { getManager ( _tomcat1 ) . setSticky ( true ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _daemon3 . stop ( ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertNull ( nodeId , " NodeId should be null, but is " + nodeId + " . " ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
public void testCookieNotSetWhenRegularMemcachedDownIssue40 ( final SessionAffinityMode sessionAffinity ) throws Exception { _daemon2 . stop ( ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertEquals ( nodeId , _nodeId1 ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
public void testReconfigureMemcachedNodesAtRuntimeFeature46 ( final SessionAffinityMode sessionAffinity ) throws Exception { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( response2 . getSessionId ( ) , sessionId1 ) ; final String sessionId2 = response2 . getResponseSessionId ( ) ; assertNotNull ( sessionId2 ) ; assertEquals ( extractNodeId ( sessionId2 ) , _nodeId3 ) ; 
public void testReconfigureFailoverNodesAtRuntimeFeature46 ( ) throws Exception { getManager ( _tomcat1 ) . setSticky ( true ) ; getManager ( _tomcat1 ) . setFailoverNodes ( _nodeId1 + " " + _nodeId2 ) ; we need to use another http client, otherwise there's no response cookie. final Response response2 = get( new DefaultHttpClient(), _portTomcat1, null ); final String sessionId2 = response2.getSessionId(); assertNotNull( sessionId2 ); assertEquals( extractNodeId( sessionId2 ), _nodeId3 ); 
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdList . create ( NODE_ID_1 , NODE_ID_2 ) , NodeIdResolver . node ( NODE_ID_1 , address1 ) . node ( NODE_ID_2 , address2 ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , PlainSocketFactory . getSocketFactory ( ) , 80 ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; } 
private Embedded startTomcat ( final int port ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = createCatalina ( port , 5 , MEMCACHED_NODES ) ; getManager ( tomcat ) . setSticky ( false ) ; tomcat . start ( ) ; return tomcat ; } 
public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _executor . shutdownNow ( ) ; } 
public Object [ ] [ ] lockingModes ( ) { return new Object [ ] [ ] { { LockingMode . ALL , null } , 
public Object [ ] [ ] lockingModesWithSessionLocking ( ) { return new Object [ ] [ ] { { LockingMode . ALL , null } , 
public void testNoStaleSessionsWithNonStickySessions ( ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat2 ) . setMaxInactiveInterval ( 1 ) ; final String key = " foo " ; final String value1 = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value1 ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; final Object session = _client . get ( sessionId1 ) ; assertNotNull ( session , " Session not found in memcached: " + sessionId1 ) ; final Response response = get ( _httpClient , TC_PORT_1 , sessionId1 ) ; assertEquals ( response . getSessionId ( ) , sessionId1 ) ; assertEquals ( response . get ( key ) , value2 ) ; 
public void testParallelRequestsDontCauseDataLoss ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { setLockingMode ( lockingMode , uriPattern ) ; final String key1 = " k1 " ; final String value1 = " v1 " ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , key1 , value1 ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; final String key2 = " k2 " ; final String value2 = " v2 " ; LOG . info ( " Start request 1 " ) ; final Future < Response > response1 = _executor . submit ( new Callable < Response > ( ) { @Override public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , key2 , value2 ) ) ; } } ) ; Thread . sleep ( 100 ) ; final String key3 = " k3 " ; final String value3 = " v3 " ; LOG . info ( " Start request 2 " ) ; final Response response2 = post ( _httpClient , TC_PORT_2 , sessionId , key3 , value3 ) ; assertEquals ( response1 . get ( ) . getSessionId ( ) , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId ) ; final Response response3 = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response3 . getSessionId ( ) , sessionId ) ; LOG . info ( " Got response for request 2 " ) ; assertEquals ( response3 . get ( key1 ) , value1 ) ; assertEquals ( response3 . get ( key2 ) , value2 ) ; assertEquals ( response3 . get ( key3 ) , value3 ) ; failed without session locking 
public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , key2 , value2 ) ) ; 
public void testReadOnlyRequestsDontLockSessionForAutoLocking ( ) throws IOException , InterruptedException , HttpException , ExecutionException { setLockingMode ( LockingMode . AUTO , null ) ; final String key1 = " k1 " ; final String value1 = " v1 " ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , key1 , value1 ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; perform a readonly request without waiting, we perform this one later again final String path = "/mypath"; final Map<String, String> params = asMap( "foo", "bar" ); final Response response0 = get( _httpClient, TC_PORT_1, path, sessionId, params ); assertEquals( response0.getSessionId(), sessionId ); perform a readonly, waiting request that we can perform again later final long timeToWaitInMillis = 500; final Map<String, String> paramsWait = asMap( PARAM_MILLIS, String.valueOf( timeToWaitInMillis ) ); final Response response1 = get( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, paramsWait ); assertEquals( response1.getSessionId(), sessionId ); now do it again, now in the background, and in parallel start another readonly request, both should not block each other final long start = System.currentTimeMillis(); final Future<Response> response2 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, paramsWait ); } }); final Future<Response> response3 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, paramsWait ); } }); response2.get(); response3.get(); assertTrue ( ( System.currentTimeMillis() - start ) < ( 2 * timeToWaitInMillis ), "The time for both requests should be less than 2 * the wait time if they don't block each other." ); assertEquals( response2.get().getSessionId(), sessionId ); assertEquals( response3.get().getSessionId(), sessionId ); now perform a modifying request and a readonly in parallel which should not be blocked final Future<Response> response4 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return post( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, asMap( PARAM_MILLIS, "500", "foo", "bar" ) ); } }); Thread.sleep( 50 ); final Response response5 = get( _httpClient, TC_PORT_1, path, sessionId, params ); assertEquals( response5.getSessionId(), sessionId ); assertFalse( response4.isDone(), "The readonly request should return before the long, session locking one" ); assertEquals( response4.get().getSessionId(), sessionId ); 
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , paramsWait ) ; } 
public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " foo " , " bar " ) ) ; } 
public void testRequestsDontLockSessionForNotMatchingUriPattern ( ) throws IOException , InterruptedException , HttpException , ExecutionException { final String pathToLock = " /locksession " ; setLockingMode ( LockingMode . URI_PATTERN , Pattern . compile ( pathToLock + " .* " ) ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; perform a request not matching the uri pattern, and in parallel start another request that should lock the session final long timeToWaitInMillis = 500; final Map<String, String> paramsWait = asMap( PARAM_WAIT, "true", PARAM_MILLIS, String.valueOf( timeToWaitInMillis ) ); final long start = System.currentTimeMillis(); final Future<Response> response2 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, "/pathNotMatchingLockUriPattern", sessionId, paramsWait ); } }); final Future<Response> response3 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, pathToLock, sessionId, paramsWait ); } }); response2.get(); response3.get(); assertTrue ( ( System.currentTimeMillis() - start ) < ( 2 * timeToWaitInMillis ), "The time for both requests should be less than 2 * the wait time if they don't block each other." ); assertEquals( response2.get().getSessionId(), sessionId ); assertEquals( response3.get().getSessionId(), sessionId ); now perform a locking request and a not locking in parallel which should also not be blocked final Future<Response> response4 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, pathToLock, sessionId, paramsWait ); } }); Thread.sleep( 50 ); final Response response5 = get( _httpClient, TC_PORT_1, "/pathNotMatchingLockUriPattern", sessionId ); assertEquals( response5.getSessionId(), sessionId ); assertFalse( response4.isDone(), "The non locking request should return before the long, session locking one" ); assertEquals( response4.get().getSessionId(), sessionId ); 
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , " /pathNotMatchingLockUriPattern " , sessionId , paramsWait ) ; } 
public Response call ( ) throws Exception { return get ( _httpClient , TC_PORT_1 , pathToLock , sessionId , paramsWait ) ; } 
public void testNonStickySessionIsValidEvenWhenAccessedReadonly ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat1 ) . setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; 
public void testNonStickySessionIsValidForDifferentSessionTrackingModes ( @Nonnull final SessionTrackingMode sessionTrackingMode ) throws IOException , InterruptedException , HttpException , ExecutionException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat1 ) . setLockingMode ( LockingMode . ALL , null ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Response response = get ( _httpClient , TC_PORT_1 , PATH_GET_REQUESTED_SESSION_INFO , sessionId , sessionTrackingMode , null , null ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( KEY_REQUESTED_SESSION_ID ) , sessionId ) ; assertEquals ( Boolean . parseBoolean ( response . get ( KEY_IS_REQUESTED_SESSION_ID_VALID ) ) , true ) ; Thread . sleep ( 100 ) ; response = get ( _httpClient , TC_PORT_1 , PATH_GET_REQUESTED_SESSION_INFO , sessionId , sessionTrackingMode , null , null ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( KEY_REQUESTED_SESSION_ID ) , sessionId ) ; assertEquals ( Boolean . parseBoolean ( response . get ( KEY_IS_REQUESTED_SESSION_ID_VALID ) ) , true ) ; 
public void testNonStickySessionIsStoredInSecondaryMemcachedForBackup ( ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat2 ) . setMaxInactiveInterval ( 1 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId1 ) ; final MemCacheDaemon < ? > primary = nodeId . equals ( NODE_ID_1 ) ? _daemon1 : _daemon2 ; final MemCacheDaemon < ? > secondary = nodeId . equals ( NODE_ID_1 ) ? _daemon2 : _daemon1 ; assertNotNull ( primary . getCache ( ) . get ( sessionId1 ) [ 0 ] ) ; assertNotNull ( primary . getCache ( ) . get ( createValidityInfoKeyName ( sessionId1 ) ) [ 0 ] ) ; The executor needs some time to finish the backup... Thread.sleep( 100 ); assertNotNull( secondary.getCache().get( fmt.createBackupKey( sessionId1 ) )[0] ); assertNotNull( secondary.getCache().get( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) )[0] ); 
public Object [ ] [ ] sessionTrackingModesProvider ( ) { return new Object [ ] [ ] { { SessionTrackingMode . COOKIE } , 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { LOG . info ( " + starting... " ) ; final String pathInfo = request . getPathInfo ( ) ; if ( PATH_GET_REQUESTED_SESSION_INFO . equals ( pathInfo ) ) { LOG . info ( " getRequestedSessionId: " + request . getRequestedSessionId ( ) ) ; LOG . info ( " isRequestedSessionIdValid: " + request . isRequestedSessionIdValid ( ) ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( KEY_REQUESTED_SESSION_ID + " = " + request . getRequestedSessionId ( ) ) ; out . println ( KEY_IS_REQUESTED_SESSION_ID_VALID + " = " + request . isRequestedSessionIdValid ( ) ) ; } else { final HttpSession session = request . getSession ( ) ; waitIfRequested ( request ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + session . getId ( ) ) ; final HttpSession session = request.getSession( false ); if ( session != null ) { final Enumeration<?> attributeNames = session.getAttributeNames(); while ( attributeNames.hasMoreElements() ) { final String name = attributeNames.nextElement().toString(); final Object value = session.getAttribute( name ); out.println( name + "=" + value ); } } } LOG.info( " - finished." ); 
protected void doPost ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { LOG . info ( " invoked " ) ; final HttpSession session = request . getSession ( ) ; waitIfRequested ( request ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( " OK: " + session . getId ( ) ) ; @SuppressWarnings ( " unchecked " ) final Enumeration < String > names = request . getParameterNames ( ) ; while ( names . hasMoreElements ( ) ) { final String name = names . nextElement ( ) ; 
public static Response get ( final DefaultHttpClient client , final int port , final String rsessionId , final Credentials credentials ) throws IOException , HttpException { return get ( client , port , null , rsessionId , null , null , credentials ) ; } 
public static Response get ( final DefaultHttpClient client , final int port , final String path , final String rsessionId ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null , null , null ) ; } 
public static Response get ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { return get ( client , port , path , rsessionId , null , params , null ) ; } 
private static String getUrl ( final int port , String path ) throws IllegalArgumentException { we assume the context_path is "/" if ( path != null && !path.startsWith( "/" ) ) { but we can also fix this path = CONTEXT_PATH + path; } return "http:"+ DEFAULT_HOST +":"+ port + ( path != null ? path : CONTEXT_PATH ); } 
private static String toQueryString ( final Map < String , String > params ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " ? " ) ; for ( final Iterator < Entry < String , String > > iterator = params . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { final Entry < String , String > entry = iterator . next ( ) ; sb . append ( entry . getKey ( ) ) . append ( " = " ) . append ( entry . getValue ( ) ) ; if ( iterator . hasNext ( ) ) { sb . append ( " & " ) ; } } final String qs = sb . toString ( ) ; return qs ; } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:"+ DEFAULT_HOST +":"+ port; final String url = getUrl( port, path ); final HttpPost method = new HttpPost( url ); if ( rsessionId != null ) { method.setHeader( "Cookie", "JSESSIONID=" + rsessionId ); } method.setEntity( createFormEntity( params ) ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); final HttpResponse response = client.execute( method ); final int statusCode = response.getStatusLine().getStatusCode(); if ( statusCode == 302 ) { return redirect( response, client, port, rsessionId, baseUri ); } if ( statusCode != 200 ) { throw new RuntimeException( "GET did not return status 200, but " + response.getStatusLine() ); } return readResponse( rsessionId, response ); } 
public static MemCacheDaemon < ? extends CacheElement > createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon < LocalCacheElement > daemon = new MemCacheDaemon < LocalCacheElement > ( ) ; final ConcurrentLinkedHashMap < String , LocalCacheElement > cacheStorage = ConcurrentLinkedHashMap . create ( EvictionPolicy . LRU , 100000 , 1024 * 1024 ) ; daemon . setCache ( new CacheImpl ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( true ) ; return daemon ; } 
public String get ( final String key ) { return _keyValues . get ( key ) ; } 
public static < T > Map < T , T > asMap ( final T . . . keysAndValues ) { if ( keysAndValues = = null ) { return null ; } if ( keysAndValues . length % 2 ! = 0 ) { throw new IllegalArgumentException ( " You must provide an even number of arguments as key/value pairs. " ) ; } final Map < T , T > result = new HashMap < T , T > ( ) ; for ( int i = 0 ; i < keysAndValues . length ; i + + ) { if ( i % 2 = = 1 ) { result . put ( keysAndValues [ i - 1 ] , keysAndValues [ i ] ) ; } } return result ; } 
public abstract boolean isSticky ( ) ; } @DataProvider public static Object [ ] [ ] stickynessProvider ( ) { return new Object [ ] [ ] { { SessionAffinityMode . STICKY } , { SessionAffinityMode . NON_STICKY } } ; } } 
public static Object [ ] [ ] stickynessProvider ( ) { return new Object [ ] [ ] { { SessionAffinityMode . STICKY } , 
public void setUp ( ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdList . create ( NODE_ID ) , NodeIdResolver . node ( NODE_ID , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private Embedded startTomcat ( final int port , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( true ) ; return tomcat ; } 
public void testSerializationOfAuthStuffWithFormAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " , JavolutionTranscoderFactory . class . getName ( ) ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdList . create ( _memcachedNodeId ) , NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public void testLoadFromMemcachedOldSessionSerializationFormat ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Session session = manager . createSession ( null ) ; final SessionTranscoder oldSessionTranscoder = manager . getTranscoderFactory ( ) . createSessionTranscoder ( manager ) ; final Future < Boolean > future = _memcached . set ( session . getId ( ) , session . getMaxInactiveInterval ( ) , session , oldSessionTranscoder ) ; Assert . assertTrue ( future . get ( ) ) ; final Session loadedFromMemcached = manager . loadFromMemcachedWithCheck ( session . getId ( ) ) ; Assert . assertNotNull ( loadedFromMemcached ) ; Assert . assertNotNull ( loadedFromMemcached . getManager ( ) ) ; Assert . assertNotNull ( loadedFromMemcached . getNoteNames ( ) ) ; assertDeepEquals ( session , loadedFromMemcached ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; _tomcat1 = createCatalina ( _portTomcat1 , memcachedNodes , " app1 " , XStreamTranscoderFactory . class . getName ( ) ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = new MemcachedClient ( new SuffixLocatorConnectionFactory ( NodeIdList . create ( _memcachedNodeId ) , NodeIdResolver . node ( _memcachedNodeId , address ) . build ( ) , new SessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( new InetSocketAddress ( " localhost " , _memcachedPort ) ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); _httpClient = new DefaultHttpClient(); } 
public void testLoadFromMemcachedOldSessionSerializationFormat ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSessionManager manager = getManager ( _tomcat1 ) ; final Session session = manager . createSession ( null ) ; final SessionTranscoder oldSessionTranscoder = manager . getTranscoderFactory ( ) . createSessionTranscoder ( manager ) ; Future < Boolean > future = _memcached . set ( session . getId ( ) , session . getMaxInactiveInterval ( ) , session , oldSessionTranscoder ) ; Assert . assertTrue ( future . get ( ) ) ; final Session loadedFromMemcached = manager . loadFromMemcachedWithCheck ( session . getId ( ) ) ; Assert . assertNotNull ( loadedFromMemcached ) ; assertDeepEquals ( session , loadedFromMemcached ) ; } 
public void testMultipleMemcachedNodesFailure ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; final Map . Entry < String , MemCacheDaemon < ? > > otherNodeWithId = info . previousNode ( ) ; otherNodeWithId . getValue ( ) . stop ( ) ; Thread . sleep ( 100 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = extractNodeId ( sid2 ) ; LOG . debug ( " Have secondNode " + secondNode ) ; final String expectedNode = info . otherNodeExcept ( otherNodeWithId . getKey ( ) ) . getKey ( ) ; assertEquals ( secondNode , expectedNode , " Unexpected nodeId: " + secondNode + " . " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; we must get the same session back assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( sid2 )[0], "The session should exist in memcached." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
private Map < String , MemCacheDaemon < ? > > asMap ( final String nodeId1 , final MemCacheDaemon < ? > daemon1 , final String nodeId2 , final MemCacheDaemon < ? > daemon2 ) { final Map < String , MemCacheDaemon < ? > > result = new LinkedHashMap < String , MemCacheDaemon < ? > > ( 2 ) ; result . put ( nodeId1 , daemon1 ) ; result . put ( nodeId2 , daemon2 ) ; return result ; } 
public Entry < String , MemCacheDaemon < ? > > previousNode ( ) { Entry < String , MemCacheDaemon < ? > > last = null ; for ( final Entry < String , MemCacheDaemon < ? > > entry : otherNodes . entrySet ( ) ) { last = entry ; } return last ; } 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final MemcachedClient memcached , @Nonnull final MemcachedBackupSessionManager manager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : return new LockingStrategyAll ( memcached , missingSessionsCache , storeSecondaryBackup ) ; 
protected void onAfterBackupSession ( @Nonnull final MemcachedBackupSession session , final boolean backupWasForced , @Nonnull final Future < BackupResult > result , @Nonnull final String requestId , @Nonnull final BackupSessionService backupSessionService ) { if ( ! backupWasForced ) { pingSessionIfBackupWasSkipped ( session , result , backupSessionService ) ; } final byte [ ] data = encode ( session . getMaxInactiveInterval ( ) , session . getLastAccessedTimeInternal ( ) , session . getThisAccessedTimeInternal ( ) ) ; final String key = createValidityInfoKeyName ( session . getIdInternal ( ) ) ; _memcached . set ( key , session . getMaxInactiveInterval ( ) , data ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Stored session validity info for session " + session . getIdInternal ( ) ) ; } if ( _storeSecondaryBackup ) { final Callable < ? > backupTask = new StoreNonStickySessionBackupTask ( session , result ) ; 
void init ( final MemcachedClient memcachedClient ) { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; if ( initialized ) { return ; } super . init ( ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = new SessionTrackerValve ( _requestUriIgnorePattern , ( Context ) getContainer ( ) , this , _statistics , _enabled ) ; getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( config ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
protected static MemcachedConfig createMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final List < String > nodeIds = new ArrayList < String > ( ) ; final Matcher matcher = NODE_PATTERN . matcher ( memcachedNodes ) ; final List < InetSocketAddress > addresses = new ArrayList < InetSocketAddress > ( ) ; final Map < InetSocketAddress , String > address2Ids = new HashMap < InetSocketAddress , String > ( ) ; while ( matcher . find ( ) ) { initHandleNodeDefinitionMatch ( matcher , addresses , address2Ids , nodeIds ) ; } final List < String > failoverNodeIds = initFailoverNodes ( failoverNodes , nodeIds ) ; if ( nodeIds . isEmpty ( ) ) { throw new IllegalArgumentException ( " All nodes are also configured as failover nodes, " + " this is a configuration failure. In this case, you probably want to leave out the failoverNodes. " ) ; } return new MemcachedConfig ( memcachedNodes , failoverNodes , new NodeIdList ( nodeIds ) , failoverNodeIds , addresses , address2Ids ) ; } 
private static List < String > initFailoverNodes ( final String failoverNodes , final List < String > nodeIds ) { final List < String > failoverNodeIds = new ArrayList < String > ( ) ; if ( failoverNodes ! = null & & failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodesArray = failoverNodes . split ( " |, " ) ; for ( final String failoverNode : failoverNodesArray ) { final String nodeId = failoverNode . trim ( ) ; if ( ! nodeIds . remove ( nodeId ) ) { throw new IllegalArgumentException ( " Invalid failover node id " + nodeId + " : " + " not existing in memcachedNodes ' " + nodeIds + " '. " ) ; } failoverNodeIds . add ( nodeId ) ; } } return failoverNodeIds ; } 
private static void initHandleNodeDefinitionMatch ( final Matcher matcher , final List < InetSocketAddress > addresses , final Map < InetSocketAddress , String > address2Ids , final List < String > nodeIds ) { final String nodeId = matcher . group ( 1 ) ; nodeIds . add ( nodeId ) ; final String hostname = matcher . group ( 2 ) ; final int port = Integer . parseInt ( matcher . group ( 3 ) ) ; final InetSocketAddress address = new InetSocketAddress ( hostname , port ) ; addresses . add ( address ) ; address2Ids . put ( address , nodeId ) ; } 
private MemcachedConfig reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( _memcached ! = null ) { _memcached . shutdown ( ) ; } _memcached = memcachedClient ; _nodeIdService = nodeIdService ; _backupSessionService = backupSessionService ; initNonStickyLockingMode ( config ) ; return config ; } 
private void initNonStickyLockingMode ( @Nonnull final MemcachedConfig config ) { if ( _sticky ) { setLockingMode ( null , null , false ) ; return ; } Pattern uriPattern = null ; LockingMode lockingMode = null ; if ( _lockingMode ! = null ) { if ( _lockingMode . startsWith ( " uriPattern: " ) ) { lockingMode = LockingMode . URI_PATTERN ; uriPattern = Pattern . compile ( _lockingMode . substring ( " uriPattern: " . length ( ) ) ) ; } else { lockingMode = LockingMode . valueOf ( _lockingMode . toUpperCase ( ) ) ; } } if ( lockingMode = = null ) { lockingMode = LockingMode . NONE ; } final boolean storeSecondaryBackup = config . getCountNodes ( ) > 1 ; setLockingMode ( lockingMode , uriPattern , storeSecondaryBackup ) ; } 
public void testChangeSessionId ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , TimeoutException { _manager . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _manager . setLockingMode ( LockingMode . NONE , null , false ) ; } final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session , false , " foo " ) . get ( ) ; final String oldSessionId = session . getId ( ) ; _manager . changeSessionId ( session ) ; on session backup we specify sessionIdChanged as false as we're not aware of this fact _manager.backupSession( session, false, "foo" ); remove session with old id and add it with the new id verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) ); verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() ); if ( !stickyness.isSticky() ) { check validity info 
public void testNonStickySessionIsValidEvenWhenAccessedReadonly ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat1 ) . setLockingMode ( lockingMode , uriPattern , true ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; 
public void testNonStickySessionIsValidForDifferentSessionTrackingModes ( @Nonnull final SessionTrackingMode sessionTrackingMode ) throws IOException , InterruptedException , HttpException , ExecutionException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat1 ) . setLockingMode ( LockingMode . ALL , null , true ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Response response = get ( _httpClient , TC_PORT_1 , PATH_GET_REQUESTED_SESSION_INFO , sessionId , sessionTrackingMode , null , null ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( KEY_REQUESTED_SESSION_ID ) , sessionId ) ; assertEquals ( Boolean . parseBoolean ( response . get ( KEY_IS_REQUESTED_SESSION_ID_VALID ) ) , true ) ; Thread . sleep ( 100 ) ; response = get ( _httpClient , TC_PORT_1 , PATH_GET_REQUESTED_SESSION_INFO , sessionId , sessionTrackingMode , null , null ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( KEY_REQUESTED_SESSION_ID ) , sessionId ) ; assertEquals ( Boolean . parseBoolean ( response . get ( KEY_IS_REQUESTED_SESSION_ID_VALID ) ) , true ) ; 
public void testNoBackupWhenRunningASingleMemcachedOnly ( ) throws IOException , HttpException { getManager ( _tomcat1 ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; try { final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; 
public void stop ( ) throws LifecycleException { if ( initialized ) { _backupSessionService . shutdown ( ) ; 
public void testSessionNotLoadedForReadonlyRequest ( ) throws IOException , HttpException { getManager ( _tomcat1 ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; try { 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { LOG . info ( " + starting... " ) ; final String pathInfo = request . getPathInfo ( ) ; if ( PATH_GET_REQUESTED_SESSION_INFO . equals ( pathInfo ) ) { LOG . info ( " getRequestedSessionId: " + request . getRequestedSessionId ( ) ) ; LOG . info ( " isRequestedSessionIdValid: " + request . isRequestedSessionIdValid ( ) ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( KEY_REQUESTED_SESSION_ID + " = " + request . getRequestedSessionId ( ) ) ; out . println ( KEY_IS_REQUESTED_SESSION_ID_VALID + " = " + request . isRequestedSessionIdValid ( ) ) ; } else if ( PATH_NO_SESSION_ACCESS . equals ( pathInfo ) ) { LOG . info ( " skipping session access " ) ; response . getWriter ( ) . println ( " Skipped session access " ) ; } else { final HttpSession session = request . getSession ( ) ; waitIfRequested ( request ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + session . getId ( ) ) ; final HttpSession session = request.getSession( false ); if ( session != null ) { final Enumeration<?> attributeNames = session.getAttributeNames(); while ( attributeNames.hasMoreElements() ) { final String name = attributeNames.nextElement().toString(); final Object value = session.getAttribute( name ); out.println( name + "=" + value ); } } } LOG.info( " - finished." ); 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId , @Nonnull final String nodeId ) { final String nextNodeId = _nodeIdService . getNextNodeId ( nodeId ) ; if ( ! _nodeIdService . isNodeAvailable ( nextNodeId ) ) { _log . info ( " Node " + nodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( _sessionIdFormat . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , getContainer ( ) . getRealm ( ) , this ) ; session . setSticky ( _sticky ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; _log . debug ( " Session needs to be relocated, setting new id on session... " ) ; final String newSessionId = _sessionIdFormat . createNewSessionId ( requestedSessionId , nextNodeId ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { final MemcachedBackupSession result ; if ( object instanceof MemcachedBackupSession ) { result = ( MemcachedBackupSession ) object ; } else { result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; } result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } _statistics . getLoadFromMemcachedProbe ( ) . registerSince ( start ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } } return null ; } 
private void swapOut ( @Nonnull final StandardSession session ) { implementation like the one in PersistentManagerBase.swapOut if (!session.isValid()) { return; } session.passivate(); remove( session, false ); session.recycle(); } 
private byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { final long start = System . currentTimeMillis ( ) ; final byte [ ] attributesData = _transcoderService . serializeAttributes ( session , attributes ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , start ) ; return attributesData ; } 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestURI ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesInternal() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.registerSince( ATTRIBUTES_SERIALIZATION, startSerialization ); _statistics.register( CACHED_DATA_SIZE, data.length ); return new SimpleFuture<BackupResult>( new BackupResult( BackupResultStatus.SUCCESS ) ); } @Override public Session findSession( final String id ) throws IOException { final Session result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.registerSince( LOAD_FROM_MEMCACHED, startDeserialization ); return null; } }} 
public Future < BackupResult > backupSession ( final Session session , final boolean sessionIdChanged , final String requestURI ) { _log . info ( " Serializing session data for session " + session . getIdInternal ( ) ) ; final long startSerialization = System . currentTimeMillis ( ) ; final byte [ ] data = _transcoderService . serializeAttributes ( ( MemcachedBackupSession ) session , ( ( MemcachedBackupSession ) session ) . getAttributesInternal ( ) ) ; _log . info ( String . format ( " Serializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) data . length / 1000 , session . getIdInternal ( ) , System . currentTimeMillis ( ) - startSerialization ) ) ; _sessionData . put ( session . getIdInternal ( ) , data ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , startSerialization ) ; _statistics . register ( CACHED_DATA_SIZE , data . length ) ; return new SimpleFuture < BackupResult > ( new BackupResult ( BackupResultStatus . SUCCESS ) ) ; } 
protected void updateExpirationInMemcached ( ) { } private final class SessionDeserialization implements Callable < Void > { private final String _id ; private final byte [ ] _data ; private SessionDeserialization ( final String id , final byte [ ] data ) { _id = id ; _data = data ; } @Override public Void call ( ) throws Exception { _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s (asynchronously). " , ( double ) _data . length / 1000 , _id ) ) ; final long startDeserialization = System . currentTimeMillis ( ) ; try { _transcoderService . deserializeAttributes ( _data ) ; } catch ( final Exception e ) { _log . warn ( " Could not deserialize session data. " , e ) ; } _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) _data . length / 1000 , _id , System . currentTimeMillis ( ) - startDeserialization ) ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , startDeserialization ) ; return null ; } } } 
public Void call ( ) throws Exception { _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s (asynchronously). " , ( double ) _data . length / 1000 , _id ) ) ; final long startDeserialization = System . currentTimeMillis ( ) ; try { _transcoderService . deserializeAttributes ( _data ) ; } catch ( final Exception e ) { _log . warn ( " Could not deserialize session data. " , e ) ; } _log . info ( String . format ( " Deserializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) _data . length / 1000 , _id , System . currentTimeMillis ( ) - startDeserialization ) ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , startDeserialization ) ; return null ; } 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final MemcachedClient memcached , @Nonnull final MemcachedBackupSessionManager manager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup , @Nonnull final Statistics stats ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : 
protected LockStatus lock ( final String sessionId , final long timeout , final TimeUnit timeUnit ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Locking session " + sessionId ) ; } final long start = System . currentTimeMillis ( ) ; try { acquireLock ( sessionId , LOCK_RETRY_INTERVAL , LOCK_MAX_RETRY_INTERVAL , timeUnit . toMillis ( timeout ) , 
protected void checkTimeoutAndWait ( @Nonnull final String sessionId , final long retryInterval , final long maxRetryInterval , final long timeout , final long start ) throws TimeoutException , InterruptedException { if ( System . currentTimeMillis ( ) > = start + timeout ) { throw new TimeoutException ( " Reached timeout when trying to aquire lock for session " + sessionId ) ; } final long timeToWait = min ( retryInterval , maxRetryInterval ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Could not aquire lock for session " + sessionId + " , waiting " + timeToWait + " millis now... " ) ; } sleep ( timeToWait ) ; } 
protected void onAfterBackupSession ( @Nonnull final MemcachedBackupSession session , final boolean backupWasForced , @Nonnull final Future < BackupResult > result , @Nonnull final String requestId , @Nonnull final BackupSessionService backupSessionService ) { final long start = System . currentTimeMillis ( ) ; if ( ! backupWasForced ) { pingSessionIfBackupWasSkipped ( session , result , backupSessionService ) ; } final long startValidity = System . currentTimeMillis ( ) ; final byte [ ] data = encode ( session . getMaxInactiveInterval ( ) , session . getLastAccessedTimeInternal ( ) , session . getThisAccessedTimeInternal ( ) ) ; final String key = createValidityInfoKeyName ( session . getIdInternal ( ) ) ; _memcached . set ( key , session . getMaxInactiveInterval ( ) , data ) ; _stats . registerSince ( RELEASE_LOCK , startValidity ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Stored session validity info for session " + session . getIdInternal ( ) ) ; } if ( _storeSecondaryBackup ) { final Callable < ? > backupTask = new StoreNonStickySessionBackupTask ( session , result ) ; _executor . submit ( backupTask ) ; final String backupKey = _sessionIdFormat . createBackupKey ( key ) ; _memcached . set ( backupKey , session . getMaxInactiveInterval ( ) , data ) ; } _stats . registerSince ( NON_STICKY_AFTER_BACKUP , start ) ; 
protected void onAfterLoadFromMemcached ( @Nonnull final MemcachedBackupSession session , @Nullable final LockStatus lockStatus ) { session . setLockStatus ( lockStatus ) ; final long start = System . currentTimeMillis ( ) ; final SessionValidityInfo info = loadSessionValidityInfo ( session . getIdInternal ( ) ) ; if ( info ! = null ) { _stats . registerSince ( NON_STICKY_AFTER_LOAD_FROM_MEMCACHED , start ) ; 
protected void onAfterDeleteFromMemcached ( @Nonnull final String sessionId ) { final long start = System . currentTimeMillis ( ) ; _memcached . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; final String validityInfoKey = createValidityInfoKeyName ( sessionId ) ; _memcached . delete ( validityInfoKey ) ; _memcached . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; _stats . registerSince ( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED , start ) ; } 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( session . getIdInternal ( ) , session . getMaxInactiveInterval ( ) , 1 ) ; try { _log . debug ( " Got ping result " + touchResult . get ( ) ) ; 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { final MemcachedBackupSession result ; if ( object instanceof MemcachedBackupSession ) { result = ( MemcachedBackupSession ) object ; } else { final long startDeserialization = System . currentTimeMillis ( ) ; result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; } _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } } return null ; } 
public void registerSince ( @Nonnull final StatsType statsType , final long startInMillis ) { register ( statsType , System . currentTimeMillis ( ) - startInMillis ) ; } 
public void register ( @Nonnull final StatsType statsType , final long value ) { _probes . get ( statsType ) . register ( value ) ; } 
public void nonStickySessionsPingFailed ( ) { _numNonStickySessionsPingFailed . incrementAndGet ( ) ; } 
public void nonStickySessionsReadOnlyRequest ( ) { _numNonStickySessionsReadOnlyRequest . incrementAndGet ( ) ; } 
public void requestWithBackupFailure ( ) { } @Override public void requestWithTomcatFailover ( ) { } @Override public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void requestWithoutSession ( ) { } @Override public void requestWithTomcatFailover ( ) { } @Override public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void requestWithoutSessionAccess ( ) { } @Override public void requestWithTomcatFailover ( ) { } @Override public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void requestWithoutSessionModification ( ) { } @Override public void requestWithTomcatFailover ( ) { } @Override public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void requestWithSession ( ) { } @Override public void requestWithTomcatFailover ( ) { } @Override public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void requestWithMemcachedFailover ( ) { } @Override public void requestWithTomcatFailover ( ) { } @Override public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void requestWithTomcatFailover ( ) { } @Override public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void nonStickySessionsPingFailed ( ) { } @Override public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public void nonStickySessionsReadOnlyRequest ( ) { } @Override public void requestWithoutAttributesAccess ( ) { } } ; } 
public CachedData encode ( final Object object ) { final CachedData result = _delegate . encode ( object ) ; _statistics . register ( StatsType . CACHED_DATA_SIZE , result . getData ( ) . length ) ; return result ; } 
public Object [ ] [ ] createStatisticMethodNames ( ) { return new Object [ ] [ ] { { " getRequestsWithBackupFailure " , " requestWithBackupFailure " } , 
public void testDisabledRequestWithBackup ( ) { final Statistics cut = Statistics . create ( false ) ; assertEquals ( cut . getRequestsWithBackupFailure ( ) , 0 ) ; cut . requestWithBackupFailure ( ) ; assertEquals ( cut . getRequestsWithBackupFailure ( ) , 0 ) ; } 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = new SessionTrackerValve ( _requestUriIgnorePattern , ( Context ) getContainer ( ) , this , _statistics , _enabled ) ; getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( config ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
public void setEnabled ( final boolean enabled ) throws IllegalStateException { if ( ! enabled & & ! _sticky ) { throw new IllegalStateException ( " Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before. " ) ; } final boolean changed = _enabled . compareAndSet ( ! enabled , enabled ) ; if ( changed & & initialized ) { reloadMemcachedConfig ( _memcachedNodes , _failoverNodes ) ; 
public void start ( ) throws LifecycleException { if ( ! initialized ) { init ( ) ; } Validate and update our current component state if (_started) { return; } _lifecycle.fireLifecycleEvent(START_EVENT, null); _started = true; Force initialization of the random number generator if (log.isDebugEnabled()) { log.debug("Force random number initialization starting"); } super.generateSessionId(); if (log.isDebugEnabled()) { log.debug("Force random number initialization completed"); } startInternal( null ); } 
public void stop ( ) throws LifecycleException { if ( log . isDebugEnabled ( ) ) { log . debug ( " Stopping " ) ; } Validate and update our current component state if (!_started) { throw new LifecycleException (sm.getString("standardManager.notStarted")); } _lifecycle.fireLifecycleEvent(STOP_EVENT, null); _started = false; Require a new random number generator if we are restarted random = null; if ( initialized ) { 
public void setup ( ) throws Exception { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _manager . setSticky ( true ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.startInternal( _memcachedMock ); 
public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _manager . resetInitialized ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _manager . setFailoverNodes ( " n1 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _manager . setFailoverNodes ( " n1 n2 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _manager . setFailoverNodes ( " n1,n2 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public static void setup ( ) throws LifecycleException { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _manager.start(); 
protected void onAfterBackupSession ( @Nonnull final MemcachedBackupSession session , final boolean backupWasForced , @Nonnull final Future < BackupResult > result , @Nonnull final String requestId , @Nonnull final BackupSessionService backupSessionService ) { final long start = System . currentTimeMillis ( ) ; if ( ! backupWasForced ) { pingSessionIfBackupWasSkipped ( session , result , backupSessionService ) ; } final long startValidity = System . currentTimeMillis ( ) ; final byte [ ] validityData = encode ( session . getMaxInactiveInterval ( ) , session . getLastAccessedTimeInternal ( ) , session . getThisAccessedTimeInternal ( ) ) ; final String validityKey = createValidityInfoKeyName ( session . getIdInternal ( ) ) ; _memcached . set ( validityKey , session . getMaxInactiveInterval ( ) , validityData ) ; _stats . registerSince ( RELEASE_LOCK , startValidity ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Stored session validity info for session " + session . getIdInternal ( ) ) ; } if ( _storeSecondaryBackup ) { try { final Callable < ? > backupSessionTask = new StoreNonStickySessionBackupTask ( session , result ) ; _executor . submit ( backupSessionTask ) ; final String backupValidityKey = _sessionIdFormat . createBackupKey ( validityKey ) ; _memcached . set ( backupValidityKey , session . getMaxInactiveInterval ( ) , validityData ) ; } catch ( final NodeFailureException e ) { handle an unavailable secondary/backup node (fix for issue #83) _log.info( "Secondary/backup node "+ e.getNodeId() +" not available, skipping additional backup of session " + session.getIdInternal() ); } catch( final RuntimeException e ) { _log.info( "Could not store secondary backup of session " + session.getIdInternal(), e ); } } _stats.registerSince( NON_STICKY_AFTER_BACKUP, start ); 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( session . getIdInternal ( ) , session . getMaxInactiveInterval ( ) , 1 ) ; try { _log . debug ( " Got ping result " + touchResult . get ( ) ) ; 
private void pingSessionBackup ( @Nonnull final MemcachedBackupSession session ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( session . getId ( ) ) ; final Future < Boolean > touchResult = _memcached . add ( key , session . getMaxInactiveInterval ( ) , 1 ) ; try { _log . debug ( " Got backup ping result " + touchResult . get ( ) ) ; 
public void updateSessionBackup ( @Nonnull final MemcachedBackupSession session , @Nonnull final String key ) throws InterruptedException { try { final byte [ ] data = _manager . serialize ( session ) ; 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { if ( _sticky ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _nodeIdService . isNodeAvailable ( nodeId ) ) { return null ; } final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { addValidLoadedSession ( backupSession ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId ) { final String backupNodeId = getBackupNodeId ( requestedSessionId ) ; if ( ! _nodeIdService . isNodeAvailable ( backupNodeId ) ) { _log . info ( " Node " + backupNodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( _sessionIdFormat . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , getContainer ( ) . getRealm ( ) , this ) ; session . setSticky ( _sticky ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; _log . debug ( " Session needs to be relocated, setting new id on session... " ) ; final String newSessionId = _sessionIdFormat . createNewSessionId ( requestedSessionId , backupNodeId ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
boolean isBackupNodeAvailable ( @Nonnull final String sessionId ) { return _nodeIdService . isNodeAvailable ( getBackupNodeId ( sessionId ) ) ; } 
byte [ ] serialize ( @Nonnull final MemcachedBackupSession session ) { return _transcoderService . serialize ( session ) ; } 
public void testMultipleMemcachedNodesFailure ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String paramKey = " foo " ; final String paramValue = " bar " ; final String sid1 = post ( _httpClient , _portTomcat1 , null , paramKey , paramValue ) . getResponseSessionId ( ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; final Map . Entry < String , MemCacheDaemon < ? > > otherNodeWithId = info . previousNode ( ) ; otherNodeWithId . getValue ( ) . stop ( ) ; Thread . sleep ( 100 ) ; final String sid2 = get ( _httpClient , _portTomcat1 , sid1 ) . getResponseSessionId ( ) ; final String secondNode = extractNodeId ( sid2 ) ; LOG . debug ( " Have secondNode " + secondNode ) ; final String expectedNode = info . otherNodeExcept ( otherNodeWithId . getKey ( ) ) . getKey ( ) ; assertEquals ( secondNode , expectedNode , " Unexpected nodeId: " + secondNode + " . " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( sid2 )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
protected void onAfterBackupSession ( @Nonnull final MemcachedBackupSession session , final boolean backupWasForced , @Nonnull final Future < BackupResult > result , @Nonnull final String requestId , @Nonnull final BackupSessionService backupSessionService ) { try { 
private void pingSessionBackup ( @Nonnull final MemcachedBackupSession session ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( session . getId ( ) ) ; final Future < Boolean > touchResultFuture = _memcached . add ( key , session . getMaxInactiveInterval ( ) , 1 ) ; try { final boolean touchResult = touchResultFuture . get ( 200 , TimeUnit . MILLISECONDS ) ; 
public void testSecondaryBackupForNonStickySessionAfterMemcachedFailover ( ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( false ) ; final String paramKey = " foo " ; final String paramValue = " bar " ; final String sid1 = post ( _httpClient , _portTomcat1 , null , paramKey , paramValue ) . getResponseSessionId ( ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getSessionId(); final String secondNode = extractNodeId( sid2 ); final String expectedNode = info.nextNode().getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( sid2 )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); 
private void waitForReconnect ( final MemcachedBackupSessionManager manager , final MemCacheDaemon < ? > value , final long timeToWait ) throws InterruptedException { MemcachedClient client ; InetSocketAddress serverAddress ; try { final Method m = MemcachedBackupSessionManager . class . getDeclaredMethod ( " getMemcached " ) ; m . setAccessible ( true ) ; client = ( MemcachedClient ) m . invoke ( manager ) ; final Field field = MemCacheDaemon . class . getDeclaredField ( " addr " ) ; field . setAccessible ( true ) ; serverAddress = ( InetSocketAddress ) field . get ( value ) ; } catch ( final Exception e ) { throw new RuntimeException ( e ) ; } waitForReconnect ( client , serverAddress , timeToWait ) ; } 
public Entry < String , MemCacheDaemon < ? > > nextNode ( ) { return otherNodes . entrySet ( ) . iterator ( ) . next ( ) ; } 
public void saveSessionBackupFromResult ( final BackupResult backupResult ) { final byte [ ] data = backupResult . getData ( ) ; if ( data ! = null ) { final String key = _sessionIdFormat . createBackupKey ( _session . getId ( ) ) ; 
public void saveValidityBackup ( ) { final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; _memcached . set ( backupValidityKey , _session . getMaxInactiveInterval ( ) , _validityData ) ; } 
public void saveSessionBackup ( @Nonnull final MemcachedBackupSession session , @Nonnull final String key ) throws InterruptedException { try { final byte [ ] data = _manager . serialize ( session ) ; 
private void addValidLoadedSession ( final StandardSession session ) { make sure the listeners know about it. (as done by PersistentManagerBase) if ( session.isNew() ) { session.tellNew(); } add( session ); session.activate(); endAccess() to ensure timeouts happen correctly. access() to keep access count correct or it will end up negative session.access(); session.endAccess(); } 
public Future < BackupResult > backupSession ( final Session session , final boolean sessionIdChanged , final String requestId ) { if ( ! _enabled . get ( ) ) { return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } final MemcachedBackupSession msmSession = ( MemcachedBackupSession ) session ; if ( ! _sticky ) { msmSession . passivate ( ) ; } final boolean force = sessionIdChanged | | msmSession . isSessionIdChanged ( ) | | ! _sticky & & ( msmSession . getSecondsSinceLastBackup ( ) > = session . getMaxInactiveInterval ( ) ) ; final Future < BackupResult > result = _backupSessionService . backupSession ( msmSession , force ) ; if ( ! _sticky ) { remove ( session , false ) ; _lockingStrategy . onAfterBackupSession ( msmSession , force , result , requestId , _backupSessionService ) ; } return result ; } 
public Session findSession ( final String id ) throws IOException { MemcachedBackupSession result = ( MemcachedBackupSession ) super . findSession ( id ) ; if ( result = = null & & canHitMemcached ( id ) & & _missingSessionsCache . get ( id ) = = null ) { when the request comes from the container, it's from CoyoteAdapter.postParseRequest if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) { we can return just null as the requestedSessionId will still be set on the request. return null; } else load the session from memcached result = loadFromMemcached( id ); checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { addValidLoadedSession( result ); } } return result; } 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { if ( _sticky ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _nodeIdService . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available, loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId ) { final String backupNodeId = getBackupNodeId ( requestedSessionId ) ; if ( backupNodeId = = null ) { _log . info ( " No backup node found for nodeId " + _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ) ; return null ; } if ( ! _nodeIdService . isNodeAvailable ( backupNodeId ) ) { _log . info ( " Node " + backupNodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( _sessionIdFormat . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , getContainer ( ) . getRealm ( ) , this ) ; session . setSticky ( _sticky ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; final String newSessionId = _sessionIdFormat . createNewSessionId ( requestedSessionId , backupNodeId ) ; _log . info ( " Session backup loaded from secondary memcached for " + requestedSessionId + " (will be relocated), " + " setting new id " + newSessionId + " on session... " ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
boolean isBackupNodeAvailable ( @Nonnull final String sessionId ) { final String backupNodeId = getBackupNodeId ( sessionId ) ; return backupNodeId = = null ? false : _nodeIdService . isNodeAvailable ( backupNodeId ) ; } 
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { if ( ! canHitMemcached ( sessionId ) | | _missingSessionsCache . get ( sessionId ) ! = null ) { return null ; } return loadFromMemcached ( sessionId ) ; } 
private boolean canHitMemcached ( @Nonnull final String sessionId ) { return _enabled . get ( ) & & _sessionIdFormat . isValid ( sessionId ) ; } 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { throw new IllegalArgumentException ( " The sessionId should contain a nodeId, this should be checked " + " by invoking canHitMemcached before invoking this method (bug, needs fix). " ) ; } if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { final MemcachedBackupSession result ; if ( object instanceof MemcachedBackupSession ) { result = ( MemcachedBackupSession ) object ; } else { final long startDeserialization = System . currentTimeMillis ( ) ; result = _transcoderService . deserialize ( ( byte [ ] ) object , getContainer ( ) . getRealm ( ) , this ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; } _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } } return null ; } 
public boolean isNodeAvailable ( @Nonnull final K key ) { final ManagedItem < Boolean > item = _map . get ( key ) ; if ( item = = null ) { return updateIsNodeAvailable ( key ) ; 
public String getNextNodeId ( @Nonnull final String nodeId ) throws IllegalArgumentException { final int idx = indexOf ( nodeId ) ; if ( idx < 0 ) { throw new IllegalArgumentException ( " The given node id is not part of this list " ) ; } if ( size ( ) = = 1 ) { return null ; } return ( idx = = size ( ) - 1 ) ? get ( 0 ) : get ( idx + 1 ) ; } 
public boolean isNodeAvailable ( @Nonnull final String nodeId ) { return _nodeAvailabilityCache . isNodeAvailable ( nodeId ) ; } 
public String getNextNodeId ( @Nonnull final String nodeId ) throws IllegalArgumentException { return _nodeIds . getNextNodeId ( nodeId ) ; } 
private void logDebugResponseCookie ( final Response response ) { final String header = response . getHeader ( " Set-Cookie " ) ; if ( header ! = null & & header . contains ( _sessionCookieName ) ) { _log . debug ( " Request finished, with Set-Cookie header: " + header ) ; 
public void testGetNextNodeId ( ) { assertEquals ( NodeIdList . create ( " n1 " , " n2 " ) . getNextNodeId ( " n1 " ) , " n2 " ) ; assertEquals ( NodeIdList . create ( " n1 " , " n2 " ) . getNextNodeId ( " n2 " ) , " n1 " ) ; assertNull ( NodeIdList . create ( " n1 " ) . getNextNodeId ( " n1 " ) ) ; try { assertNull ( NodeIdList . create ( " n1 " ) . getNextNodeId ( " n2 " ) ) ; 
protected void onBackupWithoutLoadedSession ( @Nonnull final String sessionId , @Nonnull final String requestId , @Nonnull final BackupSessionService backupSessionService ) { if ( ! _sessionIdFormat . isValid ( sessionId ) ) { return ; } try { 
protected SessionValidityInfo loadSessionValidityInfo ( @Nonnull final String sessionId ) { return loadSessionValidityInfoForValidityKey ( createValidityInfoKeyName ( sessionId ) ) ; } 
protected SessionValidityInfo loadSessionValidityInfoForValidityKey ( @Nonnull final String validityInfoKey ) { final byte [ ] validityInfo = ( byte [ ] ) _memcached . get ( validityInfoKey ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; } 
protected SessionValidityInfo loadBackupSessionValidityInfo ( @Nonnull final String sessionId ) { final String key = createValidityInfoKeyName ( sessionId ) ; final String backupKey = _sessionIdFormat . createBackupKey ( key ) ; return loadSessionValidityInfoForValidityKey ( backupKey ) ; } 
private boolean pingSession ( @Nonnull final String sessionId ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( sessionId , 1 , 1 ) ; try { _log . debug ( " Got ping result " + touchResult . get ( ) ) ; 
public Void call ( ) throws Exception { pingSession ( _sessionId ) ; if ( _storeSecondaryBackup ) { try { pingSessionBackup ( _sessionId ) ; final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; _memcached . set ( backupValidityKey , _maxInactiveInterval , _validityData ) ; } catch ( final NodeFailureException e ) { handle an unavailable secondary/backup node (fix for issue #83) _log.info( "Secondary/backup node "+ e.getNodeId() +" not available, skipping additional ping of session " + _sessionId ); } catch( final RuntimeException e ) { _log.info( "Could not store secondary backup of session " + _sessionId, e ); } } return null; } 
private boolean pingSessionBackup ( @Nonnull final String sessionId ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( sessionId ) ; final Future < Boolean > touchResultFuture = _memcached . add ( key , 1 , 1 ) ; try { final boolean touchResult = touchResultFuture . get ( 200 , TimeUnit . MILLISECONDS ) ; 
protected void onBackupWithoutLoadedSession ( @Nonnull final String sessionId , @Nonnull final String requestId , @Nonnull final BackupSessionService backupSessionService ) { if ( ! _sessionIdFormat . isValid ( sessionId ) ) { return ; } super . onBackupWithoutLoadedSession ( sessionId , requestId , backupSessionService ) ; _readOnlyRequestCache . readOnlyRequest ( requestId ) ; } 
public Future < BackupResult > backupSession ( final String sessionId , final boolean sessionIdChanged , final String requestId ) { if ( ! _enabled . get ( ) ) { return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } final MemcachedBackupSession msmSession = ( MemcachedBackupSession ) sessions . get ( sessionId ) ; if ( msmSession = = null ) { _log . debug ( " No session found in session map for " + sessionId ) ; if ( ! _sticky ) { _lockingStrategy . onBackupWithoutLoadedSession ( sessionId , requestId , _backupSessionService ) ; } return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } if ( ! msmSession . isValidInternal ( ) ) { _log . debug ( " Non valid session found in session map for " + sessionId ) ; return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } if ( ! _sticky ) { msmSession . passivate ( ) ; } final boolean force = sessionIdChanged | | msmSession . isSessionIdChanged ( ) | | ! _sticky & & ( msmSession . getSecondsSinceLastBackup ( ) > = msmSession . getMaxInactiveInterval ( ) ) ; final Future < BackupResult > result = _backupSessionService . backupSession ( msmSession , force ) ; if ( ! _sticky ) { remove ( msmSession , false ) ; _lockingStrategy . onAfterBackupSession ( msmSession , force , result , requestId , _backupSessionService ) ; } return result ; } 
private void backupSession ( final Request request , final Response response , final boolean sessionIdChanged ) { String sessionId = getSessionIdFromResponseSessionCookie ( response ) ; if ( sessionId = = null ) { sessionId = request . getRequestedSessionId ( ) ; } if ( sessionId ! = null ) { _statistics . requestWithSession ( ) ; 
public void testOnlySendModifiedSessions ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( _memcachedMock , times ( 2 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; 
public void testOnlyHashAttributesOfAccessedAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . endAccess ( ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . getAttribute ( " foo " ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 2 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testChangeSessionId ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , TimeoutException { _manager . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _manager . setLockingMode ( LockingMode . NONE , null , false ) ; } final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session . getIdInternal ( ) , false , " foo " ) . get ( ) ; final String oldSessionId = session . getId ( ) ; _manager . changeSessionId ( session ) ; on session backup we specify sessionIdChanged as false as we're not aware of this fact _manager.backupSession( session.getIdInternal(), false, "foo" ); remove session with old id and add it with the new id verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) ); verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() ); if ( !stickyness.isSticky() ) { check validity info 
public final void testBackupSessionNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _responseControl . expects ( once ( ) ) . method ( " getHeader " ) . with ( eq ( " Set-Cookie " ) ) . will ( returnValue ( null ) ) ; _sessionBackupServiceControl . expects ( never ( ) ) . method ( " backupSession " ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; } 
public final void testBackupSessionInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { _requestControl . expects ( once ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( null ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) ; _responseControl . expects ( once ( ) ) . method ( " getHeader " ) . with ( eq ( " Set-Cookie " ) ) . will ( returnValue ( generateCookieString ( cookie ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestURI " ) . will ( returnValue ( " /someRequest " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getMethod " ) . will ( returnValue ( " GET " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getQueryString " ) . will ( returnValue ( null ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( " foo " ) , eq ( false ) , ANYTHING ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
private String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; } 
public final void testBackupSessionInvokedWhenSessionExisting ( ) throws IOException , ServletException { final String sessionId = " foo " ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , sessionId ) ; _responseControl . expects ( once ( ) ) . method ( " getHeader " ) . with ( eq ( " Set-Cookie " ) ) . will ( returnValue ( generateCookieString ( cookie ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestURI " ) . will ( returnValue ( " /foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getMethod " ) . will ( returnValue ( " GET " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getQueryString " ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( sessionId ) , eq ( false ) , ANYTHING ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; _requestControl . expects ( atLeastOnce ( ) ) . method ( " getRequestedSessionId " ) . will ( returnValue ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnTomcatFailover " ) . with ( eq ( sessionId ) ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " changeSessionIdOnMemcachedFailover " ) . with ( eq ( sessionId ) ) . will ( returnValue ( newSessionId ) ) ; _requestControl . expects ( once ( ) ) . method ( " changeSessionId " ) . with ( eq ( newSessionId ) ) ; _nextValve . expects ( once ( ) ) . method ( " invoke " ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , newSessionId ) ; _responseControl . expects ( once ( ) ) . method ( " getHeader " ) . with ( eq ( " Set-Cookie " ) ) . will ( returnValue ( generateCookieString ( cookie ) ) ) ; _requestControl . expects ( once ( ) ) . method ( " getRequestURI " ) . will ( returnValue ( " /foo " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getMethod " ) . will ( returnValue ( " GET " ) ) ; _requestControl . expects ( once ( ) ) . method ( " getQueryString " ) ; _sessionBackupServiceControl . expects ( once ( ) ) . method ( " backupSession " ) . with ( eq ( newSessionId ) , eq ( true ) , ANYTHING ) . will ( returnValue ( null ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verifyMocks ( ) ; 
public void testSessionNotLoadedForReadonlyRequest ( ) throws IOException , HttpException , InterruptedException { getManager ( _tomcat1 ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; try { 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final String pathInfo = request . getPathInfo ( ) ; LOG . info ( " + starting " + pathInfo + " ... " ) ; if ( PATH_GET_REQUESTED_SESSION_INFO . equals ( pathInfo ) ) { LOG . info ( " getRequestedSessionId: " + request . getRequestedSessionId ( ) ) ; LOG . info ( " isRequestedSessionIdValid: " + request . isRequestedSessionIdValid ( ) ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( KEY_REQUESTED_SESSION_ID + " = " + request . getRequestedSessionId ( ) ) ; out . println ( KEY_IS_REQUESTED_SESSION_ID_VALID + " = " + request . isRequestedSessionIdValid ( ) ) ; } else if ( PATH_NO_SESSION_ACCESS . equals ( pathInfo ) ) { LOG . info ( " skipping session access " ) ; response . getWriter ( ) . println ( " Skipped session access " ) ; } else { final HttpSession session = request . getSession ( ) ; waitIfRequested ( request ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + session . getId ( ) ) ; final HttpSession session = request.getSession( false ); if ( session != null ) { final Enumeration<?> attributeNames = session.getAttributeNames(); while ( attributeNames.hasMoreElements() ) { final String name = attributeNames.nextElement().toString(); final Object value = session.getAttribute( name ); out.println( name + "=" + value ); } } } LOG.info( " - finished." ); 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setSessionBackupAsync( false ); sessionManager.setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); catalina.addConnector( connector ); return catalina; } 
public void setup ( ) throws Exception { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _manager . setSessionBackupAsync ( false ) ; _manager . setSticky ( true ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.startInternal( _memcachedMock ); 
public void testOnlySendModifiedSessions ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager.backupSession( session.getIdInternal(), false, null ).get(); verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any() ); 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; we need at least 1 milli between last backup and next access (due to check in BackupSessionService) Thread.sleep(1L); session.access(); session.getAttribute( "foo" ); _manager.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); we need at least 1 milli between last backup and next access (due to check in BackupSessionService) Thread.sleep(1L); _manager.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setSessionBackupAsync( false ); sessionManager.setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); catalina.addConnector( connector ); return catalina; } 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( session . getIdInternal ( ) , 5 , 1 ) ; try { _log . debug ( " Got ping result " + touchResult . get ( ) ) ; 
public void saveValidityBackup ( ) { final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; final int maxInactiveInterval = _session . getMaxInactiveInterval ( ) ; fix for #88, along with the change in session.getMemcachedExpirationTimeToSet final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval; _memcached.set( backupValidityKey, expiration, _validityData ); } 
private void pingSessionBackup ( @Nonnull final MemcachedBackupSession session ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( session . getId ( ) ) ; final Future < Boolean > touchResultFuture = _memcached . add ( key , 5 , 1 ) ; try { final boolean touchResult = touchResultFuture . get ( 200 , TimeUnit . MILLISECONDS ) ; 
public Void call ( ) throws Exception { pingSession ( _sessionId ) ; if ( _storeSecondaryBackup ) { try { pingSessionBackup ( _sessionId ) ; final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; fix for #88, along with the change in session.getMemcachedExpirationTimeToSet final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval; _memcached.set( backupValidityKey, expiration, _validityData ); } catch( final NodeFailureException e ) { handle an unavailable secondary/backup node (fix for issue #83) _log.info( "Secondary/backup node "+ e.getNodeId() +" not available, skipping additional ping of session " + _sessionId ); } catch( final RuntimeException e ) { _log.info( "Could not store secondary backup of session " + _sessionId, e ); } } return null; } 
public void testSessionTimeoutUnlimitedWithSessionLoaded ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , LifecycleException { _manager . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _manager . setLockingMode ( LockingMode . NONE , null , false ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _manager.startInternal(_memcachedMock); we must put in our mock again } final MemcachedBackupSession session = (MemcachedBackupSession) _manager.createSession( null ); session.setMaxInactiveInterval( -1 ); session.access(); session.endAccess(); session.setAttribute( "foo", "bar" ); final String sessionId = session.getId(); _manager.backupSession( sessionId, false, null ).get(); verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any() ); if ( !stickyness.isSticky() ) { check validity info 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _manager . setStickyInternal ( false ) ; _manager . setLockingMode ( LockingMode . NONE , null , false ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _manager.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _manager.getLockingStrategy().getExecutorService().shutdown(); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() ); } 
public void testCacheTTL ( ) throws InterruptedException { final LRUCache < String , String > cut = new LRUCache < String , String > ( 1 , 100 ) ; cut . put ( " foo " , " bar " ) ; Assert . assertEquals ( " bar " , cut . get ( " foo " ) ) ; Thread . sleep ( 120 ) ; Assert . assertNull ( cut . get ( " foo " ) , " expired key still existing, unexpected cache size " ) ; } 
public void testOnlySendModifiedSessions ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager.backupSession( session.getIdInternal(), false, null ).get(); verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any() ); 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAttribute ( " foo " , " bar " ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; we need some millis between last backup and next access (due to check in BackupSessionService) Thread.sleep(5L); session.access(); session.getAttribute( "foo" ); _manager.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); we need some millis between last backup and next access (due to check in BackupSessionService) Thread.sleep(5L); _manager.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _manager . setStickyInternal ( false ) ; _manager . setLockingMode ( LockingMode . NONE , null , false ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _manager.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _manager.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() ); } 
public void testNonStickySessionIsStoredInSecondaryMemcachedForBackup ( ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat2 ) . setMaxInactiveInterval ( 1 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 15 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> primary = nodeId.equals( NODE_ID_1 ) ? _daemon1 : _daemon2; final MemCacheDaemon<?> secondary = nodeId.equals( NODE_ID_1 ) ? _daemon2 : _daemon1; assertNotNull( primary.getCache().get( sessionId1 )[0] ); assertNotNull( primary.getCache().get( createValidityInfoKeyName( sessionId1 ) )[0] ); The executor needs some time to finish the backup... Thread.sleep( 100 ); assertNotNull( secondary.getCache().get( fmt.createBackupKey( sessionId1 ) )[0] ); assertNotNull( secondary.getCache().get( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) )[0] ); 
private void waitForMemcachedClient ( final long millis ) { ttry { tThread . sleep ( millis ) ; 
private void writeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes , final ObjectOutputStream oos ) throws IOException { Accumulate the names of serializable and non-serializable attributes final String keys[] = attributes.keySet().toArray( EMPTY_ARRAY ); final List<String> saveNames = new ArrayList<String>(); final List<Object> saveValues = new ArrayList<Object>(); for ( int i = 0; i < keys.length; i++ ) { final Object value = attributes.get( keys[i] ); if ( value == null || session.exclude( keys[i] ) ) { continue; } else if ( value instanceof Serializable ) { saveNames.add( keys[i] ); saveValues.add( value ); } else { if ( LOG.isDebugEnabled() ) { LOG.debug( "Ignoring attribute '" + keys[i] + "' as it does not implement Serializable" ); } } } Serialize the attribute count and the Serializable attributes final int n = saveNames.size(); oos.writeObject( new Integer( n ) ); for ( int i = 0; i < n; i++ ) { oos.writeObject( saveNames.get( i ) ); 
public Session findSession ( final String id ) throws IOException { MemcachedBackupSession result = ( MemcachedBackupSession ) super . findSession ( id ) ; if ( result = = null & & canHitMemcached ( id ) & & _missingSessionsCache . get ( id ) = = null ) { when the request comes from the container, it's from CoyoteAdapter.postParseRequest if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) { we can return just null as the requestedSessionId will still be set on the request. return null; } else load the session from memcached result = loadFromMemcached( id ); checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver (due to a tomcat failover) we don't want to notify listeners via session.activate for the old sessionId but do that later (in handleSessionTakeOver) See also http:code.google.com/p/memcached-session-manager/issues/detail?id=92 String jvmRoute; final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = getJvmRoute() ) != null && !jvmRoute.equals( _sessionIdFormat.extractJvmRoute( id ) ); final boolean activate = !sessionIdWillBeChanged; addValidLoadedSession( result, activate ); } } return result; } 
private void addValidLoadedSession ( final StandardSession session , final boolean activate ) { make sure the listeners know about it. (as done by PersistentManagerBase) if ( session.isNew() ) { session.tellNew(); } add( session ); if ( activate ) { session.activate(); } endAccess() to ensure timeouts happen correctly. access() to keep access count correct or it will end up negative session.access(); session.endAccess(); } 
public Session createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; StandardSession session = null ; if ( sessionId ! = null ) { session = loadFromMemcachedWithCheck ( sessionId ) ; checking valid() would expire() the session if it's not valid! if ( session != null && session.isValid() ) { addValidLoadedSession( session, true ); } } if ( session == null ) { session = createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( this.maxInactiveInterval ); if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) { sessionId = generateSessionId(); } session.setId( sessionId ); if ( _log.isDebugEnabled() ) { _log.debug( "Created new session with id " + session.getId() ); } } sessionCounter++; return session; 
public String changeSessionIdOnTomcatFailover ( final String requestedSessionId ) { if ( ! _sticky ) { return null ; } final String localJvmRoute = getJvmRoute ( ) ; if ( localJvmRoute ! = null & & ! localJvmRoute . equals ( _sessionIdFormat . extractJvmRoute ( requestedSessionId ) ) ) { the session might have been loaded already (by some valve), so let's check our session map MemcachedBackupSession session = (MemcachedBackupSession) sessions.get( requestedSessionId ); if ( session == null ) { session = loadFromMemcachedWithCheck( requestedSessionId ); } checking valid() can expire() the session! if ( session != null && session.isValid() ) { return handleSessionTakeOver( session ); } } return null; } 
private String handleSessionTakeOver ( final MemcachedBackupSession session ) { checkMaxActiveSessions ( ) ; final String origSessionId = session . getIdInternal ( ) ; final String newSessionId = _sessionIdFormat . changeJvmRoute ( session . getIdInternal ( ) , getJvmRoute ( ) ) ; If this session was already loaded we need to remove it from the session map See http:code.google.com/p/memcached-session-manager/issues/detail?id=92 if ( sessions.containsKey( origSessionId ) ) { sessions.remove( origSessionId ); } session.setIdInternal( newSessionId ); addValidLoadedSession( session, true ); deleteFromMemcached( origSessionId ); _statistics.requestWithTomcatFailover(); return newSessionId; 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { if ( _sticky ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _nodeIdService . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available, loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private static HttpResponse executeRequestWithAuth ( final DefaultHttpClient client , final HttpUriRequest method , final Credentials credentials ) throws IOException , ClientProtocolException { client . getCredentialsProvider ( ) . setCredentials ( AuthScope . ANY , credentials ) ; final BasicHttpContext localcontext = new BasicHttpContext ( ) ; Generate BASIC scheme object and stick it to the local execution context final BasicScheme basicAuth = new BasicScheme(); localcontext.setAttribute( "preemptive-auth", basicAuth ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); return client.execute( method, localcontext ); } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { return post ( client , port , path , rsessionId , params , null ) ; } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params , @Nullable final Credentials credentials ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:"+ DEFAULT_HOST +":"+ port; final String url = getUrl( port, path ); final HttpPost method = new HttpPost( url ); if ( rsessionId != null ) { method.setHeader( "Cookie", "JSESSIONID=" + rsessionId ); } method.setEntity( createFormEntity( params ) ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); final HttpResponse response = credentials == null ? client.execute( method ) : executeRequestWithAuth( client, method, credentials ); final int statusCode = response.getStatusLine().getStatusCode(); if ( statusCode == 302 ) { return redirect( response, client, port, rsessionId, baseUri ); } if ( statusCode != 200 ) { throw new RuntimeException( "GET did not return status 200, but " + response.getStatusLine() ); } return readResponse( rsessionId, response ); } 
public void testSerializationOfAuthStuffWithFormAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; 
public void testSerializationOfAuthStuffWithBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; 
public void testSessionOnlyLoadedOnceWithAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; assertEquals ( _daemon . getCache ( ) . getGetHits ( ) , 1 ) ; 
public void testSessionModificationOnTomcatFailoverNotLostWithAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc1Response1 = get ( _httpClient , TC_PORT_1 , null , new UsernamePasswordCredentials ( TestUtils . USER_NAME , TestUtils . PASSWORD ) ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertEquals ( sessionId , tc1Response1 . get ( TestServlet . ID ) ) ; final Response tc2Response1 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; final Response tc2Response2 = get ( _httpClient , TC_PORT_2 , tc2Response1 . getResponseSessionId ( ) ) ; assertEquals ( tc2Response2 . get ( " foo " ) , " bar " ) ; 
public void testBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , LockingMode . AUTO ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , LockingMode . AUTO ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; assertEquals ( tc2Response1 . get ( " foo " ) , " bar " ) ; 
private Embedded startTomcatWithAuth ( final int port , @Nonnull final LockingMode lockingMode ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded result = createCatalina ( port , MEMCACHED_NODES , null , LoginType . BASIC ) ; getManager ( result ) . setSticky ( false ) ; getManager ( result ) . setLockingMode ( lockingMode . name ( ) ) ; result . start ( ) ; return result ; } 
protected void onAfterDeleteFromMemcached ( @Nonnull final String sessionId ) { final long start = System . currentTimeMillis ( ) ; final String validityInfoKey = createValidityInfoKeyName ( sessionId ) ; _memcached . delete ( validityInfoKey ) ; if ( _storeSecondaryBackup ) { _memcached . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; _memcached . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; } _stats . registerSince ( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED , start ) ; } 
public void testRelocateSession ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String sid1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; Thread . sleep ( 50 ) ; final String sid2 = makeRequest ( _httpClient , _portTomcat1 , sid1 ) ; final String secondNode = extractNodeId ( sid2 ) ; assertNotSame ( secondNode , firstNode , " First node again selected " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + secondNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; we must get the same session back assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
public void testMultipleMemcachedNodesFailure ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String paramKey = " foo " ; final String paramValue = " bar " ; final String sid1 = post ( _httpClient , _portTomcat1 , null , paramKey , paramValue ) . getResponseSessionId ( ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final FailoverInfo info = getFailoverInfo ( firstNode ) ; info . activeNode . stop ( ) ; final Map . Entry < String , MemCacheDaemon < ? > > otherNodeWithId = info . previousNode ( ) ; otherNodeWithId . getValue ( ) . stop ( ) ; Thread . sleep ( 100 ) ; final String sid2 = get ( _httpClient , _portTomcat1 , sid1 ) . getResponseSessionId ( ) ; final String secondNode = extractNodeId ( sid2 ) ; LOG . debug ( " Have secondNode " + secondNode ) ; final String expectedNode = info . otherNodeExcept ( otherNodeWithId . getKey ( ) ) . getKey ( ) ; assertEquals ( secondNode , expectedNode , " Unexpected nodeId: " + secondNode + " . " ) ; assertEquals ( sid2 , sid1 . substring ( 0 , sid1 . indexOf ( " - " ) + 1 ) + expectedNode , " Unexpected sessionId, sid1: " + sid1 + " , sid2: " + sid2 ) ; we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
public void testSecondaryBackupForNonStickySessionAfterMemcachedFailover ( ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( false ) ; final String paramKey = " foo " ; final String paramValue = " bar " ; final String sid1 = post ( _httpClient , _portTomcat1 , null , paramKey , paramValue ) . getResponseSessionId ( ) ; assertNotNull ( " No session created. " , sid1 ) ; final String firstNode = extractNodeId ( sid1 ) ; assertNotNull ( " No node id encoded in session id. " , firstNode ) ; final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getSessionId(); final String secondNode = extractNodeId( sid2 ); final String expectedNode = info.nextNode().getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); 
public void testNonStickySessionIsStoredInSecondaryMemcachedForBackup ( ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat2 ) . setMaxInactiveInterval ( 1 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 15 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> primary = nodeId.equals( NODE_ID_1 ) ? _daemon1 : _daemon2; final MemCacheDaemon<?> secondary = nodeId.equals( NODE_ID_1 ) ? _daemon2 : _daemon1; assertNotNull( primary.getCache().get( key( sessionId1 ) )[0] ); assertNotNull( primary.getCache().get( key( createValidityInfoKeyName( sessionId1 ) ) )[0] ); The executor needs some time to finish the backup... Thread.sleep( 100 ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); 
public static MemCacheDaemon < ? extends CacheElement > createDaemon ( final InetSocketAddress address ) throws IOException { final MemCacheDaemon < LocalCacheElement > daemon = new MemCacheDaemon < LocalCacheElement > ( ) ; final ConcurrentLinkedHashMap < Key , LocalCacheElement > cacheStorage = ConcurrentLinkedHashMap . create ( EvictionPolicy . LRU , 100000 , 1024 * 1024 ) ; daemon . setCache ( new CacheImpl ( cacheStorage ) ) ; daemon . setAddr ( address ) ; daemon . setVerbose ( true ) ; return daemon ; } 
public abstract boolean isSticky ( ) ; } @DataProvider public static Object [ ] [ ] stickynessProvider ( ) { return new Object [ ] [ ] { { SessionAffinityMode . STICKY } , { SessionAffinityMode . NON_STICKY } } ; } @Nonnull public static Key key ( @Nonnull final String value ) { return new Key ( ChannelBuffers . wrappedBuffer ( value . getBytes ( ) ) ) ; } } 
public static Key key ( @Nonnull final String value ) { return new Key ( ChannelBuffers . wrappedBuffer ( value . getBytes ( ) ) ) ; } 
public void setUp ( ) throws Exception { _service = mock ( SessionBackupService . class ) ; _sessionTrackerValve = new SessionTrackerValve ( null , new StandardContext ( ) , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; } 
public void tearDown ( ) throws Exception { reset ( _service , _nextValve , 
public final void testBackupSessionNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; } 
public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request , never ( ) ) . getSessionInternal ( ) ; } 
public final void testBackupSessionInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( generateCookieString ( cookie ) ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( " foo " ) , eq ( false ) , anyString ( ) ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; when ( _service . changeSessionIdOnMemcachedFailover ( eq ( sessionId ) ) ) . thenReturn ( newSessionId ) ; final Cookie cookie = new Cookie( _sessionTrackerValve.getSessionCookieName(), newSessionId ); when( _response.getHeader( eq( "Set-Cookie" ) ) ).thenReturn( generateCookieString( cookie ) ); when( _request.getRequestURI() ).thenReturn( "/foo" ); when( _request.getMethod() ).thenReturn( "GET" ); when( _request.getQueryString() ).thenReturn( null ); _sessionTrackerValve.invoke( _request, _response ); verify( _request ).changeSessionId( eq( newSessionId ) ); verify( _service ).backupSession( eq( newSessionId ), eq( true ), anyString() ); 
public static Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < Object , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; sessionManager.setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.setSessionBackupAsync( false ); sessionManager.setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); catalina.addConnector( connector ); return catalina; } 
public void beforeTest ( ) { _manager = new MemcachedBackupSessionManager ( ) ; final StandardContext container = new StandardContext ( ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; when ( webappLoader . getClassLoader ( ) ) . thenReturn ( Thread . currentThread ( ) . getContextClassLoader ( ) ) ; Assert . assertNotNull ( webappLoader . getClassLoader ( ) , " Webapp Classloader is null. " ) ; _manager . getContainer ( ) . setLoader ( webappLoader ) ; Assert . assertNotNull ( _manager . getContainer ( ) . getLoader ( ) . getClassLoader ( ) , " Classloader is null. " ) ; _transcoder = new JavolutionTranscoder ( _manager , true ) ; 
private void writeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes , final ObjectOutputStream oos ) throws IOException { Accumulate the names of serializable and non-serializable attributes final String keys[] = attributes.keySet().toArray( EMPTY_ARRAY ); final List<String> saveNames = new ArrayList<String>(); final List<Object> saveValues = new ArrayList<Object>(); for ( int i = 0; i < keys.length; i++ ) { final Object value = attributes.get( keys[i] ); if ( value == null || session.exclude( keys[i] ) ) { continue; } else if ( value instanceof Serializable ) { saveNames.add( keys[i] ); saveValues.add( value ); } else { if ( LOG.isDebugEnabled() ) { LOG.debug( "Ignoring attribute '" + keys[i] + "' as it does not implement Serializable" ); } } } Serialize the attribute count and the Serializable attributes final int n = saveNames.size(); oos.writeObject( Integer.valueOf( n ) ); for ( int i = 0; i < n; i++ ) { oos.writeObject( saveNames.get( i ) ); 
public static < T > Map < T , T > asMap ( final T . . . keysAndValues ) { if ( keysAndValues = = null ) { return null ; } if ( keysAndValues . length % 2 ! = 0 ) { throw new IllegalArgumentException ( " You must provide an even number of arguments as key/value pairs. " ) ; } final Map < T , T > result = new HashMap < T , T > ( ) ; for ( int i = 0 ; i < keysAndValues . length ; i + + ) { if ( ( i & 1 ) = = 1 ) { result . put ( keysAndValues [ i - 1 ] , keysAndValues [ i ] ) ; } } return result ; } 
public void testSecondaryBackupForNonStickySessionAfterMemcachedFailover ( ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( false ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String paramKey = "foo"; final String paramValue = "bar"; final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId(); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getSessionId(); final String secondNode = extractNodeId( sid2 ); final String expectedNode = info.nextNode().getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); 
public void testReconfigureFailoverNodesAtRuntimeFeature46 ( ) throws Exception { getManager ( _tomcat1 ) . setSticky ( true ) ; Thread . sleep ( 200 ) ; we need to use another http client, otherwise there's no response cookie. final Response response2 = get( new DefaultHttpClient(), _portTomcat1, null ); final String sessionId2 = response2.getSessionId(); assertNotNull( sessionId2 ); assertEquals( extractNodeId( sessionId2 ), _nodeId3 ); 
public void testNonStickySessionIsStoredInSecondaryMemcachedForBackup ( ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat2 ) . setMaxInactiveInterval ( 1 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 100 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> primary = nodeId.equals( NODE_ID_1 ) ? _daemon1 : _daemon2; final MemCacheDaemon<?> secondary = nodeId.equals( NODE_ID_1 ) ? _daemon2 : _daemon1; assertNotNull( primary.getCache().get( key( sessionId1 ) )[0] ); assertNotNull( primary.getCache().get( key( createValidityInfoKeyName( sessionId1 ) ) )[0] ); The executor needs some time to finish the backup... Thread.sleep( 100 ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); 
public void testReconfigureMemcachedNodesAtRuntimeFeature46 ( final SessionAffinityMode sessionAffinity ) throws Exception { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( response2 . getSessionId ( ) , sessionId1 ) ; final String sessionId2 = response2 . getResponseSessionId ( ) ; assertNotNull ( sessionId2 ) ; assertEquals ( extractNodeId ( sessionId2 ) , _nodeId3 ) ; 
protected abstract Object getAttribute ( String name , InputElement xml ) throws XMLStreamException ; @Override public Object getAttribute( final String name, final javolution.xml.XMLFormat.InputElement xml ) throws XMLStreamException { return xml.getAttribute( name, 0L ); } }} 
public void testRelocateSession ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String sid1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final FailoverInfo info = getFailoverInfo( firstNode ); info.activeNode.stop(); Thread.sleep( 50 ); final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 ); final String secondNode = extractNodeId( sid2 ); assertNotSame( secondNode, firstNode, "First node again selected" ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + secondNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
public void testMultipleMemcachedNodesFailure ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String paramKey = "foo"; final String paramValue = "bar"; final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId(); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final FailoverInfo info = getFailoverInfo( firstNode ); info.activeNode.stop(); final Map.Entry<String, MemCacheDaemon<?>> otherNodeWithId = info.previousNode(); otherNodeWithId.getValue().stop(); Thread.sleep( 100 ); final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getResponseSessionId(); final String secondNode = extractNodeId( sid2 ); LOG.debug( "Have secondNode " + secondNode ); final String expectedNode = info.otherNodeExcept( otherNodeWithId.getKey() ).getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
public void testAllMemcachedNodesFailure ( ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( true ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String sid1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sid1, "No session created." ); _daemon1.stop(); _daemon2.stop(); _daemon3.stop(); wait a little bit Thread.sleep( 200 ); final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 ); assertEquals( sid1, sid2, "SessionId changed." ); assertNotNull( getSessions().get( sid1 ), "Session "+ sid1 +" not existing." ); final Session session = getManager( _tomcat1 ).findSession( sid2 ); assertFalse( session.getNoteNames().hasNext(), "Some notes are set: " + toArray( session.getNoteNames() ) ); 
public void testCookieNotSetWhenAllMemcachedsDownIssue40 ( ) throws IOException , HttpException , InterruptedException { getManager ( _tomcat1 ) . setSticky ( true ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); _daemon1.stop(); _daemon2.stop(); _daemon3.stop(); final Response response1 = get( _httpClient, _portTomcat1, null ); final String sessionId = response1.getSessionId(); assertNotNull( sessionId ); assertNotNull( response1.getResponseSessionId() ); final String nodeId = extractNodeId( response1.getResponseSessionId() ); assertNull( nodeId, "NodeId should be null, but is " + nodeId + "." ); final Response response2 = get( _httpClient, _portTomcat1, sessionId ); assertEquals( response2.getSessionId(), sessionId, "SessionId changed" ); assertNull( response2.getResponseSessionId() ); 
public void testReconfigureMemcachedNodesAtRuntimeFeature46 ( final SessionAffinityMode sessionAffinity ) throws Exception { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final Response response2 = get( _httpClient, _portTomcat1, sessionId1 ); assertNotSame( response2.getSessionId(), sessionId1 ); final String sessionId2 = response2.getResponseSessionId(); assertNotNull( sessionId2 ); assertEquals( extractNodeId( sessionId2 ), _nodeId3 ); 
public void testNoBackupWhenRunningASingleMemcachedOnly ( ) throws IOException , HttpException , InterruptedException { getManager ( _tomcat1 ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; let's take some break so that everything's up again Thread.sleep( 200 ); try { final String sessionId1 = post( _httpClient, TC_PORT_1, null, "foo", "bar" ).getSessionId(); 
public void customize ( final Kryo kryo ) { kryo . register ( LRUMap . class , new LRUMapSerializer ( kryo ) ) ; } 
public LRUMap < ? , ? > read ( final ByteBuffer buffer ) { final int maxCapacity = IntSerializer . get ( buffer , true ) ; final LRUMap < Object , Object > result = new LRUMap < Object , Object > ( maxCapacity ) ; final int size = IntSerializer . get ( buffer , true ) ; for ( int i = 0 ; i < size ; i + + ) { final Object key = _kryo . readClassAndObject ( buffer ) ; final Object value = _kryo . readClassAndObject ( buffer ) ; result . put ( key , value ) ; } return result ; } 
public void write ( final ByteBuffer buffer , final LRUMap < ? , ? > map ) { IntSerializer . put ( buffer , getMaxCapacity ( map ) , true ) ; IntSerializer . put ( buffer , map . size ( ) , true ) ; for ( final Iterator < ? extends Entry < ? , ? > > iter = map . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { final Entry < ? , ? > entry = iter . next ( ) ; _kryo . writeClassAndObject ( buffer , entry . getKey ( ) ) ; _kryo . writeClassAndObject ( buffer , entry . getValue ( ) ) ; } if ( TRACE ) trace ( " kryo " , " Wrote map: " + map ) ; } 
private boolean filterAttribute ( final String name ) { if ( this . manager = = null ) { throw new IllegalStateException ( " There's no manager set. " ) ; } Pattern pattern = ( ( MemcachedBackupSessionManager ) manager ) . getSessionAttributePattern ( ) ; if ( pattern = = null ) { return true ; } return pattern . matcher ( name ) . matches ( ) ; } 
public void updateExpiration ( final MemcachedBackupSession session ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Updating expiration time for session " + session . getId ( ) ) ; } if ( ! hasMemcachedIdSet ( session ) ) { return ; } session . setExpirationUpdateRunning ( true ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; try { final Map < String , Object > attributes = session . getAttributesFiltered ( ) ; 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestURI ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesFiltered() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.registerSince( ATTRIBUTES_SERIALIZATION, startSerialization ); _statistics.register( CACHED_DATA_SIZE, data.length ); return new SimpleFuture<BackupResult>( new BackupResult( BackupResultStatus.SUCCESS ) ); } @Override public Session findSession( final String id ) throws IOException { final Session result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.registerSince( LOAD_FROM_MEMCACHED, startDeserialization ); return null; } }} 
public Future < BackupResult > backupSession ( final Session session , final boolean sessionIdChanged , final String requestURI ) { _log . info ( " Serializing session data for session " + session . getIdInternal ( ) ) ; final long startSerialization = System . currentTimeMillis ( ) ; final byte [ ] data = _transcoderService . serializeAttributes ( ( MemcachedBackupSession ) session , ( ( MemcachedBackupSession ) session ) . getAttributesFiltered ( ) ) ; _log . info ( String . format ( " Serializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) data . length / 1000 , session . getIdInternal ( ) , System . currentTimeMillis ( ) - startSerialization ) ) ; _sessionData . put ( session . getIdInternal ( ) , data ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , startSerialization ) ; _statistics . register ( CACHED_DATA_SIZE , data . length ) ; return new SimpleFuture < BackupResult > ( new BackupResult ( BackupResultStatus . SUCCESS ) ) ; } 
private boolean filterAttribute ( final String name ) { if ( this . manager = = null ) { throw new IllegalStateException ( " There's no manager set. " ) ; } final Pattern pattern = ( ( MemcachedBackupSessionManager ) manager ) . getSessionAttributePattern ( ) ; if ( pattern = = null ) { return true ; } return pattern . matcher ( name ) . matches ( ) ; } 
private void initNonStickyLockingMode ( @Nonnull final MemcachedConfig config ) { if ( _sticky ) { setLockingMode ( null , null , false ) ; return ; } if ( _sessionAttributeFilter ! = null ) { _log . warn ( " There's a sessionAttributesFilter configured (' " + _sessionAttributeFilter + " '), " + " all other session attributes will be lost after the request due to non-sticky configuration! " ) ; } Pattern uriPattern = null ; LockingMode lockingMode = null ; if ( _lockingMode ! = null ) { if ( _lockingMode . startsWith ( " uriPattern: " ) ) { lockingMode = LockingMode . URI_PATTERN ; uriPattern = Pattern . compile ( _lockingMode . substring ( " uriPattern: " . length ( ) ) ) ; } else { lockingMode = LockingMode . valueOf ( _lockingMode . toUpperCase ( ) ) ; } } if ( lockingMode = = null ) { lockingMode = LockingMode . NONE ; } final boolean storeSecondaryBackup = config . getCountNodes ( ) > 1 ; setLockingMode ( lockingMode , uriPattern , storeSecondaryBackup ) ; } 
public void setup ( ) throws Exception { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _manager . setSessionBackupAsync ( false ) ; _manager . setSticky ( true ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; container . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration final StandardHost host = new StandardHost(); host.setParent( new StandardEngine() ); container.setParent( host ); _manager.setContainer( container ); final WebappLoader webappLoader = mock( WebappLoader.class ); webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.startInternal( _memcachedMock ); 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _manager . setStickyInternal ( false ) ; _manager . setLockingMode ( LockingMode . NONE , null , false ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _manager.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _manager.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() ); } 
public void testOnlyHashAttributesOfAccessedFilteredAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " baz " , " baz " ) ; session . access ( ) ; session . endAccess ( ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , never ( ) ) . serializeAttributes ( ( MemcachedBackupSession ) any ( ) , anyMap ( ) ) ; 
public void testOnlyFilteredAttributesAreIncludedInSessionBackup ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " foo " , " foo " ) ; session . setAttribute ( " bar " , " bar " ) ; session . setAttribute ( " baz " , " baz " ) ; _manager . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); 
public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _manager . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; _manager . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " foo " , " foo " ) ; session . setAttribute ( " bar " , " bar " ) ; session . setAttribute ( " baz " , " baz " ) ; session . access ( ) ; session . endAccess ( ) ; _manager . updateExpirationInMemcached ( ) ; capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); 
public void start ( ) throws LifecycleException { if ( ! initialized ) { init ( ) ; } Validate and update our current component state if (_started) { return; } _lifecycle.fireLifecycleEvent(START_EVENT, null); _started = true; Force initialization of the random number generator if (_log.isDebugEnabled()) { _log.debug("Force random number initialization starting"); } super.generateSessionId(); if (_log.isDebugEnabled()) { _log.debug("Force random number initialization completed"); } startInternal( null ); } 
public void stop ( ) throws LifecycleException { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Stopping " ) ; } Validate and update our current component state if (!_started) { throw new LifecycleException (sm.getString("standardManager.notStarted")); } _lifecycle.fireLifecycleEvent(STOP_EVENT, null); _started = false; Require a new random number generator if we are restarted random = null; if ( initialized ) { 
boolean wasAccessedSinceLastBackup ( ) { return super . creationTime + super . thisAccessedTime > _lastBackupTime ; } 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _msm . startInternal ( memcachedClient ) ; } 
public synchronized String generateSessionId ( ) { return _msm . newSessionId ( super . generateSessionId ( ) ) ; } 
public void expireSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " expireSession invoked: " + sessionId ) ; } super . expireSession ( sessionId ) ; _msm . deleteFromMemcached ( sessionId ) ; } 
public void remove ( final Session session ) { remove ( session , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; } 
public void removeInternal ( final Session session , final boolean update ) { update is there for tomcat7, not available in tomcat6 super.remove( session ); } 
private void remove ( final Session session , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked, removeFromMemcached: " + removeFromMemcached + " , id: " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session ) ; } 
public Session findSession ( final String id ) throws IOException { return _msm . findSession ( id ) ; } 
public Session createSession ( final String sessionId ) { return _msm . createSession ( sessionId ) ; } 
public MemcachedBackupSessionJBW3 createEmptySession ( ) { final MemcachedBackupSessionJBW3 result = new MemcachedBackupSessionJBW3 ( this ) ; result . setSticky ( _msm . isSticky ( ) ) ; return result ; } 
public void changeSessionId ( final Session session ) { e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation so that session backup won't be omitted we must store this event super.changeSessionId( session ); ((MemcachedBackupSessionJBW3)session).setSessionIdChanged( true ); } 
public void setEnabled ( final boolean enabled ) throws IllegalStateException { _msm . setEnabled ( enabled ) ; } 
public void stop ( ) throws LifecycleException { if ( log . isDebugEnabled ( ) ) { log . debug ( " Stopping " ) ; } Validate and update our current component state if (!_started) { throw new LifecycleException (sm.getString("standardManager.notStarted")); } _lifecycle.fireLifecycleEvent(STOP_EVENT, null); _started = false; Require a new random number generator if we are restarted super.random = null; if ( initialized ) { 
public void backgroundProcess ( ) { _msm . updateExpirationInMemcached ( ) ; super . backgroundProcess ( ) ; } 
public boolean isSessionBackupAsync ( ) { return _msm . isSessionBackupAsync ( ) ; } 
public SessionTrackerValveTC6 createSessionTrackerValve ( final String requestUriIgnorePattern , final Statistics statistics , final AtomicBoolean enabled ) { return new SessionTrackerValveTC6 ( requestUriIgnorePattern , ( Context ) getContainer ( ) , _msm , statistics , enabled ) ; 
public Principal readPrincipal ( final ObjectInputStream in ) throws ClassNotFoundException , IOException { final String name = in . readUTF ( ) ; final boolean hasPwd = in . readBoolean ( ) ; String pwd = null ; if ( hasPwd ) pwd = in . readUTF ( ) ; final int size = in . readInt ( ) ; final String [ ] roles = new String [ size ] ; for ( int i = 0 ; i < size ; i + + ) roles [ i ] = in . readUTF ( ) ; Principal userPrincipal = null ; final boolean hasUserPrincipal = in . readBoolean ( ) ; if ( hasUserPrincipal ) { try { userPrincipal = ( Principal ) in . readObject ( ) ; } catch ( final ClassNotFoundException e ) { log . error ( sm . getString ( " serializablePrincipal.readPrincipal.cnfe " ) , e ) ; throw e ; } } return new GenericPrincipal ( getContainer ( ) . getRealm ( ) , name , pwd , Arrays . asList ( roles ) , userPrincipal ) ; } 
public boolean isDebugEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isErrorEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isFatalEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isInfoEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isTraceEnabled ( ) ; public void fatal(Object message, Throwable t);} 
public boolean isWarnEnabled ( ) ; -------------------------------------------------------- Logging Methods public void fatal(Object message, Throwable t);} 
public void trace ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void trace ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void info ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void warn ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void error ( Object message , Throwable ) ; public void fatal ( Object message , Throwable ) ; } 
public void fatal ( Object message ) ; public void fatal ( Object message , Throwable ) ; } 
public void debug ( final Object message , final Throwable ) { _log . debug ( message , ) ; } 
public void error ( final Object message , final Throwable ) { _log . error ( message , ) ; } 
public void fatal ( final Object message , final Throwable ) { _log . fatal ( message , ) ; } 
public void info ( final Object message , final Throwable ) { _log . info ( message , ) ; } 
public void trace ( final Object message , final Throwable ) { _log . trace ( message , ) ; } 
public void warn ( final Object message , final Throwable ) { _log . warn ( message , ) ; } 
public static Log getLog ( @SuppressWarnings ( " rawtypes " ) final Class clazz ) throws LogConfigurationException { return new LogAdapter ( Logger . getLogger ( clazz ) ) ; } 
protected SessionManager createSessionManager ( ) { return new MemcachedBackupSessionManager ( ) ; } 
protected void startInternal ( final SessionManager manager , final MemcachedClient memcachedMock ) throws LifecycleException { ( ( MemcachedBackupSessionManager ) manager ) . startInternal ( memcachedMock ) ; } ; 
protected SessionTrackerValve createSessionTrackerValve ( @Nonnull final Context context ) { return new SessionTrackerValveTC6 ( null , context , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; } 
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( null , " foo " , " bar " ) ; } 
public Embedded createCatalina ( final int port , final String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes ) ; } 
public Embedded createCatalina ( final int port , final String memcachedNodes , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , null , loginType , DEFAULT_TRANSCODER_FACTORY ) ; } 
public Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , null , DEFAULT_TRANSCODER_FACTORY ) ; } 
public Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , null , transcoderFactoryClassName ) ; } 
public Embedded createCatalina ( final int port , final String memcachedNodes , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , 1 , memcachedNodes , jvmRoute , loginType , DEFAULT_TRANSCODER_FACTORY ) ; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes ) throws MalformedURLException , UnknownHostException , LifecycleException { return createCatalina ( port , sessionTimeout , memcachedNodes , null , null , DEFAULT_TRANSCODER_FACTORY ) ; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; catalina . setServer ( server ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final Engine engine = catalina . createEngine ( ) ; catalina . addEngine ( engine ) ; engine . setService ( catalina ) ; sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public abstract boolean isSticky ( ) ; } @DataProvider public static Object [ ] [ ] stickynessProvider ( ) { return new Object [ ] [ ] { { SessionAffinityMode . STICKY } , { SessionAffinityMode . NON_STICKY } } ; } @Nonnull public static Key key ( @Nonnull final String value ) { return new Key ( ChannelBuffers . wrappedBuffer ( value . getBytes ( ) ) ) ; } @Nonnull public static MemcachedBackupSession createSession ( @Nonnull final MemcachedSessionService service ) { return (MemcachedBackupSession) service.getManager().createSession( null ); final MemcachedBackupSession session = service.createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( 23 ); session.setId( "foo-n1" ); return session; }} 
public static MemcachedBackupSession createSession ( @Nonnull final MemcachedSessionService service ) { return (MemcachedBackupSession) service.getManager().createSession( null ); final MemcachedBackupSession session = service.createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( 23 ); session.setId( "foo-n1" ); return session; } 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestURI ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesFiltered() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.registerSince( ATTRIBUTES_SERIALIZATION, startSerialization ); _statistics.register( CACHED_DATA_SIZE, data.length ); return new SimpleFuture<BackupResult>( new BackupResult( BackupResultStatus.SUCCESS ) ); } @Override public Session findSession( final String id ) throws IOException { final Session result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } @Override protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.registerSince( LOAD_FROM_MEMCACHED, startDeserialization ); return null; } }} 
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return new JavaSerializationTranscoder ( manager ) ; } 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final MemcachedClient memcached , @Nonnull final MemcachedSessionService manager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup , @Nonnull final Statistics stats ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : 
private boolean filterAttribute ( final String name ) { if ( this . manager = = null ) { throw new IllegalStateException ( " There's no manager set. " ) ; } final Pattern pattern = ( ( SessionManager ) manager ) . getMemcachedSessionService ( ) . getSessionAttributePattern ( ) ; if ( pattern = = null ) { return true ; } return pattern . matcher ( name ) . matches ( ) ; } 
boolean wasAccessedSinceLastBackup ( ) { return this . thisAccessedTime > _lastBackupTime ; } 
void storeThisAccessedTimeFromLastBackupCheck ( ) { _thisAccessedTimeFromLastBackupCheck = this . thisAccessedTime ; } 
boolean wasAccessedSinceLastBackupCheck ( ) { return _thisAccessedTimeFromLastBackupCheck ! = this . thisAccessedTime ; } 
public void doAfterDeserialization ( ) { if ( listeners = = null ) { listeners = new ArrayList < SessionListener > ( ) ; } if ( notes = = null ) { notes = new ConcurrentHashMap < String , Object > ( ) ; 
public void shutdown ( ) { _log . info ( " Stopping services. " ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _memcached ! = null ) { _memcached . shutdown ( ) ; 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = _manager . createSessionTrackerValve ( _requestUriIgnorePattern , _statistics , _enabled ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( config ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( _manager ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
private TranscoderService createTranscoderService ( final Statistics statistics ) { return new TranscoderService ( getTranscoderFactory ( ) . createTranscoder ( _manager ) ) ; } 
private Class < ? extends TranscoderFactory > loadTranscoderFactoryClass ( ) throws ClassNotFoundException { Class < ? extends TranscoderFactory > transcoderFactoryClass ; final ClassLoader classLoader = _manager . getContainer ( ) . getLoader ( ) . getClassLoader ( ) ; try { _log . debug ( " Loading transcoder factory class " + _transcoderFactoryClassName + " using classloader " + classLoader ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , classLoader ) . asSubclass ( TranscoderFactory . class ) ; } catch ( final ClassNotFoundException e ) { _log . info ( " Could not load transcoderfactory class with classloader " + classLoader + " , trying " + getClass ( ) . getClassLoader ( ) ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , getClass ( ) . getClassLoader ( ) ) . asSubclass ( TranscoderFactory . class ) ; } return transcoderFactoryClass ; } 
public String newSessionId ( @Nonnull final String sessionId ) { return _sessionIdFormat . createSessionId ( sessionId , _nodeIdService . getMemcachedNodeId ( ) ) ; } 
public Session findSession ( final String id ) throws IOException { MemcachedBackupSession result = _manager . getSessionInternal ( id ) ; if ( result = = null & & canHitMemcached ( id ) & & _missingSessionsCache . get ( id ) = = null ) { when the request comes from the container, it's from CoyoteAdapter.postParseRequest if ( !_sticky && _lockingStrategy.isContainerSessionLookup() ) { we can return just null as the requestedSessionId will still be set on the request. return null; } else load the session from memcached result = loadFromMemcached( id ); checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver (due to a tomcat failover) we don't want to notify listeners via session.activate for the old sessionId but do that later (in handleSessionTakeOver) See also http:code.google.com/p/memcached-session-manager/issues/detail?id=92 String jvmRoute; final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null && !jvmRoute.equals( _sessionIdFormat.extractJvmRoute( id ) ); final boolean activate = !sessionIdWillBeChanged; addValidLoadedSession( result, activate ); } } return result; } 
private void addValidLoadedSession ( final StandardSession session , final boolean activate ) { make sure the listeners know about it. (as done by PersistentManagerBase) if ( session.isNew() ) { session.tellNew(); } _manager.add( session ); if ( activate ) { session.activate(); } endAccess() to ensure timeouts happen correctly. access() to keep access count correct or it will end up negative session.access(); session.endAccess(); } 
public Session createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; StandardSession session = null ; if ( sessionId ! = null ) { session = loadFromMemcachedWithCheck ( sessionId ) ; checking valid() would expire() the session if it's not valid! if ( session != null && session.isValid() ) { addValidLoadedSession( session, true ); } } if ( session == null ) { session = createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() ); if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) { sessionId = _manager.generateSessionId(); } session.setId( sessionId ); if ( _log.isDebugEnabled() ) { _log.debug( "Created new session with id " + session.getId() ); } } _manager.incrementSessionCounter(); return session; 
public MemcachedBackupSession createEmptySession ( ) { final MemcachedBackupSession result = _manager . newMemcachedBackupSession ( ) ; result . setSticky ( _sticky ) ; return result ; } 
public String changeSessionIdOnTomcatFailover ( final String requestedSessionId ) { if ( ! _sticky ) { return null ; } final String localJvmRoute = _manager . getJvmRoute ( ) ; if ( localJvmRoute ! = null & & ! localJvmRoute . equals ( _sessionIdFormat . extractJvmRoute ( requestedSessionId ) ) ) { the session might have been loaded already (by some valve), so let's check our session map MemcachedBackupSession session = _manager.getSessionInternal( requestedSessionId ); if ( session == null ) { session = loadFromMemcachedWithCheck( requestedSessionId ); } checking valid() can expire() the session! if ( session != null && session.isValid() ) { return handleSessionTakeOver( session ); } } return null; } 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { if ( _sticky ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _nodeIdService . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available, loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final RuntimeException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId ) { final String backupNodeId = getBackupNodeId ( requestedSessionId ) ; if ( backupNodeId = = null ) { _log . info ( " No backup node found for nodeId " + _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ) ; return null ; } if ( ! _nodeIdService . isNodeAvailable ( backupNodeId ) ) { _log . info ( " Node " + backupNodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( _sessionIdFormat . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , _manager ) ; session . setSticky ( _sticky ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; final String newSessionId = _sessionIdFormat . createNewSessionId ( requestedSessionId , backupNodeId ) ; _log . info ( " Session backup loaded from secondary memcached for " + requestedSessionId + " (will be relocated), " + " setting new id " + newSessionId + " on session... " ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
public Future < BackupResult > backupSession ( final String sessionId , final boolean sessionIdChanged , final String requestId ) { if ( ! _enabled . get ( ) ) { return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } final MemcachedBackupSession msmSession = _manager . getSessionInternal ( sessionId ) ; if ( msmSession = = null ) { _log . debug ( " No session found in session map for " + sessionId ) ; if ( ! _sticky ) { _lockingStrategy . onBackupWithoutLoadedSession ( sessionId , requestId , _backupSessionService ) ; } return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } if ( ! msmSession . isValidInternal ( ) ) { _log . debug ( " Non valid session found in session map for " + sessionId ) ; return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } if ( ! _sticky ) { msmSession . passivate ( ) ; } final boolean force = sessionIdChanged | | msmSession . isSessionIdChanged ( ) | | ! _sticky & & ( msmSession . getSecondsSinceLastBackup ( ) > = msmSession . getMaxInactiveInterval ( ) ) ; final Future < BackupResult > result = _backupSessionService . backupSession ( msmSession , force ) ; if ( ! _sticky ) { _manager . removeInternal ( msmSession , false ) ; _lockingStrategy . onAfterBackupSession ( msmSession , force , result , requestId , _backupSessionService ) ; } return result ; } 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { throw new IllegalArgumentException ( " The sessionId should contain a nodeId, this should be checked " + " by invoking canHitMemcached before invoking this method (bug, needs fix). " ) ; } if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId , _upgradeSupportTranscoder ) ; _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { final MemcachedBackupSession result ; if ( object instanceof MemcachedBackupSession ) { result = ( MemcachedBackupSession ) object ; } else { final long startDeserialization = System . currentTimeMillis ( ) ; result = _transcoderService . deserialize ( ( byte [ ] ) object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; } _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } } return null ; } 
public void setEnabled ( final boolean enabled ) throws IllegalStateException { if ( ! enabled & & ! _sticky ) { throw new IllegalStateException ( " Disabling this session manager is not allowed in non-sticky mode. You must switch to sticky operation mode before. " ) ; } final boolean changed = _enabled . compareAndSet ( ! enabled , enabled ) ; if ( changed & & _manager . isInitialized ( ) ) { reloadMemcachedConfig ( _memcachedNodes , _failoverNodes ) ; 
protected void updateExpirationInMemcached ( ) { if ( _enabled . get ( ) & & _sticky ) { final Session [ ] sessions = _manager . findSessions ( ) ; 
SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; void setCustomConverterClassNames ( String [ ] customConverterClassNames ) ; } 
public MemcachedBackupSession deserialize ( final byte [ ] data , final SessionManager manager ) { if ( data = = null ) { return null ; } try { final DeserializationResult deserializationResult = deserializeSessionFields ( data , manager ) ; 
static DeserializationResult deserializeSessionFields ( final byte [ ] data , final SessionManager manager ) throws InvalidVersionException { final MemcachedBackupSession result = manager . newMemcachedBackupSession ( ) ; final short version = ( short ) decodeNum ( data , 0 , 2 ) ; if ( version ! = CURRENT_VERSION ) { throw new InvalidVersionException ( " The version " + version + " does not match the current version " + CURRENT_VERSION , version ) ; } final short sessionFieldsDataLength = ( short ) decodeNum ( data , 2 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 4 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 12 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 20 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 24 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 25 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 26 , 8 ) ) ; result . setLastBackupTime ( decodeNum ( data , 34 , 8 ) ) ; final short idLength = ( short ) decodeNum ( data , 42 , 2 ) ; result . setIdInternal ( decodeString ( data , 44 , idLength ) ) ; final short authTypeId = ( short ) decodeNum ( data , 44 + idLength , 2 ) ; result . setAuthType ( AuthType . valueOfId ( authTypeId ) . getValue ( ) ) ; final int currentIdx = 44 + idLength + 2 ; final short principalDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( principalDataLength > 0 ) { final byte [ ] principalData = new byte [ principalDataLength ] ; System . arraycopy ( data , currentIdx + 2 , principalData , 0 , principalDataLength ) ; result . setPrincipal ( deserializePrincipal ( principalData , manager ) ) ; } final byte [ ] attributesData = new byte [ data . length - sessionFieldsDataLength ] ; System . arraycopy ( data , sessionFieldsDataLength , attributesData , 0 , data . length - sessionFieldsDataLength ) ; return new DeserializationResult ( result , attributesData ) ; } 
private static Principal deserializePrincipal ( final byte [ ] data , final SessionManager manager ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( data ) ; 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = getManager ( _tomcat1 ) ; manager . setSticky ( stickyness . isSticky ( ) ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); +1000 just to be sure that we're >4 secs assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = getManager ( _tomcat1 ) ; manager . setSticky ( stickyness . isSticky ( ) ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testLoadFromMemcachedOldSessionSerializationFormat ( ) throws InterruptedException , ExecutionException { final SessionManager manager = getManager ( _tomcat1 ) ; final Session session = manager . createSession ( null ) ; final SessionTranscoder oldSessionTranscoder = manager . getMemcachedSessionService ( ) . getTranscoderFactory ( ) . createSessionTranscoder ( manager ) ; final Future < Boolean > future = _memcached . set ( session . getId ( ) , session . getMaxInactiveInterval ( ) , session , oldSessionTranscoder ) ; assertTrue ( future . get ( ) ) ; final Session loadedFromMemcached = manager . getMemcachedSessionService ( ) . loadFromMemcachedWithCheck ( session . getId ( ) ) ; assertNotNull ( loadedFromMemcached ) ; assertDeepEquals ( session , loadedFromMemcached ) ; } 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final SessionManager manager = getManager ( _tomcat1 ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setSticky ( true ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) Thread.sleep( 4000 ); final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
public void testDisableMsmAtRuntime ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { final SessionManager manager = getManager ( _tomcat1 ) ; manager . setSticky ( true ) ; disable msm, shutdown our server and our client manager.setEnabled( false ); _memcached.shutdown(); _daemon.stop(); checkSessionFunctionalityWithMsmDisabled(); } 
public void testStartMsmDisabled ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { shutdown our server and our client _memcached.shutdown(); _daemon.stop(); start a new tomcat with msm initially disabled _tomcat1.stop(); Thread.sleep( 500 ); final String memcachedNodes = _memcachedNodeId + ":localhost:" + _memcachedPort; _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, "app1" ); final SessionManager manager = getManager( _tomcat1 ); manager.setSticky( true ); manager.setEnabled( false ); _tomcat1.start(); LOG.info( "Waiting, check logs to see if the client causes any 'Connection refused' logging..." ); Thread.sleep( 1000 ); some basic tests for session functionality checkSessionFunctionalityWithMsmDisabled(); start memcached, client and reenable msm _daemon.start(); _memcached = createMemcachedClient( new InetSocketAddress( "localhost", _memcachedPort ) ); manager.setEnabled( true ); Wait a little bit, so that msm's memcached client can connect and is ready when test starts Thread.sleep( 100 ); memcached based stuff should work again final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), "memcached node id missing with msm switched to enabled" ); Thread.sleep( 50 ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); waitForSessionExpiration( true ); assertNull( _memcached.get( sessionId1 ), "Expired session still existing in memcached" ); 
abstract TestUtils getTestUtils ( ) ; private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( getManager ( _tomcat1 ) . getMemcachedSessionService ( ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id, even with msm disabled. " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed. " ) ; } private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = getManager ( _tomcat1 ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; } } 
private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( getManager ( _tomcat1 ) . getMemcachedSessionService ( ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id, even with msm disabled. " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed. " ) ; } 
private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = getManager ( _tomcat1 ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; } 
public void setup ( ) throws Exception { final SessionManager manager = createSessionManager ( ) ; _service = manager . getMemcachedSessionService ( ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . setSticky ( true ) ; final StandardContext context = createContext ( ) ; context . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration manager.setContainer( context ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); startInternal( manager, _memcachedMock ); 
protected void startInternal ( @Nonnull final SessionManager manager , @Nonnull final MemcachedClient memcachedMock ) throws LifecycleException { throw new UnsupportedOperationException ( ) ; } 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); }} 
public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testOnlySendModifiedSessions ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSession session = createSession ( _service ) ; _service.backupSession( session.getIdInternal(), false, null ).get(); verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any() ); 
public void testOnlyHashAttributesOfAccessedAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . endAccess ( ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . setAttribute ( " foo " , " bar " ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; we need some millis between last backup and next access (due to check in BackupSessionService) Thread.sleep(5L); session.access(); session.getAttribute( "foo" ); _service.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); we need some millis between last backup and next access (due to check in BackupSessionService) Thread.sleep(5L); _service.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); 
public void testChangeSessionId ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , TimeoutException { _service . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _service . setLockingMode ( LockingMode . NONE , null , false ) ; } final MemcachedBackupSession session = createSession ( _service ) ; session . setAttribute ( " foo " , " bar " ) ; _service . backupSession ( session . getIdInternal ( ) , false , " foo " ) . get ( ) ; final String oldSessionId = session . getId ( ) ; _service . getManager ( ) . changeSessionId ( session ) ; on session backup we specify sessionIdChanged as false as we're not aware of this fact _service.backupSession( session.getIdInternal(), false, "foo" ); remove session with old id and add it with the new id verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) ); verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() ); if ( !stickyness.isSticky() ) { check validity info 
public void testSessionTimeoutUnlimitedWithSessionLoaded ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , LifecycleException { _service . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(_memcachedMock); we must put in our mock again } final MemcachedBackupSession session = createSession( _service ); session.setMaxInactiveInterval( -1 ); session.access(); session.endAccess(); session.setAttribute( "foo", "bar" ); final String sessionId = session.getId(); _service.backupSession( sessionId, false, null ).get(); verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any() ); if ( !stickyness.isSticky() ) { check validity info 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _service.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _service.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() ); } 
public void testOnlyHashAttributesOfAccessedFilteredAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; _service . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " baz " , " baz " ) ; session . access ( ) ; session . endAccess ( ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , never ( ) ) . serializeAttributes ( ( MemcachedBackupSession ) any ( ) , anyMap ( ) ) ; 
public void testOnlyFilteredAttributesAreIncludedInSessionBackup ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; _service . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " foo " , " foo " ) ; session . setAttribute ( " bar " , " bar " ) ; session . setAttribute ( " baz " , " baz " ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); 
public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; final Map < String , Object > anyMap = any ( Map . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; _service . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " foo " , " foo " ) ; session . setAttribute ( " bar " , " bar " ) ; session . setAttribute ( " baz " , " baz " ) ; session . access ( ) ; session . endAccess ( ) ; _service . updateExpirationInMemcached ( ) ; capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); 
public void setUp ( ) throws Exception { _service = mock ( SessionBackupService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( createContext ( ) ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; } 
protected abstract SessionTrackerValve createSessionTrackerValve ( @Nonnull final Context context ) ; @Nonnull protected abstract String getGlobalSessionCookieName ( @Nonnull final Context context ) ; @AfterMethod public void tearDown ( ) throws Exception { reset ( _service , _nextValve , _request , _response ) ; } @Test public final void testSessionCookieName ( ) throws IOException , ServletException { final StandardContext context = createContext ( ) ; context . setSessionCookieName ( " foo " ) ; SessionTrackerValve cut = createSessionTrackerValve ( context ) ; assertEquals ( " foo " , cut . getSessionCookieName ( ) ) ; context . setSessionCookieName ( null ) ; cut = createSessionTrackerValve ( context ) ; assertEquals ( getGlobalSessionCookieName ( context ) , cut . getSessionCookieName ( ) ) ; } @Test public final void testBackupSessionNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; } public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request , never ( ) ) . getSessionInternal ( ) ; } @Test public final void testBackupSessionInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( generateCookieString ( cookie ) ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( " foo " ) , eq ( false ) , anyString ( ) ) ; } private String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; } @Test public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; when ( _service . changeSessionIdOnMemcachedFailover ( eq ( sessionId ) ) ) . thenReturn ( newSessionId ) ; final Cookie cookie = new Cookie( _sessionTrackerValve.getSessionCookieName(), newSessionId ); when( _response.getHeader( eq( "Set-Cookie" ) ) ).thenReturn( generateCookieString( cookie ) ); when( _request.getRequestURI() ).thenReturn( "/foo" ); when( _request.getMethod() ).thenReturn( "GET" ); when( _request.getQueryString() ).thenReturn( null ); _sessionTrackerValve.invoke( _request, _response ); verify( _request ).changeSessionId( eq( newSessionId ) ); verify( _service ).backupSession( eq( newSessionId ), eq( true ), anyString() ); }} 
protected abstract String getGlobalSessionCookieName ( @Nonnull final Context context ) ; @AfterMethod public void tearDown ( ) throws Exception { reset ( _service , _nextValve , _request , _response ) ; } @Test public final void testSessionCookieName ( ) throws IOException , ServletException { final StandardContext context = createContext ( ) ; context . setSessionCookieName ( " foo " ) ; SessionTrackerValve cut = createSessionTrackerValve ( context ) ; assertEquals ( " foo " , cut . getSessionCookieName ( ) ) ; context . setSessionCookieName ( null ) ; cut = createSessionTrackerValve ( context ) ; assertEquals ( getGlobalSessionCookieName ( context ) , cut . getSessionCookieName ( ) ) ; } @Test public final void testBackupSessionNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; } public final void testGetSessionInternalNotInvokedWhenNoSessionIdPresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request , never ( ) ) . getSessionInternal ( ) ; } @Test public final void testBackupSessionInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( generateCookieString ( cookie ) ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( " foo " ) , eq ( false ) , anyString ( ) ) ; } private String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; } @Test public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; when ( _service . changeSessionIdOnMemcachedFailover ( eq ( sessionId ) ) ) . thenReturn ( newSessionId ) ; final Cookie cookie = new Cookie( _sessionTrackerValve.getSessionCookieName(), newSessionId ); when( _response.getHeader( eq( "Set-Cookie" ) ) ).thenReturn( generateCookieString( cookie ) ); when( _request.getRequestURI() ).thenReturn( "/foo" ); when( _request.getMethod() ).thenReturn( "GET" ); when( _request.getQueryString() ).thenReturn( null ); _sessionTrackerValve.invoke( _request, _response ); verify( _request ).changeSessionId( eq( newSessionId ) ); verify( _service ).backupSession( eq( newSessionId ), eq( true ), anyString() ); }} 
public final void testSessionCookieName ( ) throws IOException , ServletException { final StandardContext context = createContext ( ) ; context . setSessionCookieName ( " foo " ) ; SessionTrackerValve cut = createSessionTrackerValve ( context ) ; assertEquals ( " foo " , cut . getSessionCookieName ( ) ) ; context . setSessionCookieName ( null ) ; cut = createSessionTrackerValve ( context ) ; assertEquals ( getGlobalSessionCookieName ( context ) , cut . getSessionCookieName ( ) ) ; } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { _manager = mock ( SessionManager . class ) ; when ( _manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( _manager.newMemcachedBackupSession() ).thenReturn( newMemcachedBackupSession( _manager ) ); final MemcachedSessionService service = new MemcachedSessionService( _manager ); final MemcachedBackupSession session = createSession( service ); when( _manager.createSession( anyString() ) ).thenReturn( session ); when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() ); when( _manager.getMemcachedSessionService() ).thenReturn( service ); 
protected abstract MemcachedBackupSession newMemcachedBackupSession ( @Nullable SessionManager manager ) ; @Test public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } @Test public void testSerializeSessionFieldsWithAuthenticatedPrincipal ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAuthType ( Constants . FORM_METHOD ) ; session . setPrincipal ( createPrincipal ( ) ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } @Nonnull protected abstract GenericPrincipal createPrincipal ( ) ; @Test public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; } @Test public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastBackupTime ( ) , deserialized . getLastBackupTime ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; Assert . assertEquals ( session . getAuthType ( ) , deserialized . getAuthType ( ) ) ; assertDeepEquals ( session . getPrincipal ( ) , deserialized . getPrincipal ( ) ) ; } } 
public void testSerializeSessionFields ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionFieldsWithAuthenticatedPrincipal ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAuthType ( Constants . FORM_METHOD ) ; session . setPrincipal ( createPrincipal ( ) ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
protected abstract GenericPrincipal createPrincipal ( ) ; @Test public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; } @Test public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastBackupTime ( ) , deserialized . getLastBackupTime ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; Assert . assertEquals ( session . getAuthType ( ) , deserialized . getAuthType ( ) ) ; assertDeepEquals ( session . getPrincipal ( ) , deserialized . getPrincipal ( ) ) ; } } 
public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; } 
public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _httpClient = new DefaultHttpClient ( ) ; } 
public void testMultipleMemcachedNodesFailure ( final SessionAffinityMode sessionAffinity ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String paramKey = "foo"; final String paramValue = "bar"; final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId(); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final FailoverInfo info = getFailoverInfo( firstNode ); info.activeNode.stop(); final Map.Entry<String, MemCacheDaemon<?>> otherNodeWithId = info.previousNode(); otherNodeWithId.getValue().stop(); Thread.sleep( 100 ); final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getResponseSessionId(); final String secondNode = extractNodeId( sid2 ); LOG.debug( "Have secondNode " + secondNode ); final String expectedNode = info.otherNodeExcept( otherNodeWithId.getKey() ).getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); final MemCacheDaemon<?> activeNode = getFailoverInfo( secondNode ).activeNode; assertNotNull( activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = getManager( _tomcat1 ).findSession( sid2 ); 
public void testSecondaryBackupForNonStickySessionAfterMemcachedFailover ( ) throws Throwable { getManager ( _tomcat1 ) . setSticky ( false ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String paramKey = "foo"; final String paramValue = "bar"; final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId(); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getSessionId(); final String secondNode = extractNodeId( sid2 ); final String expectedNode = info.nextNode().getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); 
private void waitForReconnect ( final MemcachedSessionService service , final MemCacheDaemon < ? > value , final long timeToWait ) throws InterruptedException { MemcachedClient client ; InetSocketAddress serverAddress ; try { final Method m = MemcachedSessionService . class . getDeclaredMethod ( " getMemcached " ) ; m . setAccessible ( true ) ; client = ( MemcachedClient ) m . invoke ( service ) ; final Field field = MemCacheDaemon . class . getDeclaredField ( " addr " ) ; field . setAccessible ( true ) ; serverAddress = ( InetSocketAddress ) field . get ( value ) ; } catch ( final Exception e ) { throw new RuntimeException ( e ) ; } waitForReconnect ( client , serverAddress , timeToWait ) ; } 
private void restartTomcat ( final String memcachedNodes , final String failoverNodes ) throws Exception { _tomcat1 . stop ( ) ; Thread . sleep ( 500 ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , 10 , memcachedNodes ) ; getManager ( _tomcat1 ) . setFailoverNodes ( failoverNodes ) ; _tomcat1 . start ( ) ; } 
private Embedded startTomcat ( final int port ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , 5 , MEMCACHED_NODES ) ; getManager ( tomcat ) . setSticky ( false ) ; tomcat . start ( ) ; return tomcat ; } 
private Embedded startTomcatWithAuth ( final int port , @Nonnull final LockingMode lockingMode ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded result = getTestUtils ( ) . createCatalina ( port , MEMCACHED_NODES , null , LoginType . BASIC ) ; getManager ( result ) . setSticky ( false ) ; getManager ( result ) . setLockingMode ( lockingMode . name ( ) ) ; result . start ( ) ; return result ; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext( new Hashtable<String, Object>(), "ctxt" ); server.setGlobalNamingContext( globalNamingContext ); globalNamingContext.bind( USER_DATABASE, createUserDatabase() ); } catch ( final NamingException e ) { throw new RuntimeException( e ); } final URL root = new URL( TestUtils.class.getResource( "/" ), "../test-classes" ); use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
protected Context createContext ( @Nonnull final Embedded catalina , @Nonnull final String contextPath , @Nonnull final String docBase ) { return catalina . createContext ( contextPath , docBase ) ; } 
abstract TestUtils getTestUtils ( ) ; private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , jvmRoute , null ) ; } private Embedded startTomcat ( final int port , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( true ) ; return tomcat ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final Response tc2Response1 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; final Response tc2Response2 = get ( _httpClient , TC_PORT_2 , tc2Response1 . getResponseSessionId ( ) ) ; assertEquals ( tc2Response2 . get ( " foo " ) , " bar " ) ; } } 
private Embedded startTomcat ( final int port , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( true ) ; return tomcat ; } 
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { final SessionManager manager1 = getManager ( _tomcat1 ) ; final SessionManager manager2 = getManager ( _tomcat2 ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( format . stripJvmRoute ( sessionId2 ) , format . stripJvmRoute ( sessionId1 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public void testHttpSessionActivationListenersNotifiedOnLoadWithoutJvmRoute ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , null ) ; _tomcat2 = startTomcat ( TC_PORT_2 , null ) ; final SessionManager manager1 = getManager ( _tomcat1 ) ; final SessionManager manager2 = getManager ( _tomcat2 ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNull ( format . extractJvmRoute ( sessionId1 ) ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public void testDeserializeHibernateCollection ( ) { final SessionManager manager = createSessionManager ( ) ; manager . setContainer ( createContext ( ) ) ; final Set < Animal > animals = new HashSet < Animal > ( Arrays . asList ( new Animal ( " cat " ) ) ) ; final Person person = new Person ( " foo bar " , animals ) ; final Long personId = createPerson ( person ) ; final Person foundPerson = findPerson ( personId ) ; LOG . info ( " person: " + person . toString ( ) ) ; LOG . info ( " found: " + foundPerson . toString ( ) ) ; TestUtils . assertDeepEquals ( person , foundPerson ) ; final TranscoderService transcoderService = new TranscoderService ( createTranscoder ( manager ) ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789 " ) ; session . setAttribute ( " person " , foundPerson ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , manager ) ; final Person deserializedPerson = ( Person ) deserialized . getAttribute ( " person " ) ; TestUtils . assertDeepEquals ( foundPerson , deserializedPerson ) ; 
protected abstract SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } @Entity @AccessType ( " field " ) @SuppressWarnings ( " serial " ) static class Person implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; @OneToMany ( cascade = CascadeType . ALL ) public Set < Animal > animals ; public Person ( ) { } public Person ( final String name , final Set < Animal > animals ) { this . name = name ; this . animals = animals ; } @Override public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } } @Entity @AccessType ( " field " ) @SuppressWarnings ( " serial " ) static class Animal implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; public Animal ( ) { } public Animal ( final String name ) { this . name = name ; } @Override public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } } static interface Callback < T > { T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { transaction . rollback ( ) ; throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn( new MemcachedSessionService( manager ) ); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { transaction . rollback ( ) ; throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn( new MemcachedSessionService( manager ) ); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn( new MemcachedSessionService( manager ) ); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } 
private static MemcachedBackupSession createSession ( final SessionManager manager , final String id ) { final MemcachedBackupSession session = manager . getMemcachedSessionService ( ) . createEmptySession ( ) ; session . setId ( id ) ; session . setValid ( true ) ; return session ; } 
protected SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return new JavaSerializationTranscoder ( manager ) ; } 
boolean wasAccessedSinceLastBackup ( ) { return creationTime + thisAccessedTime > _lastBackupTime ; } 
void storeThisAccessedTimeFromLastBackupCheck ( ) { _thisAccessedTimeFromLastBackupCheck = thisAccessedTime ; } 
boolean wasAccessedSinceLastBackupCheck ( ) { return _thisAccessedTimeFromLastBackupCheck ! = thisAccessedTime ; } 
public MemcachedBackupSession newMemcachedBackupSession ( ) { return new MemcachedBackupSessionJBW3 ( this ) ; } 
public void debug ( final Object message , final Throwable ) { _log . doLog ( Level . DEBUG , FQCN , message , null , ) ; } 
public void debug ( final Object message ) { _log . doLog ( Level . DEBUG , FQCN , message , null , null ) ; } 
public void error ( final Object message , final Throwable ) { _log . doLog ( Level . ERROR , FQCN , message , null , ) ; } 
public void error ( final Object message ) { _log . doLog ( Level . ERROR , FQCN , message , null , null ) ; } 
public void fatal ( final Object message , final Throwable ) { _log . doLog ( Level . FATAL , FQCN , message , null , ) ; } 
public void fatal ( final Object message ) { _log . doLog ( Level . FATAL , FQCN , message , null , null ) ; } 
public void info ( final Object message , final Throwable ) { _log . doLog ( Level . INFO , FQCN , message , null , ) ; } 
public void info ( final Object message ) { _log . doLog ( Level . INFO , FQCN , message , null , null ) ; } 
public void trace ( final Object message , final Throwable ) { _log . doLog ( Level . TRACE , FQCN , message , null , ) ; } 
public void trace ( final Object message ) { _log . doLog ( Level . TRACE , FQCN , message , null , null ) ; } 
public void warn ( final Object message , final Throwable ) { _log . doLog ( Level . WARN , FQCN , message , null , ) ; } 
public void warn ( final Object message ) { _log . doLog ( Level . WARN , FQCN , message , null , null ) ; } 
protected MemcachedBackupSession newMemcachedBackupSession ( @Nullable final SessionManager manager ) { return new MemcachedBackupSessionJBW3 ( manager ) ; } 
protected Context createContext ( final Embedded catalina , final String contextPath , final String docBase ) { return catalina . createContext ( CONTEXT_PATH , " webapp " , new ContextConfig ( ) ) ; } 
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { super . testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) ; } 
public void testThisAccessedTime ( ) { final MemcachedBackupSessionJBW3 cut = new MemcachedBackupSessionJBW3 ( ) ; cut . setThisAccessedTimeInternal ( 1000 ) ; assertEquals ( cut . getThisAccessedTimeInternal ( ) , 1000 ) ; } 
public void testLastAccessedTime ( ) { final MemcachedBackupSessionJBW3 cut = new MemcachedBackupSessionJBW3 ( ) ; cut . setLastAccessedTimeInternal ( 1000 ) ; assertEquals ( cut . getLastAccessedTimeInternal ( ) , 1000 ) ; } 
public SessionTrackerValveJBW3 createSessionTrackerValve ( final String requestUriIgnorePattern , final Statistics statistics , final AtomicBoolean enabled ) { return new SessionTrackerValveJBW3 ( requestUriIgnorePattern , ( Context ) getContainer ( ) , _msm , statistics , enabled ) ; 
protected SessionTrackerValve createSessionTrackerValve ( @Nonnull final Context context ) { return new SessionTrackerValveJBW3 ( null , context , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; } 
public static StandardContext createContext ( ) { final StandardEngine engine = new StandardEngine ( ) ; engine . setService ( new StandardService ( ) ) ; final StandardContext context = new StandardContext ( ) ; context . setPath ( " / " ) ; context . setSessionCookiePath ( " / " ) ; final Loader webappLoader = new StandardLoader ( ) ; context . setLoader ( webappLoader ) ; final StandardHost host = new StandardHost ( ) ; engine . addChild ( host ) ; host . addChild ( context ) ; return context ; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext( new Hashtable<String, Object>(), "ctxt" ); server.setGlobalNamingContext( globalNamingContext ); globalNamingContext.bind( USER_DATABASE, createUserDatabase() ); } catch ( final NamingException e ) { throw new RuntimeException( e ); } final URL root = new URL( TestUtils.class.getResource( "/" ), "../test-classes" ); use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
abstract TestUtils getTestUtils ( ) ; private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , jvmRoute , null ) ; } private Embedded startTomcat ( final int port , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( true ) ; return tomcat ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final Response tc2Response1 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; final Response tc2Response2 = get ( _httpClient , TC_PORT_2 , tc2Response1 . getResponseSessionId ( ) ) ; assertEquals ( tc2Response2 . get ( " foo " ) , " bar " ) ; } } 
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { final SessionManager manager1 = getManager ( _tomcat1 ) ; final SessionManager manager2 = getManager ( _tomcat2 ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( format . stripJvmRoute ( sessionId2 ) , format . stripJvmRoute ( sessionId1 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public static void main ( final String [ ] args ) throws MalformedURLException , UnknownHostException , LifecycleException , InterruptedException { final Embedded catalina = new TestEmbeddedJBW3 ( ) . createCatalina ( 18888 ) ; catalina . start ( ) ; Thread . sleep ( Long . MAX_VALUE ) ; 
protected Context createContext ( final Embedded catalina , final String contextPath , final String docBase ) { final Context result = catalina . createContext ( CONTEXT_PATH , docBase , new ContextConfig ( ) ) ; return result ; } 
public Embedded createCatalina ( final int port ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setEnabled( false ); sessionManager.getMemcachedSessionService().setMemcachedNodes( "n1:localhost:21211" ); sessionManager.setMaxInactiveInterval( 60 ); 60 seconds sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( DEFAULT_TRANSCODER_FACTORY ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext( new Hashtable<String, Object>(), "ctxt" ); server.setGlobalNamingContext( globalNamingContext ); globalNamingContext.bind( USER_DATABASE, createUserDatabase() ); } catch ( final NamingException e ) { throw new RuntimeException( e ); } final URL root = new URL( TestUtils.class.getResource( "/" ), "../test-classes" ); use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public Embedded createCatalina ( final int port ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setEnabled( false ); sessionManager.getMemcachedSessionService().setMemcachedNodes( "n1:localhost:21211" ); sessionManager.setMaxInactiveInterval( 60 ); 60 seconds sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( DEFAULT_TRANSCODER_FACTORY ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public MemcachedBackupSession createEmptySession ( ) { return _msm . createEmptySession ( ) ; } 
public MemcachedBackupSession newMemcachedBackupSession ( ) { return new MemcachedBackupSession ( this ) ; } 
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return SerializablePrincipal . readPrincipal ( ois , getContainer ( ) . getRealm ( ) ) ; } 
protected MemcachedBackupSession newMemcachedBackupSession ( final SessionManager manager ) { return new MemcachedBackupSession ( manager ) ; } 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { super . startInternal ( ) ; _msm . startInternal ( memcachedClient ) ; setState ( LifecycleState . STARTING ) ; } 
public Session createEmptySession ( ) { return _msm . createEmptySession ( ) ; } 
public void remove ( final Session session , final boolean update ) { removeInternal ( session , update , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; } 
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session , update ) ; } 
private void removeInternal ( final Session session , final boolean update , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked, removeFromMemcached: " + removeFromMemcached + " , id: " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session , update ) ; } 
public void startInternal ( ) throws LifecycleException { startInternal ( null ) ; } 
public void stopInternal ( ) throws LifecycleException { tsetState ( LifecycleState . STOPPING ) ; if ( _msm . isSticky ( ) ) { _log . info ( " Removing sessions from local session map. " ) ; for ( final Session session : sessions . values ( ) ) { swapOut ( ( StandardSession ) session ) ; } } _msm . shutdown ( ) ; super . stopInternal ( ) ; } 
private void swapOut ( @Nonnull final StandardSession session ) { implementation like the one in PersistentManagerBase.swapOut if (!session.isValid()) { return; } session.passivate(); removeInternal( session, true ); session.recycle(); } 
public SessionTrackerValve createSessionTrackerValve ( final String requestUriIgnorePattern , final Statistics statistics , final AtomicBoolean enabled ) { return new SessionTrackerValveTC7 ( requestUriIgnorePattern , ( Context ) getContainer ( ) , _msm , statistics , enabled ) ; 
public boolean isInitialized ( ) { return getState ( ) = = LifecycleState . INITIALIZED | | getState ( ) = = LifecycleState . STARTED ; } 
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return SerializablePrincipal . readPrincipal ( ois ) ; } 
protected SessionTrackerValve createSessionTrackerValve ( @Nonnull final Context context ) { return new SessionTrackerValveTC7 ( null , context , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; } 
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( " foo " , " bar " ) ; } 
public void testMultipleMemcachedNodesFailureExtra ( ) throws Throwable { super . testMultipleMemcachedNodesFailure ( SessionAffinityMode . STICKY ) ; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
protected MemcachedBackupSession newMemcachedBackupSession ( @Nullable final SessionManager manager ) { return new MemcachedBackupSession ( manager ) ; } 
static DeserializationResult deserializeSessionFields ( final byte [ ] data , final Realm realm ) throws InvalidVersionException { final MemcachedBackupSession result = new MemcachedBackupSession ( ) ; final short version = ( short ) decodeNum ( data , 0 , 2 ) ; if ( version ! = CURRENT_VERSION ) { throw new InvalidVersionException ( " The version " + version + " does not match the current version " + CURRENT_VERSION , version ) ; } final short sessionFieldsDataLength = ( short ) decodeNum ( data , 2 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 4 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 12 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 20 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 24 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 25 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 26 , 8 ) ) ; result . setLastBackupTime ( decodeNum ( data , 34 , 8 ) ) ; final short idLength = ( short ) decodeNum ( data , 42 , 2 ) ; result . setIdInternal ( decodeString ( data , 44 , idLength ) ) ; final short authTypeId = ( short ) decodeNum ( data , 44 + idLength , 2 ) ; result . setAuthTypeInternal ( AuthType . valueOfId ( authTypeId ) . getValue ( ) ) ; final int currentIdx = 44 + idLength + 2 ; final short principalDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( principalDataLength > 0 ) { final byte [ ] principalData = new byte [ principalDataLength ] ; System . arraycopy ( data , currentIdx + 2 , principalData , 0 , principalDataLength ) ; result . setPrincipalInternal ( deserializePrincipal ( principalData , realm ) ) ; } final byte [ ] attributesData = new byte [ data . length - sessionFieldsDataLength ] ; System . arraycopy ( data , sessionFieldsDataLength , attributesData , 0 , data . length - sessionFieldsDataLength ) ; return new DeserializationResult ( result , attributesData ) ; } 
public Session findSession ( final String id ) throws IOException { MemcachedBackupSession result = ( MemcachedBackupSession ) super . findSession ( id ) ; if ( result = = null & & canHitMemcached ( id ) & & _missingSessionsCache . get ( id ) = = null ) { when the request comes from the container, it's from CoyoteAdapter.postParseRequest or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based constraint needs the session to get the authenticated principal) if ( !_sticky && _lockingStrategy.isContainerSessionLookup() && !contextHasFormBasedSecurityConstraint() ) { we can return just null as the requestedSessionId will still be set on the request. return null; } else load the session from memcached result = loadFromMemcached( id ); checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver (due to a tomcat failover) we don't want to notify listeners via session.activate for the old sessionId but do that later (in handleSessionTakeOver) See also http:code.google.com/p/memcached-session-manager/issues/detail?id=92 String jvmRoute; final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = getJvmRoute() ) != null && !jvmRoute.equals( _sessionIdFormat.extractJvmRoute( id ) ); final boolean activate = !sessionIdWillBeChanged; addValidLoadedSession( result, activate ); } } return result; } 
private boolean contextHasFormBasedSecurityConstraint ( ) { final Context context = ( Context ) getContainer ( ) ; final SecurityConstraint [ ] constraints = context . findConstraints ( ) ; final LoginConfig loginConfig = context . getLoginConfig ( ) ; return constraints ! = null & & constraints . length > 0 & & loginConfig ! = null & & Constants . FORM_METHOD . equals ( loginConfig . getAuthMethod ( ) ) ; 
private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } 
private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( sessionAffinityMode . isSticky ( ) ) ; return tomcat ; } 
public void testSerializationOfAuthStuffWithFormAuth ( final SessionAffinityMode stickyness ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_1 : null , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_2 : null , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; 
public void testSerializationOfAuthStuffWithBasicAuth ( final SessionAffinityMode stickyness ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_1 : null , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_2 : null , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; 
public void testSessionOnlyLoadedOnceWithAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , SessionAffinityMode . STICKY , JVM_ROUTE_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , SessionAffinityMode . STICKY , JVM_ROUTE_2 , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; assertEquals ( _daemon . getCache ( ) . getGetHits ( ) , 1 ) ; 
public void testSessionModificationOnTomcatFailoverNotLostWithAuth ( final SessionAffinityMode stickyness ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_1 : null , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_2 : null , LoginType . BASIC ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc1Response1 = get ( _httpClient , TC_PORT_1 , null , new UsernamePasswordCredentials ( TestUtils . USER_NAME , TestUtils . PASSWORD ) ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertEquals ( sessionId , tc1Response1 . get ( TestServlet . ID ) ) ; final Response tc2Response1 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; } else { assertEquals ( tc2Response1 . getSessionId ( ) , sessionId ) ; } final Response tc2Response2 = get ( _httpClient , TC_PORT_2 , tc2Response1 . getResponseSessionId ( ) ) ; assertEquals ( tc2Response2 . get ( " foo " ) , " bar " ) ; 
public Session findSession ( final String id ) throws IOException { MemcachedBackupSession result = _manager . getSessionInternal ( id ) ; if ( result = = null & & canHitMemcached ( id ) & & _missingSessionsCache . get ( id ) = = null ) { when the request comes from the container, it's from CoyoteAdapter.postParseRequest or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based constraint needs the session to get the authenticated principal) if ( !_sticky && _lockingStrategy.isContainerSessionLookup() && !contextHasFormBasedSecurityConstraint() ) { we can return just null as the requestedSessionId will still be set on the request. return null; } else load the session from memcached result = loadFromMemcached( id ); checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver (due to a tomcat failover) we don't want to notify listeners via session.activate for the old sessionId but do that later (in handleSessionTakeOver) See also http:code.google.com/p/memcached-session-manager/issues/detail?id=92 String jvmRoute; final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null && !jvmRoute.equals( _sessionIdFormat.extractJvmRoute( id ) ); final boolean activate = !sessionIdWillBeChanged; addValidLoadedSession( result, activate ); } } return result; } 
private boolean contextHasFormBasedSecurityConstraint ( ) { final Context context = ( Context ) _manager . getContainer ( ) ; final SecurityConstraint [ ] constraints = context . findConstraints ( ) ; final LoginConfig loginConfig = context . getLoginConfig ( ) ; return constraints ! = null & & constraints . length > 0 & & loginConfig ! = null & & Constants . FORM_METHOD . equals ( loginConfig . getAuthMethod ( ) ) ; 
public MemcachedBackupSession createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; MemcachedBackupSession session = null ; if ( sessionId ! = null ) { session = loadFromMemcachedWithCheck ( sessionId ) ; checking valid() would expire() the session if it's not valid! if ( session != null && session.isValid() ) { addValidLoadedSession( session, true ); } } if ( session == null ) { session = createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() ); if ( sessionId == null || !isNodeAvailableForSessionId( sessionId ) ) { sessionId = _manager.generateSessionId(); } session.setId( sessionId ); if ( _log.isDebugEnabled() ) { _log.debug( "Created new session with id " + session.getId() ); } } _manager.incrementSessionCounter(); return session; 
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager ) ; } 
protected JavolutionTranscoder createTranscoder ( final SessionManager manager ) { return new JavolutionTranscoder ( Thread . currentThread ( ) . getContextClassLoader ( ) , false , new HibernateCollectionsXMLFormat ( ) ) ; } 
protected KryoTranscoder createTranscoder ( final SessionManager manager ) { final String [ ] customConverter = new String [ ] { HibernateCollectionsSerializerFactory . class . getName ( ) } ; final KryoTranscoder result = new KryoTranscoder ( getClass ( ) . getClassLoader ( ) , customConverter , false ) ; return result ; } 
private static void warmup ( final MemcachedBackupSessionManager manager , final SessionAttributesTranscoder transcoder , final int loops , final int countPersons , final int nodesPerEdge ) throws InterruptedException { final TranscoderService transcoderService = new TranscoderService ( transcoder ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789abcdefghijk987654321 " , countPersons , nodesPerEdge ) ; System . out . print ( " Performing warmup for serialization using " + transcoder . getClass ( ) . getSimpleName ( ) + " ... " ) ; final long serWarmupStart = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < loops ; i + + ) transcoderService . serialize ( session ) ; System . out . println ( " ( " + ( System . currentTimeMillis ( ) - serWarmupStart ) + " ms) " ) ; System . out . print ( " Performing warmup for deserialization... " ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final long deserWarmupStart = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < loops ; i + + ) transcoderService . deserialize ( data , manager ) ; System . out . println ( " ( " + ( System . currentTimeMillis ( ) - deserWarmupStart ) + " ms) " ) ; 
public MemcachedBackupSession createSession ( final String sessionId ) { return _msm . createSession ( sessionId ) ; } 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = new SessionTrackerValve ( _requestUriIgnorePattern , ( Context ) getContainer ( ) , this , _statistics , _enabled ) ; getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( config ) ; _transcoderService = createTranscoderService ( _statistics ) ; _upgradeSupportTranscoder = getTranscoderFactory ( ) . createSessionTranscoder ( this ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
protected static MemcachedConfig createMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final List < String > nodeIds = new ArrayList < String > ( ) ; final Matcher matcher = NODE_PATTERN . matcher ( memcachedNodes ) ; final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) ; final List < InetSocketAddress > addresses = new ArrayList < InetSocketAddress > ( ) ; final Map < InetSocketAddress , String > address2Ids = new HashMap < InetSocketAddress , String > ( ) ; if ( matcher . matches ( ) ) { while ( matcher . find ( ) ) { initHandleNodeDefinitionMatch ( matcher , addresses , address2Ids , nodeIds ) ; } if ( nodeIds . isEmpty ( ) ) { throw new IllegalArgumentException ( " All nodes are also configured as failover nodes, " + " this is a configuration failure. In this case, you probably want to leave out the failoverNodes. " ) ; } } else if ( singleNodeMatcher . matches ( ) ) { for single initHandleSingleNodeDefinitionMatch(singleNodeMatcher, addresses); } final List<String> failoverNodeIds = initFailoverNodes(failoverNodes, nodeIds); return new MemcachedConfig( memcachedNodes, failoverNodes, new NodeIdList( nodeIds ), failoverNodeIds, addresses, address2Ids ); } 
public boolean isNodeAvailable ( final String key ) { try { boolean isSingleNode = ! _memcachedNodes . contains ( " " ) & & ( _failoverNodes = = null | | _failoverNodes . isEmpty ( ) ) ; 
private static void initHandleSingleNodeDefinitionMatch ( final Matcher singleNodeMatcher , final List < InetSocketAddress > addresses ) { final String hostname = singleNodeMatcher . group ( 1 ) ; final int port = Integer . parseInt ( singleNodeMatcher . group ( 2 ) ) ; final InetSocketAddress address = new InetSocketAddress ( hostname , port ) ; addresses . add ( address ) ; } 
protected synchronized String generateSessionId ( ) { boolean isSingleNode = ! _memcachedNodes . contains ( " " ) & & ( _failoverNodes = = null | | _failoverNodes . isEmpty ( ) ) ; return _sessionIdFormat . createSessionId ( super . generateSessionId ( ) , _nodeIdService . getMemcachedNodeId ( ) , isSingleNode ) ; 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { if ( _sticky ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _nodeIdService . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available, loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final IOException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId ) { final String backupNodeId = getBackupNodeId ( requestedSessionId ) ; if ( backupNodeId = = null ) { _log . info ( " No backup node found for nodeId " + _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ) ; return null ; } if ( ! _nodeIdService . isNodeAvailable ( backupNodeId ) ) { _log . info ( " Node " + backupNodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( _sessionIdFormat . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , getContainer ( ) . getRealm ( ) , this ) ; session . setSticky ( _sticky ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; boolean isSingleNode = ! _memcachedNodes . contains ( " " ) & & ( _failoverNodes = = null | | _failoverNodes . isEmpty ( ) ) ; final String newSessionId = _sessionIdFormat . createNewSessionId ( requestedSessionId , backupNodeId , isSingleNode ) ; _log . info ( " Session backup loaded from secondary memcached for " + requestedSessionId + " (will be relocated), " + " setting new id " + newSessionId + " on session... " ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
public String createSessionId ( @Nonnull final String sessionId , @Nullable final String memcachedId , boolean isSingleNode ) { if ( isSingleNode ) { return sessionId ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Creating new session id with orig id ' " + sessionId + " ' and memcached id ' " + memcachedId + " '. " ) ; } if ( memcachedId = = null ) { return sessionId ; } final int idx = sessionId . indexOf ( '.' ) ; if ( idx < 0 ) { return sessionId + " - " + memcachedId ; 
public String createNewSessionId ( @Nonnull final String sessionId , @Nonnull final String newMemcachedId , final boolean isSingleNode ) { if ( isSingleNode ) { return sessionId ; } final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot ! = - 1 ) { final String plainSessionId = sessionId . substring ( 0 , idxDot ) ; 
public void setup ( ) throws Exception { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; _manager . setSessionBackupAsync ( false ) ; _manager . setSticky ( true ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; container . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration final StandardHost host = new StandardHost(); host.setParent( new StandardEngine() ); container.setParent( host ); _manager.setContainer( container ); final WebappLoader webappLoader = mock( WebappLoader.class ); webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _manager.startInternal( _memcachedMock ); 
public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _manager . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _manager . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _manager . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _manager . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createSessionId ( " foo " , " " , false ) ) ; assertEquals ( " foo-n.jvm1 " , cut . createSessionId ( " foo.jvm1 " , " " , false ) ) ; assertEquals ( " foo-n.j-v-m1 " , cut . createSessionId ( " foo.j-v-m1 " , " " , false ) ) ; } 
public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " , false ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " , false ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " , false ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo.jvm1 " , " m " , false ) ) ; assertEquals ( " foo-m.j-v-m1 " , cut . createNewSessionId ( " foo.j-v-m1 " , " m " , false ) ) ; 
public static void setup ( ) throws LifecycleException { _manager = new MemcachedBackupSessionManager ( ) ; _manager . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; final StandardContext container = new StandardContext ( ) ; container . setPath ( " / " ) ; final StandardHost host = new StandardHost ( ) ; host . setParent ( new StandardEngine ( ) ) ; container . setParent ( host ) ; _manager . setContainer ( container ) ; final WebappLoader webappLoader = mock ( WebappLoader . class ) ; webappLoaderControl.expects( once() ).method( "setContainer" ).withAnyArguments(); when( webappLoader.getClassLoader() ).thenReturn( Thread.currentThread().getContextClassLoader() ); Assert.assertNotNull( webappLoader.getClassLoader(), "Webapp Classloader is null." ); _manager.getContainer().setLoader( webappLoader ); _manager.start(); 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = _manager . createSessionTrackerValve ( _requestUriIgnorePattern , _statistics , _enabled ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( config ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { throw new IllegalArgumentException ( " The sessionId should contain a nodeId, this should be checked " + " by invoking canHitMemcached before invoking this method (bug, needs fix). " ) ; } if ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { _log . debug ( " Asked for session " + sessionId + " , but the related " + " memcached node is still marked as unavailable (won't load from memcached). " ) ; } else { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId ) ; _nodeIdService . setNodeAvailable ( nodeId , true ) ; if ( object ! = null ) { if ( ! ( object instanceof byte [ ] ) ) { throw new RuntimeException ( " The loaded object for sessionId " + sessionId + " is not of required type byte[], but " + object . getClass ( ) . getName ( ) ) ; } final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _nodeIdService . setNodeAvailable ( nodeId , false ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } } return null ; } 
SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; void setCustomConverterClassNames ( String [ ] customConverterClassNames ) ; } 
private Triple < Kryo , SerializerFactory [ ] , UnregisteredClassHandler [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( { " rawtypes " } ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } return super . newSerializer ( clazz ) ; } @SuppressWarnings ( { " rawtypes " } ) @Override protected void handleUnregisteredClass ( final Class clazz ) { if ( _unregisteredClassHandlers ! = null ) { for ( int i = 0 ; i < _unregisteredClassHandlers . length ; i + + ) { final boolean handled = _unregisteredClassHandlers [ i ] . handleUnregisteredClass ( clazz ) ; if ( handled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " UnregisteredClassHandler " + _unregisteredClassHandlers [ i ] . getClass ( ) . getName ( ) + " handled class " + clazz ) ; } return ; } } } super . handleUnregisteredClass ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Triple.create( kryo, pair.b, pair.c ); } 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = _manager . createSessionTrackerValve ( _requestUriIgnorePattern , _statistics , _enabled ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( config ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _nodeIdService , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, have node ids " + config . getNodeIds ( ) + " and failover node ids " + config . getFailoverNodeIds ( ) ) ; 
protected static MemcachedConfig createMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final List < String > nodeIds = new ArrayList < String > ( ) ; final Matcher matcher = NODE_PATTERN . matcher ( memcachedNodes ) ; final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) ; final List < InetSocketAddress > addresses = new ArrayList < InetSocketAddress > ( ) ; final Map < InetSocketAddress , String > address2Ids = new HashMap < InetSocketAddress , String > ( ) ; if ( singleNodeMatcher . matches ( ) ) { for single initHandleSingleNodeDefinitionMatch(singleNodeMatcher, addresses); } else { If mutliple nodes are configured while (matcher.find()) { initHandleNodeDefinitionMatch(matcher, addresses, address2Ids, nodeIds); } if (nodeIds.isEmpty()) { throw new IllegalArgumentException("All nodes are also configured as failover nodes," + " this is a configuration failure. In this case, you probably want to leave out the failoverNodes."); } } final List<String> failoverNodeIds = initFailoverNodes(failoverNodes, nodeIds); return new MemcachedConfig( memcachedNodes, failoverNodes, new NodeIdList( nodeIds ), failoverNodeIds, addresses, address2Ids ); } 
public String newSessionId ( @Nonnull final String sessionId ) { return _sessionIdFormat . createSessionId ( sessionId , _nodeIdService . getMemcachedNodeId ( ) ) ; } 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { try { if ( _sticky ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _nodeIdService . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available, loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final RuntimeException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId ) { final String backupNodeId = getBackupNodeId ( requestedSessionId ) ; if ( backupNodeId = = null ) { _log . info ( " No backup node found for nodeId " + _sessionIdFormat . extractMemcachedId ( requestedSessionId ) ) ; return null ; } if ( ! _nodeIdService . isNodeAvailable ( backupNodeId ) ) { _log . info ( " Node " + backupNodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( _sessionIdFormat . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , _manager ) ; session . setSticky ( _sticky ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; final String newSessionId = _sessionIdFormat . createNewSessionId ( requestedSessionId , backupNodeId ) ; _log . info ( " Session backup loaded from secondary memcached for " + requestedSessionId + " (will be relocated), " + " setting new id " + newSessionId + " on session... " ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
public String createSessionId ( @Nonnull final String sessionId , @Nullable final String memcachedId ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Creating new session id with orig id ' " + sessionId + " ' and memcached id ' " + memcachedId + " '. " ) ; } if ( memcachedId = = null ) { return sessionId ; } final int idx = sessionId . indexOf ( '.' ) ; if ( idx < 0 ) { return sessionId + " - " + memcachedId ; 
public String createNewSessionId ( @Nonnull final String sessionId , @Nonnull final String newMemcachedId ) { final int idxDot = sessionId . indexOf ( '.' ) ; if ( idxDot ! = - 1 ) { final String plainSessionId = sessionId . substring ( 0 , idxDot ) ; 
public void testCreateSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-n.jvm1 " , cut . createSessionId ( " foo.jvm1 " , " " ) ) ; assertEquals ( " foo-n.j-v-m1 " , cut . createSessionId ( " foo.j-v-m1 " , " " ) ) ; } 
public void testCreateNewSessionId ( ) { final SessionIdFormat cut = new SessionIdFormat ( ) ; assertEquals ( " foo-n " , cut . createNewSessionId ( " foo " , " " ) ) ; assertEquals ( " foo-m " , cut . createNewSessionId ( " foo-n " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo-n.jvm1 " , " m " ) ) ; assertEquals ( " foo-m.jvm1 " , cut . createNewSessionId ( " foo.jvm1 " , " m " ) ) ; assertEquals ( " foo-m.j-v-m1 " , cut . createNewSessionId ( " foo.j-v-m1 " , " m " ) ) ; 
protected void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _msm . startInternal ( memcachedClient ) ; } 
protected void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { super . startInternal ( ) ; _msm . startInternal ( memcachedClient ) ; setState ( LifecycleState . STARTING ) ; } 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { return null ; } 
protected MemcachedClientCallback createMemcachedClientCallback ( ) { treturn new MemcachedClientCallback ( ) { @Override 
public boolean isValid ( final String sessionId ) { treturn sessionId ! = null ; } 
public String createBackupKey ( final String origKey ) { tthrow new UnsupportedOperationException ( " Not supported for single node configuration without node id. " ) ; } 
public String createLockName ( final String sessionId ) { tthrow new UnsupportedOperationException ( " Not supported for single node configuration without node id. " ) ; } 
public String createSessionId ( final String sessionId , final String memcachedId ) { treturn sessionId ; } 
public String extractMemcachedId ( final String sessionId ) { tthrow new UnsupportedOperationException ( " Not supported for single node configuration without node id. " ) ; } 
protected NodeAvailabilityCache < String > createNodeAvailabilityCache ( final int size , final long ttlInMillis , @Nonnull final MemcachedClientCallback memcachedClientCallback ) { return new NodeAvailabilityCache < String > ( size , ttlInMillis , new CacheLoader < String > ( ) { 
public boolean isNodeAvailable ( final String key ) { try { tmemcachedClientCallback . get ( _sessionIdFormat . createSessionId ( " ping " , key ) ) ; 
public static MemcachedNodesManager createFor ( final String memcachedNodes , final String failoverNodes , final MemcachedClientCallback memcachedClientCallback ) { tif ( memcachedNodes = = null | | memcachedNodes . trim ( ) . isEmpty ( ) ) { tthrow new IllegalArgumentException ( " null or empty memcachedNodes not allowed. " ) ; } if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final Matcher matcher = NODE_PATTERN . matcher ( memcachedNodes ) ; final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) ; } 
private static List < String > initFailoverNodes ( final String failoverNodes , final Collection < String > allNodeIds ) { final List < String > failoverNodeIds = new ArrayList < String > ( ) ; if ( failoverNodes ! = null & & failoverNodes . trim ( ) . length ( ) ! = 0 ) { final String [ ] failoverNodesArray = failoverNodes . split ( " |, " ) ; for ( final String failoverNodeId : failoverNodesArray ) { final String failoverNodeIdTrimmed = failoverNodeId . trim ( ) ; tif ( ! allNodeIds . contains ( failoverNodeIdTrimmed ) ) { throw new IllegalArgumentException ( " Invalid failover node id " + failoverNodeIdTrimmed + " : " + " not existing in memcachedNodes ' " + allNodeIds + " '. " ) ; } failoverNodeIds . add ( failoverNodeIdTrimmed ) ; } } return failoverNodeIds ; } 
public boolean isEncodeNodeIdInSessionId ( ) { treturn getCountNodes ( ) > 1 | | ! _primaryNodeIds . isEmpty ( ) ; } 
public String getNodeId ( final InetSocketAddress socketAddress ) throws IllegalArgumentException { tif ( socketAddress = = null ) { tthrow new IllegalArgumentException ( " SocketAddress must not be null. " ) ; } tfinal String result = _address2Ids . get ( socketAddress ) ; tif ( result = = null ) { tthrow new IllegalArgumentException ( " SocketAddress " + socketAddress + " not known (registered addresses: " + _address2Ids . keySet ( ) + " ). " ) ; } treturn result ; } 
public String createSessionId ( @Nonnull final String sessionId ) { treturn isEncodeNodeIdInSessionId ( ) ? _sessionIdFormat . createSessionId ( sessionId , _nodeIdService . getMemcachedNodeId ( ) ) : sessionId ; } 
public boolean isNodeAvailable ( final String nodeId ) { treturn _nodeIdService . isNodeAvailable ( nodeId ) ; } 
public boolean isValidForMemcached ( final String sessionId ) { tif ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { LOG . debug ( " The sessionId does not contain a nodeId so that the memcached node could not be identified. " ) ; return false ; } } treturn true ; } 
public boolean canHitMemcached ( final String sessionId ) { tif ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( sessionId ) ; if ( nodeId = = null ) { LOG . debug ( " The sessionId does not contain a nodeId so that the memcached node could not be identified. " ) ; return false ; } tif ( ! _nodeIdService . isNodeAvailable ( nodeId ) ) { LOG . debug ( " The node " + nodeId + " is not available, therefore " + sessionId + " cannot be loaded from this memcached. " ) ; return false ; } } treturn true ; } 
public void onLoadFromMemcachedSuccess ( final String sessionId ) { tsetNodeAvailableForSessionId ( sessionId , true ) ; } 
public void onLoadFromMemcachedFailure ( final String sessionId ) { tsetNodeAvailableForSessionId ( sessionId , false ) ; } 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; _memcached = memcachedClient ! = null ? memcachedClient : createMemcachedClient ( _memcachedNodesManager , _statistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = _manager . createSessionTrackerValve ( _requestUriIgnorePattern , _statistics , _enabled ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
tprotected MemcachedClientCallback createMemcachedClientCallback ( ) { treturn new MemcachedClientCallback ( ) { @Override 
protected MemcachedNodesManager createMemcachedNodesManager ( final String memcachedNodes , final String failoverNodes ) { treturn MemcachedNodesManager . createFor ( memcachedNodes , failoverNodes , _memcachedClientCallback ) ; } 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } try { final ConnectionFactory connectionFactory = createConnectionFactory ( memcachedNodesManager , statistics ) ; 
private ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , tmemcachedNodesManager . getSessionIdFormat ( ) , tstatistics ) : new BinaryConnectionFactory ( ) ; } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics ) 
public String newSessionId ( @Nonnull final String sessionId ) { return _memcachedNodesManager . createSessionId ( sessionId ) ; } 
public Session findSession ( final String id ) throws IOException { MemcachedBackupSession result = _manager . getSessionInternal ( id ) ; if ( result = = null & & canHitMemcached ( id ) & & _missingSessionsCache . get ( id ) = = null ) { when the request comes from the container, it's from CoyoteAdapter.postParseRequest or AuthenticatorBase.invoke (for some kind of security-constraint, where a form-based constraint needs the session to get the authenticated principal) if ( !_sticky && _lockingStrategy.isContainerSessionLookup() && !contextHasFormBasedSecurityConstraint() ) { we can return just null as the requestedSessionId will still be set on the request. return null; } else load the session from memcached result = loadFromMemcached( id ); checking valid() would expire() the session if it's not valid! if ( result != null && result.isValid() ) { When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver (due to a tomcat failover) we don't want to notify listeners via session.activate for the old sessionId but do that later (in handleSessionTakeOver) See also http:code.google.com/p/memcached-session-manager/issues/detail?id=92 String jvmRoute; final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( id ) ); final boolean activate = !sessionIdWillBeChanged; addValidLoadedSession( result, activate ); } } return result; } 
public MemcachedBackupSession createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; MemcachedBackupSession session = null ; if ( sessionId ! = null ) { session = loadFromMemcachedWithCheck ( sessionId ) ; checking valid() would expire() the session if it's not valid! if ( session != null && session.isValid() ) { addValidLoadedSession( session, true ); } } if ( session == null ) { session = createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( _manager.getMaxInactiveInterval() ); if ( sessionId == null || !_memcachedNodesManager.canHitMemcached( sessionId ) ) { sessionId = _manager.generateSessionId(); } session.setId( sessionId ); if ( _log.isDebugEnabled() ) { _log.debug( "Created new session with id " + session.getId() ); } } _manager.incrementSessionCounter(); return session; 
protected void deleteFromMemcached ( final String sessionId ) { if ( _enabled . get ( ) & & _memcachedNodesManager . isValidForMemcached ( sessionId ) ) { if ( _log . isDebugEnabled ( ) ) { 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { tif ( ! _memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ) { treturn null ; } try { if ( _sticky ) { final String nodeId = getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _memcachedNodesManager . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available, loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final RuntimeException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId ) { final String backupNodeId = getBackupNodeId ( requestedSessionId ) ; if ( backupNodeId = = null ) { _log . info ( " No backup node found for nodeId " + getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ) ; return null ; } if ( ! _memcachedNodesManager . isNodeAvailable ( backupNodeId ) ) { _log . info ( " Node " + backupNodeId + " that stores the backup of the session " + requestedSessionId + " is not available. " ) ; return null ; } try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; if ( validityInfo = = null | | ! validityInfo . isValid ( ) ) { _log . info ( " No validity info (or no valid one) found for sessionId " + requestedSessionId ) ; return null ; } final Object obj = _memcached . get ( getSessionIdFormat ( ) . createBackupKey ( requestedSessionId ) ) ; if ( obj = = null ) { _log . info ( " No backup found for sessionId " + requestedSessionId ) ; return null ; } final MemcachedBackupSession session = _transcoderService . deserialize ( ( byte [ ] ) obj , _manager ) ; session . setSticky ( _sticky ) ; session . setLastAccessedTimeInternal ( validityInfo . getLastAccessedTime ( ) ) ; session . setThisAccessedTimeInternal ( validityInfo . getThisAccessedTime ( ) ) ; final String newSessionId = getSessionIdFormat ( ) . createNewSessionId ( requestedSessionId , backupNodeId ) ; _log . info ( " Session backup loaded from secondary memcached for " + requestedSessionId + " (will be relocated), " + " setting new id " + newSessionId + " on session... " ) ; session . setIdInternal ( newSessionId ) ; return session ; } catch ( final Exception e ) { _log . error ( " Could not get backup validityInfo or backup session for sessionId " + requestedSessionId , e ) ; } return null ; } 
boolean isBackupNodeAvailable ( @Nonnull final String sessionId ) { final String backupNodeId = getBackupNodeId ( sessionId ) ; return backupNodeId = = null ? false : _memcachedNodesManager . isNodeAvailable ( backupNodeId ) ; } 
private boolean canHitMemcached ( @Nonnull final String sessionId ) { return _enabled . get ( ) & & _memcachedNodesManager . canHitMemcached ( sessionId ) ; } 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { if ( ! ( object instanceof byte [ ] ) ) { throw new RuntimeException ( " The loaded object for sessionId " + sessionId + " is not of required type byte[], but " + object . getClass ( ) . getName ( ) ) ; } final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final NodeFailureException e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " ) ; _memcachedNodesManager . onLoadFromMemcachedFailure ( sessionId ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } return null ; } 
private MemcachedNodesManager reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( _memcached ! = null ) { _memcached . shutdown ( ) ; } _memcached = memcachedClient ; _memcachedNodesManager = memcachedNodesManager ; _backupSessionService = backupSessionService ; initNonStickyLockingMode ( memcachedNodesManager ) ; return memcachedNodesManager ; } 
private void initNonStickyLockingMode ( @Nonnull final MemcachedNodesManager config ) { if ( _sticky ) { setLockingMode ( null , null , false ) ; return ; } if ( _sessionAttributeFilter ! = null ) { _log . warn ( " There's a sessionAttributesFilter configured (' " + _sessionAttributeFilter + " '), " + " all other session attributes will be lost after the request due to non-sticky configuration! " ) ; } Pattern uriPattern = null ; LockingMode lockingMode = null ; if ( _lockingMode ! = null ) { if ( _lockingMode . startsWith ( " uriPattern: " ) ) { lockingMode = LockingMode . URI_PATTERN ; uriPattern = Pattern . compile ( _lockingMode . substring ( " uriPattern: " . length ( ) ) ) ; } else { lockingMode = LockingMode . valueOf ( _lockingMode . toUpperCase ( ) ) ; } } if ( lockingMode = = null ) { lockingMode = LockingMode . NONE ; } final boolean storeSecondaryBackup = config . getCountNodes ( ) > 1 ; setLockingMode ( lockingMode , uriPattern , storeSecondaryBackup ) ; } 
public static < A , B > Pair < A , B > of ( final A first , final B second ) { treturn new Pair < A , B > ( first , second ) ; } 
public NodeLocator createLocator ( final List < MemcachedNode > nodes ) { return new SuffixBasedNodeLocator ( nodes , _memcachedNodesManager , _sessionIdFormat ) ; } 
public void testParseWithEmptyStringShouldThrowException ( ) { tcreateFor ( " " , null , _mcc ) ; } 
public void testSingleSimpleNodeAndFailoverNodeShouldThrowException ( ) { tcreateFor ( " localhost:11211 " , " n1 " , _mcc ) ; } 
public void testSingleNodeAndFailoverNodeShouldThrowException ( ) { tcreateFor ( " n1:localhost:11211 " , " n1 " , _mcc ) ; } 
public static Object [ ] [ ] nodesAndExpectedCountDataProvider ( ) { treturn new Object [ ] [ ] { { " localhost:11211 " , 1 } , 
public void testCountNodes ( final String memcachedNodes , final int expectedCount ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , null , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getCountNodes ( ) , expectedCount ) ; } 
public static Object [ ] [ ] nodesAndPrimaryNodesDataProvider ( ) { treturn new Object [ ] [ ] { { " localhost:11211 " , null , new NodeIdList ( ) } , 
public void testPrimaryNodes ( final String memcachedNodes , final String failoverNodes , final NodeIdList expectedPrimaryNodeIds ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getPrimaryNodeIds ( ) , expectedPrimaryNodeIds ) ; } 
public static Object [ ] [ ] nodesAndFailoverNodesDataProvider ( ) { treturn new Object [ ] [ ] { { " localhost:11211 " , null , Collections . emptyList ( ) } , 
public void testFailoverNodes ( final String memcachedNodes , final String failoverNodes , final List < String > expectedFailoverNodeIds ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getFailoverNodeIds ( ) , expectedFailoverNodeIds ) ; } 
public static Object [ ] [ ] nodesAndExpectedEncodedInSessionIdDataProvider ( ) { treturn new Object [ ] [ ] { { " localhost:11211 " , null , false } , 
public void testIsEncodeNodeIdInSessionId ( final String memcachedNodes , final String failoverNodes , final boolean expectedIsEncodeNodeIdInSessionId ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , null , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . isEncodeNodeIdInSessionId ( ) , expectedIsEncodeNodeIdInSessionId ) ; } 
public void testGetNodeIdShouldThrowExceptionForNullArgument ( ) { tfinal MemcachedNodesManager result = createFor ( " n1:localhost:11211 " , null , _mcc ) ; tresult . getNodeId ( null ) ; } 
public static Object [ ] [ ] testGetNodeIdDataProvider ( ) { treturn new Object [ ] [ ] { { " n1:localhost:11211 " , null , new InetSocketAddress ( " localhost " , 11211 ) , " n1 " } , 
public void testGetNodeId ( final String memcachedNodes , final String failoverNodes , final InetSocketAddress socketAddress , final String expectedNodeId ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertEquals ( result . getNodeId ( socketAddress ) , expectedNodeId ) ; } 
public void testGetNextPrimaryNodeId ( ) { tassertNull ( createFor ( " n1:localhost:11211 " , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) ) ; tassertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) , " n2 " ) ; } 
public static Object [ ] [ ] testgGetAllMemcachedAddressesDataProvider ( ) { treturn new Object [ ] [ ] { { " n1:localhost:11211 " , null , asList ( new InetSocketAddress ( " localhost " , 11211 ) ) } , 
public void testgGetAllMemcachedAddresses ( final String memcachedNodes , final String failoverNodes , final Collection < InetSocketAddress > expectedSocketAddresses ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertEquals ( result . getAllMemcachedAddresses ( ) , expectedSocketAddresses ) ; } 
public void testGetSessionIdFormat ( ) { tfinal SessionIdFormat sessionIdFormat = createFor ( " n1:localhost:11211 " , null , _mcc ) . getSessionIdFormat ( ) ; tassertNotNull ( sessionIdFormat ) ; } 
public void testCreateSessionIdShouldOnlyAddNodeIdIfPresent ( ) { tassertEquals ( createFor ( " n1:localhost:11211 " , null , _mcc ) . createSessionId ( " foo " ) , " foo-n1 " ) ; tassertEquals ( createFor ( " localhost:11211 " , null , _mcc ) . createSessionId ( " foo " ) , " foo " ) ; } 
public void testSetNodeAvailable ( ) { tfinal MemcachedNodesManager cut = createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , _mcc ) ; tassertTrue ( cut . isNodeAvailable ( " n1 " ) ) ; tassertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; tcut . setNodeAvailable ( " n1 " , false ) ; tassertFalse ( cut . isNodeAvailable ( " n1 " ) ) ; tassertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; _memcachedNodeId = " n1 " ; final String memcachedNodes = _memcachedNodeId + " :localhost: " + _memcachedPort ; try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , _memcachedClientCallback ) ; final MemcachedClient result = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void testStartMsmDisabled ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { shutdown our server and our client _memcached.shutdown(); _daemon.stop(); start a new tomcat with msm initially disabled _tomcat1.stop(); Thread.sleep( 500 ); final String memcachedNodes = _memcachedNodeId + ":localhost:" + _memcachedPort; _tomcat1 = getTestUtils().createCatalina( _portTomcat1, memcachedNodes, "app1" ); final SessionManager manager = getManager( _tomcat1 ); manager.setSticky( true ); manager.setEnabled( false ); _tomcat1.start(); LOG.info( "Waiting, check logs to see if the client causes any 'Connection refused' logging..." ); Thread.sleep( 1000 ); some basic tests for session functionality checkSessionFunctionalityWithMsmDisabled(); start memcached, client and reenable msm _daemon.start(); _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( "localhost", _memcachedPort ) ); manager.setEnabled( true ); Wait a little bit, so that msm's memcached client can connect and is ready when test starts Thread.sleep( 100 ); memcached based stuff should work again final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), "memcached node id missing with msm switched to enabled" ); Thread.sleep( 50 ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); waitForSessionExpiration( true ); assertNull( _memcached.get( sessionId1 ), "Expired session still existing in memcached" ); 
public Object get ( final String key ) { return _client . get ( key ) ; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , _memcachedClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , PlainSocketFactory . getSocketFactory ( ) , 80 ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , _memcachedClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) ) , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
abstract TestUtils getTestUtils ( ) ; private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( sessionAffinityMode . isSticky ( ) ) ; return tomcat ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final Response tc2Response1 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; } else { assertEquals ( tc2Response1 . getSessionId ( ) , sessionId ) ; } final Response tc2Response2 = get ( _httpClient , TC_PORT_2 , tc2Response1 . getResponseSessionId ( ) ) ; assertEquals ( tc2Response2 . get ( " foo " ) , " bar " ) ; } } 
private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , MEMCACHED_NODES , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( sessionAffinityMode . isSticky ( ) ) ; return tomcat ; } 
public void setUp ( final Method testMethod ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? _memcachedNodeId + " : " : " " ; final String memcachedNodes = nodePrefix + " localhost: " + _memcachedPort ; try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) ) : new DefaultConnectionFactory ( ) ; final MemcachedClient result = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void testSessionIdIsNotChangedIfSingleNodeWithNoMemcachedNodeIdConfigured ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertTrue ( sessionId1 . indexOf ( '-' ) = = - 1 ) ; } 
public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , _portTomcat1 , null , key , value ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; } 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); }} 
public void testConfigurationFormatMemcachedNodesFeature105 ( ) throws LifecycleException { _service . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , true ) ; _service . shutdown ( ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , true ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456-n1 " ) , true ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? NODE_ID + " : " : " " ; _memcachedNodes = nodePrefix + " localhost: " + MEMCACHED_PORT ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( _memcachedNodes , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) ) : new DefaultConnectionFactory ( ) ; _client = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
abstract TestUtils getTestUtils ( ) ; private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , _memcachedNodes , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( sessionAffinityMode . isSticky ( ) ) ; return tomcat ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final Response tc2Response1 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" ) ); if ( stickyness.isSticky() ) { assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) ); } else { assertEquals( tc2Response1.getSessionId(), sessionId ); } final Response tc2Response2 = get( _httpClient, TC_PORT_2, tc2Response1.getResponseSessionId() ); assertEquals( tc2Response2.get( "foo" ), "bar" ); }} 
private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , _memcachedNodes , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( sessionAffinityMode . isSticky ( ) ) ; return tomcat ; } 
public void testTomcatFailoverWithSingleNodeWithoutConfiguredNodeId ( ) throws IOException , InterruptedException , HttpException { with this group (GROUP_WITHOUT_NODE_ID) the setup method does no set the memcached node id in the memcached nodes configuration. the tomcat failover test does not rely on the node id so that we can just reuse it... testTomcatFailover(); } 
public void removeAttribute ( final String name ) { if ( filterAttribute ( name ) ) { _attributesAccessed = true ; } super . removeAttribute ( name ) ; } 
public void testSessionUpdatedInMemcachedWhenSessionAttributeIsRemovedIssue106 ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setSticky ( sessionAffinity . isSticky ( ) ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , _portTomcat1 , null , key , value ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; assertEquals ( response . getSessionId ( ) , sessionId1 ) ; assertEquals ( response . get ( key ) , value ) ; final Map < String , String > params = asMap ( PARAM_REMOVE , key ) ; response = get ( _httpClient , _portTomcat1 , " / " , sessionId1 , params ) ; assertEquals ( response . getSessionId ( ) , sessionId1 ) ; assertNull ( response . get ( key ) ) ; also the next request must not include this session attribute response = get( _httpClient, _portTomcat1, sessionId1 ); assertEquals( response.getSessionId(), sessionId1 ); assertNull( response.get( key ) ); 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final String pathInfo = request . getPathInfo ( ) ; LOG . info ( " + starting " + pathInfo + " ... " ) ; if ( PATH_GET_REQUESTED_SESSION_INFO . equals ( pathInfo ) ) { LOG . info ( " getRequestedSessionId: " + request . getRequestedSessionId ( ) ) ; LOG . info ( " isRequestedSessionIdValid: " + request . isRequestedSessionIdValid ( ) ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( KEY_REQUESTED_SESSION_ID + " = " + request . getRequestedSessionId ( ) ) ; out . println ( KEY_IS_REQUESTED_SESSION_ID_VALID + " = " + request . isRequestedSessionIdValid ( ) ) ; } else if ( PATH_NO_SESSION_ACCESS . equals ( pathInfo ) ) { LOG . info ( " skipping session access " ) ; response . getWriter ( ) . println ( " Skipped session access " ) ; } else { final HttpSession session = request . getSession ( ) ; waitIfRequested ( request ) ; final String removeKey = request . getParameter ( PARAM_REMOVE ) ; if ( removeKey ! = null & & ! " " . equals ( removeKey ) ) { final String [ ] keys = removeKey . split ( " , " ) ; LOG . info ( " Removing " + ( keys . length > 1 ? " keys " : " key " ) + Arrays . asList ( keys ) ) ; for ( final String key : keys ) { session . removeAttribute ( key ) ; } } final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + session . getId ( ) ) ; final HttpSession session = request.getSession( false ); if ( session != null ) { final Enumeration<?> attributeNames = session.getAttributeNames(); while ( attributeNames.hasMoreElements() ) { final String name = attributeNames.nextElement().toString(); final Object value = session.getAttribute( name ); out.println( name + "=" + value ); } } } LOG.info( " - finished." ); 
public Map < String , Object > deserializeAttributes ( byte [ ] in ) { tString deJasonise = new String ( in ) ; tlog . debug ( " deserializer the stream " ) ; ttry { @SuppressWarnings("unchecked") 
public byte [ ] serializeAttributes ( MemcachedBackupSession sessions , Map < String , Object > attributes ) { treturn doSerialize ( attributes ) ; } 
private byte [ ] doSerialize ( final Object object ) { tif ( object = = null ) { tthrow new NullPointerException ( ) ; } tfinal ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ttry { This performs a deep serialization of the target instance. 
tprotected MemcachedBackupSession deserialize ( byte [ ] in ) { tfinal ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ttry { tfinal MemcachedBackupSession session = ( MemcachedBackupSession ) manager . createEmptySession ( ) ; 
public SessionAttributesTranscoder createTranscoder ( SessionManager manager ) { treturn getTranscoder ( manager ) ; } 
private JSONTranscoder getTranscoder ( final Manager manager ) { tif ( transcoder = = null ) { ttranscoder = new JSONTranscoder ( manager ) ; } treturn transcoder ; } 
public String toString ( ) { treturn " BackupResult [_status= " + _status + " , _data= " + ( _data ! = null ? " byte[ " + _data . length + " ] " : " null " ) + " , _attributesData= " 
private byte [ ] doSerialize ( final Object object ) { tif ( object = = null ) { tthrow new NullPointerException ( ) ; } tfinal ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ttry { 
public void testReadValueIntoObject ( ) throws Exception { tfinal MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; tmanager . setContainer ( new StandardContext ( ) ) ; tfinal JSONTranscoder transcoder = new JSONTranscoder ( manager ) ; tfinal MemcachedBackupSession session = manager . createEmptySession ( ) ; tsession . setValid ( true ) ; tsession . setCreationTime ( System . currentTimeMillis ( ) ) ; tgetField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; tsession . setMaxInactiveInterval ( 600 ) ; tsession . setId ( " foo " ) ; tsession . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; tsession . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; tfinal long start1 = System . nanoTime ( ) ; ttranscoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; tSystem . out . println ( " json-ser took " + ( System . nanoTime ( ) - start1 ) / 1000 ) ; tfinal long start2 = System . nanoTime ( ) ; ttranscoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; tSystem . out . println ( " json-ser took " + ( System . nanoTime ( ) - start2 ) / 1000 ) ; tfinal long start3 = System . nanoTime ( ) ; tfinal byte [ ] json = transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; tfinal Map < String , Object > readValue = ( Map < String , Object > ) transcoder . deserializeAttributes ( json ) ; tSystem . out . println ( " json-round took " + ( System . nanoTime ( ) - start3 ) / 1000 ) ; tassertEquals ( readValue , new HashMap ( session . getAttributesInternal ( ) ) ) ; 
private Person createPerson ( final String name , final Gender gender , final String . . . emailAddresses ) { final Person person = new Person ( ) ; person . setName ( name ) ; person . setGender ( gender ) ; final ConcurrentHashMap < String , Object > props = new ConcurrentHashMap < String , Object > ( ) ; for ( int i = 0 ; i < emailAddresses . length ; i + + ) { final String emailAddress = emailAddresses [ i ] ; props . put ( " email " + i , new Email ( name , emailAddress ) ) ; } person . setProps ( props ) ; return person ; } 
private Field getField ( final Class < ? > clazz , final String name ) throws NoSuchFieldException { final Field field = clazz . getDeclaredField ( name ) ; field . setAccessible ( true ) ; return field ; } 
private void assertEquals ( final Object one , final Object another ) throws Exception { if ( one = = another ) { return ; } if ( one = = null & & another ! = null | | one ! = null & & another = = null ) { Assert . fail ( " One of both is null: " + one + " , " + another ) ; } Assert . assertEquals ( one . getClass ( ) , another . getClass ( ) ) ; if ( one . getClass ( ) . isPrimitive ( ) | | one instanceof String | | Number . class . isAssignableFrom ( one . getClass ( ) ) | | one instanceof Boolean | | one instanceof Map < ? , ? > ) { Assert . assertEquals ( one , another ) ; return ; } Class < ? extends Object > clazz = one . getClass ( ) ; while ( clazz ! = null ) { assertEqualDeclaredFields ( clazz , one , another ) ; 
tprotected static boolean isPostMethod ( final Request request ) { tfinal String method = request . getMethod ( ) ; tif ( method = = null & & _log . isDebugEnabled ( ) ) { t_log . debug ( " No method set for request " + request . getRequestURI ( ) + ( request . getQueryString ( ) ! = null ? " ? " + request . getQueryString ( ) : " " ) ) ; } treturn method ! = null ? method . toLowerCase ( ) . equals ( " post " ) : false ; } 
public void customize ( Kryo kryo ) { kryo . register ( GrailsFlashScope . class , new ReferenceFieldSerializer ( kryo , GrailsFlashScope . class ) ) ; } 
public Map < String , Object > deserializeAttributes ( byte [ ] in ) { tfinal InputStreamReader inputStream = new InputStreamReader ( new ByteArrayInputStream ( in ) ) ; tif ( log . isDebugEnabled ( ) ) log . debug ( " deserializer the stream " ) ; ttry { @SuppressWarnings("unchecked") 
private byte [ ] doSerialize ( final Object object ) { tif ( object = = null ) { tthrow new NullPointerException ( ) ; } tfinal ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ttry { 
public void testReadValueIntoObject ( ) throws Exception { tfinal MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; tmanager . setContainer ( new StandardContext ( ) ) ; tfinal JSONTranscoder transcoder = new JSONTranscoder ( manager ) ; tfinal MemcachedBackupSession session = manager . createEmptySession ( ) ; tsession . setValid ( true ) ; tsession . setCreationTime ( System . currentTimeMillis ( ) ) ; tgetField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; tsession . setMaxInactiveInterval ( 600 ) ; tsession . setId ( " foo " ) ; tsession . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; tsession . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; tfinal long start = System . nanoTime ( ) ; tfinal byte [ ] json = transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; tfinal Map < String , Object > readValue = ( Map < String , Object > ) transcoder . deserializeAttributes ( json ) ; tSystem . out . println ( " json-round took " + ( System . nanoTime ( ) - start ) / 1000 ) ; tassertEquals ( readValue , new HashMap ( session . getAttributesInternal ( ) ) ) ; 
public Map < String , Object > deserializeAttributes ( final byte [ ] in ) { tfinal InputStreamReader inputStream = new InputStreamReader ( new ByteArrayInputStream ( in ) ) ; tif ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " deserialize the stream " ) ; } ttry { tfinal Map < String , Object > result = new JSONDeserializer < Map < String , Object > > ( ) . deserialize ( inputStream ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession sessions , final Map < String , Object > attributes ) { tif ( attributes = = null ) { tthrow new NullPointerException ( ) ; } final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { This performs a deep serialization of the target instance. 
public void testReadValueIntoObject ( ) throws Exception { tfinal MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; tmanager . setContainer ( new StandardContext ( ) ) ; tfinal JSONTranscoder transcoder = new JSONTranscoder ( manager ) ; tfinal MemcachedBackupSession session = manager . createEmptySession ( ) ; tsession . setValid ( true ) ; tsession . setCreationTime ( System . currentTimeMillis ( ) ) ; tgetField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; tsession . setMaxInactiveInterval ( 600 ) ; tsession . setId ( " foo " ) ; tsession . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; tsession . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; tfinal long start = System . nanoTime ( ) ; tfinal byte [ ] json = transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; tfinal Map < String , Object > readValue = transcoder . deserializeAttributes ( json ) ; tSystem . out . println ( " json-round took " + ( System . nanoTime ( ) - start ) / 1000 ) ; tassertEquals ( readValue , new HashMap < String , Object > ( session . getAttributesInternal ( ) ) ) ; 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final MemcachedClient memcached , @Nonnull final MemcachedSessionService manager , @Nonnull final MemcachedNodesManager memcachedNodesManager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup , @Nonnull final Statistics stats ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : 
protected LockStatus lock ( final String sessionId ) { return lock ( sessionId , _manager . getOperationTimeout ( ) , TimeUnit . MILLISECONDS ) ; } 
private void pingSessionBackup ( @Nonnull final MemcachedBackupSession session ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( session . getId ( ) ) ; final Future < Boolean > touchResultFuture = _memcached . add ( key , 5 , 1 ) ; try { final boolean touchResult = touchResultFuture . get ( _manager . getOperationTimeout ( ) , TimeUnit . MILLISECONDS ) ; 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; _memcached = memcachedClient ! = null ? memcachedClient : createMemcachedClient ( _memcachedNodesManager , _statistics ) ; _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = _manager . createSessionTrackerValve ( _requestUriIgnorePattern , _statistics , _enabled ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , operation timeout " + _operationTimeout + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
private ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , tmemcachedNodesManager . getSessionIdFormat ( ) , tstatistics , _operationTimeout ) : new BinaryConnectionFactory ( ) ; } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) 
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 ) : new DefaultConnectionFactory ( ) ; final MemcachedClient result = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , _memcachedClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , PlainSocketFactory . getSocketFactory ( ) , 80 ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? NODE_ID + " : " : " " ; _memcachedNodes = nodePrefix + " localhost: " + MEMCACHED_PORT ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( _memcachedNodes , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 ) : new DefaultConnectionFactory ( ) ; _client = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestURI ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesFiltered() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.registerSince( ATTRIBUTES_SERIALIZATION, startSerialization ); _statistics.register( CACHED_DATA_SIZE, data.length ); return new SimpleFuture<BackupResult>( new BackupResult( BackupResultStatus.SUCCESS ) ); } @Override public MemcachedBackupSession findSession( final String id ) throws IOException { final MemcachedBackupSession result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } @Override protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.registerSince( LOAD_FROM_MEMCACHED, startDeserialization ); return null; } }} 
public MemcachedBackupSession findSession ( final String id ) throws IOException { final MemcachedBackupSession result = super . findSession ( id ) ; if ( result ! = null ) { final byte [ ] data = _sessionData . remove ( id ) ; if ( data ! = null ) { _executorService . submit ( new SessionDeserialization ( id , data ) ) ; } } return result ; } 
public synchronized boolean registerReference ( ) { return _refCount . add ( Thread . currentThread ( ) . getId ( ) ) ; } 
public synchronized int releaseReference ( ) { _refCount . remove ( Thread . currentThread ( ) . getId ( ) ) ; return _refCount . size ( ) ; } 
private void addValidLoadedSession ( final MemcachedBackupSession result ) { When the sessionId will be changed later in changeSessionIdOnTomcatFailover/handleSessionTakeOver (due to a tomcat failover) we don't want to notify listeners via session.activate for the old sessionId but do that later (in handleSessionTakeOver) See also http:code.google.com/p/memcached-session-manager/issues/detail?id=92 String jvmRoute; final boolean sessionIdWillBeChanged = _sticky && ( jvmRoute = _manager.getJvmRoute() ) != null && !jvmRoute.equals( getSessionIdFormat().extractJvmRoute( result.getId() ) ); final boolean activate = !sessionIdWillBeChanged; addValidLoadedSession( result, activate ); } 
public String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) { tif ( ! _memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ) { treturn null ; } try { if ( _sticky ) { final String nodeId = getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null | | _memcachedNodesManager . isNodeAvailable ( nodeId ) ) { return null ; } _log . info ( " Session needs to be relocated as node " + nodeId + " is not available, loading backup session for " + requestedSessionId ) ; final MemcachedBackupSession backupSession = loadBackupSession ( requestedSessionId ) ; if ( backupSession ! = null ) { _log . debug ( " Loaded backup session for " + requestedSessionId + " , adding locally with " + backupSession . getIdInternal ( ) + " . " ) ; addValidLoadedSession ( backupSession , true ) ; _statistics . requestWithMemcachedFailover ( ) ; return backupSession . getId ( ) ; } } } catch ( final RuntimeException e ) { _log . warn ( " Could not find session in local session map. " , e ) ; } return null ; } 
public void setup ( ) throws Exception { final SessionManager manager = createSessionManager ( ) ; _service = manager . getMemcachedSessionService ( ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . setSticky ( true ) ; final StandardContext context = createContext ( ) ; context . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration manager.setContainer( context ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final Future<Boolean> futureMock = mock( Future.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); startInternal( manager, _memcachedMock ); _executor = Executors.newCachedThreadPool(); 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); startInternal(_service.getManager(), _memcachedMock); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(new SimpleFuture<Boolean>(true)); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc _service.getLockingStrategy().onRequestStart(mock(Request.class)); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); }} 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; startInternal ( _service . getManager ( ) , _memcachedMock ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( new SimpleFuture < Boolean > ( true ) ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc _service.getLockingStrategy().onRequestStart(mock(Request.class)); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
public BackupResult call ( ) throws Exception { final MemcachedBackupSession session3 = _service . findSession ( session . getId ( ) ) ; assertSame ( session3 , session2 ) ; assertEquals ( session3 . getRefCount ( ) , 2 ) ; let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } 
public void testParallelRequestsToSameTomcatInstanceIssue111 ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; this request should lock and update the session. final Future<Response> response2 = _executor.submit(new Callable<Response>() { @Override public Response call() throws Exception { return post(_httpClient, TC_PORT_1, PATH_WAIT, sessionId, asMap(PARAM_MILLIS, "500", "k2", "v2")); } }); Thread.sleep(200); this request should update the same session instance and reuse the lock. post(_httpClient, TC_PORT_1, sessionId, "k3", "v3"); this request should wait until the second and third requests have released the session lock. final Response finalResponse = get(_httpClient, TC_PORT_2, sessionId); assertEquals(finalResponse.getSessionId(), sessionId); assertEquals(response2.get().getSessionId(), sessionId); the final response should contain all keys/values assertEquals(finalResponse.get("k1"), "v1"); assertEquals(finalResponse.get("k2"), "v2"); assertEquals(finalResponse.get("k3"), "v3"); } 
public Response call ( ) throws Exception { return post ( _httpClient , TC_PORT_1 , PATH_WAIT , sessionId , asMap ( PARAM_MILLIS , " 500 " , " k2 " , " v2 " ) ) ; } 
public void sessionRemoved ( final String id ) { if ( ! _sticky ) { _removedSessions . put ( id , " unused " ) ; 
public void setUp ( final Method testMethod ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? _memcachedNodeId + " : " : " " ; final String memcachedNodes = nodePrefix + " localhost: " + _memcachedPort ; try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , memcachedNodes , " app1 " ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
public void testSessionUpdatedInMemcachedWhenSessionAttributeIsRemovedIssue106 ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , _portTomcat1 , null , key , value ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; assertEquals ( response . getSessionId ( ) , sessionId1 ) ; assertEquals ( response . get ( key ) , value ) ; final Map < String , String > params = asMap ( PARAM_REMOVE , key ) ; response = get ( _httpClient , _portTomcat1 , " / " , sessionId1 , params ) ; assertEquals ( response . getSessionId ( ) , sessionId1 ) ; assertNull ( response . get ( key ) ) ; also the next request must not include this session attribute response = get( _httpClient, _portTomcat1, sessionId1 ); assertEquals( response.getSessionId(), sessionId1 ); assertNull( response.get( key ) ); 
public void testSessionFoundIfSingleNodeWithNoMemcachedNodeIdConfigured ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , _portTomcat1 , null , key , value ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; } 
public void testInvalidSessionId ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , " 12345 " ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertTrue ( sessionId1 . indexOf ( '-' ) > - 1 , " Invalid session id format " ) ; } 
public void testSessionAvailableInMemcached ( final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId1 ) , " Session not available in memcached. " ) ; } 
public void testExpiredSessionRemovedFromMemcached ( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; waitForSessionExpiration ( sessionAffinity . isSticky ( ) ) ; assertNull ( _memcached . get ( sessionId1 ) , " Expired session still existing in memcached " ) ; } 
public void testInvalidatedSessionRemovedFromMemcached ( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final Response response = get ( _httpClient , _portTomcat1 , PATH_INVALIDATE , sessionId1 ) ; assertNull ( response . getResponseSessionId ( ) ) ; assertEquals ( _daemon . getCache ( ) . getGetMisses ( ) , 1 ) ; 1 is ok assertNull( _memcached.get( sessionId1 ), "Invalidated session still existing in memcached" ); if(!sessionAffinity.isSticky()) { assertNull( _memcached.get(createValidityInfoKeyName( sessionId1 )), "ValidityInfo for invalidated session still exists in memcached." ); 
public void testInvalidSessionNotFound ( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; Thread . sleep ( 2100 ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId1 , sessionId2 , " Expired session returned. " ) ; } 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final String pathInfo = request . getPathInfo ( ) ; LOG . info ( " + starting " + pathInfo + " ... " ) ; if ( PATH_GET_REQUESTED_SESSION_INFO . equals ( pathInfo ) ) { LOG . info ( " getRequestedSessionId: " + request . getRequestedSessionId ( ) ) ; LOG . info ( " isRequestedSessionIdValid: " + request . isRequestedSessionIdValid ( ) ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( KEY_REQUESTED_SESSION_ID + " = " + request . getRequestedSessionId ( ) ) ; out . println ( KEY_IS_REQUESTED_SESSION_ID_VALID + " = " + request . isRequestedSessionIdValid ( ) ) ; } else if ( PATH_NO_SESSION_ACCESS . equals ( pathInfo ) ) { LOG . info ( " skipping session access " ) ; response . getWriter ( ) . println ( " Skipped session access " ) ; } else if ( PATH_INVALIDATE . equals ( pathInfo ) ) { final HttpSession session = request . getSession ( false ) ; LOG . info ( " Invalidating session " + session . getId ( ) ) ; session . invalidate ( ) ; response . getWriter ( ) . println ( " Invalidated session " + session . getId ( ) ) ; } else { final HttpSession session = request . getSession ( ) ; waitIfRequested ( request ) ; final String removeKey = request . getParameter ( PARAM_REMOVE ) ; if ( removeKey ! = null & & ! " " . equals ( removeKey ) ) { final String [ ] keys = removeKey . split ( " , " ) ; LOG . info ( " Removing " + ( keys . length > 1 ? " keys " : " key " ) + Arrays . asList ( keys ) ) ; for ( final String key : keys ) { session . removeAttribute ( key ) ; } } final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + session . getId ( ) ) ; final HttpSession session = request.getSession( false ); final Enumeration<?> attributeNames = session.getAttributeNames(); while ( attributeNames.hasMoreElements() ) { final String name = attributeNames.nextElement().toString(); final Object value = session.getAttribute( name ); out.println( name + "=" + value ); } } LOG.info( " - finished." ); 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public abstract boolean isSticky ( ) ; } @DataProvider public static Object [ ] [ ] stickynessProvider ( ) { return new Object [ ] [ ] { { SessionAffinityMode . STICKY } , { SessionAffinityMode . NON_STICKY } } ; } @Nonnull public static Key key ( @Nonnull final String value ) { return new Key ( ChannelBuffers . wrappedBuffer ( value . getBytes ( ) ) ) ; } @Nonnull public static MemcachedBackupSession createSession ( @Nonnull final MemcachedSessionService service ) { return (MemcachedBackupSession) service.getManager().createSession( null ); final MemcachedBackupSession session = service.createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( 23 ); session.setId( "foo-n1" ); return session; }} 
private void remove ( final Session session , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked, removeFromMemcached: " + removeFromMemcached + " , id: " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session ) ; _msm . sessionRemoved ( session . getIdInternal ( ) ) ; } 
private void removeInternal ( final Session session , final boolean update , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked, removeFromMemcached: " + removeFromMemcached + " , id: " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session , update ) ; _msm . sessionRemoved ( session . getIdInternal ( ) ) ; } 
BackupResult doBackupSession ( final MemcachedBackupSession session , final byte [ ] data , final byte [ ] attributesData ) throws InterruptedException { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Trying to store session in memcached: " + session . getId ( ) ) ; } try { storeSessionInMemcached ( session , data ) ; 
private void handleException ( final MemcachedBackupSession session , final Exception e ) { if ( _log.isWarnEnabled() ) { String msg = "Could not store session " + session.getId() + " in memcached."; if ( _force ) { msg += "Note that this session was relocated to this node because the" + " original node was not available."; } _log.warn(msg, e); } _memcachedNodesManager.setNodeAvailableForSessionId(session.getId(), false); } 
private void storeSessionInMemcached ( final MemcachedBackupSession session , final byte [ ] data ) throws InterruptedException , ExecutionException , TimeoutException { final int expirationTime = session . getMemcachedExpirationTimeToSet ( ) ; final long start = System . currentTimeMillis ( ) ; try { final Future < Boolean > future = _memcached . set ( session . getId ( ) , expirationTime , data ) ; 
public Void call ( ) throws Exception { pingSession ( _sessionId ) ; if ( _storeSecondaryBackup ) { try { pingSessionBackup ( _sessionId ) ; final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; fix for #88, along with the change in session.getMemcachedExpirationTimeToSet final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval; _memcached.set( backupValidityKey, expiration, _validityData ); } catch( final RuntimeException e ) { _log.info( "Could not store secondary backup of session " + _sessionId, e ); } } return null; } 
private boolean isMembaseConfig ( final String memcachedNodes ) { return memcachedNodes . startsWith ( " http: " ) ; } 
public static MemcachedNodesManager createFor ( final String memcachedNodes , final String failoverNodes , final MemcachedClientCallback memcachedClientCallback ) { tif ( memcachedNodes = = null | | memcachedNodes . trim ( ) . isEmpty ( ) ) { tthrow new IllegalArgumentException ( " null or empty memcachedNodes not allowed. " ) ; } if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! MEMBASE_BUCKET_NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) ; } 
public boolean isMembaseBucketConfig ( ) { return MEMBASE_BUCKET_NODES_PATTERN . matcher ( _memcachedNodes ) . matches ( ) ; } 
public static ConnectionType valueOf ( final boolean membaseBucketConfig , final String username , final String password ) { return new ConnectionType ( membaseBucketConfig , username , password ) ; } 
boolean isMembaseBucketConfig ( ) { return membaseBucketConfig ; } 
boolean isSASL ( ) { return ! membaseBucketConfig & & ! isBlank ( username ) & & ! isBlank ( password ) ; } 
boolean isDefault ( ) { return ! isMembaseBucketConfig ( ) & & ! isSASL ( ) ; } 
boolean isBlank ( final String value ) { return value = = null | | value . trim ( ) . length ( ) = = 0 ; } 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } try { final ConnectionType connectionType = ConnectionType . valueOf ( memcachedNodesManager . isMembaseBucketConfig ( ) , _username , _password ) ; 
protected ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final ConnectionType connectionType , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { if ( connectionType . isSASL ( ) ) { ? new SuffixLocatorConnectionFactory( memcachedNodesManager, memcachedNodesManager.getSessionIdFormat(), statistics, _operationTimeout ) 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { if ( ! ( object instanceof byte [ ] ) ) { throw new RuntimeException ( " The loaded object for sessionId " + sessionId + " is not of required type byte[], but " + object . getClass ( ) . getName ( ) ) ; } final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _missingSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } return null ; } 
public void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) { } 
public void addOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; } 
public void connected ( ) { throw new UnsupportedOperationException ( ) ; } 
public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void fillWriteBuffer ( final boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; } 
public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean hasReadOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean hasWriteOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean isActive ( ) { throw new UnsupportedOperationException ( ) ; } 
public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; } 
public void registerChannel ( final SocketChannel ch , final SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; } 
public void transitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; } 
public int writeSome ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } 
public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public MemcachedNode createMemcachedNode ( final SocketAddress sa , final SocketChannel c , final int bufSize ) { final boolean doAuth = false ; final long defaultOpTimeout = getOperationTimeout ( ) ; return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , 
public void setUp ( final Method testMethod ) throws Throwable { membaseProvided = Boolean . parseBoolean ( System . getProperty ( " membase.provided " , " false " ) ) ; final int membasePort = Integer . parseInt ( System . getProperty ( " membase.port " , " 18091 " ) ) ; if ( ! membaseProvided ) { cluster . add ( setupMembase ( membasePort ) ) ; } try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , " http:localhost: " + membasePort + " /pools " ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; getService ( _tomcat1 ) . setMemcachedProtocol ( " binary " ) ; getManager ( _tomcat1 ) . setUsername ( " default " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } setupMembaseClient ( ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( getManager ( _tomcat1 ) ) ) ; } 
public void tearDown ( ) throws Exception { mc . shutdown ( ) ; mc = null ; if ( ! membaseProvided ) { tearDownMembase ( ) ; } _tomcat1 . stop ( ) ; } 
public void testBackupSessionInMembase ( ) throws InterruptedException , ExecutionException { final MemcachedSessionService service = getService ( _tomcat1 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , getManager ( _tomcat1 ) ) ; checkSession ( loadedSession , session ) ; } 
public void testBackupSessionInMembaseCluster ( ) throws Exception { final MemcachedSessionService service = getService ( _tomcat1 ) ; cluster . add ( setupMembase ( getMaxMembasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupMembaseClient ( ) ; waitForReconnect ( service . getMemcached ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , getManager ( _tomcat1 ) ) ; checkSession ( loadedSession , session ) ; } 
private void checkSession ( final MemcachedBackupSession actual , final MemcachedBackupSession expected ) { assertNotNull ( actual ) ; assertEquals ( actual . getId ( ) , expected . getId ( ) ) ; assertEquals ( actual . getAttributesInternal ( ) , expected . getAttributesInternal ( ) ) ; } 
private void setupMembaseClient ( ) throws URISyntaxException , IOException , ConfigurationException { if ( mc ! = null ) { LOG . info ( " Closing existing membase client. " ) ; mc . shutdown ( ) ; } final List < URI > uris = getURIs ( ) ; LOG . info ( " Creating new membase client with uris " + uris ) ; mc = new MemcachedClient ( uris , " default " , " " ) ; } 
private List < URI > getURIs ( ) throws URISyntaxException { final List < URI > uris = new ArrayList < URI > ( cluster . size ( ) ) ; for ( final Pair < CouchbaseMock , Thread > server : cluster ) { uris . add ( new URI ( " http:localhost: " + server . getFirst ( ) . getHttpPort ( ) + " /pools " ) ) ; } return uris ; } 
private Pair < CouchbaseMock , Thread > setupMembase ( final int membasePort ) throws IOException { final CouchbaseMock membase = new CouchbaseMock ( " localhost " , membasePort , 1 , 1 ) ; membase . setRequiredHttpAuthorization ( null ) ; final Thread thread = new Thread ( membase ) ; thread . start ( ) ; return Pair . of ( membase , thread ) ; } 
private void tearDownMembase ( ) throws InterruptedException { for ( final Pair < CouchbaseMock , Thread > server : cluster ) { server . getSecond ( ) . interrupt ( ) ; server . getSecond ( ) . join ( 1000 ) ; server . getFirst ( ) . close ( ) ; } cluster . clear ( ) ; } 
public void testMembaseNodesAndFailoverNodeShouldThrowException ( ) { createFor ( " http:localhost:8091/pools " , " n1 " , _mcc ) ; } 
public static Object [ ] [ ] testgGetAllMemcachedAddressesDataProvider ( ) { treturn new Object [ ] [ ] { { " localhost:11211 " , null , asList ( new InetSocketAddress ( " localhost " , 11211 ) ) } , 
public void testGetAllMemcachedAddresses ( final String memcachedNodes , final String failoverNodes , final Collection < InetSocketAddress > expectedSocketAddresses ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertEquals ( result . getAllMemcachedAddresses ( ) , expectedSocketAddresses ) ; } 
public void testIsMembaseBucketConfig ( ) { assertTrue ( createFor ( " http:10.10.0.1:8091/pools " , null , _mcc ) . isMembaseBucketConfig ( ) ) ; assertTrue ( createFor ( " http:10.10.0.1:8091/pools,http:10.10.0.2:8091/pools " , null , _mcc ) . isMembaseBucketConfig ( ) ) ; } 
public void testGetMembaseBucketURIs ( ) throws URISyntaxException { assertEquals ( createFor ( " http:10.10.0.1:8091/pools " , null , _mcc ) . getMembaseBucketURIs ( ) , Arrays . asList ( new URI ( " http:10.10.0.1:8091/pools " ) ) ) ; assertEquals ( createFor ( " http:10.10.0.1:8091/pools,http:10.10.0.2:8091/pools " , null , _mcc ) . getMembaseBucketURIs ( ) , Arrays . asList ( new URI ( " http:10.10.0.1:8091/pools " ) , new URI ( " http:10.10.0.2:8091/pools " ) ) ) ; 
public void setup ( ) throws Exception { final SessionManager manager = createSessionManager ( ) ; _service = manager . getMemcachedSessionService ( ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . setSticky ( true ) ; final StandardContext context = createContext ( ) ; context . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration manager.setContainer( context ); _memcachedMock = mock( MemcachedClient.class ); @SuppressWarnings( "unchecked" ) final OperationFuture<Boolean> futureMock = mock( OperationFuture.class ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); startInternal( manager, _memcachedMock ); _executor = Executors.newCachedThreadPool(); 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); startInternal(_service.getManager(), _memcachedMock); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc _service.getLockingStrategy().onRequestStart(mock(Request.class)); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); }} 
public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105 ( ) throws Exception { _service . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . startInternal ( _memcachedMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > futureMock = mock ( OperationFuture . class ) ; when ( futureMock . get ( anyInt ( ) , any ( TimeUnit . class ) ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception. " ) ) ) ; when ( _memcachedMock . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ) . thenReturn ( futureMock ) ; final BackupResult backupResult = _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . FAILURE ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) ) ; } 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final OperationFuture<Boolean> futureMock = mock( OperationFuture.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _service.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _service.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() ); } 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; startInternal ( _service . getManager ( ) , _memcachedMock ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc _service.getLockingStrategy().onRequestStart(mock(Request.class)); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
public void testNonStickySessionIsStoredInSecondaryMemcachedForBackup ( ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat2 ) . setMaxInactiveInterval ( 1 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 100 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> primary = nodeId.equals( NODE_ID_1 ) ? _daemon1 : _daemon2; final MemCacheDaemon<?> secondary = nodeId.equals( NODE_ID_1 ) ? _daemon2 : _daemon1; assertNotNull( primary.getCache().get( key( sessionId1 ) )[0] ); assertNotNull( primary.getCache().get( key( createValidityInfoKeyName( sessionId1 ) ) )[0] ); The executor needs some time to finish the backup... Thread.sleep( 500 ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); 
public void testNoBackupWhenRunningASingleMemcachedOnly ( ) throws IOException , HttpException , InterruptedException { getManager ( _tomcat1 ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; let's take some break so that everything's up again Thread.sleep( 500 ); try { final String sessionId1 = post( _httpClient, TC_PORT_1, null, "foo", "bar" ).getSessionId(); 
public abstract boolean isSticky ( ) ; } @DataProvider public static Object [ ] [ ] stickynessProvider ( ) { return new Object [ ] [ ] { { SessionAffinityMode . STICKY } , { SessionAffinityMode . NON_STICKY } } ; } @DataProvider public static Object [ ] [ ] booleanProvider ( ) { return new Object [ ] [ ] { { true } , { false } } ; } @Nonnull public static Key key ( @Nonnull final String value ) { return new Key ( ChannelBuffers . wrappedBuffer ( value . getBytes ( ) ) ) ; } @Nonnull public static MemcachedBackupSession createSession ( @Nonnull final MemcachedSessionService service ) { return (MemcachedBackupSession) service.getManager().createSession( null ); final MemcachedBackupSession session = service.createEmptySession(); session.setNew( true ); session.setValid( true ); session.setCreationTime( System.currentTimeMillis() ); session.setMaxInactiveInterval( 23 ); session.setId( "foo-n1" ); return session; }} 
public static Object [ ] [ ] booleanProvider ( ) { return new Object [ ] [ ] { { true } , 
public void beforeMethod ( ) { cut = new MemcachedBackupSession ( ) ; executor = Executors . newCachedThreadPool ( ) ; } 
public void testRefCount ( ) throws InterruptedException , ExecutionException { assertEquals ( cut . getRefCount ( ) , 0 ) ; cut . registerReference ( ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; cut . releaseReference ( ) ; assertEquals ( cut . getRefCount ( ) , 0 ) ; other threads must each increment the ref count final Runnable registerReference = new Runnable() { @Override public void run() { cut.registerReference(); } }; executor.submit(registerReference).get(); assertEquals(cut.getRefCount(), 1); executor.submit(registerReference).get(); assertEquals(cut.getRefCount(), 2); we (no ref registered) must not be able to decrement the ref count cut.releaseReference(); assertEquals(cut.getRefCount(), 2); } 
public static MemcachedNodesManager createFor ( final String memcachedNodes , final String failoverNodes , final MemcachedClientCallback memcachedClientCallback ) { tif ( memcachedNodes = = null | | memcachedNodes . trim ( ) . isEmpty ( ) ) { tthrow new IllegalArgumentException ( " null or empty memcachedNodes not allowed. " ) ; } if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! MEMBASE_BUCKET_NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) ; } 
private MemcachedBackupSession loadBackupSession ( @Nonnull final String requestedSessionId ) { final String nodeId = getSessionIdFormat ( ) . extractMemcachedId ( requestedSessionId ) ; if ( nodeId = = null ) { _log . info ( " Cannot load backupSession for sessionId without nodeId: " + requestedSessionId ) ; return null ; } final String newNodeId = _memcachedNodesManager . getNextAvailableNodeId ( nodeId ) ; if ( newNodeId = = null ) { _log . info ( " No next available node found for nodeId " + nodeId ) ; return null ; } MemcachedBackupSession result = loadBackupSession ( requestedSessionId , newNodeId ) ; String nextNodeId = nodeId ; if we didn't find the backup in the next node, let's go through other nodes to see if the backup is there. For this we have to fake the session id so that the SuffixBasedNodeLocator selects another backup node. while(result == null && (nextNodeId = _memcachedNodesManager.getNextAvailableNodeId(nextNodeId)) != null && !nextNodeId.equals(nodeId)) { final String newSessionId = getSessionIdFormat().createNewSessionId(requestedSessionId, nextNodeId); result = loadBackupSession(newSessionId, newNodeId); } if ( result == null ) { _log.info( "No backup found for sessionId " + requestedSessionId ); return null; } return result; } 
private MemcachedBackupSession loadBackupSession ( final String requestedSessionId , final String newNodeId ) { try { final SessionValidityInfo validityInfo = _lockingStrategy . loadBackupSessionValidityInfo ( requestedSessionId ) ; 
public void testPrimaryNodes ( final String memcachedNodes , final String failoverNodes , final NodeIdList expectedPrimaryNodeIds ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getPrimaryNodeIds ( ) , expectedPrimaryNodeIds ) ; } 
public void testFailoverNodes ( final String memcachedNodes , final String failoverNodes , final List < String > expectedFailoverNodeIds ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getFailoverNodeIds ( ) , expectedFailoverNodeIds ) ; } 
public void testGetNodeId ( final String memcachedNodes , final String failoverNodes , final InetSocketAddress socketAddress , final String expectedNodeId ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , _mcc ) ; tassertEquals ( result . getNodeId ( socketAddress ) , expectedNodeId ) ; } 
public void testGetNextAvailableNodeId ( ) { assertNull ( createFor ( " n1:localhost:11211 " , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) , " n2 " ) ; final MemcachedClientCallback mcc = mock ( MemcachedClientCallback . class ) ; when ( mcc . get ( anyString ( ) ) ) . thenReturn ( null ) ; when ( mcc . get ( endsWith ( " n2 " ) ) ) . thenThrow ( new OperationTimeoutException ( " SimulatedException " ) ) ; assertNull ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212,n3:localhost:11213 " , null , mcc ) . getNextAvailableNodeId ( " n1 " ) , " n3 " ) ; } 
public void testSetNodeAvailable ( ) { tfinal MemcachedNodesManager cut = createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , _mcc ) ; tassertTrue ( cut . isNodeAvailable ( " n1 " ) ) ; tassertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; tcut . setNodeAvailable ( " n1 " , false ) ; tassertFalse ( cut . isNodeAvailable ( " n1 " ) ) ; tassertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; } 
public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; if ( _daemon3 ! = null & & _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _executor . shutdownNow ( ) ; } 
public void testNonStickySessionSecondaryBackupFailover ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat1 ) . setMemcachedNodes ( memcachedNodes ) ; getManager ( _tomcat1 ) . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 100 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> first = memcachedsByNodeId.get(nodeId); assertNotNull( first.getCache().get( key( sessionId1 ) )[0] ); assertNotNull( first.getCache().get( key( createValidityInfoKeyName( sessionId1 ) ) )[0] ); The executor needs some time to finish the backup... Thread.sleep( 500 ); final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNull( second.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( second.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Request / Update final String sessionId2 = post( _httpClient, TC_PORT_1, sessionId1, "key", "v2" ).getSessionId(); assertEquals( sessionId2, sessionId1 ); Thread.sleep( 500 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNull( third.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( third.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v2"); 
public void testNonStickySessionSecondaryBackupFailoverForSkippedUpdate ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; getManager ( _tomcat1 ) . setMaxInactiveInterval ( 1 ) ; getManager ( _tomcat1 ) . setMemcachedNodes ( memcachedNodes ) ; getManager ( _tomcat1 ) . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 100 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> first = memcachedsByNodeId.get(nodeId); assertNotNull( first.getCache().get( key( sessionId1 ) )[0] ); assertNotNull( first.getCache().get( key( createValidityInfoKeyName( sessionId1 ) ) )[0] ); The executor needs some time to finish the backup... Thread.sleep( 500 ); final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNull( second.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( second.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Request / Update final String sessionId2 = get( _httpClient, TC_PORT_1, sessionId1 ).getSessionId(); assertEquals( sessionId2, sessionId1 ); Thread.sleep( 500 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNull( third.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( third.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v1"); 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _memcached = memcachedClient ; startInternal ( ) ; } 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; _sessionTrackerValve = _manager . createSessionTrackerValve ( _requestUriIgnorePattern , _statistics , _enabled ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , operation timeout " + _operationTimeout + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc _service.getLockingStrategy().onRequestStart(mock(Request.class)); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); }} 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; _service . setMemcachedClient ( _memcachedMock ) ; _service . startInternal ( ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc _service.getLockingStrategy().onRequestStart(mock(Request.class)); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
protected void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { _msm . setMemcachedClient ( memcachedClient ) ; _msm . startInternal ( ) ; } 
public void startInternal ( ) throws LifecycleException { super . startInternal ( ) ; _msm . startInternal ( ) ; setState ( LifecycleState . STARTING ) ; } 
protected void startInternal ( final SessionManager manager , final MemcachedClient memcachedMock ) throws LifecycleException { manager . getMemcachedSessionService ( ) . setMemcachedClient ( memcachedMock ) ; ( ( MemcachedBackupSessionManager ) manager ) . start ( ) ; } 
public void testSessionIdFormatForSingleNodeSetupShouldSupportLocking ( ) { final SessionIdFormat sessionIdFormat = createFor ( " localhost:11211 " , null , _mcc ) . getSessionIdFormat ( ) ; assertNotNull ( sessionIdFormat ) ; final String sessionId = " 12345678 " ; assertEquals ( sessionIdFormat . createLockName ( sessionId ) , " lock: " + sessionId ) ; } 
public void testSessionLockingSupportedWithSingleNodeSetup ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { getManager ( _tomcat1 ) . setMemcachedNodes ( " localhost: " + MEMCACHED_PORT_1 ) ; getManager ( _tomcat1 ) . setLockingMode ( lockingMode , uriPattern , false ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; just want to see that we can access/load the session Response response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); and we want to be able to update the session post(_httpClient, TC_PORT_1, sessionId, "k2", "v2"); response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); assertEquals(response.get("k2"), "v2"); } 
public boolean isValid ( ) { final long timeNow = System . currentTimeMillis ( ) ; final int timeIdle = ( int ) ( ( timeNow - _thisAccessedTime ) / 1000L ) ; if tomcat session inactivity is negative or 0, session should not expire return _maxInactiveInterval <= 0 || timeIdle < _maxInactiveInterval; } 
public void negativeInactivityAlwaysValid ( ) { long now = System . currentTimeMillis ( ) ; SessionValidityInfo info = new SessionValidityInfo ( - 1 , 0 , 0 ) ; assertTrue ( info . isValid ( ) ) ; } 
public void testLoadBackupSessionShouldWorkWithInfiniteSessionTimeoutIssue120 ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( - 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; we want to get the session from the primary node Response response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); now we shut down the primary node so that the session is loaded from the backup node final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId ); final MemCacheDaemon<?> primary = NODE_ID_1.equals(nodeId) ? _daemon1 : _daemon2; primary.stop(); Thread.sleep( 200 ); the session should be loaded from the backup node response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(fmt.createNewSessionId(response.getSessionId(), nodeId), sessionId); assertEquals(response.get("k1"), "v1"); } 
protected ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final ConnectionType connectionType , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { if ( connectionType . isSASL ( ) ) { final AuthDescriptor authDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( _username , _password ) ) ; return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout , authDescriptor ) : new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setAuthDescriptor ( authDescriptor ) . setOpTimeout ( _operationTimeout ) . build ( ) ; } else if ( connectionType . isMembaseBucketConfig ( ) ) { return new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setOpTimeout ( _operationTimeout ) . build ( ) ; } else { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) : new BinaryConnectionFactory ( ) ; } } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) 
public MemcachedNode createMemcachedNode ( final SocketAddress sa , final SocketChannel c , final int bufSize ) { final boolean doAuth = _authDescriptor ! = null ; final long defaultOpTimeout = getOperationTimeout ( ) ; return new BinaryMemcachedNodeImpl ( sa , c , bufSize , createReadOperationQueue ( ) , 
public MemcachedBackupSession createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; final MemcachedBackupSession session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( _manager . getMaxInactiveInterval ( ) ) ; if ( sessionId = = null | | ! _memcachedNodesManager . canHitMemcached ( sessionId ) ) { sessionId = _manager . generateSessionId ( ) ; } session . setId ( sessionId ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Created new session with id " + session . getId ( ) ) ; } _manager . incrementSessionCounter ( ) ; return session ; 
protected void checkTimeoutAndWait ( @Nonnull final String sessionId , final long timeToWait , final long timeout , final long start ) throws TimeoutException , InterruptedException { if ( System . currentTimeMillis ( ) > = start + timeout ) { throw new TimeoutException ( " Reached timeout when trying to aquire lock for session " + sessionId ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Could not aquire lock for session " + sessionId + " , waiting " + timeToWait + " millis now... " ) ; } sleep ( timeToWait ) ; } 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; final String sessionCookieName = _manager . getSessionCookieName ( ) ; _sessionTrackerValve = new SessionTrackerValve ( _requestUriIgnorePattern , sessionCookieName , this , _statistics , _enabled ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve ) ; _sessionTrackerValve2 = new SessionTrackerValve2 ( sessionCookieName , this ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _sessionTrackerValve2 ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , operation timeout " + _operationTimeout + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
private boolean isContainerSessionLookup ( ) { return ! _sessionTrackerValve2 . wasInvokedWith ( _lockingStrategy . getCurrentRequest ( ) ) ; } 
public boolean wasInvokedWith ( final Request currentRequest ) { return currentRequest ! = null & & currentRequest . getNote ( INVOKED ) = = Boolean . TRUE ; } 
public void invoke ( final Request request , final Response response ) throws IOException , ServletException { final Object processRequest = request . getNote ( SessionTrackerValve . REQUEST_PROCESS ) ; if ( processRequest ! = Boolean . TRUE ) { getNext ( ) . invoke ( request , response ) ; 
String changeSessionIdOnTomcatFailover ( final String requestedSessionId ) ; SKIPPED } } } 
String changeSessionIdOnMemcachedFailover ( final String requestedSessionId ) ; SKIPPED } } } 
Future < BackupResult > backupSession ( @Nonnull String sessionId , boolean sessionIdChanged , String requestId ) ; SKIPPED } } } 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(SessionTrackerValve2.INVOKED))).thenReturn(Boolean.TRUE); _service.getLockingStrategy().onRequestStart(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); }} 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; _service . setMemcachedClient ( _memcachedMock ) ; _service . startInternal ( ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(SessionTrackerValve2.INVOKED))).thenReturn(Boolean.TRUE); _service.getLockingStrategy().onRequestStart(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; when ( _request . getNote ( eq ( SessionTrackerValve . REQUEST_PROCESS ) ) ) . thenReturn ( Boolean . TRUE ) ; } 
protected SessionTrackerValve2 createSessionTrackerValve ( ) { return new SessionTrackerValve2 ( " foo " , _service ) ; } 
public final void testGetSessionCookieName ( ) throws IOException , ServletException { final SessionTrackerValve2 cut = new SessionTrackerValve2 ( " foo " , _service ) ; assertEquals ( cut . getSessionCookieName ( ) , " foo " ) ; } 
public final void testRequestIsMarkedAsProcessed ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request ) . setNote ( eq ( SessionTrackerValve . REQUEST_PROCESSED ) , eq ( Boolean . TRUE ) ) ; } 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; when ( _service . changeSessionIdOnMemcachedFailover ( eq ( sessionId ) ) ) . thenReturn ( newSessionId ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request ) . changeSessionId ( eq ( newSessionId ) ) ; verify ( _request ) . setNote ( eq ( SessionTrackerValve . SESSION_ID_CHANGED ) , eq ( Boolean . TRUE ) ) ; 
public void setUp ( ) throws Exception { _service = mock ( SessionBackupService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; when ( _request . getNote ( eq ( SessionTrackerValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( SessionTrackerValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; } 
protected SessionTrackerValve createSessionTrackerValve ( ) { return new SessionTrackerValve ( null , " somesessionid " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; } 
public final void testGetSessionCookieName ( ) throws IOException , ServletException { final SessionTrackerValve cut = new SessionTrackerValve ( null , " foo " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; assertEquals ( cut . getSessionCookieName ( ) , " foo " ) ; } 
public final void testProcessRequestNotePresent ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; verify ( _request ) . setNote ( eq ( SessionTrackerValve . REQUEST_PROCESS ) , eq ( Boolean . TRUE ) ) ; } 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getNote ( eq ( SessionTrackerValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , newSessionId ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( generateCookieString ( cookie ) ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /foo " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( newSessionId ) , eq ( true ) , anyString ( ) ) ; 
private Embedded startTomcatWithAuth ( final int port , @Nonnull final LockingMode lockingMode ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcatWithAuth ( port , lockingMode , LoginType . BASIC ) ; } 
private Embedded startTomcatWithAuth ( final int port , final LockingMode lockingMode , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded result = getTestUtils ( ) . createCatalina ( port , MEMCACHED_NODES , null , loginType ) ; getManager ( result ) . setSticky ( false ) ; getManager ( result ) . setLockingMode ( lockingMode . name ( ) ) ; result . start ( ) ; return result ; } 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { super . testSessionsRefCountHandlingIssue111 ( ) ; } 
public void testSerializationOfAuthStuffWithBasicAuthSticky ( ) throws Exception { testSerializationOfAuthStuffWithBasicAuth ( SessionAffinityMode . STICKY ) ; } 
public void testBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , LockingMode . AUTO ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , LockingMode . AUTO ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; assertEquals ( tc2Response1 . get ( " foo " ) , " bar " ) ; 
public void registerReadonlyRequest ( final String requestId ) { _readOnlyRequestCache . readOnlyRequest ( requestId ) ; } 
public void requestFinished ( final String sessionId , final String requestId ) { if ( ! _sticky ) { final MemcachedBackupSession msmSession = _manager . getSessionInternal ( sessionId ) ; 
public boolean isIgnoredRequest ( ) { final Request request = _lockingStrategy = = null ? null : _lockingStrategy . getCurrentRequest ( ) ; return request ! = null & & request . getNote ( REQUEST_IGNORED ) = = Boolean . TRUE ; } 
public void invoke ( final Request request , final Response response ) throws IOException , ServletException { if ( ! _enabled . get ( ) ) { getNext ( ) . invoke ( request , response ) ; 
private void backupSession ( final Request request , final Response response , final boolean sessionIdChanged ) { final String sessionId = getSessionId ( request , response ) ; if ( sessionId ! = null ) { _statistics . requestWithSession ( ) ; 
public void invoke ( final Request request , final Response response ) throws IOException , ServletException { final Object processRequest = request . getNote ( SessionTrackerValve . REQUEST_PROCESS ) ; if ( processRequest ! = Boolean . TRUE ) { request . setNote ( INVOKED , Boolean . TRUE ) ; 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getNote ( eq ( SessionTrackerValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( SessionTrackerValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; } 
protected SessionTrackerValve createSessionTrackerValve ( ) { return new SessionTrackerValve ( " .* \\ .(png|gif|jpg|css|js|ico)$ " , " somesessionid " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; } 
public final void testBackupSessionInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( generateCookieString ( cookie ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( " foo " ) , eq ( false ) , anyString ( ) ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getNote ( eq ( SessionTrackerValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , newSessionId ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( generateCookieString ( cookie ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( newSessionId ) , eq ( true ) , anyString ( ) ) ; 
public final void testRequestFinishedShouldBeInvokedForIgnoredResources ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( " foo " ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /pixel.gif " ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . requestFinished ( eq ( " foo " ) , anyString ( ) ) ; } 
private Embedded startTomcat ( final int port ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , MEMCACHED_NODES , null ) ; } 
private Embedded startTomcat ( final int port , final String memcachedNodes , final LockingMode lockingMode ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , 5 , memcachedNodes ) ; getManager ( tomcat ) . setSticky ( false ) ; if ( lockingMode ! = null ) { getManager ( tomcat ) . setLockingMode ( lockingMode . name ( ) ) ; } tomcat . start ( ) ; return tomcat ; } 
public void testIgnoredResourcesWithSessionCookieDontCauseSessionStaleness ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO ) ; _tomcat2 = startTomcat ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO ) ; final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId ); assertEquals(tc2Response1.getSessionId(), sessionId); assertEquals( tc2Response1.get( TestServlet.ID ), sessionId ); assertEquals( tc2Response1.get( "foo" ), "bar" ); assertEquals( tc2Response1.get( "bar" ), "baz" ); 
public void testBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , LockingMode . AUTO ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , LockingMode . AUTO ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; assertEquals ( tc2Response1 . get ( " foo " ) , " bar " ) ; 
public void testIgnoredResourcesWithFormAuthDontCauseSessionStaleness ( ) throws Exception { TODO: see testSessionCreatedForContainerProtectedResourceIsStoredInMemcached _tomcat1.stop(); _tomcat2.stop(); _tomcat1 = startTomcatWithAuth( TC_PORT_1, LockingMode.AUTO, LoginType.FORM ); _tomcat2 = startTomcatWithAuth( TC_PORT_2, LockingMode.AUTO, LoginType.FORM ); getManager( _tomcat1 ).setMemcachedNodes( NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1 ); getManager( _tomcat2 ).setMemcachedNodes( NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1 ); setChangeSessionIdOnAuth( _tomcat1, false ); setChangeSessionIdOnAuth( _tomcat2, false ); final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId ); assertEquals(tc2Response1.getSessionId(), sessionId); assertNull(tc2Response1.getResponseSessionId()); assertEquals( tc2Response1.get( TestServlet.ID ), sessionId ); assertEquals( tc2Response1.get( "foo" ), "bar" ); assertEquals( tc2Response1.get( "bar" ), "baz" ); 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { TODO: see testSessionCreatedForContainerProtectedResourceIsStoredInMemcached _tomcat1.stop(); _tomcat2.stop(); _tomcat1 = startTomcatWithAuth( TC_PORT_1, LockingMode.AUTO, LoginType.FORM ); _tomcat2 = startTomcatWithAuth( TC_PORT_2, LockingMode.AUTO, LoginType.FORM ); getManager( _tomcat1 ).setMemcachedNodes( NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1 ); getManager( _tomcat2 ).setMemcachedNodes( NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1 ); setChangeSessionIdOnAuth( _tomcat1, false ); setChangeSessionIdOnAuth( _tomcat2, false ); final Response response1 = get( _httpClient, TC_PORT_1, null ); final String sessionId = response1.getSessionId(); assertNotNull( sessionId ); assertTrue(response1.getContent().contains("j_security_check")); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, false ); assertNull(response2.getResponseSessionId()); assertEquals(response2.getStatusCode(), 302, response2.getContent()); final Response response3 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" )); assertEquals(response3.getSessionId(), sessionId); final Response response4 = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response4.getSessionId(), sessionId); assertEquals(response4.get( TestServlet.ID ), sessionId); assertEquals(response4.get( "foo" ), "bar"); 
public void init ( final ServletConfig config ) throws ServletException { super . init ( config ) ; defaultServlet = new DefaultServlet ( ) ; defaultServlet . init ( config ) ; } 
protected void doGet ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { final String pathInfo = request . getPathInfo ( ) ; LOG . info ( " + starting " + pathInfo + " ... " ) ; if ( " /pixel.gif " . equals ( pathInfo ) ) { defaultServlet . service ( request , response ) ; return ; } else if ( PATH_GET_REQUESTED_SESSION_INFO . equals ( pathInfo ) ) { LOG . info ( " getRequestedSessionId: " + request . getRequestedSessionId ( ) ) ; LOG . info ( " isRequestedSessionIdValid: " + request . isRequestedSessionIdValid ( ) ) ; final PrintWriter out = response . getWriter ( ) ; out . println ( KEY_REQUESTED_SESSION_ID + " = " + request . getRequestedSessionId ( ) ) ; out . println ( KEY_IS_REQUESTED_SESSION_ID_VALID + " = " + request . isRequestedSessionIdValid ( ) ) ; } else if ( PATH_NO_SESSION_ACCESS . equals ( pathInfo ) ) { LOG . info ( " skipping session access " ) ; response . getWriter ( ) . println ( " Skipped session access " ) ; } else if ( PATH_INVALIDATE . equals ( pathInfo ) ) { final HttpSession session = request . getSession ( false ) ; LOG . info ( " Invalidating session " + session . getId ( ) ) ; session . invalidate ( ) ; response . getWriter ( ) . println ( " Invalidated session " + session . getId ( ) ) ; } else { final HttpSession session = request . getSession ( ) ; waitIfRequested ( request ) ; final String removeKey = request . getParameter ( PARAM_REMOVE ) ; if ( removeKey ! = null & & ! " " . equals ( removeKey ) ) { final String [ ] keys = removeKey . split ( " , " ) ; LOG . info ( " Removing " + ( keys . length > 1 ? " keys " : " key " ) + Arrays . asList ( keys ) ) ; for ( final String key : keys ) { session . removeAttribute ( key ) ; } } final PrintWriter out = response . getWriter ( ) ; out . println ( ID + " = " + session . getId ( ) ) ; final HttpSession session = request.getSession( false ); final Enumeration<?> attributeNames = session.getAttributeNames(); while ( attributeNames.hasMoreElements() ) { final String name = attributeNames.nextElement().toString(); final Object value = session.getAttribute( name ); out.println( name + "=" + value ); } } LOG.info( " - finished." ); 
public static String loginWithForm ( final DefaultHttpClient client , final int tcPort ) throws IOException , HttpException { final Response tc1Response1 = get ( client , tcPort , null ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( tc1Response1 . getContent ( ) . contains ( " j_security_check " ) ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response tc1Response2 = post ( client , tcPort , " /j_security_check " , sessionId , params ) ; assertEquals ( tc1Response2 . getSessionId ( ) , sessionId ) ; System . out . println ( " ----------------xxx (status " + tc1Response2 . getStatusCode ( ) + " ) " + tc1Response2 . getContent ( ) ) ; new RuntimeException ( " err " ) . printStackTrace ( ) ; assertTrue ( sessionId . equals ( tc1Response2 . get ( TestServlet . ID ) ) ) ; return tc1Response2 . getSessionId ( ) ; } 
private static Response readResponse ( final String rsessionId , final HttpResponse response ) throws IOException { final String responseSessionId = getSessionIdFromResponse ( response ) ; System.out.println( "response cookie: " + responseSessionId ); final StringBuilder sb = new StringBuilder(); final Map<String, String> keyValues = new LinkedHashMap<String, String>(); BufferedReader reader = null; try { reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) ); String line = null; while ( ( line = reader.readLine() ) != null ) { sb.append(line); final String[] keyValue = line.split( "=" ); if ( keyValue.length > 0 ) { keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null ); } } } finally { reader.close(); } return new Response( response, responseSessionId == null ? rsessionId : responseSessionId, responseSessionId, sb.toString(), keyValues ); } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params ) throws IOException , HttpException { return post ( client , port , path , rsessionId , params , null , true ) ; } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params , @Nullable final Credentials credentials , final boolean followRedirects ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:"+ DEFAULT_HOST +":"+ port; final String url = getUrl( port, path ); final HttpPost method = new HttpPost( url ); if ( rsessionId != null ) { method.setHeader( "Cookie", "JSESSIONID=" + rsessionId ); } method.setEntity( createFormEntity( params ) ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); final HttpResponse response = credentials == null ? client.execute( method ) : executeRequestWithAuth( client, method, credentials ); final int statusCode = response.getStatusLine().getStatusCode(); System.out.println("---------- POST status code " + statusCode); if ( followRedirects && statusCode == 302 ) { return redirect( response, client, port, rsessionId, baseUri ); } if ( statusCode != 200 && !(!followRedirects && statusCode != 302) ) { throw new RuntimeException( "GET did not return status 200, but " + response.getStatusLine() + "" + toString(response.getEntity().getContent()) ); } return readResponse( rsessionId, response ); } 
public static String toString ( final InputStream in ) { final StringBuilder sb = new StringBuilder ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) ! = null ) { sb . append ( line ) ; } } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } finally { try { reader . close ( ) ; } catch ( final IOException e ) { } } return sb . toString ( ) ; } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final URL loggingProperties = getClass ( ) . getResource ( " /logging.properties " ) ; System . setProperty ( " java.util.logging.config.file " , loggingProperties . getFile ( ) ) ; final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
abstract TestUtils getTestUtils ( ) ; private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . createCatalina ( port , _memcachedNodes , jvmRoute , loginType ) ; tomcat . start ( ) ; getManager ( tomcat ) . setSticky ( sessionAffinityMode . isSticky ( ) ) ; return tomcat ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final Response tc2Response1 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" ) ); if ( stickyness.isSticky() ) { assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) ); } else { assertEquals( tc2Response1.getSessionId(), sessionId ); } final Response tc2Response2 = get( _httpClient, TC_PORT_2, tc2Response1.getResponseSessionId() ); assertEquals( tc2Response2.get( "foo" ), "bar" ); }} 
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { final SessionManager manager1 = getManager ( _tomcat1 ) ; final SessionManager manager2 = getManager ( _tomcat2 ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( format . stripJvmRoute ( sessionId2 ) , format . stripJvmRoute ( sessionId1 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public void testSerializationOfAuthStuffWithFormAuth ( final SessionAffinityMode stickyness ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_1 : null , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_2 : null , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; 
public void testIgnoredResourcesWithSessionCookieDontCauseSessionStaleness ( ) throws Exception { TODO Auto-generated method stub super.testIgnoredResourcesWithSessionCookieDontCauseSessionStaleness(); } 
public void testIgnoredResourcesWithFormAuthDontCauseSessionStaleness ( ) throws Exception { super . testIgnoredResourcesWithFormAuthDontCauseSessionStaleness ( ) ; } 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { TODO Auto-generated method stub super.testFormAuthDontCauseSessionStaleness(); } 
public void testSessionCreatedForContainerProtectedResourceIsStoredInMemcached ( ) throws Exception { TODO Auto-generated method stub super.testSessionCreatedForContainerProtectedResourceIsStoredInMemcached(); } 
boolean authenticationChanged ( ) { return _authenticationChanged | | getNote ( Constants . FORM_PRINCIPAL_NOTE ) ! = null ; } 
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session ) { return serializeSessionFields ( session , VERSION_2 ) ; } 
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session , final int version ) { final byte [ ] idData = serializeId ( session . getIdInternal ( ) ) ; final byte [ ] principalData = serializePrincipal ( session . getPrincipal ( ) ) ; final int principalDataLength = principalData ! = null ? principalData . length : 0 ; final byte [ ] savedRequestData = serializeSavedRequest ( session . getNote ( Constants . FORM_REQUEST_NOTE ) ) ; final int savedRequestDataLength = savedRequestData ! = null ? savedRequestData . length : 0 ; final byte [ ] savedPrincipalData = serializePrincipal ( ( Principal ) session . getNote ( Constants . FORM_PRINCIPAL_NOTE ) ) ; final int savedPrincipalDataLength = savedPrincipalData ! = null ? savedPrincipalData . length : 0 ; int sessionFieldsDataLength = 2 short value for the version the following might change with other versions, refactoring needed then + 2 short value that stores the dataLength + NUM_BYTES bytes that store all session attributes but the id + 2 short value that stores the idData length + idData.length the number of bytes for the id + 2 short value for the authType + 2 short value that stores the principalData length + principalDataLength; the number of bytes for the principal if(version > VERSION_1) { sessionFieldsDataLength = sessionFieldsDataLength + 2 short value that stores the savedRequestData length + savedRequestDataLength the number of bytes for the savedRequest + 2 short value that stores the savedPrincipalData length + savedPrincipalDataLength; the number of bytes for the savedPrincipal } final byte[] data = new byte[sessionFieldsDataLength]; int idx = 0; idx = encodeNum( version, data, idx, 2 ); idx = encodeNum( sessionFieldsDataLength, data, idx, 2 ); idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 ); idx = encodeBoolean( session.isNewInternal(), data, idx ); idx = encodeBoolean( session.isValidInternal(), data, idx ); idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastBackupTime(), data, idx, 8 ); idx = encodeNum( idData.length, data, idx, 2 ); idx = copy( idData, data, idx ); idx = encodeNum( AuthType.valueOfValue( session.getAuthType() ).getId(), data, idx, 2 ); idx = encodeNum( principalDataLength, data, idx, 2 ); idx = copy( principalData, data, idx ); if(version > VERSION_1) { idx = encodeNum( savedRequestDataLength, data, idx, 2 ); idx = copy( savedRequestData, data, idx ); idx = encodeNum( savedPrincipalDataLength, data, idx, 2 ); idx = copy( savedPrincipalData, data, idx ); } return data; } 
static DeserializationResult deserializeSessionFields ( final byte [ ] data , final SessionManager manager ) throws InvalidVersionException { final MemcachedBackupSession result = manager . newMemcachedBackupSession ( ) ; final short version = ( short ) decodeNum ( data , 0 , 2 ) ; if ( version ! = VERSION_1 & & version ! = VERSION_2 ) { throw new InvalidVersionException ( " The version " + version + " does not match the current version " + VERSION_2 , version ) ; } final short sessionFieldsDataLength = ( short ) decodeNum ( data , 2 , 2 ) ; result . setCreationTimeInternal ( decodeNum ( data , 4 , 8 ) ) ; result . setLastAccessedTimeInternal ( decodeNum ( data , 12 , 8 ) ) ; result . setMaxInactiveInterval ( ( int ) decodeNum ( data , 20 , 4 ) ) ; result . setIsNewInternal ( decodeBoolean ( data , 24 ) ) ; result . setIsValidInternal ( decodeBoolean ( data , 25 ) ) ; result . setThisAccessedTimeInternal ( decodeNum ( data , 26 , 8 ) ) ; result . setLastBackupTime ( decodeNum ( data , 34 , 8 ) ) ; final short idLength = ( short ) decodeNum ( data , 42 , 2 ) ; result . setIdInternal ( decodeString ( data , 44 , idLength ) ) ; final short authTypeId = ( short ) decodeNum ( data , 44 + idLength , 2 ) ; result . setAuthTypeInternal ( AuthType . valueOfId ( authTypeId ) . getValue ( ) ) ; int currentIdx = 44 + idLength + 2 ; final short principalDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( principalDataLength > 0 ) { final byte [ ] principalData = new byte [ principalDataLength ] ; System . arraycopy ( data , currentIdx + 2 , principalData , 0 , principalDataLength ) ; result . setPrincipalInternal ( deserializePrincipal ( principalData , manager ) ) ; } if ( version > VERSION_1 ) { currentIdx + = 2 + principalDataLength ; final short savedRequestDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( savedRequestDataLength > 0 ) { final byte [ ] savedRequestData = new byte [ savedRequestDataLength ] ; System . arraycopy ( data , currentIdx + 2 , savedRequestData , 0 , savedRequestDataLength ) ; result . setNote ( Constants . FORM_REQUEST_NOTE , deserializeSavedRequest ( savedRequestData ) ) ; } currentIdx + = 2 + savedRequestDataLength ; final short savedPrincipalDataLength = ( short ) decodeNum ( data , currentIdx , 2 ) ; if ( savedPrincipalDataLength > 0 ) { final byte [ ] savedPrincipalData = new byte [ savedPrincipalDataLength ] ; System . arraycopy ( data , currentIdx + 2 , savedPrincipalData , 0 , savedPrincipalDataLength ) ; result . setNote ( Constants . FORM_PRINCIPAL_NOTE , deserializePrincipal ( savedPrincipalData , manager ) ) ; } } final byte [ ] attributesData = new byte [ data . length - sessionFieldsDataLength ] ; System . arraycopy ( data , sessionFieldsDataLength , attributesData , 0 , data . length - sessionFieldsDataLength ) ; return new DeserializationResult ( result , attributesData ) ; } 
private static byte [ ] serializePrincipal ( final Principal principal ) { if ( principal = = null ) { return null ; } ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
private static byte [ ] serializeSavedRequest ( final Object obj ) { if ( obj = = null ) { return null ; } final SavedRequest savedRequest = ( SavedRequest ) obj ; ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
private static SavedRequest deserializeSavedRequest ( final byte [ ] data ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( data ) ; 
private static < T > List < T > newArrayList ( final Iterator < T > iter ) { if ( ! iter . hasNext ( ) ) { return Collections . emptyList ( ) ; } final List < T > result = new ArrayList < T > ( ) ; while ( iter . hasNext ( ) ) { result . add ( iter . next ( ) ) ; } return result ; } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { _manager = mock ( SessionManager . class ) ; when ( _manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( _manager.newMemcachedBackupSession() ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return newMemcachedBackupSession( _manager ); } }); final MemcachedSessionService service = new MemcachedSessionService( _manager ); when( _manager.createSession( anyString() ) ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return createSession(service); } }); when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() ); when( _manager.getMemcachedSessionService() ).thenReturn( service ); 
public MemcachedBackupSession answer ( final InvocationOnMock invocation ) throws Throwable { return newMemcachedBackupSession ( _manager ) ; } 
public MemcachedBackupSession answer ( final InvocationOnMock invocation ) throws Throwable { return createSession ( service ) ; } 
public void testSerializeSessionFieldsIncludesFormPrincipalNote ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final Principal saved = createPrincipal ( ) ; session . setNote ( Constants . FORM_PRINCIPAL_NOTE , saved ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; final Principal actual = ( Principal ) deserialized . getNote ( Constants . FORM_PRINCIPAL_NOTE ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , saved ) ; } 
public void testSerializeSessionFieldsIncludesFormRequestNote ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final SavedRequest saved = new SavedRequest ( ) ; saved . setQueryString ( " foo=bar " ) ; saved . setRequestURI ( " http:www.foo.org " ) ; session . setNote ( Constants . FORM_REQUEST_NOTE , saved ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; final SavedRequest actual = ( SavedRequest ) deserialized . getNote ( Constants . FORM_REQUEST_NOTE ) ; assertNotNull ( actual ) ; assertDeepEquals ( actual , saved ) ; } 
public void testVersionUpgrade ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session , TranscoderService . VERSION_1 ) ; final byte [ ] attributesData = TranscoderService . deserializeSessionFields ( data , _manager ) . getAttributesData ( ) ; we just check that data is read (w/o) bounds issues and no data is left (we just passed data in, w/o added attributesData appended) assertEquals(attributesData.length, 0); } 
public void testIgnoredResourcesWithFormAuthDontCauseSessionStaleness ( ) throws Exception { TODO: see testSessionCreatedForContainerProtectedResourceIsStoredInMemcached _tomcat1.stop(); _tomcat2.stop(); _tomcat1 = startTomcatWithAuth( TC_PORT_1, NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1, LockingMode.AUTO, LoginType.FORM ); _tomcat2 = startTomcatWithAuth( TC_PORT_2, NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1, LockingMode.AUTO, LoginType.FORM ); setChangeSessionIdOnAuth( _tomcat1, false ); setChangeSessionIdOnAuth( _tomcat2, false ); final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId ); assertEquals(tc2Response1.getSessionId(), sessionId); assertNull(tc2Response1.getResponseSessionId()); assertEquals( tc2Response1.get( TestServlet.ID ), sessionId ); assertEquals( tc2Response1.get( "foo" ), "bar" ); assertEquals( tc2Response1.get( "bar" ), "baz" ); 
public void testSessionCreatedForContainerProtectedResourceIsStoredInMemcached ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) ) ; failed sometimes, randomly (timing issue?)?! 2 sets for session and validity assertEquals( _daemon1.getCache().getSetCmds(), 2 ); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, false ); assertNull(response2.getResponseSessionId()); assertEquals(response2.getStatusCode(), 302, response2.getContent()); 2 gets for session and validity assertEquals( _daemon1.getCache().getGetHits(), 2 ); 2 new sets for session and validity assertEquals( _daemon1.getCache().getSetCmds(), 4 ); 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response response2 = post ( _httpClient , TC_PORT_2 , " /j_security_check " , sessionId , params , null , true ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; assertEquals ( response2 . getStatusCode ( ) , 200 , response2 . getContent ( ) ) ; assertEquals ( response2 . get ( TestServlet . ID ) , sessionId ) ; final Response response3 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; assertEquals ( response3 . getSessionId ( ) , sessionId ) ; final Response response4 = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response4 . getSessionId ( ) , sessionId ) ; assertEquals ( response4 . get ( TestServlet . ID ) , sessionId ) ; assertEquals ( response4 . get ( " foo " ) , " bar " ) ; 
private Embedded startTomcatWithAuth ( final int port , final LockingMode lockingMode , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcatWithAuth ( port , MEMCACHED_NODES , lockingMode , loginType ) ; } 
private Embedded startTomcatWithAuth ( final int port , final String memcachedNodes , final LockingMode lockingMode , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded result = getTestUtils ( ) . createCatalina ( port , memcachedNodes , null , loginType ) ; getManager ( result ) . setSticky ( false ) ; getManager ( result ) . setLockingMode ( lockingMode . name ( ) ) ; result . start ( ) ; return result ; } 
public static String loginWithForm ( final DefaultHttpClient client , final int tcPort ) throws IOException , HttpException { final Response tc1Response1 = get ( client , tcPort , null ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( tc1Response1 . getContent ( ) . contains ( " j_security_check " ) ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response tc1Response2 = post ( client , tcPort , " /j_security_check " , sessionId , params ) ; assertEquals ( tc1Response2 . getSessionId ( ) , sessionId ) ; System . out . println ( " ----------------xxx (status " + tc1Response2 . getStatusCode ( ) + " ) " + tc1Response2 . getContent ( ) ) ; new RuntimeException ( " err " ) . printStackTrace ( ) ; assertEquals ( tc1Response2 . get ( TestServlet . ID ) , sessionId ) ; return tc1Response2 . getSessionId ( ) ; } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params , @Nullable final Credentials credentials , final boolean followRedirects ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:"+ DEFAULT_HOST +":"+ port; final String url = getUrl( port, path ); final HttpPost method = new HttpPost( url ); if ( rsessionId != null ) { method.setHeader( "Cookie", "JSESSIONID=" + rsessionId ); } method.setEntity( createFormEntity( params ) ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); final HttpResponse response = credentials == null ? client.execute( method ) : executeRequestWithAuth( client, method, credentials ); final int statusCode = response.getStatusLine().getStatusCode(); if ( followRedirects && statusCode == 302 ) { return redirect( response, client, port, rsessionId, baseUri ); } if ( statusCode != 200 && !(!followRedirects && statusCode == 302) ) { throw new RuntimeException( "GET did not return status 200, but " + response.getStatusLine() + "" + toString(response.getEntity().getContent()) ); } return readResponse( rsessionId, response ); } 
public void invoke ( final Request request , final Response response ) throws IOException , ServletException { final String requestId = getURIWithQueryString ( request ) ; if ( ! _enabled . get ( ) ) { getNext ( ) . invoke ( request , response ) ; 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResult> backupSession( final Session session, final boolean sessionIdChanged, final String requestURI ) { _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesFiltered() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.registerSince( ATTRIBUTES_SERIALIZATION, startSerialization ); _statistics.register( CACHED_DATA_SIZE, data.length ); return new SimpleFuture<BackupResult>( new BackupResult( BackupResultStatus.SUCCESS ) ); } @Override public MemcachedBackupSession findSession( final String id ) throws IOException { final MemcachedBackupSession result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } @Override protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.registerSince( LOAD_FROM_MEMCACHED, startDeserialization ); return null; } }} 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; final String sessionCookieName = _manager . getSessionCookieName ( ) ; _trackingHostValve = new RequestTrackingHostValve ( _requestUriIgnorePattern , sessionCookieName , this , _statistics , _enabled ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . addValve ( _trackingHostValve ) ; _trackingContextValve = new RequestTrackingContextValve ( sessionCookieName , this ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _trackingContextValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , operation timeout " + _operationTimeout + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
private boolean isContainerSessionLookup ( ) { return ! _trackingContextValve . wasInvokedWith ( _lockingStrategy . getCurrentRequest ( ) ) ; } 
public void invoke ( final Request request , final Response response ) throws IOException , ServletException { final Object processRequest = request . getNote ( RequestTrackingHostValve . REQUEST_PROCESS ) ; if ( processRequest ! = Boolean . TRUE ) { request . setNote ( INVOKED , Boolean . TRUE ) ; 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getLockingStrategy().onRequestStart(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); }} 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; _service . setMemcachedClient ( _memcachedMock ) ; _service . startInternal ( ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getLockingStrategy().onRequestStart(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESS ) ) ) . thenReturn ( Boolean . TRUE ) ; } 
protected RequestTrackingContextValve createSessionTrackerValve ( ) { return new RequestTrackingContextValve ( " foo " , _service ) ; } 
public final void testGetSessionCookieName ( ) throws IOException , ServletException { final RequestTrackingContextValve cut = new RequestTrackingContextValve ( " foo " , _service ) ; assertEquals ( cut . getSessionCookieName ( ) , " foo " ) ; } 
public final void testRequestIsMarkedAsProcessed ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request ) . setNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) , eq ( Boolean . TRUE ) ) ; } 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; when ( _service . changeSessionIdOnMemcachedFailover ( eq ( sessionId ) ) ) . thenReturn ( newSessionId ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _request ) . changeSessionId ( eq ( newSessionId ) ) ; verify ( _request ) . setNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) , eq ( Boolean . TRUE ) ) ; 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; } 
protected RequestTrackingHostValve createSessionTrackerValve ( ) { return new RequestTrackingHostValve ( " .* \\ .(png|gif|jpg|css|js|ico)$ " , " somesessionid " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; } 
public final void testGetSessionCookieName ( ) throws IOException , ServletException { final RequestTrackingHostValve cut = new RequestTrackingHostValve ( null , " foo " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) ) ; assertEquals ( cut . getSessionCookieName ( ) , " foo " ) ; } 
public final void testProcessRequestNotePresent ( ) throws IOException , ServletException { _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service , never ( ) ) . backupSession ( anyString ( ) , anyBoolean ( ) , anyString ( ) ) ; verify ( _request ) . setNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESS ) , eq ( Boolean . TRUE ) ) ; } 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , newSessionId ) ; when ( _response . getHeader ( eq ( " Set-Cookie " ) ) ) . thenReturn ( generateCookieString ( cookie ) ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( newSessionId ) , eq ( true ) , anyString ( ) ) ; 
public void testSessionCreatedForContainerProtectedResourceIsStoredInMemcached ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; LOG . info ( " START foo1234 " ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; LOG . info ( " END foo1234 " ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) ) ; failed sometimes, randomly (timing issue?)?! Thread.sleep(200); 2 sets for session and validity assertEquals( _daemon1.getCache().getSetCmds(), 2 ); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, false ); assertNull(response2.getResponseSessionId()); assertEquals(response2.getStatusCode(), 302, response2.getContent()); 2 gets for session and validity assertEquals( _daemon1.getCache().getGetHits(), 2 ); 2 new sets for session and validity assertEquals( _daemon1.getCache().getSetCmds(), 4 ); 
private boolean contextHasFormBasedSecurityConstraint ( ) { if ( _contextHasFormBasedSecurityConstraint ! = null ) { return _contextHasFormBasedSecurityConstraint . booleanValue ( ) ; } final Context context = ( Context ) _manager . getContainer ( ) ; final SecurityConstraint [ ] constraints = context . findConstraints ( ) ; final LoginConfig loginConfig = context . getLoginConfig ( ) ; _contextHasFormBasedSecurityConstraint = constraints ! = null & & constraints . length > 0 & & loginConfig ! = null & & Constants . FORM_METHOD . equals ( loginConfig . getAuthMethod ( ) ) ; return _contextHasFormBasedSecurityConstraint ; } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = getManager ( _tomcat1 ) ; manager . setSticky ( stickyness . isSticky ( ) ) ; Wait some time for reconfiguration waitForReconnect(manager.getMemcachedSessionService().getMemcached(), 1, 500); set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); +1000 just to be sure that we're >4 secs assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = getManager ( _tomcat1 ) ; setStickyness ( stickyness ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); +1000 just to be sure that we're >4 secs assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void sessionRemoved ( final MemcachedBackupSession session ) { if ( ! _sticky ) { if ( session . isLocked ( ) ) { 
public void testInvalidateSessionShouldReleaseLockIssue144 ( ) throws IOException , InterruptedException , HttpException { getManager ( _tomcat1 ) . setLockingMode ( LockingMode . AUTO . name ( ) ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final Response response = get ( _httpClient , TC_PORT_1 , PATH_INVALIDATE , sessionId1 ) ; assertNull ( response . getResponseSessionId ( ) ) ; assertNull ( _client . get ( sessionId1 ) , " Invalidated session should be removed from memcached " ) ; assertNull ( _client . get ( new SessionIdFormat ( ) . createLockName ( sessionId1 ) ) , " Lock should be released. " ) ; } 
private void remove ( final Session session , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked, removeFromMemcached: " + removeFromMemcached + " , id: " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session ) ; _msm . sessionRemoved ( ( MemcachedBackupSession ) session ) ; } 
private void removeInternal ( final Session session , final boolean update , final boolean removeFromMemcached ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " remove invoked, removeFromMemcached: " + removeFromMemcached + " , id: " + session . getId ( ) ) ; } if ( removeFromMemcached ) { _msm . deleteFromMemcached ( session . getId ( ) ) ; } super . remove ( session , update ) ; _msm . sessionRemoved ( ( MemcachedBackupSession ) session ) ; } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = getManager ( _tomcat1 ) ; setStickyness ( stickyness ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNullWaitingWithProxy(200l, _memcached).get( sessionId1 ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getLockingStrategy().onRequestStart(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getLockingStrategy().onRequestFinished(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); }} 
public void testChangeSessionId ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , TimeoutException { _service . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _service . setLockingMode ( LockingMode . NONE , null , false ) ; } final MemcachedBackupSession session = createSession ( _service ) ; session . setAttribute ( " foo " , " bar " ) ; _service . backupSession ( session . getIdInternal ( ) , false , " foo " ) . get ( ) ; final String oldSessionId = session . getId ( ) ; _service . getManager ( ) . changeSessionId ( session ) ; on session backup we specify sessionIdChanged as false as we're not aware of this fact _service.backupSession( session.getIdInternal(), false, "foo" ); remove session with old id and add it with the new id verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) ); verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any() ); if ( !stickyness.isSticky() ) { Thread.sleep(200l); 
public void testNonStickySessionSecondaryBackupFailover ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = getManager ( _tomcat1 ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getMemcached ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId1 ) ; final MemCacheDaemon < ? > first = memcachedsByNodeId . get ( nodeId ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); Request / Update final String sessionId2 = post( _httpClient, TC_PORT_1, sessionId1, "key", "v2" ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v2"); 
public void testNonStickySessionSecondaryBackupFailoverForSkippedUpdate ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = getManager ( _tomcat1 ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getMemcached ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> first = memcachedsByNodeId.get(nodeId); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Thread.sleep(100); Request / Update final String sessionId2 = get( _httpClient, TC_PORT_1, sessionId1 ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Thread.sleep(100); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v1"); 
private Embedded startTomcatWithAuth ( final int port , @Nonnull final LockingMode lockingMode ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcatWithAuth ( port , MEMCACHED_NODES , lockingMode , LoginType . BASIC ) ; } 
private Embedded startTomcatWithAuth ( final int port , final String memcachedNodes , final LockingMode lockingMode , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded result = getTestUtils ( ) . createCatalina ( port , 5 , memcachedNodes , null , loginType , null ) ; getManager ( result ) . setSticky ( false ) ; getManager ( result ) . setLockingMode ( lockingMode . name ( ) ) ; result . start ( ) ; return result ; } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params , @Nullable final Credentials credentials , final boolean followRedirects ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:"+ DEFAULT_HOST +":"+ port; final String url = getUrl( port, path ); final HttpPost method = new HttpPost( url ); if ( rsessionId != null ) { method.setHeader( "Cookie", "JSESSIONID=" + rsessionId ); } method.setEntity( createFormEntity( params ) ); System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); final HttpResponse response = credentials == null ? client.execute( method ) : executeRequestWithAuth( client, method, credentials ); final int statusCode = response.getStatusLine().getStatusCode(); if ( followRedirects && statusCode == 302 ) { return redirect( response, client, port, rsessionId, baseUri ); } if ( statusCode != 200 && !(!followRedirects && statusCode == 302) ) { throw new RuntimeException( "POST"+(path != null ? " " + path : "")+" did not return status 200, but " + response.getStatusLine() + "" + toString(response.getEntity().getContent()) ); } return readResponse( rsessionId, response ); } 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final URL loggingProperties = getClass ( ) . getResource ( " /logging.properties " ) ; System . setProperty ( " java.util.logging.config.file " , loggingProperties . getFile ( ) ) ; final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public static Object assertNotNullElementWaiting ( final int elementIndex , final long maxTimeToWait , final Object obj , final Method method , final Object [ ] args ) throws Exception { final long start = System . currentTimeMillis ( ) ; while ( System . currentTimeMillis ( ) < start + maxTimeToWait ) { final Object items = method . invoke ( obj , args ) ; if ( items ! = null ) { if ( items instanceof List & & ( ( List < ? > ) items ) . get ( elementIndex ) ! = null | | items instanceof Object [ ] & & ( ( Object [ ] ) items ) [ elementIndex ] ! = null ) { return items ; } } try { Thread . sleep ( 20 ) ; } catch ( final InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } } throw new AssertionError ( " Expected not null within " + maxTimeToWait + " millis, got null. " ) ; } 
public static < T , V > T assertNotNullElementWaitingWithProxy ( final int elementIndex , final long maxTimeToWait , final T objectToProxy ) { final Class < ? > [ ] interfaces = objectToProxy . getClass ( ) . getInterfaces ( ) ; return ( T ) Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , interfaces , 
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { return assertNotNullElementWaiting ( elementIndex , maxTimeToWait , objectToProxy , method , args ) ; } 
public static < T , V > T assertNotNullWaitingWithProxy ( final long maxTimeToWait , final T objectToProxy ) { final Class < ? > [ ] interfaces = objectToProxy . getClass ( ) . getInterfaces ( ) ; return ( T ) Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , interfaces , 
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { return assertNotNullWaiting ( maxTimeToWait , objectToProxy , method , args ) ; } 
public static Object assertNotNullWaiting ( final long maxTimeToWait , final Object obj , final Method method , final Object [ ] args ) throws Exception { final long start = System . currentTimeMillis ( ) ; while ( System . currentTimeMillis ( ) < start + maxTimeToWait ) { final Object result = method . invoke ( obj , args ) ; if ( result ! = null ) { return result ; } try { Thread . sleep ( 10 ) ; } catch ( final InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } } throw new AssertionError ( " Expected not null, actual null. " ) ; } 
public void setup ( ) throws Exception { final SessionManager manager = createSessionManager ( ) ; _service = manager . getMemcachedSessionService ( ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . setSticky ( true ) ; final StandardContext context = createContext ( ) ; context . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration manager.setContainer( context ); _memcachedMock = mock( MemcachedClient.class ); final OperationFuture<Boolean> setResultMock = mock( OperationFuture.class ); when( setResultMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( setResultMock ); final OperationFuture<Boolean> deleteResultMock = mock( OperationFuture.class ); when( deleteResultMock.get() ).thenReturn( Boolean.TRUE ); when( _memcachedMock.delete( anyString() ) ).thenReturn( deleteResultMock ); startInternal( manager, _memcachedMock ); _executor = Executors.newCachedThreadPool(); 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; System . out . println ( " ********* START testFormAuthDontCauseSessionStaleness " ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response response2 = post ( _httpClient , TC_PORT_2 , " /j_security_check " , sessionId , params , null , true ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; assertEquals ( response2 . getStatusCode ( ) , 200 , response2 . getContent ( ) ) ; assertEquals ( response2 . get ( TestServlet . ID ) , sessionId ) ; final Response response3 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; assertEquals ( response3 . getSessionId ( ) , sessionId ) ; final Response response4 = get ( _httpClient , TC_PORT_1 , sessionId ) ; assertEquals ( response4 . getSessionId ( ) , sessionId ) ; assertEquals ( response4 . get ( TestServlet . ID ) , sessionId ) ; assertEquals ( response4 . get ( " foo " ) , " bar " ) ; System . out . println ( " ********* END testFormAuthDontCauseSessionStaleness " ) ; 
private static void initLogConfig ( final Class < ? extends TestUtils > clazz ) { final URL loggingProperties = clazz . getResource ( " /logging.properties " ) ; try { System . setProperty ( " java.util.logging.config.file " , new File ( loggingProperties . toURI ( ) ) . getAbsolutePath ( ) ) ; } catch ( final Exception e ) { we don't have a plain file (e.g. the case for msm-kryo-serializer etc), so we can skip reading the config return; } try { LogManager.getLogManager().readConfiguration(); 
public Embedded createCatalina ( final int port , final int sessionTimeout , final String memcachedNodes , final String jvmRoute , final LoginType loginType , final String transcoderFactoryClassName ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = getManager ( _tomcat1 ) ; setStickyness ( stickyness ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertWaitingWithProxy(Predicates.<MemcachedClientIF> notNull(), 200l, _memcached).get( sessionId1 ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testCookieNotSetWhenRegularMemcachedDownIssue40 ( final SessionAffinityMode sessionAffinity ) throws Exception { _daemon2 . stop ( ) ; TestUtils . waitForReconnect ( getService ( _tomcat1 ) . getMemcached ( ) , 1 , 1000l ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertEquals ( nodeId , _nodeId1 ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
public void testSessionNotLoadedForReadonlyRequest ( ) throws IOException , HttpException , InterruptedException { getManager ( _tomcat1 ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; waitForReconnect ( getService ( _tomcat1 ) . getMemcached ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; 2 for session and validity, if backup would be stored this would be 4 instead assertWaitingWithProxy(equalTo(2), 1000, _daemon1.getCache()).getSetCmds(); no gets at all assertEquals( _daemon1.getCache().getGetHits(), 0 ); a request without session access should not pull the session from memcached but update the validity info (get + set) get( _httpClient, TC_PORT_1, PATH_NO_SESSION_ACCESS, sessionId1 ); assertWaitingWithProxy(equalTo(3), 1000, _daemon1.getCache()).getSetCmds(); assertEquals( _daemon1.getCache().getGetHits(), 1 ); } 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; waitForReconnect ( getService ( _tomcat1 ) . getMemcached ( ) , 1 , 1000 ) ; waitForReconnect ( getService ( _tomcat2 ) . getMemcached ( ) , 1 , 1000 ) ; System . out . println ( " ********* START testFormAuthDontCauseSessionStaleness " ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) ) ; System . out . println ( " ********* AFTER GET: testFormAuthDontCauseSessionStaleness " ) ; Wait some time so that the GET is finished Thread.sleep(200); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, true ); assertNull(response2.getResponseSessionId()); assertEquals(response2.getStatusCode(), 200, response2.getContent()); assertEquals(response2.get( TestServlet.ID ), sessionId); final Response response3 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" )); assertEquals(response3.getSessionId(), sessionId); final Response response4 = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response4.getSessionId(), sessionId); assertEquals(response4.get( TestServlet.ID ), sessionId); assertEquals(response4.get( "foo" ), "bar"); System.out.println("********* END testFormAuthDontCauseSessionStaleness"); 
public static < T , V > T assertNotNullElementWaitingWithProxy ( final int elementIndex , final long maxTimeToWait , final T objectToProxy ) { return assertWaitingWithProxy ( elementAt ( elementIndex , notNull ( ) ) , maxTimeToWait , objectToProxy ) ; } 
public static < T , V > T assertWaitingWithProxy ( final Predicate < V > predicate , final long maxTimeToWait , final T objectToProxy ) { final Class < ? > [ ] interfaces = objectToProxy . getClass ( ) . getInterfaces ( ) ; return ( T ) Proxy . newProxyInstance ( Thread . currentThread ( ) . getContextClassLoader ( ) , interfaces , 
public Object invoke ( final Object proxy , final Method method , final Object [ ] args ) throws Throwable { return assertPredicateWaiting ( predicate , maxTimeToWait , objectToProxy , method , args ) ; } 
private static < V > V assertPredicateWaiting ( final Predicate < V > predicate , final long maxTimeToWait , final Object obj , final Method method , final Object [ ] args ) throws Exception { final long start = System . currentTimeMillis ( ) ; while ( System . currentTimeMillis ( ) < start + maxTimeToWait ) { @java.lang.SuppressWarnings ( " unchecked " ) final V result = ( V ) method . invoke ( obj , args ) ; if ( predicate . apply ( result ) ) { return result ; } try { Thread . sleep ( 10 ) ; } catch ( final InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } } throw new AssertionError ( " Expected not null, actual null. " ) ; } 
boolean apply ( @Nullable T input ) ; } public static class Predicates { private static final Predicate < Object > NOT_NULL = new Predicate < Object > ( ) { @Override public boolean apply ( final Object input ) { return input ! = null ; } } ; private static final Predicate < Object > IS_NULL = new Predicate < Object > ( ) { @Override public boolean apply ( final Object input ) { return input = = null ; } } ; public static < T > Predicate < T > equalTo ( @Nullable final T target ) { return ( target = = null ) ? Predicates . < T > isNull ( ) : new Predicate < T > ( ) { @Override public boolean apply ( final T input ) { return target . equals ( input ) ; } } ; } public static < T > Predicate < T [ ] > elementAt ( final int index , @Nonnull final Predicate < T > elementPredicate ) { return new Predicate < T [ ] > ( ) { @Override public boolean apply ( final T [ ] input ) { return input ! = null & & input . length > index & & elementPredicate . apply ( input [ index ] ) ; } } ; } } } 
public boolean apply ( final Object input ) { return input ! = null ; } 
public boolean apply ( final Object input ) { return input = = null ; } 
public static < T > Predicate < T > notNull ( ) { return ( Predicate < T > ) NOT_NULL ; } 
public static < T > Predicate < T > isNull ( ) { return ( Predicate < T > ) IS_NULL ; } 
public static < T > Predicate < T > equalTo ( @Nullable final T target ) { return ( target = = null ) ? Predicates . < T > isNull ( ) : new Predicate < T > ( ) { 
public boolean apply ( final T input ) { return target . equals ( input ) ; } 
public static < T > Predicate < T [ ] > elementAt ( final int index , @Nonnull final Predicate < T > elementPredicate ) { return new Predicate < T [ ] > ( ) { @Override 
public boolean apply ( final T [ ] input ) { return input ! = null & & input . length > index & & elementPredicate . apply ( input [ index ] ) ; } 
private static Response readResponse ( final String rsessionId , final HttpResponse response ) throws IOException { final String responseSessionId = getSessionIdFromResponse ( response ) ; System.out.println( "response cookie: " + responseSessionId ); final StringBuilder sb = new StringBuilder(); final Map<String, String> keyValues = new LinkedHashMap<String, String>(); BufferedReader reader = null; try { reader = new BufferedReader( new InputStreamReader( response.getEntity().getContent() ) ); String line = null; while ( ( line = reader.readLine() ) != null ) { sb.append(line); final String[] keyValue = line.split( "=" ); if ( keyValue.length > 0 ) { keyValues.put( keyValue[0], keyValue.length > 1 ? keyValue[1] : null ); } } } finally { if(reader != null) { reader.close(); } } return new Response( response, responseSessionId == null ? rsessionId : responseSessionId, responseSessionId, sb.toString(), keyValues ); } 
public static String toString ( final InputStream in ) { final StringBuilder sb = new StringBuilder ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) ! = null ) { sb . append ( line ) ; } } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader ! = null ) { try { reader . close ( ) ; } catch ( final IOException e ) { } } } return sb . toString ( ) ; } 
protected abstract SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } @Entity @AccessType ( " field " ) @SuppressWarnings ( " serial " ) static class Person implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; @OneToMany ( cascade = CascadeType . ALL ) public Set < Animal > animals ; public Person ( ) { } public Person ( final String name , final Set < Animal > animals ) { this . name = name ; this . animals = animals ; } @Override public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } } @Entity @AccessType ( " field " ) @SuppressWarnings ( " serial " ) static class Animal implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; public Animal ( ) { } public Animal ( final String name ) { this . name = name ; } @Override public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } } static interface Callback < T > { T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn( new MemcachedSessionService( manager ) ); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn( new MemcachedSessionService( manager ) ); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; setChangeSessionIdOnAuth ( _tomcat1 , false ) ; setChangeSessionIdOnAuth ( _tomcat2 , false ) ; waitForReconnect ( getService ( _tomcat1 ) . getMemcached ( ) , 1 , 1000 ) ; waitForReconnect ( getService ( _tomcat2 ) . getMemcached ( ) , 1 , 1000 ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) ) ; Wait some time so that the GET is finished Thread.sleep(200); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, true ); assertNull(response2.getResponseSessionId()); assertEquals(response2.getStatusCode(), 200, response2.getContent()); assertEquals(response2.get( TestServlet.ID ), sessionId); final Response response3 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" )); assertEquals(response3.getSessionId(), sessionId); final Response response4 = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response4.getSessionId(), sessionId); assertEquals(response4.get( TestServlet.ID ), sessionId); assertEquals(response4.get( "foo" ), "bar"); 
public static String loginWithForm ( final DefaultHttpClient client , final int tcPort ) throws IOException , HttpException { final Response tc1Response1 = get ( client , tcPort , null ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( tc1Response1 . getContent ( ) . contains ( " j_security_check " ) ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response tc1Response2 = post ( client , tcPort , " /j_security_check " , sessionId , params ) ; assertEquals ( tc1Response2 . getSessionId ( ) , sessionId ) ; new RuntimeException ( " err " ) . printStackTrace ( ) ; assertEquals ( tc1Response2 . get ( TestServlet . ID ) , sessionId ) ; return tc1Response2 . getSessionId ( ) ; } 
private Triple < Kryo , SerializerFactory [ ] , UnregisteredClassHandler [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( { " rawtypes " , " unchecked " } ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this , clazz ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } if ( Date . class . isAssignableFrom ( clazz ) ) { return new DateSerializer ( clazz ) ; } return super . newSerializer ( clazz ) ; } @SuppressWarnings ( { " rawtypes " } ) @Override protected void handleUnregisteredClass ( final Class clazz ) { if ( _unregisteredClassHandlers ! = null ) { for ( int i = 0 ; i < _unregisteredClassHandlers . length ; i + + ) { final boolean handled = _unregisteredClassHandlers [ i ] . handleUnregisteredClass ( clazz ) ; if ( handled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " UnregisteredClassHandler " + _unregisteredClassHandlers [ i ] . getClass ( ) . getName ( ) + " handled class " + clazz ) ; } return ; } } } super . handleUnregisteredClass ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); final Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Triple.create( kryo, pair.b, pair.c ); } 
public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this , clazz ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } if ( Date . class . isAssignableFrom ( clazz ) ) { return new DateSerializer ( clazz ) ; } return super . newSerializer ( clazz ) ; } 
public final void testBackupSessionInvokedWhenResponseCookiePresent ( ) throws IOException , ServletException { when ( _request . getRequestedSessionId ( ) ) . thenReturn ( null ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , " foo " ) ; setupGetResponseSetCookieHeadersExpectations ( _response , new String [ ] { generateCookieString ( cookie ) } ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( " foo " ) , eq ( false ) , anyString ( ) ) ; 
public final void testChangeSessionIdForRelocatedSession ( ) throws IOException , ServletException { final String sessionId = " bar " ; final String newSessionId = " newId " ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getRequestedSessionId ( ) ) . thenReturn ( sessionId ) ; final Cookie cookie = new Cookie ( _sessionTrackerValve . getSessionCookieName ( ) , newSessionId ) ; setupGetResponseSetCookieHeadersExpectations ( _response , new String [ ] { generateCookieString ( cookie ) } ) ; _sessionTrackerValve . invoke ( _request , _response ) ; verify ( _service ) . backupSession ( eq ( newSessionId ) , eq ( true ) , anyString ( ) ) ; 
protected abstract void setupGetResponseSetCookieHeadersExpectations ( Response response , String [ ] result ) ; private String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; } } 
private String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; } 
protected void setupGetResponseSetCookieHeadersExpectations ( Response response , String [ ] result ) { when ( response . getHeaderValues ( eq ( " Set-Cookie " ) ) ) . thenReturn ( result ) ; } 
protected void setupGetResponseSetCookieHeadersExpectations ( Response response , String [ ] result ) { when ( response . getHeaders ( eq ( " Set-Cookie " ) ) ) . thenReturn ( Arrays . asList ( result ) ) ; } 
public void updateLocator ( final List < MemcachedNode > nodes ) { } 
private void setupMembaseClient ( ) throws URISyntaxException , IOException { if ( mc ! = null ) { LOG . info ( " Closing existing membase client. " ) ; mc . shutdown ( ) ; } final List < URI > uris = getURIs ( ) ; LOG . info ( " Creating new membase client with uris " + uris ) ; mc = new CouchbaseClient ( uris , " default " , " " ) ; } 
private boolean isCouchbaseConfig ( final String memcachedNodes ) { return memcachedNodes . startsWith ( " http: " ) ; } 
public static MemcachedNodesManager createFor ( final String memcachedNodes , final String failoverNodes , final MemcachedClientCallback memcachedClientCallback ) { tif ( memcachedNodes = = null | | memcachedNodes . trim ( ) . isEmpty ( ) ) { tthrow new IllegalArgumentException ( " null or empty memcachedNodes not allowed. " ) ; } if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! COUCHBASE_BUCKET_NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) ; } 
public boolean isCouchbaseBucketConfig ( ) { return COUCHBASE_BUCKET_NODES_PATTERN . matcher ( _memcachedNodes ) . matches ( ) ; } 
public static ConnectionType valueOf ( final boolean couchbaseBucketConfig , final String username , final String password ) { return new ConnectionType ( couchbaseBucketConfig , username , password ) ; } 
boolean isCouchbaseBucketConfig ( ) { return couchbaseBucketConfig ; } 
boolean isSASL ( ) { return ! couchbaseBucketConfig & & ! isBlank ( username ) & & ! isBlank ( password ) ; } 
boolean isDefault ( ) { return ! isCouchbaseBucketConfig ( ) & & ! isSASL ( ) ; } 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } try { final ConnectionType connectionType = ConnectionType . valueOf ( memcachedNodesManager . isCouchbaseBucketConfig ( ) , _username , _password ) ; 
protected ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final ConnectionType connectionType , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { if ( connectionType . isSASL ( ) ) { final AuthDescriptor authDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( _username , _password ) ) ; return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout , authDescriptor ) : new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setAuthDescriptor ( authDescriptor ) . setOpTimeout ( _operationTimeout ) . build ( ) ; } else if ( connectionType . isCouchbaseBucketConfig ( ) ) { return new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setOpTimeout ( _operationTimeout ) . build ( ) ; } else { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) : new BinaryConnectionFactory ( ) ; } } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) 
public void setUp ( final Method testMethod ) throws Throwable { couchbaseProvided = Boolean . parseBoolean ( System . getProperty ( " couchbase.provided " , " false " ) ) ; final int couchbasePort = Integer . parseInt ( System . getProperty ( " couchbase.port " , " 18091 " ) ) ; if ( ! couchbaseProvided ) { cluster . add ( setupCouchbase ( couchbasePort ) ) ; } try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . createCatalina ( _portTomcat1 , " http:localhost: " + couchbasePort + " /pools " ) ; getManager ( _tomcat1 ) . setSticky ( true ) ; getService ( _tomcat1 ) . setMemcachedProtocol ( " binary " ) ; getManager ( _tomcat1 ) . setUsername ( " default " ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } setupCouchbaseClient ( ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( getManager ( _tomcat1 ) ) ) ; } 
public void tearDown ( ) throws Exception { mc . shutdown ( ) ; mc = null ; if ( ! couchbaseProvided ) { tearDownCouchbase ( ) ; } _tomcat1 . stop ( ) ; } 
public void testBackupSessionInCouchbase ( ) throws InterruptedException , ExecutionException { final MemcachedSessionService service = getService ( _tomcat1 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , getManager ( _tomcat1 ) ) ; checkSession ( loadedSession , session ) ; } 
public void testBackupSessionInCouchbaseCluster ( ) throws Exception { final MemcachedSessionService service = getService ( _tomcat1 ) ; cluster . add ( setupCouchbase ( getMaxCouchbasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupCouchbaseClient ( ) ; waitForReconnect ( service . getMemcached ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , getManager ( _tomcat1 ) ) ; checkSession ( loadedSession , session ) ; } 
private void setupCouchbaseClient ( ) throws URISyntaxException , IOException { if ( mc ! = null ) { LOG . info ( " Closing existing couchbase client. " ) ; mc . shutdown ( ) ; } final List < URI > uris = getURIs ( ) ; LOG . info ( " Creating new couchbase client with uris " + uris ) ; mc = new CouchbaseClient ( uris , " default " , " " ) ; } 
private Pair < CouchbaseMock , Thread > setupCouchbase ( final int couchbasePort ) throws IOException { final CouchbaseMock couchbase = new CouchbaseMock ( " localhost " , couchbasePort , 1 , 1 ) ; couchbase . setRequiredHttpAuthorization ( null ) ; final Thread thread = new Thread ( couchbase ) ; thread . start ( ) ; return Pair . of ( couchbase , thread ) ; } 
private void tearDownCouchbase ( ) throws InterruptedException { for ( final Pair < CouchbaseMock , Thread > server : cluster ) { server . getSecond ( ) . interrupt ( ) ; server . getSecond ( ) . join ( 1000 ) ; server . getFirst ( ) . close ( ) ; } cluster . clear ( ) ; } 
public void testCouchbaseNodesAndFailoverNodeShouldThrowException ( ) { createFor ( " http:localhost:8091/pools " , " n1 " , _mcc ) ; } 
public void testIsCouchbaseBucketConfig ( ) { assertTrue ( createFor ( " http:10.10.0.1:8091/pools " , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; assertTrue ( createFor ( " http:10.10.0.1:8091/pools,http:10.10.0.2:8091/pools " , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; } 
public void testGetCouchbaseBucketURIs ( ) throws URISyntaxException { assertEquals ( createFor ( " http:10.10.0.1:8091/pools " , null , _mcc ) . getCouchbaseBucketURIs ( ) , Arrays . asList ( new URI ( " http:10.10.0.1:8091/pools " ) ) ) ; assertEquals ( createFor ( " http:10.10.0.1:8091/pools,http:10.10.0.2:8091/pools " , null , _mcc ) . getCouchbaseBucketURIs ( ) , Arrays . asList ( new URI ( " http:10.10.0.1:8091/pools " ) , new URI ( " http:10.10.0.2:8091/pools " ) ) ) ; 
protected ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final ConnectionType connectionType , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { if ( connectionType . isSASL ( ) ) { final AuthDescriptor authDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( _username , _password ) ) ; return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout , authDescriptor ) : new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setAuthDescriptor ( authDescriptor ) . setOpTimeout ( _operationTimeout ) . build ( ) ; } else { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) : new BinaryConnectionFactory ( ) ; } } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) 
public void shutdown ( ) { _log . info ( " Stopping services. " ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . removeValve ( _trackingHostValve ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _memcached ! = null ) { _memcached . shutdown ( ) ; 
private void initNonStickyLockingMode ( @Nonnull final MemcachedNodesManager config ) { if ( _sticky ) { setLockingMode ( null , null , false ) ; return ; } if ( _sessionAttributeFilter ! = null ) { _log . warn ( " There's a sessionAttributesFilter configured (' " + _sessionAttributeFilter + " '), " + " all other session attributes will be lost after the request due to non-sticky configuration! " ) ; } Pattern uriPattern = null ; LockingMode lockingMode = null ; if ( _lockingMode ! = null ) { if ( _lockingMode . startsWith ( " uriPattern: " ) ) { lockingMode = LockingMode . URI_PATTERN ; uriPattern = Pattern . compile ( _lockingMode . substring ( " uriPattern: " . length ( ) ) ) ; } else { lockingMode = LockingMode . valueOf ( _lockingMode . toUpperCase ( ) ) ; } } if ( lockingMode = = null ) { lockingMode = LockingMode . NONE ; } final boolean storeSecondaryBackup = config . getCountNodes ( ) > 1 & & ! config . isCouchbaseBucketConfig ( ) ; setLockingMode ( lockingMode , uriPattern , storeSecondaryBackup ) ; } 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; Context _contextContainer = mock ( Context . class ) ; Host _hostContainer = mock ( Host . class ) ; SessionManager _manager = mock ( SessionManager . class ) ; when ( _service . getManager ( ) ) . thenReturn ( _manager ) ; when ( _manager . getContainer ( ) ) . thenReturn ( _contextContainer ) ; when ( _contextContainer . getParent ( ) ) . thenReturn ( _hostContainer ) ; when ( _contextContainer . getPath ( ) ) . thenReturn ( " / " ) ; _sessionTrackerValve . setContainer ( _hostContainer ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { couchbaseProvided = Boolean . parseBoolean ( System . getProperty ( " couchbase.provided " , " false " ) ) ; final int couchbasePort = Integer . parseInt ( System . getProperty ( " couchbase.port " , " 18091 " ) ) ; if ( ! couchbaseProvided ) { cluster . add ( setupCouchbase ( couchbasePort ) ) ; } try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " http:localhost: " + couchbasePort + " /pools " ) . sticky ( true ) . memcachedProtocol ( " binary " ) . username ( " default " ) . build ( ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } setupCouchbaseClient ( ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( getManager ( _tomcat1 ) ) ) ; } 
public void tearDown ( ) throws Exception { mc . shutdown ( ) ; mc = null ; if ( ! couchbaseProvided ) { tearDownCouchbase ( ) ; } _tomcat1 . stop ( ) ; } 
public void testBackupSessionInCouchbase ( ) throws InterruptedException , ExecutionException { final MemcachedSessionService service = getService ( _tomcat1 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , getManager ( _tomcat1 ) ) ; checkSession ( loadedSession , session ) ; } 
public void testBackupSessionInCouchbaseCluster ( ) throws Exception { final MemcachedSessionService service = getService ( _tomcat1 ) ; cluster . add ( setupCouchbase ( getMaxCouchbasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupCouchbaseClient ( ) ; waitForReconnect ( service . getMemcached ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , getManager ( _tomcat1 ) ) ; checkSession ( loadedSession , session ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? _memcachedNodeId + " : " : " " ; final String memcachedNodes = nodePrefix + " localhost: " + _memcachedPort ; try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( memcachedNodes ) . sticky ( true ) . jvmRoute ( " app1 " ) . build ( ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
public void testStartMsmDisabled ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { shutdown our server and our client _memcached.shutdown(); _daemon.stop(); start a new tomcat with msm initially disabled _tomcat1.stop(); Thread.sleep( 500 ); final String memcachedNodes = _memcachedNodeId + ":localhost:" + _memcachedPort; _tomcat1 = getTestUtils().tomcatBuilder().port(_portTomcat1).memcachedNodes(memcachedNodes).sticky(true).enabled(false).jvmRoute("app1").build(); _tomcat1.start(); LOG.info( "Waiting, check logs to see if the client causes any 'Connection refused' logging..." ); Thread.sleep( 1000 ); some basic tests for session functionality checkSessionFunctionalityWithMsmDisabled(); start memcached, client and reenable msm _daemon.start(); _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( "localhost", _memcachedPort ) ); getManager( _tomcat1 ).setEnabled( true ); Wait a little bit, so that msm's memcached client can connect and is ready when test starts Thread.sleep( 100 ); memcached based stuff should work again final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), "memcached node id missing with msm switched to enabled" ); Thread.sleep( 50 ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); waitForSessionExpiration( true ); assertNull( _memcached.get( sessionId1 ), "Expired session still existing in memcached" ); 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . sticky ( true ) . build ( ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _httpClient = new DefaultHttpClient ( ) ; } 
private void restartTomcat ( final String memcachedNodes , final String failoverNodes ) throws Exception { _tomcat1 . stop ( ) ; Thread . sleep ( 500 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . failoverNodes ( failoverNodes ) . build ( ) ; _tomcat1 . start ( ) ; } 
private Embedded startTomcat ( final int port , final String memcachedNodes , final LockingMode lockingMode ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . sessionTimeout ( 5 ) . memcachedNodes ( memcachedNodes ) . sticky ( false ) . lockingMode ( lockingMode ) . build ( ) ; tomcat . start ( ) ; return tomcat ; } 
private Embedded startTomcatWithAuth ( final int port , final String memcachedNodes , final LockingMode lockingMode , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded result = getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . sessionTimeout ( 5 ) . loginType ( loginType ) . memcachedNodes ( memcachedNodes ) . sticky ( false ) . lockingMode ( lockingMode ) . build ( ) ; result . start ( ) ; return result ; } 
public TomcatBuilder tomcatBuilder ( ) { return new TomcatBuilder ( ) { @Override 
protected SessionManager createSessionManager ( ) { return TestUtils . this . createSessionManager ( ) ; } 
public TomcatBuilder port ( final int port ) { this . port = port ; return this ; } 
public TomcatBuilder sessionTimeout ( final int sessionTimeout ) { this . sessionTimeout = sessionTimeout ; return this ; } 
public TomcatBuilder cookies ( final boolean cookies ) { this . cookies = cookies ; return this ; } 
public TomcatBuilder memcachedNodes ( final String memcachedNodes ) { this . memcachedNodes = memcachedNodes ; return this ; } 
public TomcatBuilder failoverNodes ( final String failoverNodes ) { this . failoverNodes = failoverNodes ; return this ; } 
public TomcatBuilder enabled ( final boolean enabled ) { this . enabled = enabled ; return this ; } 
public TomcatBuilder sticky ( final boolean sticky ) { this . sticky = sticky ; return this ; } 
public TomcatBuilder lockingMode ( final LockingMode lockingMode ) { this . lockingMode = lockingMode ; return this ; } 
public TomcatBuilder memcachedProtocol ( final String memcachedProtocol ) { this . memcachedProtocol = memcachedProtocol ; return this ; } 
public TomcatBuilder username ( final String memcachedUsername ) { this . username = memcachedUsername ; return this ; } 
public TomcatBuilder jvmRoute ( final String jvmRoute ) { this . jvmRoute = jvmRoute ; return this ; } 
public TomcatBuilder loginType ( final LoginType loginType ) { this . loginType = loginType ; return this ; } 
public TomcatBuilder transcoderFactoryClassName ( final String transcoderFactoryClassName ) { this . transcoderFactoryClassName = transcoderFactoryClassName ; return this ; } 
public Embedded build ( ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.getMemcachedSessionService().setFailoverNodes( failoverNodes ); sessionManager.getMemcachedSessionService().setEnabled(enabled); sessionManager.getMemcachedSessionService().setSticky(sticky); if(lockingMode != null) { sessionManager.getMemcachedSessionService().setLockingMode(lockingMode.name()); } sessionManager.getMemcachedSessionService().setMemcachedProtocol(memcachedProtocol); sessionManager.getMemcachedSessionService().setUsername(username); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
protected abstract SessionManager createSessionManager ( ) ; private static SecurityConstraint createSecurityConstraint ( final String pattern , final String role ) { final SecurityConstraint constraint = new SecurityConstraint ( ) ; final SecurityCollection securityCollection = new SecurityCollection ( ) ; securityCollection . addPattern ( pattern ) ; constraint . addCollection ( securityCollection ) ; if ( role ! = null ) { constraint . addAuthRole ( role ) ; } return constraint ; } } 
abstract TestUtils getTestUtils ( ) ; private Embedded startTomcat ( final int port , final String jvmRoute ) throws MalformedURLException , UnknownHostException , LifecycleException { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . build ( ) ; tomcat . start ( ) ; return tomcat ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final Response tc2Response1 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" ) ); if ( stickyness.isSticky() ) { assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) ); } else { assertEquals( tc2Response1.getSessionId(), sessionId ); } final Response tc2Response2 = get( _httpClient, TC_PORT_2, tc2Response1.getResponseSessionId() ); assertEquals( tc2Response2.get( "foo" ), "bar" ); }} 
private Embedded startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded tomcat = getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . build ( ) ; tomcat . start ( ) ; return tomcat ; } 
public void set ( final Request request ) { _requestsThreadLocal . set ( request ) ; } 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final MemcachedClient memcached , @Nonnull final MemcachedSessionService manager , @Nonnull final MemcachedNodesManager memcachedNodesManager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup , @Nonnull final Statistics stats , @Nonnull final CurrentRequest currentRequest ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; final String sessionCookieName = _manager . getSessionCookieName ( ) ; _currentRequest = new CurrentRequest ( ) ; _trackingHostValve = new RequestTrackingHostValve ( _requestUriIgnorePattern , sessionCookieName , this , _statistics , _enabled , _currentRequest ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . addValve ( _trackingHostValve ) ; _trackingContextValve = new RequestTrackingContextValve ( sessionCookieName , this ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _trackingContextValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , operation timeout " + _operationTimeout + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
private boolean isContainerSessionLookup ( ) { return ! _trackingContextValve . wasInvokedWith ( _currentRequest . get ( ) ) ; } 
public MemcachedBackupSession createSession ( String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " createSession invoked: " + sessionId ) ; } checkMaxActiveSessions ( ) ; final MemcachedBackupSession session = createEmptySession ( ) ; session . setNew ( true ) ; session . setValid ( true ) ; session . setCreationTime ( System . currentTimeMillis ( ) ) ; session . setMaxInactiveInterval ( _manager . getMaxInactiveInterval ( ) ) ; if ( sessionId = = null | | ! _memcachedNodesManager . canHitMemcached ( sessionId ) ) { sessionId = _manager . generateSessionId ( ) ; } session . setId ( sessionId ) ; final Request request = _currentRequest . get ( ) ; if ( request ! = null ) { request . setNote ( NEW_SESSION_ID , sessionId ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Created new session with id " + session . getId ( ) ) ; } _manager . incrementSessionCounter ( ) ; return session ; 
public boolean isIgnoredRequest ( ) { final Request request = _currentRequest . get ( ) ; return request ! = null & & request . getNote ( REQUEST_IGNORED ) = = Boolean . TRUE ; } 
void storeRequestThreadLocal ( @Nonnull final Request request ) { _currentRequest . set ( request ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? _memcachedNodeId + " : " : " " ; _memcachedNodes = nodePrefix + " localhost: " + _memcachedPort ; try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = tcBuilder ( ) . build ( ) ; _tomcat1 . start ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( _memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private TomcatBuilder tcBuilder ( ) { return getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( _memcachedNodes ) . sticky ( true ) . jvmRoute ( " app1 " ) ; } 
public void testSessionAvailableInMemcachedWithCookiesDisabled ( final SessionAffinityMode sessionAffinity ) throws Exception { _tomcat1 . stop ( ) ; _tomcat1 = tcBuilder ( ) . sticky ( sessionAffinity . isSticky ( ) ) . cookies ( false ) . jvmRoute ( " app1 " ) . build ( ) ; _tomcat1 . start ( ) ; final Response response = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response . get ( TestServlet . ID ) ; assertNotNull ( sessionId , " No session created. " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId ) , " Session not available in memcached. " ) ; } 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); }} 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; _service . setMemcachedClient ( _memcachedMock ) ; _service . startInternal ( ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
public BackupResult call ( ) throws Exception { final MemcachedBackupSession session3 = _service . findSession ( session . getId ( ) ) ; assertSame ( session3 , session2 ) ; assertEquals ( session3 . getRefCount ( ) , 2 ) ; let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; final Context _contextContainer = mock ( Context . class ) ; final Host _hostContainer = mock ( Host . class ) ; final SessionManager _manager = mock ( SessionManager . class ) ; when ( _service . getManager ( ) ) . thenReturn ( _manager ) ; when ( _manager . getContainer ( ) ) . thenReturn ( _contextContainer ) ; when ( _contextContainer . getParent ( ) ) . thenReturn ( _hostContainer ) ; when ( _contextContainer . getPath ( ) ) . thenReturn ( " / " ) ; _sessionTrackerValve . setContainer ( _hostContainer ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; } 
protected RequestTrackingHostValve createSessionTrackerValve ( ) { return new RequestTrackingHostValve ( " .* \\ .(png|gif|jpg|css|js|ico)$ " , " somesessionid " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) , new CurrentRequest ( ) ) ; 
public final void testGetSessionCookieName ( ) throws IOException , ServletException { final RequestTrackingHostValve cut = new RequestTrackingHostValve ( null , " foo " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) , new CurrentRequest ( ) ) ; assertEquals ( cut . getSessionCookieName ( ) , " foo " ) ; } 
public String getNextNodeId ( @Nonnull final String nodeId ) throws IllegalArgumentException { final int idx = indexOf ( nodeId ) ; if ( idx < 0 ) { throw new IllegalArgumentException ( " The given node id " + nodeId + " is not part of this list " + toString ( ) ) ; } if ( size ( ) = = 1 ) { return null ; } return ( idx = = size ( ) - 1 ) ? get ( 0 ) : get ( idx + 1 ) ; } 
public Thread newThread ( final Runnable runnable ) { final Thread = new Thread ( group , runnable , namePrefix + threadNumber . getAndIncrement ( ) ) ; if ( . isDaemon ( ) ) . setDaemon ( false ) ; if ( . getPriority ( ) ! = Thread . NORM_PRIORITY ) . setPriority ( Thread . NORM_PRIORITY ) ; return ; } 
public void shutdown ( ) { _log . info ( " Stopping services. " ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . removeValve ( _trackingHostValve ) ; _manager . getContainer ( ) . getPipeline ( ) . removeValve ( _trackingContextValve ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _memcached ! = null ) { _memcached . shutdown ( ) ; _memcached = null ; } _transcoderFactory = null ; } 
public void testContextReload ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = post ( _httpClient , _portTomcat1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; getContext ( _tomcat1 ) . reload ( ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String actualValue = response . get ( " foo " ) ; assertEquals ( " bar " , actualValue ) ; } 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; final Context _contextContainer = mock ( Context . class ) ; final Host _hostContainer = mock ( Host . class ) ; final SessionManager _manager = mock ( SessionManager . class ) ; when ( _service . getManager ( ) ) . thenReturn ( _manager ) ; when ( _manager . getContainer ( ) ) . thenReturn ( _contextContainer ) ; when ( _contextContainer . getParent ( ) ) . thenReturn ( _hostContainer ) ; when ( _contextContainer . getPath ( ) ) . thenReturn ( " / " ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _sessionTrackerValve . setContainer ( _hostContainer ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getContext ( ) ) . thenReturn ( _contextContainer ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; } 
public void customize ( final Kryo kryo ) { tkryo . register ( User . class , new SpringSecurityUserSerializer ( kryo ) ) ; } 
public User read ( final ByteBuffer buffer ) { tfinal String password = StringSerializer . get ( buffer ) ; tfinal String username = StringSerializer . get ( buffer ) ; tfinal int size = IntSerializer . get ( buffer , true ) ; tfinal List < GrantedAuthority > authorities = new ArrayList < GrantedAuthority > ( size ) ; tfor ( int i = 0 ; i < size ; i + + ) { tauthorities . add ( ( GrantedAuthority ) _kryo . readClassAndObject ( buffer ) ) ; } tfinal boolean accountNonExpired = buffer . get ( ) = = 1 ; tfinal boolean accountNonLocked = buffer . get ( ) = = 1 ; tfinal boolean credentialsNonExpired = buffer . get ( ) = = 1 ; tfinal boolean enabled = buffer . get ( ) = = 1 ; treturn new User ( username , password , enabled , accountNonExpired , credentialsNonExpired , accountNonLocked , authorities ) ; } 
public void write ( final ByteBuffer buffer , final User user ) { tStringSerializer . put ( buffer , user . getPassword ( ) ) ; tStringSerializer . put ( buffer , user . getUsername ( ) ) ; tfinal Collection < GrantedAuthority > authorities = user . getAuthorities ( ) ; tIntSerializer . put ( buffer , authorities . size ( ) , true ) ; tfor ( final GrantedAuthority item : authorities ) { t_kryo . writeClassAndObject ( buffer , item ) ; } tput ( buffer , user . isAccountNonExpired ( ) ) ; tput ( buffer , user . isAccountNonLocked ( ) ) ; tput ( buffer , user . isCredentialsNonExpired ( ) ) ; tput ( buffer , user . isEnabled ( ) ) ; } 
private void put ( final ByteBuffer buffer , final boolean value ) { tbuffer . put ( value ? ( byte ) 1 : ( byte ) 0 ) ; } 
public void testSpringSecurityUserSerializer ( ) { tfinal Kryo kryo = new KryoReflectionFactorySupport ( ) ; tkryo . setRegistrationOptional ( true ) ; tnew SpringSecurityUserRegistration ( ) . customize ( kryo ) ; tfinal Collection < ? extends GrantedAuthority > authorities = Arrays . asList ( new SimpleGrantedAuthority ( " foo " ) ) ; tfinal User user = new User ( " foo " , " bar " , authorities ) ; tfinal ObjectBuffer buffer = new ObjectBuffer ( kryo , 100 , 1024 ) ; tfinal byte [ ] data = buffer . writeObject ( user ) ; tfinal User user2 = buffer . readObject ( data , User . class ) ; tTestUtils . assertDeepEquals ( user , user2 ) ; } 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } try { final String password = _password = = null ? " " : _password ; 
protected ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final ConnectionType connectionType , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( _memcachedProtocol ) ) { if ( connectionType . isSASL ( ) ) { final AuthDescriptor authDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( _username , _password = = null ? " " : _password ) ) ; return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout , authDescriptor ) : new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setAuthDescriptor ( authDescriptor ) . setOpTimeout ( _operationTimeout ) . build ( ) ; } else { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) : new BinaryConnectionFactory ( ) ; } } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , _operationTimeout ) 
public void addOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; } 
public void insertOp ( final Operation op ) { throw new UnsupportedOperationException ( ) ; } 
public void connected ( ) { throw new UnsupportedOperationException ( ) ; } 
public void copyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void fillWriteBuffer ( final boolean optimizeGets ) { throw new UnsupportedOperationException ( ) ; } 
public void fixupOps ( ) { throw new UnsupportedOperationException ( ) ; } 
public void reconnecting ( ) { throw new UnsupportedOperationException ( ) ; } 
public void registerChannel ( final SocketChannel ch , final SelectionKey selectionKey ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentReadOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public Operation removeCurrentWriteOp ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setupResend ( ) { throw new UnsupportedOperationException ( ) ; } 
public void transitionWriteItem ( ) { throw new UnsupportedOperationException ( ) ; } 
public int writeSome ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } 
public Collection < Operation > destroyInputQueue ( ) { throw new UnsupportedOperationException ( ) ; } 
public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; } 
public void setupForAuth ( ) { throw new UnsupportedOperationException ( ) ; } 
public boolean isAuthenticated ( ) { throw new UnsupportedOperationException ( ) ; } 
public long lastReadDelta ( ) { throw new UnsupportedOperationException ( ) ; } 
public void completedRead ( ) { throw new UnsupportedOperationException ( ) ; } 
protected CouchbaseClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , String password , final long operationTimeout , final Statistics statistics ) { try { CouchbaseClient does not accept null for password 
protected CouchbaseConnectionFactoryBuilder newCouchbaseConnectionFactoryBuilder ( ) { return new CouchbaseConnectionFactoryBuilder ( ) ; } 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final Statistics statistics ) { try { final ConnectionType connectionType = ConnectionType . valueOf ( memcachedNodesManager . isCouchbaseBucketConfig ( ) , username , password ) ; 
protected MemcachedClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final Statistics statistics ) { return new CouchbaseClientFactory ( ) . createCouchbaseClient ( memcachedNodesManager , memcachedProtocol , username , password , operationTimeout , statistics ) ; } 
protected ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final ConnectionType connectionType , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( memcachedProtocol ) ) { if ( connectionType . isSASL ( ) ) { final AuthDescriptor authDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( username , password ) ) ; return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , operationTimeout , authDescriptor ) : new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setAuthDescriptor ( authDescriptor ) . setOpTimeout ( operationTimeout ) . build ( ) ; } else { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , operationTimeout ) : new BinaryConnectionFactory ( ) ; } } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , operationTimeout ) 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } return new MemcachedClientFactory ( ) . createMemcachedClient ( memcachedNodesManager , _memcachedProtocol , _username , _password , _operationTimeout , statistics ) ; } 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } _missingSessionsCache = new LRUCache < String , Boolean > ( 200 , 500 ) ; final String sessionCookieName = _manager . getSessionCookieName ( ) ; _currentRequest = new CurrentRequest ( ) ; _trackingHostValve = createRequestTrackingHostValve ( sessionCookieName , _currentRequest ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . addValve ( _trackingHostValve ) ; _trackingContextValve = createRequestTrackingContextValve ( sessionCookieName ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _trackingContextValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , operation timeout " + _operationTimeout + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
protected RequestTrackingContextValve createRequestTrackingContextValve ( final String sessionCookieName ) { return new RequestTrackingContextValve ( sessionCookieName , this ) ; } 
protected RequestTrackingHostValve createRequestTrackingHostValve ( final String sessionCookieName , final CurrentRequest currentRequest ) { return new RequestTrackingHostValve ( _requestUriIgnorePattern , sessionCookieName , this , _statistics , _enabled , currentRequest ) ; } 
protected RequestTrackingContextValve createRequestTrackingContextValve ( final String sessionCookieName ) { final RequestTrackingContextValve result = super . createRequestTrackingContextValve ( sessionCookieName ) ; result . setAsyncSupported ( true ) ; return result ; } 
protected RequestTrackingHostValve createRequestTrackingHostValve ( final String sessionCookieName , final CurrentRequest currentRequest ) { final RequestTrackingHostValve result = super . createRequestTrackingHostValve ( sessionCookieName , currentRequest ) ; result . setAsyncSupported ( true ) ; return result ; } 
public void beforeMethod ( ) { cut = new MemcachedBackupSession ( ) ; executor = Executors . newCachedThreadPool ( ) ; alternateExecutor = Executors . newCachedThreadPool ( ) ; } 
public void afterMethod ( ) { executor . shutdown ( ) ; alternateExecutor . shutdown ( ) ; } 
public void testRefCount ( ) throws InterruptedException , ExecutionException { assertEquals ( cut . getRefCount ( ) , 0 ) ; cut . registerReference ( ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; assertEquals ( cut . getRefCount ( ) , 1 ) ; cut . releaseReference ( ) ; assertEquals ( cut . getRefCount ( ) , 0 ) ; other threads must each increment the ref count final Runnable registerReference = new Runnable() { @Override public void run() { cut.registerReference(); } }; executor.submit(registerReference).get(); assertEquals(cut.getRefCount(), 1); alternateExecutor.submit(registerReference).get(); assertEquals(cut.getRefCount(), 2); we (no ref registered) must not be able to decrement the ref count cut.releaseReference(); assertEquals(cut.getRefCount(), 2); } 
public CouchbaseClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , String password , final long operationTimeout , final Statistics statistics ) { try { CouchbaseClient does not accept null for password 
MemcachedClient createCouchbaseClient ( MemcachedNodesManager memcachedNodesManager , String memcachedProtocol , String username , String password , long operationTimeout , Statistics statistics ) ; } protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final Statistics statistics ) { try { final ConnectionType connectionType = ConnectionType . valueOf ( memcachedNodesManager . isCouchbaseBucketConfig ( ) , username , password ) ; if ( connectionType . isCouchbaseBucketConfig ( ) ) { return createCouchbaseClient ( memcachedNodesManager , memcachedProtocol , username , password , operationTimeout , statistics ) ; } final ConnectionFactory connectionFactory = createConnectionFactory ( memcachedNodesManager , connectionType , memcachedProtocol , username , password , operationTimeout , statistics ) ; return new MemcachedClient ( connectionFactory , memcachedNodesManager . getAllMemcachedAddresses ( ) ) ; } catch ( final Exception e ) { throw new RuntimeException ( " Could not create memcached client " , e ) ; } } protected MemcachedClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final Statistics statistics ) { try { final CouchbaseClientFactory factory = Class . forName ( " de.javakaffee.web.msm.CouchbaseClientFactory " ) . asSubclass ( CouchbaseClientFactory . class ) . newInstance ( ) ; return factory . createCouchbaseClient ( memcachedNodesManager , memcachedProtocol , username , password , operationTimeout , statistics ) ; } catch ( final Exception e ) { throw new RuntimeException ( e ) ; } } protected ConnectionFactory createConnectionFactory ( final MemcachedNodesManager memcachedNodesManager , final ConnectionType connectionType , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final Statistics statistics ) { if ( PROTOCOL_BINARY . equals ( memcachedProtocol ) ) { if ( connectionType . isSASL ( ) ) { final AuthDescriptor authDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( username , password ) ) ; return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , operationTimeout , authDescriptor ) : new ConnectionFactoryBuilder ( ) . setProtocol ( ConnectionFactoryBuilder . Protocol . BINARY ) . setAuthDescriptor ( authDescriptor ) . setOpTimeout ( operationTimeout ) . build ( ) ; } else { return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorBinaryConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , operationTimeout ) : new BinaryConnectionFactory ( ) ; } } return memcachedNodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( memcachedNodesManager , memcachedNodesManager . getSessionIdFormat ( ) , statistics , operationTimeout ) : new DefaultConnectionFactory ( ) ; } static class ConnectionType { private final boolean couchbaseBucketConfig ; private final String username ; private final String password ; public ConnectionType ( final boolean couchbaseBucketConfig , final String username , final String password ) { this . couchbaseBucketConfig = couchbaseBucketConfig ; this . username = username ; this . password = password ; } public static ConnectionType valueOf ( final boolean couchbaseBucketConfig , final String username , final String password ) { return new ConnectionType ( couchbaseBucketConfig , username , password ) ; } boolean isCouchbaseBucketConfig ( ) { return couchbaseBucketConfig ; } boolean isSASL ( ) { return ! couchbaseBucketConfig & & ! isBlank ( username ) & & ! isBlank ( password ) ; } boolean isDefault ( ) { return ! isCouchbaseBucketConfig ( ) & & ! isSASL ( ) ; } boolean isBlank ( final String value ) { return value = = null | | value . trim ( ) . length ( ) = = 0 ; } } } 
protected MemcachedClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final Statistics statistics ) { try { final CouchbaseClientFactory factory = Class . forName ( " de.javakaffee.web.msm.CouchbaseClientFactory " ) . asSubclass ( CouchbaseClientFactory . class ) . newInstance ( ) ; 
public void recycle ( ) { super . recycle ( ) ; _attributesAccessed = false ; _dataHashCode = 0 ; _expirationUpdateRunning = false ; _backupRunning = false ; _lockStatus = null ; } 
public CouchbaseClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , String password , final long operationTimeout , final long maxReconnectDelay , final Statistics statistics ) { try { CouchbaseClient does not accept null for password 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final long maxReconnectDelay , final Statistics statistics ) { try { final ConnectionType connectionType = ConnectionType . valueOf ( memcachedNodesManager . isCouchbaseBucketConfig ( ) , username , password ) ; 
protected MemcachedClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final long maxReconnectDelay , final Statistics statistics ) { try { final CouchbaseClientFactory factory = Class . forName ( " de.javakaffee.web.msm.CouchbaseClientFactory " ) . asSubclass ( CouchbaseClientFactory . class ) . newInstance ( ) ; 
protected MemcachedClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } final long maxReconnectDelay = getSystemProperty ( MAX_RECONNECT_DELAY_KEY , DefaultConnectionFactory . DEFAULT_MAX_RECONNECT_DELAY ) ; return new MemcachedClientFactory ( ) . createMemcachedClient ( memcachedNodesManager , _memcachedProtocol , _username , _password , _operationTimeout , maxReconnectDelay , statistics ) ; 
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { tfinal MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; final MemcachedClient result = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , _memcachedClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , PlainSocketFactory . getSocketFactory ( ) , 80 ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? NODE_ID + " : " : " " ; _memcachedNodes = nodePrefix + " localhost: " + MEMCACHED_PORT ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( _memcachedNodes , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; _client = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
protected RequestTrackingHostValve createRequestTrackingHostValve ( final String sessionCookieName , final CurrentRequest currentRequest ) { return new RequestTrackingHostValve ( _requestUriIgnorePattern , sessionCookieName , this , _statistics , _enabled , currentRequest ) { @Override 
protected abstract String [ ] getSetCookieHeaders ( final Response response ) ; private void logDebugResponseCookie ( final Response response ) { final String header = response . getHeader ( " Set-Cookie " ) ; if ( header ! = null & & header . contains ( _sessionCookieName ) ) { _log . debug ( " Request finished, with Set-Cookie header: " + header ) ; } } } 
protected RequestTrackingHostValve createSessionTrackerValve ( ) { return new RequestTrackingHostValve ( " .* \\ .(png|gif|jpg|css|js|ico)$ " , " somesessionid " , _service , Statistics . create ( ) , new AtomicBoolean ( true ) , new CurrentRequest ( ) ) { 
protected void setupGetResponseSetCookieHeadersExpectations ( final Response response , final String [ ] result ) { when ( response . getHeaderValues ( eq ( " Set-Cookie " ) ) ) . thenReturn ( result ) ; } 
protected void setupGetResponseSetCookieHeadersExpectations ( final Response response , final String [ ] result ) { when ( response . getHeaders ( eq ( " Set-Cookie " ) ) ) . thenReturn ( Arrays . asList ( result ) ) ; } 
private void storeSessionInMemcached ( final MemcachedBackupSession session , final byte [ ] data ) throws InterruptedException , ExecutionException , TimeoutException { final int expirationTime = session . getMemcachedExpirationTimeToSet ( ) ; final long start = System . currentTimeMillis ( ) ; try { final Future < Boolean > future = _memcached . set ( session . getId ( ) , toMemcachedExpiration ( expirationTime ) , data ) ; 
public void saveValidityBackup ( ) { final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; final int maxInactiveInterval = _session . getMaxInactiveInterval ( ) ; fix for #88, along with the change in session.getMemcachedExpirationTimeToSet final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval; _memcached.set( backupValidityKey, toMemcachedExpiration(expiration), _validityData ); } 
public Void call ( ) throws Exception { pingSession ( _sessionId ) ; if ( _storeSecondaryBackup ) { try { pingSessionBackup ( _sessionId ) ; final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; fix for #88, along with the change in session.getMemcachedExpirationTimeToSet final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval; _memcached.set( backupValidityKey, toMemcachedExpiration(expiration), _validityData ); } catch( final RuntimeException e ) { _log.info( "Could not store secondary backup of session " + _sessionId, e ); } } return null; } 
static int toMemcachedExpiration ( final int expirationInSeconds ) { return expirationInSeconds < = THIRTY_DAYS ? expirationInSeconds : ( int ) ( System . currentTimeMillis ( ) / 1000 ) + expirationInSeconds ; } 
public static void main ( final String [ ] args ) { System . out . println ( System . currentTimeMillis ( ) / 1000 + TimeUnit . DAYS . toSeconds ( 1000 ) ) ; System . out . println ( Integer . MAX_VALUE ) ; } 
public void testToMemcachedExpiration ( ) throws Exception { assertEquals ( toMemcachedExpiration ( 60 * 60 * 24 * 30 ) , 60 * 60 * 24 * 30 ) ; assertEquals ( toMemcachedExpiration ( 60 * 60 * 24 * 30 + 1 ) , System . currentTimeMillis ( ) / 1000 + 60 * 60 * 24 * 30 + 1 ) ; } 
public void testLoadBackupSessionShouldWorkWithHighSessionTimeoutIssue104 ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { getManager ( _tomcat1 ) . setMaxInactiveInterval ( 60 * 60 * 24 * 30 / 2 + 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; we want to get the session from the primary node Response response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); now we shut down the primary node so that the session is loaded from the backup node final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId ); final MemCacheDaemon<?> primary = NODE_ID_1.equals(nodeId) ? _daemon1 : _daemon2; primary.stop(); Thread.sleep( 200 ); the session should be loaded from the backup node response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(fmt.createNewSessionId(response.getSessionId(), nodeId), sessionId); assertEquals(response.get("k1"), "v1"); } 
private Triple < Kryo , SerializerFactory [ ] , UnregisteredClassHandler [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( { " rawtypes " , " unchecked " } ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this , clazz ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } if ( Date . class . isAssignableFrom ( clazz ) ) { return new DateSerializer ( clazz ) ; } return super . newSerializer ( clazz ) ; } @SuppressWarnings ( { " rawtypes " } ) @Override protected void handleUnregisteredClass ( final Class clazz ) { if ( _unregisteredClassHandlers ! = null ) { for ( int i = 0 ; i < _unregisteredClassHandlers . length ; i + + ) { final boolean handled = _unregisteredClassHandlers [ i ] . handleUnregisteredClass ( clazz ) ; if ( handled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " UnregisteredClassHandler " + _unregisteredClassHandlers [ i ] . getClass ( ) . getName ( ) + " handled class " + clazz ) ; } return ; } } } super . handleUnregisteredClass ( clazz ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); kryo.register( Locale.class, new LocaleSerializer() ); final Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Triple.create( kryo, pair.b, pair.c ); } 
private Class < ? extends TranscoderFactory > loadTranscoderFactoryClass ( ) throws ClassNotFoundException { Class < ? extends TranscoderFactory > transcoderFactoryClass ; final ClassLoader classLoader = _manager . getContainerClassLoader ( ) ; try { _log . debug ( " Loading transcoder factory class " + _transcoderFactoryClassName + " using classloader " + classLoader ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , classLoader ) . asSubclass ( TranscoderFactory . class ) ; } catch ( final ClassNotFoundException e ) { _log . info ( " Could not load transcoderfactory class with classloader " + classLoader + " , trying " + getClass ( ) . getClassLoader ( ) ) ; transcoderFactoryClass = Class . forName ( _transcoderFactoryClassName , false , getClass ( ) . getClassLoader ( ) ) . asSubclass ( TranscoderFactory . class ) ; } return transcoderFactoryClass ; } 
public void setUp ( final Method testMethod ) throws Throwable { couchbaseProvided = Boolean . parseBoolean ( System . getProperty ( " couchbase.provided " , " false " ) ) ; final int couchbasePort = Integer . parseInt ( System . getProperty ( " couchbase.port " , " 18091 " ) ) ; if ( ! couchbaseProvided ) { cluster . add ( setupCouchbase ( couchbasePort ) ) ; } try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " http:localhost: " + couchbasePort + " /pools " ) . sticky ( true ) . memcachedProtocol ( " binary " ) . username ( " default " ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } setupCouchbaseClient ( ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _tomcat1 . getManager ( ) ) ) ; } 
public void testBackupSessionInCouchbase ( ) throws InterruptedException , ExecutionException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; } 
public void testBackupSessionInCouchbaseCluster ( ) throws Exception { final MemcachedSessionService service = _tomcat1 . getService ( ) ; cluster . add ( setupCouchbase ( getMaxCouchbasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupCouchbaseClient ( ) ; waitForReconnect ( service . getMemcached ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( ( byte [ ] ) mc . get ( sessionId ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { _portTomcat1 = 18888 ; _memcachedPort = 21211 ; final InetSocketAddress address = new InetSocketAddress ( " localhost " , _memcachedPort ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? _memcachedNodeId + " : " : " " ; _memcachedNodes = nodePrefix + " localhost: " + _memcachedPort ; try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = tcBuilder ( ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _memcached = createMemcachedClient ( _memcachedNodes , address ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private TomcatBuilder < ? > tcBuilder ( ) { return getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( _memcachedNodes ) . sticky ( true ) . jvmRoute ( " app1 " ) ; } 
public void testContextReload ( ) throws IOException , InterruptedException , HttpException { final String sessionId1 = post ( _httpClient , _portTomcat1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; _tomcat1 . getContext ( ) . reload ( ) ; final Response response = get ( _httpClient , _portTomcat1 , sessionId1 ) ; final String actualValue = response . get ( " foo " ) ; assertEquals ( " bar " , actualValue ) ; } 
public void testSessionAvailableInMemcachedWithCookiesDisabled ( final SessionAffinityMode sessionAffinity ) throws Exception { _tomcat1 . stop ( ) ; _tomcat1 = tcBuilder ( ) . sticky ( sessionAffinity . isSticky ( ) ) . cookies ( false ) . jvmRoute ( " app1 " ) . buildAndStart ( ) ; final Response response = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response . get ( TestServlet . ID ) ; assertNotNull ( sessionId , " No session created. " ) ; Thread . sleep ( 50 ) ; assertNotNull ( _memcached . get ( sessionId ) , " Session not available in memcached. " ) ; } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = _tomcat1 . getManager ( ) ; setStickyness ( stickyness ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); +1000 just to be sure that we're >4 secs assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = _tomcat1 . getManager ( ) ; setStickyness ( stickyness ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContainer().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertWaitingWithProxy(Predicates.<MemcachedClientIF> notNull(), 200l, _memcached).get( sessionId1 ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setSticky ( true ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) Thread.sleep( 4000 ); final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
public void testDisableMsmAtRuntime ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException , LifecycleException , HttpException { final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setSticky ( true ) ; disable msm, shutdown our server and our client manager.setEnabled( false ); _memcached.shutdown(); _daemon.stop(); checkSessionFunctionalityWithMsmDisabled(); } 
public void testStartMsmDisabled ( ) throws Exception { shutdown our server and our client _memcached.shutdown(); _daemon.stop(); start a new tomcat with msm initially disabled _tomcat1.stop(); Thread.sleep( 500 ); final String memcachedNodes = _memcachedNodeId + ":localhost:" + _memcachedPort; _tomcat1 = getTestUtils().tomcatBuilder().port(_portTomcat1).memcachedNodes(memcachedNodes).sticky(true).enabled(false).jvmRoute("app1").buildAndStart(); LOG.info( "Waiting, check logs to see if the client causes any 'Connection refused' logging..." ); Thread.sleep( 1000 ); some basic tests for session functionality checkSessionFunctionalityWithMsmDisabled(); start memcached, client and reenable msm _daemon.start(); _memcached = createMemcachedClient( memcachedNodes, new InetSocketAddress( "localhost", _memcachedPort ) ); _tomcat1.getManager().setEnabled( true ); Wait a little bit, so that msm's memcached client can connect and is ready when test starts Thread.sleep( 100 ); memcached based stuff should work again final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( new SessionIdFormat().extractMemcachedId( sessionId1 ), "memcached node id missing with msm switched to enabled" ); Thread.sleep( 50 ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); waitForSessionExpiration( true ); assertNull( _memcached.get( sessionId1 ), "Expired session still existing in memcached" ); 
abstract TestUtils < ? > getTestUtils ( ) ; private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( _tomcat1 . getManager ( ) . getMemcachedSessionService ( ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id, even with msm disabled. " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed. " ) ; } private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = _tomcat1 . getManager ( ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; } } 
private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( _tomcat1 . getManager ( ) . getMemcachedSessionService ( ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id, even with msm disabled. " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed. " ) ; } 
private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = _tomcat1 . getManager ( ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContainer ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; } 
public void negativeInactivityAlwaysValid ( ) { final SessionValidityInfo info = new SessionValidityInfo ( - 1 , 0 , 0 ) ; assertTrue ( info . isValid ( ) ) ; } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { _manager = mock ( SessionManager . class ) ; when ( _manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( _manager.newMemcachedBackupSession() ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return newMemcachedBackupSession( _manager ); } }); final MemcachedSessionService service = new DummyMemcachedSessionService<SessionManager>( _manager ); when( _manager.createSession( anyString() ) ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return createSession(service); } }); when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() ); when( _manager.getMemcachedSessionService() ).thenReturn( service ); 
public void testSerializeSessionFieldsWithAuthenticatedPrincipal ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setAuthType ( HttpServletRequest . FORM_AUTH ) ; session . setPrincipal ( createPrincipal ( ) ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = TranscoderService . serializeSessionFields ( session ) ; final MemcachedBackupSession deserialized = TranscoderService . deserializeSessionFields ( data , _manager ) . getSession ( ) ; assertSessionFields ( session , deserialized ) ; } 
public void setUp ( ) throws Throwable { _portTomcat1 = 18888 ; _address1 = new InetSocketAddress ( " localhost " , 21211 ) ; _daemon1 = createDaemon ( _address1 ) ; _daemon1 . start ( ) ; _address2 = new InetSocketAddress ( " localhost " , 21212 ) ; _daemon2 = createDaemon ( _address2 ) ; _daemon2 . start ( ) ; _address3 = new InetSocketAddress ( " localhost " , 21213 ) ; _daemon3 = createDaemon ( _address3 ) ; _daemon3 . start ( ) ; _nodeId1 = " n1 " ; _nodeId2 = " n2 " ; _nodeId3 = " n3 " ; try { final String memcachedNodes = toString ( _nodeId1 , _address1 ) + " " + toString ( _nodeId2 , _address2 ) + " " + toString ( _nodeId3 , _address3 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . sticky ( true ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } _httpClient = new DefaultHttpClient ( ) ; } 
public void testRelocateSession ( final SessionAffinityMode sessionAffinity ) throws Throwable { _tomcat1 . getManager ( ) . setSticky ( sessionAffinity . isSticky ( ) ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String sid1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final FailoverInfo info = getFailoverInfo( firstNode ); info.activeNode.stop(); Thread.sleep( 50 ); final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 ); final String secondNode = extractNodeId( sid2 ); assertNotSame( secondNode, firstNode, "First node again selected" ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + secondNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back assertEquals( makeRequest( _httpClient, _portTomcat1, sid2 ), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = _tomcat1.getManager().findSession( sid2 ); 
public void testMultipleMemcachedNodesFailure ( final SessionAffinityMode sessionAffinity ) throws Throwable { _tomcat1 . getManager ( ) . setSticky ( sessionAffinity . isSticky ( ) ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String paramKey = "foo"; final String paramValue = "bar"; final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId(); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final FailoverInfo info = getFailoverInfo( firstNode ); info.activeNode.stop(); final Map.Entry<String, MemCacheDaemon<?>> otherNodeWithId = info.previousNode(); otherNodeWithId.getValue().stop(); Thread.sleep( 100 ); final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getResponseSessionId(); final String secondNode = extractNodeId( sid2 ); LOG.debug( "Have secondNode " + secondNode ); final String expectedNode = info.otherNodeExcept( otherNodeWithId.getKey() ).getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); final MemCacheDaemon<?> activeNode = getFailoverInfo( secondNode ).activeNode; assertNotNull( activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); some more checks in sticky mode if ( sessionAffinity.isSticky() ) { final Session session = _tomcat1.getManager().findSession( sid2 ); 
public void testSecondaryBackupForNonStickySessionAfterMemcachedFailover ( ) throws Throwable { _tomcat1 . getManager ( ) . setSticky ( false ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String paramKey = "foo"; final String paramValue = "bar"; final String sid1 = post( _httpClient, _portTomcat1, null, paramKey, paramValue ).getResponseSessionId(); assertNotNull( sid1, "No session created." ); final String firstNode = extractNodeId( sid1 ); assertNotNull( firstNode, "No node id encoded in session id." ); final String sid2 = get( _httpClient, _portTomcat1, sid1 ).getSessionId(); final String secondNode = extractNodeId( sid2 ); final String expectedNode = info.nextNode().getKey(); assertEquals( secondNode, expectedNode, "Unexpected nodeId: " + secondNode + "." ); assertEquals( sid2, sid1.substring( 0, sid1.indexOf( "-" ) + 1 ) + expectedNode, "Unexpected sessionId, sid1: " + sid1 + ", sid2: " + sid2 ); we must get the same session back final Response response2 = get( _httpClient, _portTomcat1, sid2 ); assertEquals( response2.getSessionId(), sid2, "We should keep the sessionId." ); assertNotNull( getFailoverInfo( secondNode ).activeNode.getCache().get( key( sid2 ) )[0], "The session should exist in memcached." ); assertEquals( response2.get( paramKey ), paramValue, "The session should still contain the previously stored value." ); 
public void testAllMemcachedNodesFailure ( ) throws Throwable { _tomcat1 . getManager ( ) . setSticky ( true ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final String sid1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sid1, "No session created." ); _daemon1.stop(); _daemon2.stop(); _daemon3.stop(); wait a little bit Thread.sleep( 200 ); final String sid2 = makeRequest( _httpClient, _portTomcat1, sid1 ); assertEquals( sid1, sid2, "SessionId changed." ); assertNotNull( getSessions().get( sid1 ), "Session "+ sid1 +" not existing." ); final Session session = _tomcat1.getManager().findSession( sid2 ); assertFalse( session.getNoteNames().hasNext(), "Some notes are set: " + toArray( session.getNoteNames() ) ); 
public void testCookieNotSetWhenAllMemcachedsDownIssue40 ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setSticky ( true ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); _daemon1.stop(); _daemon2.stop(); _daemon3.stop(); final Response response1 = get( _httpClient, _portTomcat1, null ); final String sessionId = response1.getSessionId(); assertNotNull( sessionId ); assertNotNull( response1.getResponseSessionId() ); final String nodeId = extractNodeId( response1.getResponseSessionId() ); assertNull( nodeId, "NodeId should be null, but is " + nodeId + "." ); final Response response2 = get( _httpClient, _portTomcat1, sessionId ); assertEquals( response2.getSessionId(), sessionId, "SessionId changed" ); assertNull( response2.getResponseSessionId() ); 
public void testCookieNotSetWhenRegularMemcachedDownIssue40 ( final SessionAffinityMode sessionAffinity ) throws Exception { _daemon2 . stop ( ) ; TestUtils . waitForReconnect ( _tomcat1 . getService ( ) . getMemcached ( ) , 1 , 1000l ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertEquals ( nodeId , _nodeId1 ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
public void testReconfigureMemcachedNodesAtRuntimeFeature46 ( final SessionAffinityMode sessionAffinity ) throws Exception { _tomcat1 . getManager ( ) . setSticky ( sessionAffinity . isSticky ( ) ) ; we had a situation where no session was created, so let's take some break so that everything's up again Thread.sleep( 200 ); final Response response2 = get( _httpClient, _portTomcat1, sessionId1 ); assertNotSame( response2.getSessionId(), sessionId1 ); final String sessionId2 = response2.getResponseSessionId(); assertNotNull( sessionId2 ); assertEquals( extractNodeId( sessionId2 ), _nodeId3 ); 
public void testReconfigureFailoverNodesAtRuntimeFeature46 ( ) throws Exception { _tomcat1 . getManager ( ) . setSticky ( true ) ; Thread . sleep ( 200 ) ; we need to use another http client, otherwise there's no response cookie. final Response response2 = get( new DefaultHttpClient(), _portTomcat1, null ); final String sessionId2 = response2.getSessionId(); assertNotNull( sessionId2 ); assertEquals( extractNodeId( sessionId2 ), _nodeId3 ); 
private void restartTomcat ( final String memcachedNodes , final String failoverNodes ) throws Exception { _tomcat1 . stop ( ) ; Thread . sleep ( 500 ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . sessionTimeout ( 10 ) . memcachedNodes ( memcachedNodes ) . failoverNodes ( failoverNodes ) . buildAndStart ( ) ; } 
private Map < String , Session > getSessions ( ) throws NoSuchFieldException , IllegalAccessException { final Field field = ManagerBase . class . getDeclaredField ( " sessions " ) ; field . setAccessible ( true ) ; @SuppressWarnings ( " unchecked " ) final Map < String , Session > sessions = ( Map < String , Session > ) field . get ( _tomcat1 . getManager ( ) ) ; return sessions ; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , _memcachedClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , 80 , PlainSocketFactory . getSocketFactory ( ) ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; } 
private TomcatBuilder < ? > startTomcat ( final int port ) throws Exception { return startTomcat ( port , MEMCACHED_NODES , null ) ; } 
private TomcatBuilder < ? > startTomcat ( final int port , final String memcachedNodes , final LockingMode lockingMode ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . sessionTimeout ( 5 ) . memcachedNodes ( memcachedNodes ) . sticky ( false ) . lockingMode ( lockingMode ) . buildAndStart ( ) ; 
public void testLoadBackupSessionShouldWorkWithInfiniteSessionTimeoutIssue120 ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( - 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; we want to get the session from the primary node Response response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); now we shut down the primary node so that the session is loaded from the backup node final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId ); final MemCacheDaemon<?> primary = NODE_ID_1.equals(nodeId) ? _daemon1 : _daemon2; primary.stop(); Thread.sleep( 200 ); the session should be loaded from the backup node response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(fmt.createNewSessionId(response.getSessionId(), nodeId), sessionId); assertEquals(response.get("k1"), "v1"); } 
public void testLoadBackupSessionShouldWorkWithHighSessionTimeoutIssue104 ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 60 * 60 * 24 * 30 / 2 + 1 ) ; setLockingMode ( lockingMode , uriPattern ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Thread . sleep ( 200 ) ; we want to get the session from the primary node Response response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); now we shut down the primary node so that the session is loaded from the backup node final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId ); final MemCacheDaemon<?> primary = NODE_ID_1.equals(nodeId) ? _daemon1 : _daemon2; primary.stop(); Thread.sleep( 200 ); the session should be loaded from the backup node response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(fmt.createNewSessionId(response.getSessionId(), nodeId), sessionId); assertEquals(response.get("k1"), "v1"); } 
public void testSessionLockingSupportedWithSingleNodeSetup ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMemcachedNodes ( " localhost: " + MEMCACHED_PORT_1 ) ; _tomcat1 . getManager ( ) . setLockingMode ( lockingMode , uriPattern , false ) ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , " k1 " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; just want to see that we can access/load the session Response response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); and we want to be able to update the session post(_httpClient, TC_PORT_1, sessionId, "k2", "v2"); response = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response.getSessionId(), sessionId); assertEquals(response.get("k1"), "v1"); assertEquals(response.get("k2"), "v2"); } 
public void testNoStaleSessionsWithNonStickySessions ( ) throws IOException , InterruptedException , HttpException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; _tomcat2 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; final String key = " foo " ; final String value1 = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value1 ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; final Object session = _client . get ( sessionId1 ) ; assertNotNull ( session , " Session not found in memcached: " + sessionId1 ) ; final Response response = get ( _httpClient , TC_PORT_1 , sessionId1 ) ; assertEquals ( response . getSessionId ( ) , sessionId1 ) ; assertEquals ( response . get ( key ) , value2 ) ; 
public void testNonStickySessionIsValidEvenWhenAccessedReadonly ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; _tomcat1 . getManager ( ) . setLockingMode ( lockingMode , uriPattern , true ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId ) ; 
public void testNonStickySessionIsValidForDifferentSessionTrackingModes ( @Nonnull final SessionTrackingMode sessionTrackingMode ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; _tomcat1 . getManager ( ) . setLockingMode ( LockingMode . ALL , null , true ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; Response response = get ( _httpClient , TC_PORT_1 , PATH_GET_REQUESTED_SESSION_INFO , sessionId , sessionTrackingMode , null , null ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( KEY_REQUESTED_SESSION_ID ) , sessionId ) ; assertEquals ( Boolean . parseBoolean ( response . get ( KEY_IS_REQUESTED_SESSION_ID_VALID ) ) , true ) ; Thread . sleep ( 100 ) ; response = get ( _httpClient , TC_PORT_1 , PATH_GET_REQUESTED_SESSION_INFO , sessionId , sessionTrackingMode , null , null ) ; assertEquals ( response . getSessionId ( ) , sessionId ) ; assertEquals ( response . get ( KEY_REQUESTED_SESSION_ID ) , sessionId ) ; assertEquals ( Boolean . parseBoolean ( response . get ( KEY_IS_REQUESTED_SESSION_ID_VALID ) ) , true ) ; 
public void testNonStickySessionIsStoredInSecondaryMemcachedForBackup ( ) throws IOException , InterruptedException , HttpException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; _tomcat2 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 100 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> primary = nodeId.equals( NODE_ID_1 ) ? _daemon1 : _daemon2; final MemCacheDaemon<?> secondary = nodeId.equals( NODE_ID_1 ) ? _daemon2 : _daemon1; assertNotNull( primary.getCache().get( key( sessionId1 ) )[0] ); assertNotNull( primary.getCache().get( key( createValidityInfoKeyName( sessionId1 ) ) )[0] ); The executor needs some time to finish the backup... Thread.sleep( 500 ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); 
public void testNonStickySessionSecondaryBackupFailover ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getMemcached ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId1 ) ; final MemCacheDaemon < ? > first = memcachedsByNodeId . get ( nodeId ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); Request / Update final String sessionId2 = post( _httpClient, TC_PORT_1, sessionId1, "key", "v2" ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v2"); 
public void testNonStickySessionSecondaryBackupFailoverForSkippedUpdate ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getMemcached ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> first = memcachedsByNodeId.get(nodeId); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Thread.sleep(100); Request / Update final String sessionId2 = get( _httpClient, TC_PORT_1, sessionId1 ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Thread.sleep(100); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v1"); 
public void testNoBackupWhenRunningASingleMemcachedOnly ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; let's take some break so that everything's up again Thread.sleep( 500 ); try { final String sessionId1 = post( _httpClient, TC_PORT_1, null, "foo", "bar" ).getSessionId(); 
public void testSessionNotLoadedForReadonlyRequest ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getMemcached ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; 2 for session and validity, if backup would be stored this would be 4 instead assertWaitingWithProxy(equalTo(2), 1000, _daemon1.getCache()).getSetCmds(); no gets at all assertEquals( _daemon1.getCache().getGetHits(), 0 ); a request without session access should not pull the session from memcached but update the validity info (get + set) get( _httpClient, TC_PORT_1, PATH_NO_SESSION_ACCESS, sessionId1 ); assertWaitingWithProxy(equalTo(3), 1000, _daemon1.getCache()).getSetCmds(); assertEquals( _daemon1.getCache().getGetHits(), 1 ); } 
public void testBasicAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , LockingMode . AUTO ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , LockingMode . AUTO ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( sessionId , tc2Response1 . get ( TestServlet . ID ) ) ; assertEquals ( tc2Response1 . get ( " foo " ) , " bar " ) ; 
public void testIgnoredResourcesWithFormAuthDontCauseSessionStaleness ( ) throws Exception { TODO: see testSessionCreatedForContainerProtectedResourceIsStoredInMemcached _tomcat1.stop(); _tomcat2.stop(); _tomcat1 = startTomcatWithAuth( TC_PORT_1, NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1, LockingMode.AUTO, LoginType.FORM ); _tomcat2 = startTomcatWithAuth( TC_PORT_2, NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1, LockingMode.AUTO, LoginType.FORM ); _tomcat1.setChangeSessionIdOnAuth( false ); _tomcat2.setChangeSessionIdOnAuth( false ); final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId ); assertEquals(tc2Response1.getSessionId(), sessionId); assertNull(tc2Response1.getResponseSessionId()); assertEquals( tc2Response1.get( TestServlet.ID ), sessionId ); assertEquals( tc2Response1.get( "foo" ), "bar" ); assertEquals( tc2Response1.get( "bar" ), "baz" ); 
public void testSessionCreatedForContainerProtectedResourceIsStoredInMemcached ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; LOG . info ( " START foo1234 " ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; LOG . info ( " END foo1234 " ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) , " IllegalState: /j_security_check not found, app is not properly initialized " ) ; failed sometimes, randomly (timing issue?)?! Thread.sleep(200); 2 sets for session and validity assertEquals( _daemon1.getCache().getSetCmds(), 2 ); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, false ); assertNull(response2.getResponseSessionId()); assertTrue(isRedirect(response2.getStatusCode()), "IllegalState: 'POST /j_security_check' did not issue a redirect," + " but status " + response2.getStatusCode() +". Page content: " + response2.getContent()); 2 gets for session and validity assertEquals( _daemon1.getCache().getGetHits(), 2 ); 2 new sets for session and validity assertEquals( _daemon1.getCache().getSetCmds(), 4 ); 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; waitForReconnect ( _tomcat1 . getService ( ) . getMemcached ( ) , 1 , 1000 ) ; waitForReconnect ( _tomcat2 . getService ( ) . getMemcached ( ) , 1 , 1000 ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) , " IllegalState: /j_security_check not found, app is not properly initialized " ) ; Wait some time so that the GET is finished Thread.sleep(200); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, true ); assertNull(response2.getResponseSessionId()); assertEquals(response2.getStatusCode(), 200, response2.getContent()); assertEquals(response2.get( TestServlet.ID ), sessionId); final Response response3 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" )); assertEquals(response3.getSessionId(), sessionId); final Response response4 = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response4.getSessionId(), sessionId); assertEquals(response4.get( TestServlet.ID ), sessionId); assertEquals(response4.get( "foo" ), "bar"); 
public void testInvalidateSessionShouldReleaseLockIssue144 ( ) throws IOException , InterruptedException , HttpException { _tomcat1 . getManager ( ) . setLockingMode ( LockingMode . AUTO . name ( ) ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final Response response = get ( _httpClient , TC_PORT_1 , PATH_INVALIDATE , sessionId1 ) ; assertNull ( response . getResponseSessionId ( ) ) ; assertNull ( _client . get ( sessionId1 ) , " Invalidated session should be removed from memcached " ) ; assertNull ( _client . get ( new SessionIdFormat ( ) . createLockName ( sessionId1 ) ) , " Lock should be released. " ) ; } 
private TomcatBuilder < ? > startTomcatWithAuth ( final int port , @Nonnull final LockingMode lockingMode ) throws Exception { return startTomcatWithAuth ( port , MEMCACHED_NODES , lockingMode , LoginType . BASIC ) ; } 
private TomcatBuilder < ? > startTomcatWithAuth ( final int port , final String memcachedNodes , final LockingMode lockingMode , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . sessionTimeout ( 5 ) . loginType ( loginType ) . memcachedNodes ( memcachedNodes ) . sticky ( false ) . lockingMode ( lockingMode ) . buildAndStart ( ) ; 
public static void initLogConfig ( @SuppressWarnings ( " rawtypes " ) final Class < ? extends TestUtils > clazz ) { final URL loggingProperties = clazz . getResource ( " /logging.properties " ) ; try { System . setProperty ( " java.util.logging.config.file " , new File ( loggingProperties . toURI ( ) ) . getAbsolutePath ( ) ) ; } catch ( final Exception e ) { we don't have a plain file (e.g. the case for msm-kryo-serializer etc), so we can skip reading the config return; } try { LogManager.getLogManager().readConfiguration(); 
public static String loginWithForm ( final DefaultHttpClient client , final int tcPort ) throws IOException , HttpException { final Response tc1Response1 = get ( client , tcPort , null ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( tc1Response1 . getContent ( ) . contains ( " j_security_check " ) , " /j_security_check not found, app is not properly initialized " ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response tc1Response2 = post ( client , tcPort , " /j_security_check " , sessionId , params ) ; assertEquals ( tc1Response2 . getSessionId ( ) , sessionId ) ; new RuntimeException ( " err " ) . printStackTrace ( ) ; assertEquals ( tc1Response2 . get ( TestServlet . ID ) , sessionId ) ; return tc1Response2 . getSessionId ( ) ; } 
public static Response post ( final DefaultHttpClient client , final int port , final String path , final String rsessionId , final Map < String , String > params , @Nullable final Credentials credentials , final boolean followRedirects ) throws IOException , HttpException { System.out.println( port + " >>>>>>>>>>>>>>>>>> Client Starting >>>>>>>>>>>>>>>>>>>>"); final String baseUri = "http:"+ DEFAULT_HOST +":"+ port; final String url = getUrl( port, path ); final HttpPost method = new HttpPost( url ); if ( rsessionId != null ) { method.setHeader( "Cookie", "JSESSIONID=" + rsessionId ); } method.setEntity( createFormEntity( params ) ); For 303 httpclient automatically redirects, so let's prevent this if requested. if (!followRedirects) { HttpClientParams.setRedirecting(method.getParams(), false); } System.out.println( "cookies: " + method.getParams().getCookiePolicy() ); method.getParams().setCookiePolicy(CookiePolicy.RFC_2109); final HttpResponse response = credentials == null ? client.execute( method ) : executeRequestWithAuth( client, method, credentials ); final int statusCode = response.getStatusLine().getStatusCode(); if ( followRedirects && isRedirect(statusCode) ) { return redirect( response, client, port, rsessionId, baseUri ); } if ( statusCode != 200 && !(!followRedirects && isRedirect(statusCode)) ) { throw new RuntimeException( "POST"+(path != null ? " " + path : "")+" did not return status 200, but " + response.getStatusLine() + "" + toString(response.getEntity().getContent()) ); } return readResponse( rsessionId, response ); } 
public static boolean isRedirect ( final int statusCode ) { return statusCode = = 302 | | statusCode = = 303 ; } 
private static Response redirect ( final HttpResponse response , final DefaultHttpClient client , final int port , final String rsessionId , final String baseUri ) throws IOException , HttpException { final String location = response . getFirstHeader ( " Location " ) . getValue ( ) ; if ( ! location . startsWith ( baseUri ) ) { throw new RuntimeException ( " There's s.th. wrong, the location header should start with the base URI " + baseUri + " . The location header: " + location ) ; } final String redirectPath = location . substring ( baseUri . length ( ) , location . length ( ) ) ; return get ( client , port , redirectPath , rsessionId ) ; } 
public TomcatBuilder < T > port ( final int port ) { this . port = port ; return this ; } 
public TomcatBuilder < T > sessionTimeout ( final int sessionTimeout ) { this . sessionTimeout = sessionTimeout ; return this ; } 
public TomcatBuilder < T > cookies ( final boolean cookies ) { this . cookies = cookies ; return this ; } 
public TomcatBuilder < T > memcachedNodes ( final String memcachedNodes ) { this . memcachedNodes = memcachedNodes ; return this ; } 
public TomcatBuilder < T > failoverNodes ( final String failoverNodes ) { this . failoverNodes = failoverNodes ; return this ; } 
public TomcatBuilder < T > enabled ( final boolean enabled ) { this . enabled = enabled ; return this ; } 
public TomcatBuilder < T > sticky ( final boolean sticky ) { this . sticky = sticky ; return this ; } 
public TomcatBuilder < T > lockingMode ( final LockingMode lockingMode ) { this . lockingMode = lockingMode ; return this ; } 
public TomcatBuilder < T > memcachedProtocol ( final String memcachedProtocol ) { this . memcachedProtocol = memcachedProtocol ; return this ; } 
public TomcatBuilder < T > username ( final String memcachedUsername ) { this . username = memcachedUsername ; return this ; } 
public TomcatBuilder < T > jvmRoute ( final String jvmRoute ) { this . jvmRoute = jvmRoute ; return this ; } 
public TomcatBuilder < T > loginType ( final LoginType loginType ) { this . loginType = loginType ; return this ; } 
public TomcatBuilder < T > transcoderFactoryClassName ( final String transcoderFactoryClassName ) { this . transcoderFactoryClassName = transcoderFactoryClassName ; return this ; } 
public abstract TomcatBuilder < T > buildAndStart ( ) throws Exception ; public abstract void stop ( ) throws Exception ; public abstract Context getContext ( ) ; public abstract SessionManager getManager ( ) ; public abstract MemcachedSessionService getService ( ) ; public abstract Engine getEngine ( ) ; public abstract void setChangeSessionIdOnAuth ( final boolean changeSessionIdOnAuth ) ; protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } @Nonnull protected abstract SessionManager createSessionManager ( ) ; } 
public abstract void stop ( ) throws Exception ; public abstract Context getContext ( ) ; public abstract SessionManager getManager ( ) ; public abstract MemcachedSessionService getService ( ) ; public abstract Engine getEngine ( ) ; public abstract void setChangeSessionIdOnAuth ( final boolean changeSessionIdOnAuth ) ; protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } @Nonnull protected abstract SessionManager createSessionManager ( ) ; } 
public abstract Context getContext ( ) ; public abstract SessionManager getManager ( ) ; public abstract MemcachedSessionService getService ( ) ; public abstract Engine getEngine ( ) ; public abstract void setChangeSessionIdOnAuth ( final boolean changeSessionIdOnAuth ) ; protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } @Nonnull protected abstract SessionManager createSessionManager ( ) ; } 
public abstract SessionManager getManager ( ) ; public abstract MemcachedSessionService getService ( ) ; public abstract Engine getEngine ( ) ; public abstract void setChangeSessionIdOnAuth ( final boolean changeSessionIdOnAuth ) ; protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } @Nonnull protected abstract SessionManager createSessionManager ( ) ; } 
public abstract MemcachedSessionService getService ( ) ; public abstract Engine getEngine ( ) ; public abstract void setChangeSessionIdOnAuth ( final boolean changeSessionIdOnAuth ) ; protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } @Nonnull protected abstract SessionManager createSessionManager ( ) ; } 
public abstract Engine getEngine ( ) ; public abstract void setChangeSessionIdOnAuth ( final boolean changeSessionIdOnAuth ) ; protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } @Nonnull protected abstract SessionManager createSessionManager ( ) ; } 
public abstract void setChangeSessionIdOnAuth ( final boolean changeSessionIdOnAuth ) ; protected UserDatabase createUserDatabase ( ) { final MemoryUserDatabase userDatabase = new MemoryUserDatabase ( ) ; final Role role = userDatabase . createRole ( ROLE_NAME , " the role for unit tests " ) ; final User user = userDatabase . createUser ( USER_NAME , PASSWORD , " the user for unit tests " ) ; user . addRole ( role ) ; return userDatabase ; } @Nonnull protected abstract SessionManager createSessionManager ( ) ; } 
abstract TestUtils < ? > getTestUtils ( ) ; private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private TomcatBuilder < ? > startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . buildAndStart ( ) ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final Response tc2Response1 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" ) ); if ( stickyness.isSticky() ) { assertEquals( tc2Response1.getResponseSessionId(), new SessionIdFormat().changeJvmRoute( sessionId, JVM_ROUTE_2 ) ); } else { assertEquals( tc2Response1.getSessionId(), sessionId ); } final Response tc2Response2 = get( _httpClient, TC_PORT_2, tc2Response1.getResponseSessionId() ); assertEquals( tc2Response2.get( "foo" ), "bar" ); }} 
private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } 
private TomcatBuilder < ? > startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . buildAndStart ( ) ; 
public void testHttpSessionActivationListenersNotifiedOnLoadWithJvmRoute ( ) throws Exception { final SessionManager manager1 = _tomcat1 . getManager ( ) ; final SessionManager manager2 = _tomcat2 . getManager ( ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( format . stripJvmRoute ( sessionId2 ) , format . stripJvmRoute ( sessionId1 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public void testHttpSessionActivationListenersNotifiedOnLoadWithoutJvmRoute ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , null ) ; _tomcat2 = startTomcat ( TC_PORT_2 , null ) ; final SessionManager manager1 = _tomcat1 . getManager ( ) ; final SessionManager manager2 = _tomcat2 . getManager ( ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String sessionId1 = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNull ( format . extractJvmRoute ( sessionId1 ) ) ; final MemcachedBackupSession session = ( MemcachedBackupSession ) manager1 . findSession ( sessionId1 ) ; session . setAttribute ( " listener " , new RecordingSessionActivationListener ( ) ) ; get ( _httpClient , TC_PORT_1 , sessionId1 ) ; final String sessionId2 = get ( _httpClient , TC_PORT_2 , sessionId1 ) . getSessionId ( ) ; assertEquals ( sessionId2 , sessionId1 ) ; final MemcachedBackupSession loaded = ( MemcachedBackupSession ) manager2 . findSession ( sessionId2 ) ; assertNotNull ( loaded ) ; final RecordingSessionActivationListener listener = ( RecordingSessionActivationListener ) loaded . getAttribute ( " listener " ) ; assertNotNull ( listener ) ; final String notifiedSessionId = listener . getSessionDidActivate ( ) ; assertEquals ( notifiedSessionId , sessionId2 ) ; } 
public void testSerializationOfAuthStuffWithFormAuth ( final SessionAffinityMode stickyness ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_1 : null , LoginType . FORM ) ; _tomcat2 = startTomcat ( TC_PORT_2 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_2 : null , LoginType . FORM ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; 
public void testSerializationOfAuthStuffWithBasicAuth ( final SessionAffinityMode stickyness ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_1 : null , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_2 : null , LoginType . BASIC ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; 
public void testSessionOnlyLoadedOnceWithAuth ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , SessionAffinityMode . STICKY , JVM_ROUTE_1 , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , SessionAffinityMode . STICKY , JVM_ROUTE_2 , LoginType . BASIC ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; final Response tc2Response1 = get ( _httpClient , TC_PORT_2 , sessionId ) ; assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; assertEquals ( _daemon . getCache ( ) . getGetHits ( ) , 1 ) ; 
public void testSessionModificationOnTomcatFailoverNotLostWithAuth ( final SessionAffinityMode stickyness ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcat ( TC_PORT_1 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_1 : null , LoginType . BASIC ) ; _tomcat2 = startTomcat ( TC_PORT_2 , stickyness , stickyness . isSticky ( ) ? JVM_ROUTE_2 : null , LoginType . BASIC ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; final Response tc1Response1 = get ( _httpClient , TC_PORT_1 , null , new UsernamePasswordCredentials ( TestUtils . USER_NAME , TestUtils . PASSWORD ) ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertEquals ( sessionId , tc1Response1 . get ( TestServlet . ID ) ) ; final Response tc2Response1 = post ( _httpClient , TC_PORT_2 , " / " , sessionId , asMap ( " foo " , " bar " ) ) ; if ( stickyness . isSticky ( ) ) { assertEquals ( tc2Response1 . getResponseSessionId ( ) , new SessionIdFormat ( ) . changeJvmRoute ( sessionId , JVM_ROUTE_2 ) ) ; } else { assertEquals ( tc2Response1 . getSessionId ( ) , sessionId ) ; } final Response tc2Response2 = get ( _httpClient , TC_PORT_2 , tc2Response1 . getResponseSessionId ( ) ) ; assertEquals ( tc2Response2 . get ( " foo " ) , " bar " ) ; 
protected abstract SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } @Entity @AccessType ( " field " ) @SuppressWarnings ( " serial " ) static class Person implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; @OneToMany ( cascade = CascadeType . ALL ) public Set < Animal > animals ; public Person ( ) { } public Person ( final String name , final Set < Animal > animals ) { this . name = name ; this . animals = animals ; } @Override public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } } @Entity @AccessType ( " field " ) @SuppressWarnings ( " serial " ) static class Animal implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; public Animal ( ) { } public Animal ( final String name ) { this . name = name ; } @Override public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } } static interface Callback < T > { T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } 
protected MemcachedSessionService newMemcachedSessionService ( final SessionManager manager ) { return new MemcachedSessionService ( manager ) ; } 
public boolean contextHasFormBasedSecurityConstraint ( ) { if ( _contextHasFormBasedSecurityConstraint ! = null ) { return _contextHasFormBasedSecurityConstraint . booleanValue ( ) ; } final Context context = ( Context ) getContainer ( ) ; final SecurityConstraint [ ] constraints = context . findConstraints ( ) ; final LoginConfig loginConfig = context . getLoginConfig ( ) ; _contextHasFormBasedSecurityConstraint = constraints ! = null & & constraints . length > 0 & & loginConfig ! = null & & Constants . FORM_METHOD . equals ( loginConfig . getAuthMethod ( ) ) ; return _contextHasFormBasedSecurityConstraint ; } 
public Tomcat6Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; } 
public Embedded build ( ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.getMemcachedSessionService().setFailoverNodes( failoverNodes ); sessionManager.getMemcachedSessionService().setEnabled(enabled); sessionManager.getMemcachedSessionService().setSticky(sticky); if(lockingMode != null) { sessionManager.getMemcachedSessionService().setLockingMode(lockingMode.name()); } sessionManager.getMemcachedSessionService().setMemcachedProtocol(memcachedProtocol); sessionManager.getMemcachedSessionService().setUsername(username); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public boolean contextHasFormBasedSecurityConstraint ( ) { if ( _contextHasFormBasedSecurityConstraint ! = null ) { return _contextHasFormBasedSecurityConstraint . booleanValue ( ) ; } final Context context = ( Context ) getContainer ( ) ; final SecurityConstraint [ ] constraints = context . findConstraints ( ) ; final LoginConfig loginConfig = context . getLoginConfig ( ) ; _contextHasFormBasedSecurityConstraint = constraints ! = null & & constraints . length > 0 & & loginConfig ! = null & & HttpServletRequest . FORM_AUTH . equals ( loginConfig . getAuthMethod ( ) ) ; return _contextHasFormBasedSecurityConstraint ; } 
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( " foo " , " bar " , null ) ; } 
public Tomcat build ( ) throws MalformedURLException , UnknownHostException , LifecycleException { final Tomcat tomcat = new Tomcat ( ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Connector connector = tomcat.getConnector(); connector.setPort(port); connector.setProperty("bindOnInit", "false"); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.getMemcachedSessionService().setFailoverNodes( failoverNodes ); sessionManager.getMemcachedSessionService().setEnabled(enabled); sessionManager.getMemcachedSessionService().setSticky(sticky); if(lockingMode != null) { sessionManager.getMemcachedSessionService().setLockingMode(lockingMode.name()); } sessionManager.getMemcachedSessionService().setMemcachedProtocol(memcachedProtocol); sessionManager.getMemcachedSessionService().setUsername(username); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); return tomcat; } 
public Tomcat7Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; } 
public boolean contextHasFormBasedSecurityConstraint ( ) { if ( _contextHasFormBasedSecurityConstraint ! = null ) { return _contextHasFormBasedSecurityConstraint . booleanValue ( ) ; } final SecurityConstraint [ ] constraints = getContext ( ) . findConstraints ( ) ; final LoginConfig loginConfig = getContext ( ) . getLoginConfig ( ) ; _contextHasFormBasedSecurityConstraint = constraints ! = null & & constraints . length > 0 & & loginConfig ! = null & & HttpServletRequest . FORM_AUTH . equals ( loginConfig . getAuthMethod ( ) ) ; return _contextHasFormBasedSecurityConstraint ; } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , tIOException { tsuper . setup ( ) ; final Context context = ( Context ) _manager . getContainer ( ) ; twhen ( _manager . getContext ( ) ) . thenReturn ( context ) ; } 
protected GenericPrincipal createPrincipal ( ) { return new GenericPrincipal ( " foo " , " bar " , new ArrayList < String > ( ) ) ; } 
public Tomcat8Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; } 
public String changeSessionIdForTomcatFailover ( @Nonnull final String sessionId , final String jvmRoute ) { final String newSessionId = jvmRoute ! = null & & ! jvmRoute . trim ( ) . isEmpty ( ) ? _sessionIdFormat . changeJvmRoute ( sessionId , jvmRoute ) : _sessionIdFormat . stripJvmRoute ( sessionId ) ; if ( isEncodeNodeIdInSessionId ( ) ) { final String nodeId = _sessionIdFormat . extractMemcachedId ( newSessionId ) ; if ( _failoverNodeIds ! = null & & _failoverNodeIds . contains ( nodeId ) ) { final String newNodeId = _nodeIdService . getAvailableNodeId ( nodeId ) ; if ( newNodeId ! = null ) { return _sessionIdFormat . createNewSessionId ( newSessionId , newNodeId ) ; } } } return newSessionId ; } 
public void testChangeSessionIdForTomcatFailover ( ) { assertEquals ( createFor ( " localhost:11211 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , null , null ) , null ) , sessionId ( " 123 " , null , null ) ) ; assertEquals ( createFor ( " localhost:11211 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , null , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , null , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , null ) , sessionId ( " 123 " , " n1 " , null ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n2 " , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , null ) , sessionId ( " 123 " , " n1 " , null ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n2 " , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n2 " , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n1 " , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , null ) , sessionId ( " 123 " , " n2 " , null ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n1 " , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , " tc2 " ) , sessionId ( " 123 " , " n2 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n1 " , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , " n2 " , " tc2 " ) ) ; 
private static String sessionId ( final String plainId , final String memcachedId , final String jvmRoute ) { final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final String withMemcachedId = sessionIdFormat . createSessionId ( plainId , memcachedId ) ; return jvmRoute ! = null ? sessionIdFormat . changeJvmRoute ( withMemcachedId , jvmRoute ) : withMemcachedId ; } 
abstract TestUtils < ? > getTestUtils ( ) ; private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private TomcatBuilder < ? > startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . buildAndStart ( ) ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final String actualValue = response.get( key ); assertEquals( value, actualValue ); Thread.sleep( 10 ); } private MemCacheDaemon<?> startMemcached(final int memcachedPort) throws IOException { final InetSocketAddress address = new InetSocketAddress( "localhost", memcachedPort ); final MemCacheDaemon<?> daemon2 = createDaemon( address ); daemon2.start(); return daemon2; }} 
public void testTomcatFailoverMovesSessionToNonFailoverNode ( ) throws Exception { final MemCacheDaemon < ? > daemon2 = startMemcached ( MEMCACHED_PORT + 1 ) ; final String memcachedNodes = _memcachedNodes + " , " + " n2:localhost: " + ( MEMCACHED_PORT + 1 ) ; _tomcat1 . getService ( ) . setMemcachedNodes ( memcachedNodes ) ; _tomcat1 . getService ( ) . setFailoverNodes ( " n1 " ) ; _tomcat2 . getService ( ) . setMemcachedNodes ( memcachedNodes ) ; _tomcat2 . getService ( ) . setFailoverNodes ( " n2 " ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value ) . getSessionId ( ) ; assertEquals ( format . extractMemcachedId ( sessionId1 ) , " n2 " ) ; assertEquals ( _daemon . getCache ( ) . getCurrentItems ( ) , 0 ) ; assertEquals ( daemon2 . getCache ( ) . getCurrentItems ( ) , 1 ) ; failover simulation, just request the session from tomcat2 final Response response = get( _httpClient, TC_PORT_2, sessionId1 ); final String sessionId2 = response.getSessionId(); assertEquals( format.extractMemcachedId( sessionId2 ), "n1" ); assertEquals(_daemon.getCache().getCurrentItems(), 1); assertEquals( format.stripJvmRoute( sessionId1 ).replaceAll("n2", "n1"), format.stripJvmRoute( sessionId2 ) ); final String actualValue = response.get( key ); assertEquals( value, actualValue ); Thread.sleep( 10 ); 
private MemCacheDaemon < ? > startMemcached ( final int memcachedPort ) throws IOException { final InetSocketAddress address = new InetSocketAddress ( " localhost " , memcachedPort ) ; final MemCacheDaemon < ? > daemon2 = createDaemon ( address ) ; daemon2 . start ( ) ; return daemon2 ; } 
public Serializer newSerializer ( final Class < ? > type ) { if ( HIBERNATE_ABSTRACT_COLLECTION_CLASS = = null ) { return null ; } else if ( HIBERNATE_ABSTRACT_COLLECTION_CLASS . isAssignableFrom ( type ) ) { return new FieldSerializer ( _kryo , type ) ; } return null ; } 
public void test ( ) { HibernateCollectionsSerializerFactory factory = new HibernateCollectionsSerializerFactory ( new Kryo ( ) ) ; Serializer serializer = factory . newSerializer ( PersistentList . class ) ; assertNotNull ( serializer ) ; } 
Object put ( String key , Object value ) ; Object get ( String key ) ; Set < Entry < String , Object > > entrySet ( ) ; } 
public Object put ( final String key , final Object value ) { return _map . put ( key , value ) ; } 
public void shutdown ( ) { _log . info ( " Stopping services. " ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . removeValve ( _trackingHostValve ) ; _manager . getContainer ( ) . getPipeline ( ) . removeValve ( _trackingContextValve ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _memcached ! = null ) { _memcached . shutdown ( ) ; _memcached = null ; } _transcoderFactory = null ; _invalidSessionsCache . clear ( ) ; } 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } final String sessionCookieName = _manager . getSessionCookieName ( ) ; _currentRequest = new CurrentRequest ( ) ; _trackingHostValve = createRequestTrackingHostValve ( sessionCookieName , _currentRequest ) ; _manager . getContainer ( ) . getParent ( ) . getPipeline ( ) . addValve ( _trackingHostValve ) ; _trackingContextValve = createRequestTrackingContextValve ( sessionCookieName ) ; _manager . getContainer ( ) . getPipeline ( ) . addValve ( _trackingContextValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( getClass ( ) . getSimpleName ( ) + " finished initialization, sticky " + _sticky + " , operation timeout " + _operationTimeout + " , with node ids " + t_memcachedNodesManager . getPrimaryNodeIds ( ) + " and failover node ids " + _memcachedNodesManager . getFailoverNodeIds ( ) ) ; 
protected MemcachedBackupSession loadFromMemcachedWithCheck ( final String sessionId ) { if ( ! canHitMemcached ( sessionId ) | | _invalidSessionsCache . get ( sessionId ) ! = null ) { return null ; } return loadFromMemcached ( sessionId ) ; } 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { if ( ! ( object instanceof byte [ ] ) ) { throw new RuntimeException ( " The loaded object for sessionId " + sessionId + " is not of required type byte[], but " + object . getClass ( ) . getName ( ) ) ; } final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; } } return null ; } 
public void testClear ( ) { final LRUCache < String , Integer > cut = new LRUCache < String , Integer > ( 3 ) ; cut . put ( " foo " , 1 ) ; cut . clear ( ) ; assertNull ( cut . get ( " foo " ) ) ; } 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137 ( ) throws Exception { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . startInternal ( _memcachedMock ) ; we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); } 
private boolean pingSession ( @Nonnull final String sessionId ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( sessionId , 1 , 1 ) ; try { if ( touchResult . get ( ) ) { 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( session . getIdInternal ( ) , 5 , 1 ) ; try { if ( touchResult . get ( ) ) { 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( sessionId ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { if ( ! ( object instanceof byte [ ] ) ) { throw new RuntimeException ( " The loaded object for sessionId " + sessionId + " is not of required type byte[], but " + object . getClass ( ) . getName ( ) ) ; } final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { releaseIfLocked ( sessionId , lockStatus ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final TranscoderDeserializationException e ) { _log . warn ( " Could not deserialize session with id " + sessionId + " from memcached, session will be purged from storage. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; _memcached . delete ( sessionId ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; } finally { } return null ; } 
protected void releaseIfLocked ( final String sessionId , LockStatus lockStatus ) { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; 
protected abstract GenericPrincipal createPrincipal ( ) ; @Test public void testSerializeSessionWithoutAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; } @Test public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; } private void assertSessionFields ( final MemcachedBackupSession session , final MemcachedBackupSession deserialized ) { Assert . assertEquals ( session . getCreationTimeInternal ( ) , deserialized . getCreationTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastAccessedTimeInternal ( ) , deserialized . getLastAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getMaxInactiveInterval ( ) , deserialized . getMaxInactiveInterval ( ) ) ; Assert . assertEquals ( session . isNewInternal ( ) , deserialized . isNewInternal ( ) ) ; Assert . assertEquals ( session . isValidInternal ( ) , deserialized . isValidInternal ( ) ) ; Assert . assertEquals ( session . getThisAccessedTimeInternal ( ) , deserialized . getThisAccessedTimeInternal ( ) ) ; Assert . assertEquals ( session . getLastBackupTime ( ) , deserialized . getLastBackupTime ( ) ) ; Assert . assertEquals ( session . getIdInternal ( ) , deserialized . getIdInternal ( ) ) ; Assert . assertEquals ( session . getAuthType ( ) , deserialized . getAuthType ( ) ) ; assertDeepEquals ( session . getPrincipal ( ) , deserialized . getPrincipal ( ) ) ; } } 
public void testSerializeSessionWithAttributes ( ) { final MemcachedBackupSession session = ( MemcachedBackupSession ) _manager . createSession ( null ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _manager ) ) ; final String value = " bar " ; session . setAttribute ( " foo " , value ) ; session . setLastBackupTime ( System . currentTimeMillis ( ) ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , _manager ) ; assertSessionFields ( session , deserialized ) ; Assert . assertEquals ( value , deserialized . getAttribute ( " foo " ) ) ; 
public Map < String , Object > deserializeAttributes ( final byte [ ] data ) { try { return new ObjectBuffer ( _kryo ) . readObject ( data , ConcurrentHashMap . class ) ; 
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager . getContainer ( ) . getLoader ( ) . getClassLoader ( ) ) ; } 
protected SessionAttributesTranscoder createTranscoder ( final ClassLoader loader ) { return getTranscoder ( loader ) ; } 
private static byte [ ] makeClass ( final String name , final String . . . fields ) { final ClassPool pool = ClassPool . getDefault ( ) ; final CtClass newClass = pool . makeClass ( name ) ; try { for ( final String field : fields ) { 
protected Class < ? > findClass ( final String name ) throws ClassNotFoundException { if ( _className . equals ( name ) ) { return defineClass ( name , _classBytes , 0 , _classBytes . length ) ; } return super . findClass ( name ) ; } 
public static ClassLoader makeClassLoaderForCustomClass ( final ClassLoader parent , final String className , final String . . . fields ) { return new ByteClassLoader ( parent , className , makeClass ( className , fields ) ) ; } 
public void testDeserializationError ( ) { Create a class with one simple field: final ClassLoader loaderForCustomClassInVersion1 = ClassGenerationUtil.makeClassLoaderForCustomClass( this.getClass().getClassLoader(), TEST_TYPE_CLASS_NAME, "field1" ); final Object value = makeValueInstance( loaderForCustomClassInVersion1 ); final SessionAttributesTranscoder transcoder = new KryoTranscoderFactory().createTranscoder( loaderForCustomClassInVersion1 ); serialize one instance final MemcachedBackupSession memcachedBackupSession = new MemcachedBackupSession(); final Map<String, Object> attributes = new HashMap<String, Object>(); attributes.put( "test", value ); byte[] data = transcoder.serializeAttributes( memcachedBackupSession, attributes ); final Map<String, Object> deserializeAttributes = transcoder.deserializeAttributes( data ); final Object actual = deserializeAttributes.get( "test" ); assertNotNull(actual); assertDeepEquals(actual, value); create same class with second field final ClassLoader loaderForCustomClassInVersion2 = ClassGenerationUtil.makeClassLoaderForCustomClass( this.getClass().getClassLoader(), TEST_TYPE_CLASS_NAME, "field1", "field2" ); final SessionAttributesTranscoder secondTranscoder = new KryoTranscoderFactory().createTranscoder( loaderForCustomClassInVersion2 ); this should lead to an exception secondTranscoder.deserializeAttributes( data ); } 
private static Object makeValueInstance ( ClassLoader loaderForCustomClass ) { try { Class < ? > forName = Class . forName ( TEST_TYPE_CLASS_NAME , true , loaderForCustomClass ) ; 
public Serializer newDefaultSerializer ( Kryo kryo , Class < ? > type ) { return new CompatibleFieldSerializer ( kryo , type ) ; } 
protected KryoDefaultSerializerFactory loadDefaultSerializerFactory ( final ClassLoader classLoader , final String defaultSerializerFactoryClass ) { try { final ClassLoader loader = classLoader ! = null ? classLoader : Thread . currentThread ( ) . getContextClassLoader ( ) ; 
private Triple < Kryo , SerializerFactory [ ] , UnregisteredClassHandler [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( { " rawtypes " , " unchecked " } ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this , clazz ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } if ( Date . class . isAssignableFrom ( clazz ) ) { return new DateSerializer ( clazz ) ; } return super . newSerializer ( clazz ) ; } @SuppressWarnings ( { " rawtypes " } ) @Override protected void handleUnregisteredClass ( final Class clazz ) { if ( _unregisteredClassHandlers ! = null ) { for ( int i = 0 ; i < _unregisteredClassHandlers . length ; i + + ) { final boolean handled = _unregisteredClassHandlers [ i ] . handleUnregisteredClass ( clazz ) ; if ( handled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " UnregisteredClassHandler " + _unregisteredClassHandlers [ i ] . getClass ( ) . getName ( ) + " handled class " + clazz ) ; } return ; } } } super . handleUnregisteredClass ( clazz ) ; } @Override protected Serializer newDefaultSerializer ( @SuppressWarnings ( " rawtypes " ) Class type ) { return _defaultSerializerFactory . newDefaultSerializer ( this , type ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); kryo.register( Locale.class, new LocaleSerializer() ); final Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Triple.create( kryo, pair.b, pair.c ); } 
protected Serializer newDefaultSerializer ( @SuppressWarnings ( " rawtypes " ) Class type ) { return _defaultSerializerFactory . newDefaultSerializer ( this , type ) ; } 
public Serializer newDefaultSerializer ( final Kryo kryo , final Class < ? > type ) { final ReferenceFieldSerializer result = new ReferenceFieldSerializer ( kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; } 
private Triple < Kryo , SerializerFactory [ ] , UnregisteredClassHandler [ ] > createKryo ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final Kryo kryo = new KryoReflectionFactorySupport ( ) { @Override @SuppressWarnings ( { " rawtypes " , " unchecked " } ) public Serializer newSerializer ( final Class clazz ) { final Serializer customSerializer = loadCustomSerializer ( clazz ) ; if ( customSerializer ! = null ) { return customSerializer ; } if ( EnumSet . class . isAssignableFrom ( clazz ) ) { return new EnumSetSerializer ( this ) ; } if ( EnumMap . class . isAssignableFrom ( clazz ) ) { return new EnumMapSerializer ( this ) ; } if ( SubListSerializer . canSerialize ( clazz ) ) { return new SubListSerializer ( this , clazz ) ; } if ( copyCollectionsForSerialization ) { final Serializer copyCollectionSerializer = loadCopyCollectionSerializer ( clazz , this ) ; if ( copyCollectionSerializer ! = null ) { return copyCollectionSerializer ; } } if ( Date . class . isAssignableFrom ( clazz ) ) { return new DateSerializer ( clazz ) ; } return super . newSerializer ( clazz ) ; } @SuppressWarnings ( { " rawtypes " } ) @Override protected void handleUnregisteredClass ( final Class clazz ) { if ( _unregisteredClassHandlers ! = null ) { for ( int i = 0 ; i < _unregisteredClassHandlers . length ; i + + ) { final boolean handled = _unregisteredClassHandlers [ i ] . handleUnregisteredClass ( clazz ) ; if ( handled ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " UnregisteredClassHandler " + _unregisteredClassHandlers [ i ] . getClass ( ) . getName ( ) + " handled class " + clazz ) ; } return ; } } } super . handleUnregisteredClass ( clazz ) ; } @Override protected Serializer newDefaultSerializer ( @SuppressWarnings ( " rawtypes " ) final Class type ) { return _defaultSerializerFactory . newDefaultSerializer ( this , type ) ; } } ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationOptional( true ); kryo.register( ArrayList.class ); kryo.register( LinkedList.class ); kryo.register( HashSet.class ); kryo.register( HashMap.class ); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer( kryo ) ); kryo.register( Currency.class, new CurrencySerializer( kryo ) ); kryo.register( StringBuffer.class, new StringBufferSerializer( kryo ) ); kryo.register( StringBuilder.class, new StringBuilderSerializer( kryo ) ); kryo.register( Collections.EMPTY_LIST.getClass(), new CollectionsEmptyListSerializer() ); kryo.register( Collections.EMPTY_MAP.getClass(), new CollectionsEmptyMapSerializer() ); kryo.register( Collections.EMPTY_SET.getClass(), new CollectionsEmptySetSerializer() ); kryo.register( Collections.singletonList( "" ).getClass(), new CollectionsSingletonListSerializer( kryo ) ); kryo.register( Collections.singleton( "" ).getClass(), new CollectionsSingletonSetSerializer( kryo ) ); kryo.register( Collections.singletonMap( "", "" ).getClass(), new CollectionsSingletonMapSerializer( kryo ) ); kryo.register( Class.class, new ClassSerializer( kryo ) ); kryo.register( BigDecimal.class, new BigDecimalSerializer() ); kryo.register( BigInteger.class, new BigIntegerSerializer() ); kryo.register( GregorianCalendar.class, new GregorianCalendarSerializer() ); kryo.register( InvocationHandler.class, new JdkProxySerializer( kryo ) ); UnmodifiableCollectionsSerializer.registerSerializers( kryo ); SynchronizedCollectionsSerializer.registerSerializers( kryo ); kryo.register( Locale.class, new LocaleSerializer() ); final Triple<KryoCustomization[], SerializerFactory[], UnregisteredClassHandler[]> pair = loadCustomConverter( customConverterClassNames, classLoader, kryo ); final KryoCustomization[] customizations = pair.a; if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return Triple.create( kryo, pair.b, pair.c ); } 
protected Serializer newDefaultSerializer ( @SuppressWarnings ( " rawtypes " ) final Class type ) { return _defaultSerializerFactory . newDefaultSerializer ( this , type ) ; } 
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager ) ; } 
private void storeSessionInMemcached ( final MemcachedBackupSession session , final byte [ ] data ) throws InterruptedException , ExecutionException , TimeoutException { final int expirationTime = session . getMemcachedExpirationTimeToSet ( ) ; final long start = System . currentTimeMillis ( ) ; try { final Future < Boolean > future = _memcached . set ( 
protected SessionValidityInfo loadSessionValidityInfo ( @Nonnull final String sessionId ) { return loadSessionValidityInfoForValidityKey ( _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ) ; } 
protected SessionValidityInfo loadSessionValidityInfoForValidityKey ( @Nonnull final String validityInfoKey ) { final byte [ ] validityInfo = ( byte [ ] ) _memcached . get ( _storageKeyFormat . format ( validityInfoKey ) ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; } 
protected SessionValidityInfo loadBackupSessionValidityInfo ( @Nonnull final String sessionId ) { final String key = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; final String backupKey = _sessionIdFormat . createBackupKey ( key ) ; return loadSessionValidityInfoForValidityKey ( backupKey ) ; } 
protected void onAfterDeleteFromMemcached ( @Nonnull final String sessionId ) { final long start = System . currentTimeMillis ( ) ; final String validityInfoKey = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; _memcached . delete ( validityInfoKey ) ; if ( _storeSecondaryBackup ) { _memcached . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; _memcached . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; } _stats . registerSince ( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED , start ) ; } 
private boolean pingSession ( @Nonnull final String sessionId ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( _storageKeyFormat . format ( sessionId ) , 1 , 1 ) ; try { if ( touchResult . get ( ) ) { 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( _storageKeyFormat . format ( session . getIdInternal ( ) ) , 5 , 1 ) ; try { if ( touchResult . get ( ) ) { 
public static MemcachedNodesManager createFor ( final String memcachedNodes , final String failoverNodes , final StorageKeyFormat storageKeyFormat , final MemcachedClientCallback memcachedClientCallback ) { tif ( memcachedNodes = = null | | memcachedNodes . trim ( ) . isEmpty ( ) ) { tthrow new IllegalArgumentException ( " null or empty memcachedNodes not allowed. " ) ; } if ( ! NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) . matches ( ) & & ! COUCHBASE_BUCKET_NODES_PATTERN . matcher ( memcachedNodes ) . matches ( ) ) { throw new IllegalArgumentException ( " Configured memcachedNodes attribute has wrong format, must match " + NODES_REGEX ) ; } final Matcher singleNodeMatcher = SINGLE_NODE_PATTERN . matcher ( memcachedNodes ) ; } 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } final String sessionCookieName = _manager . getSessionCookieName ( ) ; _currentRequest = new CurrentRequest ( ) ; _trackingHostValve = createRequestTrackingHostValve ( sessionCookieName , _currentRequest ) ; final Context context = ( Context ) _manager . getContainer ( ) ; context . getParent ( ) . getPipeline ( ) . addValve ( _trackingHostValve ) ; _trackingContextValve = createRequestTrackingContextValve ( sessionCookieName ) ; context . getPipeline ( ) . addValve ( _trackingContextValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( " -------- n- " + getClass ( ) . getSimpleName ( ) + " finished initialization: " + " n- sticky: " + _sticky + 
public Object get ( final String key ) { treturn _memcached . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; } 
protected MemcachedNodesManager createMemcachedNodesManager ( final String memcachedNodes , final String failoverNodes ) { final Context context = ( Context ) _manager . getContainer ( ) ; final String webappVersion = Reflections . invoke ( context , " getWebappVersion " , null ) ; final StorageKeyFormat storageKeyFormat = StorageKeyFormat . of ( _storageKeyPrefix , context . getParent ( ) . getName ( ) , context . getName ( ) , webappVersion ) ; treturn MemcachedNodesManager . createFor ( memcachedNodes , failoverNodes , storageKeyFormat , _memcachedClientCallback ) ; } 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final Object object = _memcached . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { if ( ! ( object instanceof byte [ ] ) ) { throw new RuntimeException ( " The loaded object for sessionId " + sessionId + " is not of required type byte[], but " + object . getClass ( ) . getName ( ) ) ; } final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( ( byte [ ] ) object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { releaseIfLocked ( sessionId , lockStatus ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final TranscoderDeserializationException e ) { _log . warn ( " Could not deserialize session with id " + sessionId + " from memcached, session will be purged from storage. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; _memcached . delete ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; } finally { } return null ; } 
protected void releaseIfLocked ( final String sessionId , final LockStatus lockStatus ) { if ( lockStatus = = LockStatus . LOCKED ) { _lockingStrategy . releaseLock ( sessionId ) ; 
static < T > T invoke ( final Object obj , final String methodName , final T defaultValue ) { try { final Method method = obj . getClass ( ) . getMethod ( methodName ) ; 
public String createLockName ( @Nonnull final String sessionId ) { if ( sessionId = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null. " ) ; } return " lock: " + _storageKeyFormat . format ( sessionId ) ; } 
public String createValidityInfoKeyName ( @Nonnull final String origKey ) { if ( origKey = = null ) { throw new IllegalArgumentException ( " The sessionId must not be null. " ) ; } return " validity: " + _storageKeyFormat . format ( origKey ) ; } 
public String createBackupKey ( @Nonnull final String origKey ) { if ( origKey = = null ) { throw new IllegalArgumentException ( " The origKey must not be null. " ) ; } return BACKUP_PREFIX + _storageKeyFormat . format ( origKey ) ; } 
public static StorageKeyFormat ofHost ( final String host ) { return of ( HOST , host , null , null ) ; } 
public static StorageKeyFormat of ( final String config , final String host , final String context , final String webappVersion ) { tif ( config = = null | | config . trim ( ) . isEmpty ( ) ) treturn EMPTY ; tfinal String [ ] tokens = config . split ( " , " ) ; tfinal StringBuilder sb = new StringBuilder ( ) ; tfor ( int i = 0 ; i < tokens . length ; i + + ) { tfinal String value = PrefixTokenFactory . parse ( tokens [ i ] , host , context , webappVersion ) ; tif ( value ! = null & & ! value . trim ( ) . isEmpty ( ) ) { if ( sb . length ( ) > 0 ) sb . append ( STORAGE_TOKEN_SEP ) ; sb . append ( value ) ; } } tfinal String prefix = sb . length ( ) = = 0 ? null : sb . append ( STORAGE_KEY_SEP ) . toString ( ) ; return new StorageKeyFormat ( prefix , config ) ; } 
public String format ( final String input ) { tif ( prefix = = null ) { treturn input ; } treturn prefix + input ; } 
tstatic String parse ( final String configToken , final String host , final String context , final String webappVersion ) { tfinal Matcher staticMatcher = STATIC_PATTERN . matcher ( configToken ) ; tif ( staticMatcher . matches ( ) ) treturn staticMatcher . group ( 1 ) ; tif ( HOST . equals ( configToken ) ) treturn host ; tif ( HOST_HASH . equals ( configToken ) ) treturn hashString ( host ) ; tif ( CONTEXT . equals ( configToken ) ) treturn context ; tif ( CONTEXT_HASH . equals ( configToken ) ) treturn hashString ( context ) ; tif ( WEBAPP_VERSION . equals ( configToken ) ) treturn webappVersion ; tthrow new IllegalArgumentException ( " Unsupported config token " + configToken ) ; } 
tstatic String hashString ( final String s , final int maxLength ) { tbyte [ ] hash = null ; ttry { tfinal MessageDigest md = MessageDigest . getInstance ( " SHA-256 " ) ; thash = md . digest ( s . getBytes ( ) ) ; } catch ( final NoSuchAlgorithmException e ) { tthrow new RuntimeException ( e ) ; } tfinal StringBuilder sb = new StringBuilder ( ) ; tfor ( int i = 0 ; i < hash . length ; + + i ) { tfinal String hex = Integer . toHexString ( hash [ i ] ) ; tif ( hex . length ( ) = = 1 ) { tsb . append ( 0 ) ; tsb . append ( hex . charAt ( hex . length ( ) - 1 ) ) ; } else { tsb . append ( hex . substring ( hex . length ( ) - 2 ) ) ; } } tfinal String str = sb . toString ( ) ; treturn str . substring ( 0 , Math . min ( maxLength , str . length ( ) ) ) ; } 
public String toString ( ) { return " StorageKeyFormat [prefix= " + prefix + " , config= " + config + " ] " ; } 
public void testParseWithNullShouldThrowException ( ) { tcreateFor ( null , null , null , _mcc ) ; } 
public void testParseWithEmptyStringShouldThrowException ( ) { tcreateFor ( " " , null , null , _mcc ) ; } 
public void testSingleSimpleNodeAndFailoverNodeShouldThrowException ( ) { tcreateFor ( " localhost:11211 " , " n1 " , null , _mcc ) ; } 
public void testSingleNodeAndFailoverNodeShouldThrowException ( ) { tcreateFor ( " n1:localhost:11211 " , " n1 " , null , _mcc ) ; } 
public void testCouchbaseNodesAndFailoverNodeShouldThrowException ( ) { createFor ( " http:localhost:8091/pools " , " n1 " , null , _mcc ) ; } 
public void testCountNodes ( final String memcachedNodes , final int expectedCount ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , null , null , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getCountNodes ( ) , expectedCount ) ; } 
public void testPrimaryNodes ( final String memcachedNodes , final String failoverNodes , final NodeIdList expectedPrimaryNodeIds ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getPrimaryNodeIds ( ) , expectedPrimaryNodeIds ) ; } 
public void testFailoverNodes ( final String memcachedNodes , final String failoverNodes , final List < String > expectedFailoverNodeIds ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . getFailoverNodeIds ( ) , expectedFailoverNodeIds ) ; } 
public void testIsEncodeNodeIdInSessionId ( final String memcachedNodes , final String failoverNodes , final boolean expectedIsEncodeNodeIdInSessionId ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , null , null , _mcc ) ; tassertNotNull ( result ) ; tassertEquals ( result . isEncodeNodeIdInSessionId ( ) , expectedIsEncodeNodeIdInSessionId ) ; } 
public void testGetNodeIdShouldThrowExceptionForNullArgument ( ) { tfinal MemcachedNodesManager result = createFor ( " n1:localhost:11211 " , null , null , _mcc ) ; tresult . getNodeId ( null ) ; } 
public void testGetNodeId ( final String memcachedNodes , final String failoverNodes , final InetSocketAddress socketAddress , final String expectedNodeId ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; tassertEquals ( result . getNodeId ( socketAddress ) , expectedNodeId ) ; } 
public void testGetNextPrimaryNodeId ( ) { tassertNull ( createFor ( " n1:localhost:11211 " , null , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) ) ; tassertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) . getNextPrimaryNodeId ( " n1 " ) , " n2 " ) ; } 
public void testGetNextAvailableNodeId ( ) { assertNull ( createFor ( " n1:localhost:11211 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) , " n2 " ) ; final MemcachedClientCallback mcc = mock ( MemcachedClientCallback . class ) ; when ( mcc . get ( anyString ( ) ) ) . thenReturn ( null ) ; when ( mcc . get ( endsWith ( " n2 " ) ) ) . thenThrow ( new OperationTimeoutException ( " SimulatedException " ) ) ; assertNull ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212,n3:localhost:11213 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) , " n3 " ) ; } 
public void testGetAllMemcachedAddresses ( final String memcachedNodes , final String failoverNodes , final Collection < InetSocketAddress > expectedSocketAddresses ) { tfinal MemcachedNodesManager result = createFor ( memcachedNodes , failoverNodes , null , _mcc ) ; tassertEquals ( result . getAllMemcachedAddresses ( ) , expectedSocketAddresses ) ; } 
public void testGetSessionIdFormat ( ) { tfinal SessionIdFormat sessionIdFormat = createFor ( " n1:localhost:11211 " , null , null , _mcc ) . getSessionIdFormat ( ) ; tassertNotNull ( sessionIdFormat ) ; } 
public void testSessionIdFormatForSingleNodeSetupShouldSupportLocking ( ) { final SessionIdFormat sessionIdFormat = createFor ( " localhost:11211 " , null , StorageKeyFormat . EMPTY , _mcc ) . getSessionIdFormat ( ) ; assertNotNull ( sessionIdFormat ) ; final String sessionId = " 12345678 " ; assertEquals ( sessionIdFormat . createLockName ( sessionId ) , " lock: " + sessionId ) ; } 
public void testCreateSessionIdShouldOnlyAddNodeIdIfPresent ( ) { tassertEquals ( createFor ( " n1:localhost:11211 " , null , null , _mcc ) . createSessionId ( " foo " ) , " foo-n1 " ) ; tassertEquals ( createFor ( " localhost:11211 " , null , null , _mcc ) . createSessionId ( " foo " ) , " foo " ) ; } 
public void testSetNodeAvailable ( ) { tfinal MemcachedNodesManager cut = createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) ; tassertTrue ( cut . isNodeAvailable ( " n1 " ) ) ; tassertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; tcut . setNodeAvailable ( " n1 " , false ) ; tassertFalse ( cut . isNodeAvailable ( " n1 " ) ) ; tassertTrue ( cut . isNodeAvailable ( " n2 " ) ) ; } 
public void testIsCouchbaseBucketConfig ( ) { assertTrue ( createFor ( " http:10.10.0.1:8091/pools " , null , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; assertTrue ( createFor ( " http:10.10.0.1:8091/pools,http:10.10.0.2:8091/pools " , null , null , _mcc ) . isCouchbaseBucketConfig ( ) ) ; } 
public void testGetCouchbaseBucketURIs ( ) throws URISyntaxException { assertEquals ( createFor ( " http:10.10.0.1:8091/pools " , null , null , _mcc ) . getCouchbaseBucketURIs ( ) , Arrays . asList ( new URI ( " http:10.10.0.1:8091/pools " ) ) ) ; assertEquals ( createFor ( " http:10.10.0.1:8091/pools,http:10.10.0.2:8091/pools " , null , null , _mcc ) . getCouchbaseBucketURIs ( ) , Arrays . asList ( new URI ( " http:10.10.0.1:8091/pools " ) , new URI ( " http:10.10.0.2:8091/pools " ) ) ) ; 
public void testChangeSessionIdForTomcatFailover ( ) { assertEquals ( createFor ( " localhost:11211 " , null , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , null , null ) , null ) , sessionId ( " 123 " , null , null ) ) ; assertEquals ( createFor ( " localhost:11211 " , null , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , null , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , null , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , null ) , sessionId ( " 123 " , " n1 " , null ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n2 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , null ) , sessionId ( " 123 " , " n1 " , null ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n2 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n2 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , " n1 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n1 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , null ) , sessionId ( " 123 " , " n2 " , null ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n1 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , null ) , " tc2 " ) , sessionId ( " 123 " , " n2 " , " tc2 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , " n1 " , null , _mcc ) . changeSessionIdForTomcatFailover ( sessionId ( " 123 " , " n1 " , " tc1 " ) , " tc2 " ) , sessionId ( " 123 " , " n2 " , " tc2 " ) ) ; 
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; final MemcachedClient result = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void testInvalidatedSessionRemovedFromMemcached ( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final Response response = get ( _httpClient , _portTomcat1 , PATH_INVALIDATE , sessionId1 ) ; assertNull ( response . getResponseSessionId ( ) ) ; assertEquals ( _daemon . getCache ( ) . getGetMisses ( ) , 1 ) ; 1 is ok assertNull( _memcached.get( sessionId1 ), "Invalidated session still existing in memcached" ); if(!sessionAffinity.isSticky()) { assertNull( _memcached.get(new SessionIdFormat().createValidityInfoKeyName( sessionId1 )), "ValidityInfo for invalidated session still exists in memcached." ); 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setSticky ( true ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) waitForReconnect(manager.getMemcachedSessionService().getMemcached(), 1, 4000); final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final Map<String, Object> anyMap = any( Map.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<Map> model = ArgumentCaptor.forClass( Map.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final OperationFuture<Boolean> futureMock = mock( OperationFuture.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any() ) ).thenReturn( futureMock ); _service.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any() ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _service.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any() ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any() ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any() ); } 
public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137 ( ) throws Exception { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . startInternal ( _memcachedMock ) ; we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); } 
public void testCreateBackupKey ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createBackupKey ( " foo " ) , " bak:localhost_foo " ) ; } 
public void testIsBackupKey ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertTrue ( cut . isBackupKey ( " bak:localhost_foo " ) ) ; } 
public void testCreateLockName ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createLockName ( " foo " ) , " lock:localhost_foo " ) ; } 
public void testCreateValidityInfoKeyName ( ) { final SessionIdFormat cut = new SessionIdFormat ( StorageKeyFormat . ofHost ( " localhost " ) ) ; assertEquals ( cut . createValidityInfoKeyName ( " foo " ) , " validity:localhost_foo " ) ; } 
public void testBlankValue ( ) { tassertEquals ( StorageKeyFormat . of ( null , null , null , null ) . format ( " foo " ) , " foo " ) ; tassertEquals ( StorageKeyFormat . of ( " " , null , null , null ) . format ( " foo " ) , " foo " ) ; } 
public void testPrefixBuilderFactory ( ) { tfinal String prefix = PrefixTokenFactory . parse ( " static:foo " , null , null , null ) ; tassertEquals ( prefix , " foo " ) ; } 
public void testStaticValue ( ) { tfinal StorageKeyFormat cut = StorageKeyFormat . of ( " static:x " , null , null , null ) ; tassertNotNull ( cut ) ; tassertEquals ( cut . format ( " foo " ) , " x_foo " ) ; } 
public void testHost ( ) { tfinal StorageKeyFormat cut = StorageKeyFormat . of ( " host " , " hst " , null , null ) ; tassertNotNull ( cut ) ; tassertEquals ( cut . format ( " foo " ) , " hst_foo " ) ; } 
public void testHostHash ( ) { tfinal StorageKeyFormat cut = StorageKeyFormat . of ( " host.hash " , " hst " , null , null ) ; tassertNotNull ( cut ) ; tassertEquals ( cut . format ( " foo " ) , hashString ( " hst " ) + " _foo " ) ; } 
public void testContext ( ) { tassertEquals ( StorageKeyFormat . of ( " context " , null , " ctxt " , null ) . format ( " foo " ) , " ctxt_foo " ) ; assertEquals ( StorageKeyFormat . of ( " context " , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " context " , null , " " , null ) . format ( " foo " ) , " foo " ) ; } 
public void testContextHash ( ) { tassertEquals ( StorageKeyFormat . of ( " context.hash " , null , " ctxt " , null ) . format ( " foo " ) , hashString ( " ctxt " ) + " _foo " ) ; } 
public void testWebappVersion ( ) { tassertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , " 001 " ) . format ( " foo " ) , " 001_foo " ) ; assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , null ) . format ( " foo " ) , " foo " ) ; assertEquals ( StorageKeyFormat . of ( " webappVersion " , null , null , " " ) . format ( " foo " ) , " foo " ) ; } 
public void testHostAndContext ( ) { tassertEquals ( StorageKeyFormat . of ( " host,context " , " hst " , " ctxt " , null ) . format ( " foo " ) , " hst:ctxt_foo " ) ; assertEquals ( StorageKeyFormat . of ( " host,context " , " hst " , " " , null ) . format ( " foo " ) , " hst_foo " ) ; } 
public void testHostAndContextHashesWithWebappVersion ( ) { tfinal StorageKeyFormat cut = StorageKeyFormat . of ( " host.hash,context.hash,webappVersion " , " hst " , " ctxt " , " 001 " ) ; tassertNotNull ( cut ) ; tassertEquals ( cut . format ( " foo " ) , hashString ( " hst " ) + " : " + hashString ( " ctxt " ) + " :001_foo " ) ; } 
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , null , _memcachedClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , 80 , PlainSocketFactory . getSocketFactory ( ) ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; } 
private TomcatBuilder < ? > startTomcat ( final int port , final String memcachedNodes , final LockingMode lockingMode ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . sessionTimeout ( 5 ) . memcachedNodes ( memcachedNodes ) . sticky ( false ) . lockingMode ( lockingMode ) . storageKeyPrefix ( null ) . buildAndStart ( ) ; 
public void testNonStickySessionIsStoredInSecondaryMemcachedForBackup ( ) throws IOException , InterruptedException , HttpException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; _tomcat2 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) waitForMemcachedClient( 100 ); final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> primary = nodeId.equals( NODE_ID_1 ) ? _daemon1 : _daemon2; final MemCacheDaemon<?> secondary = nodeId.equals( NODE_ID_1 ) ? _daemon2 : _daemon1; assertNotNull( primary.getCache().get( key( sessionId1 ) )[0], sessionId1 ); assertNotNull( primary.getCache().get( key( fmt.createValidityInfoKeyName( sessionId1 ) ) )[0], fmt.createValidityInfoKeyName( sessionId1 ) ); The executor needs some time to finish the backup... Thread.sleep( 500 ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( sessionId1 ) ) )[0] ); assertNotNull( secondary.getCache().get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) )[0] ); 
public void testNonStickySessionSecondaryBackupFailover ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getMemcached ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId1 ) ; final MemCacheDaemon < ? > first = memcachedsByNodeId . get ( nodeId ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( fmt.createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); Request / Update final String sessionId2 = post( _httpClient, TC_PORT_1, sessionId1, "key", "v2" ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v2"); 
public void testNonStickySessionSecondaryBackupFailoverForSkippedUpdate ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getMemcached ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> first = memcachedsByNodeId.get(nodeId); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( fmt.createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Thread.sleep(100); Request / Update final String sessionId2 = get( _httpClient, TC_PORT_1, sessionId1 ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Thread.sleep(100); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v1"); 
public TomcatBuilder < T > storageKeyPrefix ( final String storageKeyPrefix ) { this . storageKeyPrefix = storageKeyPrefix ; return this ; } 
public void setUp ( final Method testMethod ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? NODE_ID + " : " : " " ; _memcachedNodes = nodePrefix + " localhost: " + MEMCACHED_PORT ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( _memcachedNodes , null , null , _memcachedClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; _client = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
abstract TestUtils < ? > getTestUtils ( ) ; private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private TomcatBuilder < ? > startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . storageKeyPrefix ( null ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . buildAndStart ( ) ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _daemon . stop ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; } final String actualValue = response.get( key ); assertEquals( value, actualValue ); Thread.sleep( 10 ); } private MemCacheDaemon<?> startMemcached(final int memcachedPort) throws IOException { final InetSocketAddress address = new InetSocketAddress( "localhost", memcachedPort ); final MemCacheDaemon<?> daemon2 = createDaemon( address ); daemon2.start(); return daemon2; }} 
private TomcatBuilder < ? > startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . storageKeyPrefix ( null ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . buildAndStart ( ) ; 
public Embedded build ( ) throws MalformedURLException , UnknownHostException , LifecycleException { final Embedded catalina = new Embedded ( ) ; final StandardServer server = new StandardServer ( ) ; server . addService ( catalina ) ; try { final NamingContext globalNamingContext = new NamingContext ( new Hashtable < String , Object > ( ) , " ctxt " ) ; server . setGlobalNamingContext ( globalNamingContext ) ; globalNamingContext . bind ( USER_DATABASE , createUserDatabase ( ) ) ; } catch ( final NamingException e ) { throw new RuntimeException ( e ) ; } final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Engine engine = catalina.createEngine(); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.getMemcachedSessionService().setFailoverNodes( failoverNodes ); sessionManager.getMemcachedSessionService().setEnabled(enabled); sessionManager.getMemcachedSessionService().setSticky(sticky); if(lockingMode != null) { sessionManager.getMemcachedSessionService().setLockingMode(lockingMode.name()); } sessionManager.getMemcachedSessionService().setMemcachedProtocol(memcachedProtocol); sessionManager.getMemcachedSessionService().setUsername(username); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); sessionManager.getMemcachedSessionService().setStorageKeyPrefix(storageKeyPrefix); final Connector connector = catalina.createConnector( "localhost", port, false ); connector.setProperty("bindOnInit", "false"); catalina.addConnector( connector ); return catalina; } 
public Tomcat build ( ) throws MalformedURLException , UnknownHostException , LifecycleException { final Tomcat tomcat = new Tomcat ( ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Connector connector = tomcat.getConnector(); connector.setPort(port); connector.setProperty("bindOnInit", "false"); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.getMemcachedSessionService().setFailoverNodes( failoverNodes ); sessionManager.getMemcachedSessionService().setEnabled(enabled); sessionManager.getMemcachedSessionService().setSticky(sticky); if(lockingMode != null) { sessionManager.getMemcachedSessionService().setLockingMode(lockingMode.name()); } sessionManager.getMemcachedSessionService().setMemcachedProtocol(memcachedProtocol); sessionManager.getMemcachedSessionService().setUsername(username); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); sessionManager.getMemcachedSessionService().setStorageKeyPrefix(storageKeyPrefix); return tomcat; } 
public Tomcat build ( ) throws MalformedURLException , UnknownHostException , LifecycleException { final Tomcat tomcat = new Tomcat ( ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Connector connector = tomcat.getConnector(); connector.setPort(port); connector.setProperty("bindOnInit", "false"); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.getMemcachedSessionService().setFailoverNodes( failoverNodes ); sessionManager.getMemcachedSessionService().setEnabled(enabled); sessionManager.getMemcachedSessionService().setSticky(sticky); if(lockingMode != null) { sessionManager.getMemcachedSessionService().setLockingMode(lockingMode.name()); } sessionManager.getMemcachedSessionService().setMemcachedProtocol(memcachedProtocol); sessionManager.getMemcachedSessionService().setUsername(username); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); sessionManager.getMemcachedSessionService().setStorageKeyPrefix(storageKeyPrefix); return tomcat; } 
private CustomXMLFormat < ? > [ ] loadCustomFormats ( final SessionManager manager ) { if ( _customConverterClassNames = = null | | _customConverterClassNames . length = = 0 ) { return null ; } final CustomXMLFormat < ? > [ ] customFormats = new CustomXMLFormat < ? > [ _customConverterClassNames . length ] ; for ( int i = 0 ; i < _customConverterClassNames . length ; i + + ) { final String className = _customConverterClassNames [ i ] ; try { final CustomXMLFormat < ? > xmlFormat = Class . forName ( className , true , manager . getContainerClassLoader ( ) ) . asSubclass ( CustomXMLFormat . class ) . newInstance ( ) ; customFormats [ i ] = xmlFormat ; } catch ( final Exception e ) { throw new RuntimeException ( " Could not load custom xml format " + className , e ) ; } } return customFormats ; } 
public SessionAttributesTranscoder createTranscoder ( final SessionManager manager ) { return getTranscoder ( manager . getContainerClassLoader ( ) ) ; } 
protected abstract void setupGetResponseSetCookieHeadersExpectations ( Response response , String [ ] result ) ; @Nonnull protected String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; } } 
protected String generateCookieString ( final Cookie cookie ) { final StringBuffer sb = new StringBuffer ( ) ; ServerCookie . appendCookieValue ( sb , cookie . getVersion ( ) , cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) , true ) ; final String setSessionCookieHeader = sb . toString ( ) ; return setSessionCookieHeader ; } 
protected String generateCookieString ( final Cookie cookie ) { return SetCookieSupport . generateHeader ( cookie ) ; } 
protected void deleteFromMemcached ( final String sessionId ) { no memcached access } public Future<BackupResult> backupSession( final String sessionId, final boolean sessionIdChanged, final String requestId ) { final MemcachedBackupSession session = _manager.getSessionInternal( sessionId ); if ( session == null ) { if(_log.isDebugEnabled()) _log.debug( "No session found in session map for " + sessionId ); return new SimpleFuture<BackupResult>( BackupResult.SKIPPED ); } _log.info( "Serializing session data for session " + session.getIdInternal() ); final long startSerialization = System.currentTimeMillis(); final byte[] data = _transcoderService.serializeAttributes( (MemcachedBackupSession) session, ((MemcachedBackupSession) session).getAttributesFiltered() ); _log.info( String.format( "Serializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)data.length / 1000, session.getIdInternal(), System.currentTimeMillis() - startSerialization ) ); _sessionData.put( session.getIdInternal(), data ); _statistics.registerSince( ATTRIBUTES_SERIALIZATION, startSerialization ); _statistics.register( CACHED_DATA_SIZE, data.length ); return new SimpleFuture<BackupResult>( new BackupResult( BackupResultStatus.SUCCESS ) ); } @Override public MemcachedBackupSession findSession( final String id ) throws IOException { final MemcachedBackupSession result = super.findSession( id ); if ( result != null ) { final byte[] data = _sessionData.remove( id ); if ( data != null ) { _executorService.submit( new SessionDeserialization( id, data ) ); } } return result; } @Override protected MemcachedBackupSession loadFromMemcachedWithCheck( final String sessionId ) { return null; } @Override protected void updateExpirationInMemcached() { } private final class SessionDeserialization implements Callable<Void> { private final String _id; private final byte[] _data; private SessionDeserialization( final String id, final byte[] data ) { _id = id; _data = data; } @Override public Void call() throws Exception { _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s (asynchronously).", (double)_data.length / 1000, _id ) ); final long startDeserialization = System.currentTimeMillis(); try { _transcoderService.deserializeAttributes( _data ); } catch( final Exception e ) { _log.warn( "Could not deserialize session data.", e ); } _log.info( String.format( "Deserializing %1$,.3f kb session data for session %2$s took %3$d ms.", (double)_data.length / 1000, _id, System.currentTimeMillis() - startDeserialization ) ); _statistics.registerSince( LOAD_FROM_MEMCACHED, startDeserialization ); return null; } }} 
public Future < BackupResult > backupSession ( final String sessionId , final boolean sessionIdChanged , final String requestId ) { final MemcachedBackupSession session = _manager . getSessionInternal ( sessionId ) ; if ( session = = null ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( " No session found in session map for " + sessionId ) ; return new SimpleFuture < BackupResult > ( BackupResult . SKIPPED ) ; } _log . info ( " Serializing session data for session " + session . getIdInternal ( ) ) ; final long startSerialization = System . currentTimeMillis ( ) ; final byte [ ] data = _transcoderService . serializeAttributes ( ( MemcachedBackupSession ) session , ( ( MemcachedBackupSession ) session ) . getAttributesFiltered ( ) ) ; _log . info ( String . format ( " Serializing %1$,.3f kb session data for session %2$s took %3$d ms. " , ( double ) data . length / 1000 , session . getIdInternal ( ) , System . currentTimeMillis ( ) - startSerialization ) ) ; _sessionData . put ( session . getIdInternal ( ) , data ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , startSerialization ) ; _statistics . register ( CACHED_DATA_SIZE , data . length ) ; return new SimpleFuture < BackupResult > ( new BackupResult ( BackupResultStatus . SUCCESS ) ) ; } 
public String generateSessionId ( ) { return _msm . newSessionId ( super . generateSessionId ( ) ) ; } 
public KryoBuilder configure ( KryoBuilder kryoBuilder ) { return kryoBuilder . withClassResolver ( createClassResolver ( ) ) 
public void customize ( final Kryo kryo ) { kryo . register ( CGLibProxySerializer . CGLibProxyMarker . class , new CGLibProxySerializer ( ) ) ; } 
public Serializer newSerializer ( Class < ? > type ) { if ( CGLibProxySerializer . canSerialize ( type ) ) { return kryo . getSerializer ( CGLibProxySerializer . CGLibProxyMarker . class ) ; } return null ; } 
protected ClassResolver createClassResolver ( ) { return new CGLibProxyClassResolver ( ) ; } 
public KryoBuilder configure ( KryoBuilder kryoBuilder ) { return kryoBuilder . withInstantiatorStrategy ( 
public void customize ( Kryo kryo ) { kryo . addDefaultSerializer ( Component . class , new com . esotericsoftware . kryo . factories . SerializerFactory ( ) { @Override 
public Serializer makeSerializer ( Kryo kryo , Class < ? > type ) { final FieldSerializer result = new FieldSerializer < Component > ( kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; } 
public Serializer newDefaultSerializer ( final Kryo kryo , final Class < ? > type ) { final FieldSerializer result = new FieldSerializer ( kryo , type ) ; result . setIgnoreSyntheticFields ( false ) ; return result ; } 
public LRUMap < ? , ? > read ( Kryo kryo , Input input , Class < LRUMap < ? , ? > > type ) { final int maxCapacity = input . readInt ( true ) ; final LRUMap < Object , Object > result = new LRUMap < Object , Object > ( maxCapacity ) ; final int size = input . readInt ( true ) ; for ( int i = 0 ; i < size ; i + + ) { final Object key = _kryo . readClassAndObject ( input ) ; final Object value = _kryo . readClassAndObject ( input ) ; result . put ( key , value ) ; } return result ; } 
public void write ( Kryo kryo , Output output , LRUMap < ? , ? > map ) { output . writeInt ( getMaxCapacity ( map ) , true ) ; output . writeInt ( map . size ( ) , true ) ; for ( final Entry < ? , ? > entry : map . entrySet ( ) ) { _kryo . writeClassAndObject ( output , entry . getKey ( ) ) ; _kryo . writeClassAndObject ( output , entry . getValue ( ) ) ; } if ( TRACE ) trace ( " kryo " , " Wrote map: " + map ) ; } 
public void customize ( Kryo kryo ) { tkryo . setReferences ( true ) ; kryo . register ( GrailsFlashScope . class , new FieldSerializer ( kryo , GrailsFlashScope . class ) ) ; } 
public void customize ( final Kryo kryo ) { kryo . register ( Interval . class , new JodaIntervalSerializer ( ) ) ; kryo . register ( DateTime . class , new JodaDateTimeSerializer ( ) ) ; kryo . register ( LocalDateTime . class , new JodaLocalDateTimeSerializer ( ) ) ; kryo . register ( LocalDate . class , new JodaLocalDateSerializer ( ) ) ; } 
public Kryo build ( ) { Kryo kryo = createKryo ( classResolver ! = null ? classResolver : new DefaultClassResolver ( ) , referenceResolver ! = null ? referenceResolver : new MapReferenceResolver ( ) , streamFactory ! = null ? streamFactory : new DefaultStreamFactory ( ) ) ; return kryo ; } 
protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return new Kryo ( classResolver , referenceResolver , streamFactory ) ; } 
public KryoBuilder withClassResolver ( final ClassResolver classResolver ) { this . classResolver = classResolver ; return this ; } 
public KryoBuilder withReferenceResolver ( final ReferenceResolver referenceResolver ) { this . referenceResolver = referenceResolver ; return this ; } 
public KryoBuilder withStreamFactory ( final StreamFactory streamFactory ) { this . streamFactory = streamFactory ; return this ; } 
private Kryo buildFrom ( KryoBuilder target ) { we must transfer local fields to the target which creates the Kryo instance. yes, it's a bit hackish, but if s.o. calls the same method twice with different arguments it's kind of bullshit in... if(target.classResolver == null) target.classResolver = classResolver; if(target.referenceResolver == null) target.referenceResolver = referenceResolver; if(target.streamFactory == null) target.streamFactory = streamFactory; return target.build(); } 
public KryoBuilder withRegistrationRequired ( final boolean registrationRequired ) { return new KryoBuilder ( ) { @Override 
public Kryo build ( ) { Kryo k = buildFrom ( KryoBuilder . this ) ; k . setRegistrationRequired ( registrationRequired ) ; return k ; } 
public KryoBuilder withInstantiatorStrategy ( final InstantiatorStrategy instantiatorStrategy ) { return new KryoBuilder ( ) { @Override 
public Kryo build ( ) { Kryo k = buildFrom ( KryoBuilder . this ) ; k . setInstantiatorStrategy ( instantiatorStrategy ) ; return k ; } 
public KryoBuilder withReferences ( final boolean references ) { return new KryoBuilder ( ) { @Override 
public Kryo build ( ) { Kryo k = buildFrom ( KryoBuilder . this ) ; k . setReferences ( references ) ; return k ; } 
public KryoBuilder withKryoCustomization ( final KryoCustomization kryoCustomization ) { return new KryoBuilder ( ) { @Override 
public Kryo build ( ) { Kryo k = buildFrom ( KryoBuilder . this ) ; kryoCustomization . customize ( k ) ; return k ; } 
public Serializer newDefaultSerializer ( Kryo kryo , Class < ? > type ) ; static class SerializerFactoryAdapter implements com . esotericsoftware . kryo . factories . SerializerFactory { private final KryoDefaultSerializerFactory delegate ; public SerializerFactoryAdapter ( KryoDefaultSerializerFactory delegate ) { this . delegate = delegate ; } @Override public Serializer makeSerializer ( Kryo kryo , Class < ? > type ) { return delegate . newDefaultSerializer ( kryo , type ) ; } } } 
public Serializer makeSerializer ( Kryo kryo , Class < ? > type ) { return delegate . newDefaultSerializer ( kryo , type ) ; } 
private KryoFactory createKryoFactory ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { final KryoBuilder kryoBuilder = new KryoBuilder ( ) { @Override protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return KryoTranscoder . this . createKryo ( classResolver , referenceResolver , streamFactory , classLoader , customConverterClassNames , copyCollectionsForSerialization ) ; } } . withInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; final List < KryoBuilderConfiguration > builderConfigs = load ( KryoBuilderConfiguration . class , customConverterClassNames , classLoader ) ; for ( KryoBuilderConfiguration config : builderConfigs ) { config . configure ( kryoBuilder ) ; } return new KryoFactory ( ) { @Override 
protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return KryoTranscoder . this . createKryo ( classResolver , referenceResolver , streamFactory , classLoader , customConverterClassNames , copyCollectionsForSerialization ) ; 
public Kryo create ( ) { Kryo kryo = kryoBuilder . build ( ) ; kryo . setDefaultSerializer ( new KryoDefaultSerializerFactory . SerializerFactoryAdapter ( _defaultSerializerFactory ) ) ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationRequired(false); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer() ); kryo.register(InvocationHandler.class, new JdkProxySerializer()); UnmodifiableCollectionsSerializer.registerSerializers(kryo); SynchronizedCollectionsSerializer.registerSerializers(kryo); kryo.addDefaultSerializer(EnumMap.class, EnumMapSerializer.class); SubListSerializers.addDefaultSerializers(kryo); final List<KryoCustomization> customizations = load(KryoCustomization.class, customConverterClassNames, classLoader, kryo); if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return kryo; } 
protected Kryo createKryo ( final ClassResolver classResolver , final ReferenceResolver referenceResolver , final StreamFactory streamFactory , final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { return new Kryo ( classResolver , referenceResolver , streamFactory ) { 
private Serializer loadCustomSerializer ( final Class < ? > clazz , List < SerializerFactory > serializerFactories ) { if ( serializerFactories ! = null ) { for ( SerializerFactory serializerFactory : serializerFactories ) { final Serializer serializer = serializerFactory . newSerializer ( clazz ) ; if ( serializer ! = null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading custom serializer " + serializer . getClass ( ) . getName ( ) + " for class " + clazz ) ; } return serializer ; } } } return null ; } 
private Serializer loadCopyCollectionSerializer ( final Class < ? > clazz ) { if ( Collection . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateCollectionSerializer for class " + clazz ) ; } return new CopyForIterateCollectionSerializer ( ) ; } if ( Map . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateMapSerializer for class " + clazz ) ; } return new CopyForIterateMapSerializer ( ) ; } return null ; } 
public Map < String , Object > deserializeAttributes ( final byte [ ] data ) { final Kryo kryo = _kryoPool . borrow ( ) ; try { return kryo . readObject ( new Input ( data ) , ConcurrentHashMap . class ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes ) { final Kryo kryo = _kryoPool . borrow ( ) ; try { / * * 
private < T > List < T > load ( Class < T > type , final String [ ] customConverterClassNames , final ClassLoader classLoader ) { return load ( type , customConverterClassNames , classLoader , null ) ; } 
private < T > List < T > load ( Class < T > type , final String [ ] customConverterClassNames , final ClassLoader classLoader , final Kryo kryo ) { if ( customConverterClassNames = = null | | customConverterClassNames . length = = 0 ) { return Collections . emptyList ( ) ; } final List < T > result = new ArrayList < T > ( ) ; final ClassLoader loader = classLoader ! = null ? classLoader : Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( final String element : customConverterClassNames ) { try { final Class < ? > clazz = Class . forName ( element , true , loader ) ; if ( type . isAssignableFrom ( clazz ) ) { LOG . info ( " Loading " + type . getSimpleName ( ) + " " + element ) ; final T item = createInstance ( clazz . asSubclass ( type ) , kryo ) ; result . add ( item ) ; } } catch ( final Exception e ) { LOG . error ( " Could not instantiate " + element + " , omitting this " + type . getSimpleName ( ) + " . " , e ) ; throw new RuntimeException ( " Could not load " + type . getSimpleName ( ) + " " + element , e ) ; } } return result ; } 
public User read ( Kryo kryo , Input input , Class < User > type ) { tfinal String password = input . readString ( ) ; tfinal String username = input . readString ( ) ; tfinal int size = input . readInt ( true ) ; tfinal List < GrantedAuthority > authorities = new ArrayList < GrantedAuthority > ( size ) ; tfor ( int i = 0 ; i < size ; i + + ) { tauthorities . add ( ( GrantedAuthority ) _kryo . readClassAndObject ( input ) ) ; } tfinal boolean accountNonExpired = input . readBoolean ( ) ; tfinal boolean accountNonLocked = input . readBoolean ( ) ; tfinal boolean credentialsNonExpired = input . readBoolean ( ) ; tfinal boolean enabled = input . readBoolean ( ) ; treturn new User ( username , password , enabled , accountNonExpired , credentialsNonExpired , accountNonLocked , authorities ) ; } 
public void write ( Kryo kryo , Output output , User user ) { toutput . writeString ( user . getPassword ( ) ) ; toutput . writeString ( user . getUsername ( ) ) ; tfinal Collection < GrantedAuthority > authorities = user . getAuthorities ( ) ; toutput . writeInt ( authorities . size ( ) , true ) ; tfor ( final GrantedAuthority item : authorities ) { t_kryo . writeClassAndObject ( output , item ) ; } toutput . writeBoolean ( user . isAccountNonExpired ( ) ) ; toutput . writeBoolean ( user . isAccountNonLocked ( ) ) ; toutput . writeBoolean ( user . isCredentialsNonExpired ( ) ) ; toutput . writeBoolean ( user . isEnabled ( ) ) ; } 
public void customize ( final Kryo kryo ) { kryo . register ( MiniMap . class , new MiniMapSerializer ( ) ) ; } 
public void customize ( final Kryo kryo ) { new WicketMiniMapRegistration ( ) . customize ( kryo ) ; new ComponentSerializerFactory ( ) . customize ( kryo ) ; } 
public Serializer newSerializer ( final Class < ? > type ) { Serializer serializer ; if ( ( serializer = _childListSerializerFactory . newSerializer ( type ) ) ! = null ) { return serializer ; } return null ; } 
public void testSpringSecurityUserSerializer ( ) { tfinal Kryo kryo = new Kryo ( ) ; tkryo . setInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; tkryo . setRegistrationRequired ( false ) ; tnew SpringSecurityUserRegistration ( ) . customize ( kryo ) ; tfinal Collection < ? extends GrantedAuthority > authorities = Arrays . asList ( new SimpleGrantedAuthority ( " foo " ) ) ; tfinal User user = new User ( " foo " , " bar " , authorities ) ; tOutput out = new Output ( 100 , 1024 ) ; tkryo . writeObject ( out , user ) ; tfinal byte [ ] data = out . toBytes ( ) ; tfinal User user2 = kryo . readObject ( new Input ( data ) , User . class ) ; tTestUtils . assertDeepEquals ( user , user2 ) ; } 
public static void main ( final String [ ] args ) throws InterruptedException { Thread.sleep( 1000 ); final MemcachedBackupSessionManager manager = createManager(); some warmup final int warmupCycles = 100000; final int warmupCycles = 100; warmup( manager, new KryoTranscoder(), warmupCycles, 100, 3 ); warmup( manager, new JavaSerializationTranscoder(), warmupCycles, 100, 3 ); warmup( manager, new JavolutionTranscoder( Thread.currentThread().getContextClassLoader(), false ), warmupCycles, 100, 3 ); recover(); benchmark( manager, 10, 500, 4 ); 
private static void benchmark ( final MemcachedBackupSessionManager manager , final int rounds , final int countPersons , final int nodesPerEdge ) throws InterruptedException { final Stats kryoSerStats = new Stats ( ) ; final Stats kryoDeSerStats = new Stats ( ) ; benchmark ( manager , new KryoTranscoder ( ) , kryoSerStats , kryoDeSerStats , rounds , countPersons , nodesPerEdge ) ; final Stats javaSerStats = new Stats ( ) ; final Stats javaDeSerStats = new Stats ( ) ; benchmark ( manager , new JavaSerializationTranscoder ( ) , javaSerStats , javaDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; final Stats javolutionSerStats = new Stats ( ) ; final Stats javolutionDeSerStats = new Stats ( ) ; benchmark ( manager , new JavolutionTranscoder ( Thread . currentThread ( ) . getContextClassLoader ( ) , false ) , javolutionSerStats , javolutionDeSerStats , rounds , countPersons , nodesPerEdge ) ; recover ( ) ; System . out . println ( " Serialization,Size,Ser-Min,Ser-Avg,Ser-Max,Deser-Min,Deser-Avg,Deser-Max " ) ; System . out . println ( toCSV ( " Java " , javaSerStats , javaDeSerStats ) ) ; System . out . println ( toCSV ( " Javolution " , javolutionSerStats , javolutionDeSerStats ) ) ; System . out . println ( toCSV ( " Kryo " , kryoSerStats , kryoDeSerStats ) ) ; } 
static byte [ ] serializeSessionFields ( final MemcachedBackupSession session , final int version ) { final byte [ ] idData = serializeId ( session . getIdInternal ( ) ) ; final byte [ ] principalData = serializePrincipal ( session . getPrincipal ( ) , session . getManager ( ) ) ; final int principalDataLength = principalData ! = null ? principalData . length : 0 ; final byte [ ] savedRequestData = serializeSavedRequest ( session . getNote ( Constants . FORM_REQUEST_NOTE ) ) ; final int savedRequestDataLength = savedRequestData ! = null ? savedRequestData . length : 0 ; final byte [ ] savedPrincipalData = serializePrincipal ( ( Principal ) session . getNote ( Constants . FORM_PRINCIPAL_NOTE ) , session . getManager ( ) ) ; final int savedPrincipalDataLength = savedPrincipalData ! = null ? savedPrincipalData . length : 0 ; int sessionFieldsDataLength = 2 short value for the version the following might change with other versions, refactoring needed then + 2 short value that stores the dataLength + NUM_BYTES bytes that store all session attributes but the id + 2 short value that stores the idData length + idData.length the number of bytes for the id + 2 short value for the authType + 2 short value that stores the principalData length + principalDataLength; the number of bytes for the principal if(version > VERSION_1) { sessionFieldsDataLength = sessionFieldsDataLength + 2 short value that stores the savedRequestData length + savedRequestDataLength the number of bytes for the savedRequest + 2 short value that stores the savedPrincipalData length + savedPrincipalDataLength; the number of bytes for the savedPrincipal } final byte[] data = new byte[sessionFieldsDataLength]; int idx = 0; idx = encodeNum( version, data, idx, 2 ); idx = encodeNum( sessionFieldsDataLength, data, idx, 2 ); idx = encodeNum( session.getCreationTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getMaxInactiveInterval(), data, idx, 4 ); idx = encodeBoolean( session.isNewInternal(), data, idx ); idx = encodeBoolean( session.isValidInternal(), data, idx ); idx = encodeNum( session.getThisAccessedTimeInternal(), data, idx, 8 ); idx = encodeNum( session.getLastBackupTime(), data, idx, 8 ); idx = encodeNum( idData.length, data, idx, 2 ); idx = copy( idData, data, idx ); idx = encodeNum( AuthType.valueOfValue( session.getAuthType() ).getId(), data, idx, 2 ); idx = encodeNum( principalDataLength, data, idx, 2 ); idx = copy( principalData, data, idx ); if(version > VERSION_1) { idx = encodeNum( savedRequestDataLength, data, idx, 2 ); idx = copy( savedRequestData, data, idx ); idx = encodeNum( savedPrincipalDataLength, data, idx, 2 ); idx = copy( savedPrincipalData, data, idx ); } return data; } 
private static byte [ ] serializePrincipal ( final Principal principal , final SessionManager manager ) { if ( principal = = null ) { return null ; } ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
public void writePrincipal ( @Nonnull Principal principal , @Nonnull ObjectOutputStream oos ) throws IOException { SerializablePrincipal . writePrincipal ( ( GenericPrincipal ) principal , oos ) ; } 
public MemcachedBackupSession createSession ( final String sessionId ) { return _msm . createSession ( sessionId ) ; } 
public void expireSession ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " expireSession invoked: " + sessionId ) ; } super . expireSession ( sessionId ) ; _msm . deleteFromMemcached ( sessionId ) ; } 
public void remove ( final Session session , final boolean update ) { removeInternal ( session , update , session . getNote ( MemcachedSessionService . NODE_FAILURE ) ! = Boolean . TRUE ) ; } 
public void removeInternal ( final Session session , final boolean update ) { super . remove ( session , update ) ; } 
public void changeSessionId ( final Session session ) { e.g. invoked by the AuthenticatorBase (for BASIC auth) on login to prevent session fixation so that session backup won't be omitted we must store this event super.changeSessionId( session ); ((MemcachedBackupSession)session).setSessionIdChanged(true); } 
private void swapOut ( @Nonnull final StandardSession session ) { implementation like the one in PersistentManagerBase.swapOut if (!session.isValid()) { return; } session.passivate(); removeInternal(session, true); session.recycle(); } 
public void writePrincipal ( @Nonnull Principal principal , @Nonnull ObjectOutputStream oos ) throws IOException { oos . writeObject ( principal ) ; } 
public Principal readPrincipal ( final ObjectInputStream ois ) throws ClassNotFoundException , IOException { return ( Principal ) ois . readObject ( ) ; } 
private static Response redirect ( final HttpResponse response , final DefaultHttpClient client , final int port , final String rsessionId , final String baseUri ) throws IOException , HttpException { final String location = response . getFirstHeader ( " Location " ) . getValue ( ) ; final String redirectPath = location . startsWith ( baseUri ) ? location . substring ( baseUri . length ( ) , location . length ( ) ) : location ; return get ( client , port , redirectPath , rsessionId ) ; } 
protected void beforeTest ( ) { Configuration configuration = new Configuration ( ) . addAnnotatedClass ( Person . class ) . addAnnotatedClass ( Animal . class ) . configure ( ) ; StandardServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder ( ) . applySettings ( configuration . getProperties ( ) ) . build ( ) ; _sessionFactory = configuration . buildSessionFactory ( serviceRegistry ) ; } 
protected abstract SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } @Entity ( name = " persons " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Person implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; @OneToMany ( cascade = CascadeType . ALL ) public Set < Animal > animals ; public Person ( ) { } public Person ( final String name , final Set < Animal > animals ) { this . name = name ; this . animals = animals ; } @Override public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } } @Entity ( name = " animals " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Animal implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; public Animal ( ) { } public Animal ( final String name ) { this . name = name ; } @Override public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } } static interface Callback < T > { T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContainer ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
public void test ( ) { HibernateCollectionsSerializerFactory factory = new HibernateCollectionsSerializerFactory ( new Kryo ( ) ) ; Serializer serializer = factory . newSerializer ( PERSISTENT_LIST_CLASS ) ; assertNotNull ( serializer ) ; } 
abstract TestUtils < ? > getTestUtils ( ) ; private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private TomcatBuilder < ? > startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . storageKeyPrefix ( null ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . buildAndStart ( ) ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _daemon . stop ( ) ; if ( _daemon2 ! = null ) _daemon2 . stop ( ) ; } final String actualValue = response.get( key ); assertEquals( value, actualValue ); } private MemCacheDaemon<?> startMemcached(final int memcachedPort) throws IOException { final InetSocketAddress address = new InetSocketAddress( "localhost", memcachedPort ); final MemCacheDaemon<?> daemon2 = createDaemon( address ); daemon2.start(); return daemon2; }} 
public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _daemon . stop ( ) ; if ( _daemon2 ! = null ) _daemon2 . stop ( ) ; 
public void testTomcatFailoverMovesSessionToNonFailoverNode ( ) throws Exception { _daemon2 = startMemcached ( MEMCACHED_PORT + 1 ) ; final String memcachedNodes = _memcachedNodes + " , " + " n2:localhost: " + ( MEMCACHED_PORT + 1 ) ; _tomcat1 . getService ( ) . setMemcachedNodes ( memcachedNodes ) ; _tomcat1 . getService ( ) . setFailoverNodes ( " n1 " ) ; _tomcat2 . getService ( ) . setMemcachedNodes ( memcachedNodes ) ; _tomcat2 . getService ( ) . setFailoverNodes ( " n2 " ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value ) . getSessionId ( ) ; assertEquals ( format . extractMemcachedId ( sessionId1 ) , " n2 " ) ; assertEquals ( _daemon . getCache ( ) . getCurrentItems ( ) , 0 ) ; assertEquals ( _daemon2 . getCache ( ) . getCurrentItems ( ) , 1 ) ; failover simulation, just request the session from tomcat2 final Response response = get( _httpClient, TC_PORT_2, sessionId1 ); final String sessionId2 = response.getSessionId(); assertEquals( format.extractMemcachedId( sessionId2 ), "n1" ); assertEquals(_daemon.getCache().getCurrentItems(), 1); assertEquals( format.stripJvmRoute( sessionId1 ).replaceAll("n2", "n1"), format.stripJvmRoute( sessionId2 ) ); final String actualValue = response.get( key ); assertEquals( value, actualValue ); 
protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { HttpSession session = req . getSession ( ) ; Integer counter = ( Integer ) session . getAttribute ( COUNTER ) ; int iTmp = 0 ; if ( counter ! = null ) { iTmp = counter + 1 ; } String sTmp = Integer . toString ( iTmp ) ; resp . getOutputStream ( ) . println ( sTmp ) ; session . setAttribute ( COUNTER , iTmp ) ; resp . flushBuffer ( ) ; } 
public void testIgnoredResourcesWithFormAuthDontCauseSessionStaleness ( ) throws Exception { TODO: see testSessionCreatedForContainerProtectedResourceIsStoredInMemcached _tomcat1.stop(); _tomcat2.stop(); _tomcat1 = startTomcatWithAuth( TC_PORT_1, NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1, LockingMode.AUTO, LoginType.FORM ); _tomcat2 = startTomcatWithAuth( TC_PORT_2, NODE_ID_1 + ":localhost:" + MEMCACHED_PORT_1, LockingMode.AUTO, LoginType.FORM ); _tomcat1.setChangeSessionIdOnAuth( false ); _tomcat2.setChangeSessionIdOnAuth( false ); final Response tc2Response1 = get( _httpClient, TC_PORT_2, sessionId ); assertEquals(tc2Response1.getSessionId(), sessionId); assertNull(tc2Response1.getResponseSessionId()); assertEquals( tc2Response1.get( TestServlet.ID ), sessionId ); assertEquals( tc2Response1.get( "foo" ), "bar" ); assertEquals( tc2Response1.get( "bar" ), "baz" ); 
private boolean isConnectorSessionLookup ( ) { return _currentRequest . get ( ) = = null ; } 
public void testSessionNotLoadedForReadonlyRequest ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getMemcached ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; 2 for session and validity, if backup would be stored this would be 4 instead assertWaitingWithProxy(equalTo(2), 1000, _daemon1.getCache()).getSetCmds(); no gets at all assertEquals( _daemon1.getCache().getGetHits(), 0 ); a request without session access should not pull the session from memcached but update the validity info (get + set) get( _httpClient, TC_PORT_1, PATH_NO_SESSION_ACCESS, sessionId1 ); assertWaitingWithProxy(equalTo(3), 1000, _daemon1.getCache()).getSetCmds(); node availability check + loading session from AuthenticatorBase.invoke(AuthenticatorBase.java:430) (in TC 7.0.67) which seems to be installed and always check the user principal assertEquals( _daemon1.getCache().getGetHits(), 2 ); } 
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Key key1 = ( Key ) o ; bytes . readerIndex ( 0 ) ; key1 . bytes . readerIndex ( 0 ) ; if ( ! bytes . equals ( key1 . bytes ) ) return false ; return true ; } 
public String toString ( ) { return new String ( bytes . toByteBuffer ( ) . array ( ) ) ; } 
public void testSessionNotLoadedForNoSessionAccess ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getMemcached ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; 2 for session and validity, if backup would be stored this would be 4 instead assertWaitingWithProxy(equalTo(2), 1000, _daemon1.getCache()).getSetCmds(); no gets at all assertEquals( _daemon1.getCache().getGetHits(), 0 ); a request without session access should not pull the session from memcached but update the validity info (get + set) get( _httpClient, TC_PORT_1, PATH_NO_SESSION_ACCESS, sessionId1 ); assertWaitingWithProxy(equalTo(3), 1000, _daemon1.getCache()).getSetCmds(); For TC7 the session is looked up by AuthenticatorBase.invoke(AuthenticatorBase.java:430) (TC 7.0.67) which seems to be installed and always check the user principal - therefore we have 2 hits for the session and the validity info. And we want to allow context level valves to access the session (issue #286), therefore we load the session even if our context valve has not been passed (i.e. findSession is not directly triggered from the webapp). For TC{6,8} there's no call from AuthenticatorBase, so there's only 1 hit (validity info) assertEquals( _daemon1.getCache().getGetHits(), getExpectedHitsForNoSessionAccess()); } 
public void shutdown ( ) { _log . info ( " Stopping services. " ) ; _manager . getContext ( ) . getParent ( ) . getPipeline ( ) . removeValve ( _trackingHostValve ) ; _manager . getContext ( ) . getPipeline ( ) . removeValve ( _trackingContextValve ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _memcached ! = null ) { _memcached . shutdown ( ) ; _memcached = null ; } _transcoderFactory = null ; _invalidSessionsCache . clear ( ) ; } 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _memcached = = null ) { _memcached = createMemcachedClient ( _memcachedNodesManager , _statistics ) ; } final String sessionCookieName = _manager . getSessionCookieName ( ) ; _currentRequest = new CurrentRequest ( ) ; _trackingHostValve = createRequestTrackingHostValve ( sessionCookieName , _currentRequest ) ; final Context context = _manager . getContext ( ) ; context . getParent ( ) . getPipeline ( ) . addValve ( _trackingHostValve ) ; _trackingContextValve = createRequestTrackingContextValve ( sessionCookieName ) ; context . getPipeline ( ) . addValve ( _trackingContextValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _memcached , _memcachedNodesManager , _statistics ) ; _log . info ( " -------- n- " + getClass ( ) . getSimpleName ( ) + " finished initialization: " + " n- sticky: " + _sticky + 
protected MemcachedNodesManager createMemcachedNodesManager ( final String memcachedNodes , final String failoverNodes ) { final Context context = _manager . getContext ( ) ; final String webappVersion = Reflections . invoke ( context , " getWebappVersion " , null ) ; final StorageKeyFormat storageKeyFormat = StorageKeyFormat . of ( _storageKeyPrefix , context . getParent ( ) . getName ( ) , context . getName ( ) , webappVersion ) ; treturn MemcachedNodesManager . createFor ( memcachedNodes , failoverNodes , storageKeyFormat , _memcachedClientCallback ) ; } 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedSimple ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = _tomcat1 . getManager ( ) ; setStickyness ( stickyness ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContext().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertNotNull( _memcached.get( sessionId1 ), "Session not available in memcached." ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); +1000 just to be sure that we're >4 secs assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
public void testExpirationOfSessionsInMemcachedIfBackupWasSkippedManyReadonlyRequests ( final SessionAffinityMode stickyness ) throws Exception { final SessionManager manager = _tomcat1 . getManager ( ) ; setStickyness ( stickyness ) ; set to 1 sec above (in setup), default is 10 seconds final int delay = manager.getContext().getBackgroundProcessorDelay(); manager.setMaxInactiveInterval( delay * 4 ); final String sessionId1 = makeRequest( _httpClient, _portTomcat1, null ); assertNotNull( sessionId1, "No session created." ); assertWaitingWithProxy(Predicates.<MemcachedClientIF> notNull(), 200l, _memcached).get( sessionId1 ); Thread.sleep( TimeUnit.SECONDS.toMillis( delay ) + 500 ); assertNotSame( makeRequest( _httpClient, _portTomcat1, sessionId1 ), sessionId1, "The sessionId should have changed due to expired sessin" ); 
abstract TestUtils < ? > getTestUtils ( ) ; private void checkSessionFunctionalityWithMsmDisabled ( ) throws IOException , HttpException , InterruptedException { assertTrue ( _tomcat1 . getManager ( ) . getMemcachedSessionService ( ) . isSticky ( ) ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; assertNull ( new SessionIdFormat ( ) . extractMemcachedId ( sessionId1 ) , " Got a memcached node id, even with msm disabled. " ) ; waitForSessionExpiration ( true ) ; final String sessionId2 = makeRequest ( _httpClient , _portTomcat1 , sessionId1 ) ; assertNotSame ( sessionId2 , sessionId1 , " SessionId not changed. " ) ; } private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = _tomcat1 . getManager ( ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContext ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; } } 
private void waitForSessionExpiration ( final boolean sticky ) throws InterruptedException { final SessionManager manager = _tomcat1 . getManager ( ) ; assertEquals ( manager . getMemcachedSessionService ( ) . isSticky ( ) , sticky ) ; final Container container = manager . getContext ( ) ; final long timeout = TimeUnit . SECONDS . toMillis ( sticky ? container . getBackgroundProcessorDelay ( ) + manager . getMaxInactiveInterval ( ) : 2 * manager . getMaxInactiveInterval ( ) ) + 1000 ; Thread . sleep ( timeout ) ; } 
public void setUp ( ) throws Exception { _service = mock ( MemcachedSessionService . class ) ; _request = mock ( Request . class ) ; _response = mock ( Response . class ) ; final Context _contextContainer = mock ( Context . class ) ; final Host _hostContainer = mock ( Host . class ) ; final SessionManager _manager = mock ( SessionManager . class ) ; when ( _service . getManager ( ) ) . thenReturn ( _manager ) ; when ( _manager . getContext ( ) ) . thenReturn ( _contextContainer ) ; when ( _contextContainer . getParent ( ) ) . thenReturn ( _hostContainer ) ; when ( _contextContainer . getPath ( ) ) . thenReturn ( " / " ) ; _sessionTrackerValve = createSessionTrackerValve ( ) ; _nextValve = mock ( Valve . class ) ; _sessionTrackerValve . setNext ( _nextValve ) ; _sessionTrackerValve . setContainer ( _hostContainer ) ; when ( _request . getRequestURI ( ) ) . thenReturn ( " /someRequest " ) ; when ( _request . getMethod ( ) ) . thenReturn ( " GET " ) ; when ( _request . getQueryString ( ) ) . thenReturn ( null ) ; when ( _request . getContext ( ) ) . thenReturn ( _contextContainer ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . REQUEST_PROCESSED ) ) ) . thenReturn ( Boolean . TRUE ) ; when ( _request . getNote ( eq ( RequestTrackingHostValve . SESSION_ID_CHANGED ) ) ) . thenReturn ( Boolean . FALSE ) ; } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { _manager = mock ( SessionManager . class ) ; when ( _manager . getContext ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( _manager.newMemcachedBackupSession() ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return newMemcachedBackupSession( _manager ); } }); final MemcachedSessionService service = new DummyMemcachedSessionService<SessionManager>( _manager ); when( _manager.createSession( anyString() ) ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return createSession(service); } }); when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() ); when( _manager.getMemcachedSessionService() ).thenReturn( service ); 
protected abstract SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } @Entity ( name = " persons " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Person implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; @OneToMany ( cascade = CascadeType . ALL ) public Set < Animal > animals ; public Person ( ) { } public Person ( final String name , final Set < Animal > animals ) { this . name = name ; this . animals = animals ; } @Override public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } } @Entity ( name = " animals " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Animal implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; public Animal ( ) { } public Animal ( final String name ) { this . name = name ; } @Override public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } } static interface Callback < T > { T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContext ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContext ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; when ( manager . getContext ( ) ) . thenReturn ( new StandardContext ( ) ) ; needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); return manager; } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , tIOException { tsuper . setup ( ) ; final Context context = ( Context ) _manager . getContext ( ) ; twhen ( _manager . getContext ( ) ) . thenReturn ( context ) ; } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { _manager = mock ( SessionManager . class ) ; final Context context = new StandardContext ( ) ; when ( _manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession when( _manager.getContainer() ).thenReturn( context ); needed for createSession when( _manager.newMemcachedBackupSession() ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return newMemcachedBackupSession( _manager ); } }); final MemcachedSessionService service = new DummyMemcachedSessionService<SessionManager>( _manager ); when( _manager.createSession( anyString() ) ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return createSession(service); } }); when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() ); when( _manager.getMemcachedSessionService() ).thenReturn( service ); when( _manager.willAttributeDistribute(anyString(), any())).thenReturn(true); 
protected abstract SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } @Entity ( name = " persons " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Person implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; @OneToMany ( cascade = CascadeType . ALL ) public Set < Animal > animals ; public Person ( ) { } public Person ( final String name , final Set < Animal > animals ) { this . name = name ; this . animals = animals ; } @Override public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } } @Entity ( name = " animals " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Animal implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; public Animal ( ) { } public Animal ( final String name ) { this . name = name ; } @Override public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } } static interface Callback < T > { T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = new StandardContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession when( manager.getContainer() ).thenReturn(context); needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); when( manager.willAttributeDistribute(anyString(), anyObject())).thenReturn(true); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = new StandardContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession when( manager.getContainer() ).thenReturn(context); needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); when( manager.willAttributeDistribute(anyString(), anyObject())).thenReturn(true); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = new StandardContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession when( manager.getContainer() ).thenReturn(context); needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); when( manager.willAttributeDistribute(anyString(), anyObject())).thenReturn(true); return manager; } 
protected void doGet ( HttpServletRequest req , HttpServletResponse resp ) throws ServletException , IOException { String to = req . getParameter ( " to " ) ; if ( to = = null ) { resp . setStatus ( 400 ) ; resp . getOutputStream ( ) . println ( " The parameter 'to' is missing, please specify a number > 0. " ) ; } else { int = Integer . parseInt ( to ) ; String maybeLast = req . getParameter ( " last " ) ; int last = maybeLast ! = null ? Integer . parseInt ( maybeLast ) : - 1 ; HttpSession session = req . getSession ( ) ; Integer counter = ( Integer ) session . getAttribute ( COUNTER ) ; int iTmp = 0 ; if "last" was not submitted, the user is starting a new run, so let's ignore session data if ( maybeLast != null && counter != null ) { iTmp = counter + 1; } if(iTmp != (last + 1)) { resp.setStatus(500); resp.getOutputStream().println("KO: The last saved value was "+ last +" but "+ counter +" was retrieved from the session - the last write seems to be lost."); } else if(iTmp == t) { resp.setStatus(500); resp.getOutputStream().println("OK: All counts from 0 to " + counter + " were saved and retrieved as expected - no data was lost."); } else { session.setAttribute(COUNTER, iTmp); String location = req.getRequestURI() + "?last=" + iTmp + "&to=" + to; String content = "<html><head>" + "<meta http-equiv=\"refresh\" content=\"0;URL='"+ location +"'\" />" + try to prevent favicon requests that might cause the round robin lb and route "real" requests mainly to a single node "<link rel=\"icon\" type=\"image/png\" href=\"data:image/png;base64,iVBORw0KGgo=\">" + "</head>" + "<body>"+ iTmp +"</body></html>"; resp.getOutputStream().println(content); } } resp.flushBuffer(); 
private byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { final long start = System . currentTimeMillis ( ) ; final byte [ ] attributesData = _transcoderService . serializeAttributes ( session , attributes ) ; _statistics . registerSince ( ATTRIBUTES_SERIALIZATION , start ) ; return attributesData ; } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { if ( attributes = = null ) { throw new NullPointerException ( " Can't serialize null " ) ; } ByteArrayOutputStream bos = null ; ObjectOutputStream oos = null ; try { bos = new ByteArrayOutputStream ( ) ; 
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] in ) { ByteArrayInputStream bis = null ; ObjectInputStream ois = null ; try { bis = new ByteArrayInputStream ( in ) ; 
public ConcurrentMap < String , Object > get ( MemcachedBackupSession session ) { try { return ( ConcurrentMap < String , Object > ) attributesField . get ( session ) ; 
public void set ( MemcachedBackupSession session , ConcurrentMap < String , Object > attributes ) { try { attributesField . set ( session , attributes ) ; 
public ConcurrentMap < String , Object > get ( MemcachedBackupSession session ) { return ( ConcurrentMap < String , Object > ) session . attributes ; } 
public void set ( MemcachedBackupSession session , ConcurrentMap < String , Object > attributes ) { session . attributes = attributes ; } 
ConcurrentMap < String , Object > get ( MemcachedBackupSession session ) ; void set ( MemcachedBackupSession session , ConcurrentMap < String , Object > attributes ) ; } } 
void set ( MemcachedBackupSession session , ConcurrentMap < String , Object > attributes ) ; } } 
byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) ; ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] data ) ; } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { return _attributesTranscoder . serializeAttributes ( session , attributes ) ; } 
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] data ) { return _attributesTranscoder . deserializeAttributes ( data ) ; } 
protected abstract SessionManager createSessionManager ( ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public void testOnlyHashAttributesOfAccessedAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final ConcurrentMap < String , Object > anyMap = any ( ConcurrentMap . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; session . access ( ) ; session . endAccess ( ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; 
public void testOnlyHashAttributesOfAccessedSessionsAndAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; @SuppressWarnings ( " unchecked " ) final ConcurrentMap < String , Object > anyMap = any ( ConcurrentMap . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . setAttribute ( " foo " , " bar " ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , times ( 1 ) ) . serializeAttributes ( eq ( session ) , eq ( session . getAttributesInternal ( ) ) ) ; we need some millis between last backup and next access (due to check in BackupSessionService) Thread.sleep(5L); session.access(); session.getAttribute( "foo" ); _service.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); we need some millis between last backup and next access (due to check in BackupSessionService) Thread.sleep(5L); _service.backupSession( session.getIdInternal(), false, null ).get(); verify( transcoderServiceMock, times( 2 ) ).serializeAttributes( eq( session ), eq( session.getAttributesInternal() ) ); 
public void testOnlyHashAttributesOfAccessedFilteredAttributes ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; _service . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " baz " , " baz " ) ; session . access ( ) ; session . endAccess ( ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; verify ( transcoderServiceMock , never ( ) ) . serializeAttributes ( ( MemcachedBackupSession ) any ( ) , ( ConcurrentMap ) any ( ) ) ; 
public void testOnlyFilteredAttributesAreIncludedInSessionBackup ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; final ConcurrentMap < String , Object > anyMap = any ( ConcurrentMap . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; _service . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " foo " , " foo " ) ; session . setAttribute ( " bar " , " bar " ) ; session . setAttribute ( " baz " , " baz " ) ; _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); 
public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration ( ) throws InterruptedException , ExecutionException { final TranscoderService transcoderServiceMock = mock ( TranscoderService . class ) ; final ConcurrentMap < String , Object > anyMap = any ( ConcurrentMap . class ) ; when ( transcoderServiceMock . serializeAttributes ( any ( MemcachedBackupSession . class ) , anyMap ) ) . thenReturn ( new byte [ 0 ] ) ; _service . setTranscoderService ( transcoderServiceMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; _service . setSessionAttributeFilter ( " ^(foo|bar)$ " ) ; session . setAttribute ( " foo " , " foo " ) ; session . setAttribute ( " bar " , " bar " ) ; session . setAttribute ( " baz " , " baz " ) ; session . access ( ) ; session . endAccess ( ) ; _service . updateExpirationInMemcached ( ) ; capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); 
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] in ) { tfinal InputStreamReader inputStream = new InputStreamReader ( new ByteArrayInputStream ( in ) ) ; tif ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " deserialize the stream " ) ; } ttry { treturn deserializer . deserializeInto ( inputStream , new ConcurrentHashMap < String , Object > ( ) ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession sessions , final ConcurrentMap < String , Object > attributes ) { tif ( attributes = = null ) { tthrow new NullPointerException ( ) ; } final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { This performs a deep serialization of the target instance. 
public void testReadValueIntoObject ( ) throws Exception { tfinal MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; tmanager . setContainer ( new StandardContext ( ) ) ; tfinal JSONTranscoder transcoder = new JSONTranscoder ( manager ) ; tfinal MemcachedBackupSession session = manager . createEmptySession ( ) ; tsession . setValid ( true ) ; tsession . setCreationTime ( System . currentTimeMillis ( ) ) ; tgetField ( StandardSession . class , " lastAccessedTime " ) . set ( session , System . currentTimeMillis ( ) + 100 ) ; tsession . setMaxInactiveInterval ( 600 ) ; tsession . setId ( " foo " ) ; tsession . setAttribute ( " person1 " , createPerson ( " foo bar " , Gender . MALE , " foo.bar@example.org " , " foo.bar@example.com " ) ) ; tsession . setAttribute ( " person2 " , createPerson ( " bar baz " , Gender . FEMALE , " bar.baz@example.org " , " bar.baz@example.com " ) ) ; tfinal long start = System . nanoTime ( ) ; tfinal byte [ ] json = transcoder . serializeAttributes ( session , session . getAttributesInternal ( ) ) ; tfinal Map < String , Object > readValue = transcoder . deserializeAttributes ( json ) ; tassertEquals ( readValue , session . getAttributesInternal ( ) ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { return doSerialize ( attributes , " attributes " ) ; } 
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] in ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Reading serialized data: " + new String ( in ) ) ; } return doDeserialize ( in , " attributes " ) ; } 
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] data ) { final Kryo kryo = _kryoPool . borrow ( ) ; try { return kryo . readObject ( new Input ( data ) , ConcurrentHashMap . class ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { final Kryo kryo = _kryoPool . borrow ( ) ; try { / * * 
public void testDeserializationError ( ) { Create a class with one simple field: final ClassLoader loaderForCustomClassInVersion1 = ClassGenerationUtil.makeClassLoaderForCustomClass( this.getClass().getClassLoader(), TEST_TYPE_CLASS_NAME, "field1" ); final Object value = makeValueInstance( loaderForCustomClassInVersion1 ); final SessionAttributesTranscoder transcoder = new KryoTranscoderFactory().createTranscoder( loaderForCustomClassInVersion1 ); serialize one instance final MemcachedBackupSession memcachedBackupSession = new MemcachedBackupSession(); final ConcurrentMap<String, Object> attributes = new ConcurrentHashMap<String, Object>(); attributes.put( "test", value ); byte[] data = transcoder.serializeAttributes( memcachedBackupSession, attributes ); final Map<String, Object> deserializeAttributes = transcoder.deserializeAttributes( data ); final Object actual = deserializeAttributes.get( "test" ); assertNotNull(actual); assertDeepEquals(actual, value); create same class with second field final ClassLoader loaderForCustomClassInVersion2 = ClassGenerationUtil.makeClassLoaderForCustomClass( this.getClass().getClassLoader(), TEST_TYPE_CLASS_NAME, "field1", "field2" ); final SessionAttributesTranscoder secondTranscoder = new KryoTranscoderFactory().createTranscoder( loaderForCustomClassInVersion2 ); this should lead to an exception secondTranscoder.deserializeAttributes( data ); } 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { return doSerialize ( attributes ) ; 
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] in ) { final ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; try { @SuppressWarnings ( " unchecked " ) 
private void writeAttributes ( final MemcachedBackupSession session , final Map < String , Object > attributes , final ObjectOutputStream oos ) throws IOException { Accumulate the names of serializable and non-serializable attributes final String keys[] = attributes.keySet().toArray( EMPTY_ARRAY ); final List<String> saveNames = new ArrayList<String>(); final List<Object> saveValues = new ArrayList<Object>(); for ( int i = 0; i < keys.length; i++ ) { final Object value = attributes.get( keys[i] ); if ( value == null || session.exclude( keys[i], value ) ) { continue; } else if ( value instanceof Serializable ) { saveNames.add( keys[i] ); saveValues.add( value ); } else { if ( LOG.isDebugEnabled() ) { LOG.debug( "Ignoring attribute '" + keys[i] + "' as it does not implement Serializable" ); } } } Serialize the attribute count and the Serializable attributes final int n = saveNames.size(); oos.writeObject( Integer.valueOf( n ) ); for ( int i = 0; i < n; i++ ) { oos.writeObject( saveNames.get( i ) ); 
protected boolean exclude ( final String name , Object value ) { return super . exclude ( name , value ) ; } 
public void setup ( ) throws Exception { final StandardContext context = createContext ( ) ; context . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration final SessionManager manager = createSessionManager(context); _service = manager.getMemcachedSessionService(); _service.setMemcachedNodes( "n1:127.0.0.1:11211" ); _service.setSessionBackupAsync( false ); _service.setSticky( true ); _memcachedMock = mock( MemcachedClient.class ); final OperationFuture<Boolean> setResultMock = mock( OperationFuture.class ); when( setResultMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any() ) ).thenReturn( setResultMock ); final OperationFuture<Boolean> deleteResultMock = mock( OperationFuture.class ); when( deleteResultMock.get() ).thenReturn( Boolean.TRUE ); when( _memcachedMock.delete( anyString() ) ).thenReturn( deleteResultMock ); startInternal( manager, _memcachedMock ); _executor = Executors.newCachedThreadPool(); 
protected abstract SessionManager createSessionManager ( Context context ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(TimeUnit.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public void setup ( ) throws LifecycleException , ClassNotFoundException , IOException { _manager = mock ( SessionManager . class ) ; final Context context = new StandardContext ( ) ; when ( _manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession Manager.getContainer no longer available in tc 8.5+ if(_managerHasGetContainer) { when( _manager.getContainer() ).thenReturn( context ); } when( _manager.newMemcachedBackupSession() ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return newMemcachedBackupSession( _manager ); } }); final MemcachedSessionService service = new DummyMemcachedSessionService<SessionManager>( _manager ); when( _manager.createSession( anyString() ) ).thenAnswer(new Answer<MemcachedBackupSession>() { @Override public MemcachedBackupSession answer(final InvocationOnMock invocation) throws Throwable { return createSession(service); } }); when( _manager.readPrincipal( (ObjectInputStream)any() ) ).thenReturn( createPrincipal() ); when( _manager.getMemcachedSessionService() ).thenReturn( service ); when( _manager.willAttributeDistribute(anyString(), any())).thenReturn(true); 
public void testDeserializeHibernateCollection ( ) { final SessionManager manager = createSessionManager ( ) ; final Set < Animal > animals = new HashSet < Animal > ( Arrays . asList ( new Animal ( " cat " ) ) ) ; final Person person = new Person ( " foo bar " , animals ) ; final Long personId = createPerson ( person ) ; final Person foundPerson = findPerson ( personId ) ; LOG . info ( " person: " + person . toString ( ) ) ; LOG . info ( " found: " + foundPerson . toString ( ) ) ; TestUtils . assertDeepEquals ( person , foundPerson ) ; final TranscoderService transcoderService = new TranscoderService ( createTranscoder ( manager ) ) ; final MemcachedBackupSession session = createSession ( manager , " 123456789 " ) ; session . setAttribute ( " person " , foundPerson ) ; final byte [ ] data = transcoderService . serialize ( session ) ; final MemcachedBackupSession deserialized = transcoderService . deserialize ( data , manager ) ; final Person deserializedPerson = ( Person ) deserialized . getAttribute ( " person " ) ; TestUtils . assertDeepEquals ( foundPerson , deserializedPerson ) ; 
protected abstract SessionAttributesTranscoder createTranscoder ( SessionManager manager ) ; private Person findPerson ( final Long personId ) { final Person foundPerson = withSession ( new Callback < Person > ( ) { @Override public Person execute ( final Session session ) { final Criteria crit = session . createCriteria ( Person . class ) . add ( Restrictions . idEq ( personId ) ) ; @SuppressWarnings ( " unchecked " ) final List < Person > list = crit . list ( ) ; Assert . assertEquals ( list . size ( ) , 1 ) ; final Person result = list . get ( 0 ) ; Hibernate . initialize ( result . animals ) ; return result ; } } ) ; return foundPerson ; } private Long createPerson ( final Person person ) { final Long personId = withSession ( new Callback < Long > ( ) { @Override public Long execute ( final Session session ) { return ( Long ) session . save ( person ) ; } } ) ; return personId ; } @Entity ( name = " persons " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Person implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; @OneToMany ( cascade = CascadeType . ALL ) public Set < Animal > animals ; public Person ( ) { } public Person ( final String name , final Set < Animal > animals ) { this . name = name ; this . animals = animals ; } @Override public String toString ( ) { return " Person [id= " + id + " , name= " + name + " , animals= " + animals + " ] " ; } } @Entity ( name = " animals " ) @AttributeAccessor ( " field " ) @SuppressWarnings ( " serial " ) static class Animal implements Serializable { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) public Long id ; public String name ; public Animal ( ) { } public Animal ( final String name ) { this . name = name ; } @Override public String toString ( ) { return " Animal [id= " + id + " , name= " + name + " ] " ; } } static interface Callback < T > { T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = createContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession when( manager.getContainer() ).thenReturn(context); needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); when( manager.willAttributeDistribute(anyString(), anyObject())).thenReturn(true); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
T execute ( Session session ) ; } < T > T withSession ( final Callback < T > callback ) { final Session session = _sessionFactory . openSession ( ) ; Transaction transaction = null ; try { transaction = session . beginTransaction ( ) ; final T result = callback . execute ( session ) ; transaction . commit ( ) ; return result ; } catch ( final HibernateException e ) { if ( transaction ! = null ) { transaction . rollback ( ) ; } throw new RuntimeException ( e ) ; } finally { session . close ( ) ; } } @Nonnull protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = createContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession when( manager.getContainer() ).thenReturn(context); needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); when( manager.willAttributeDistribute(anyString(), anyObject())).thenReturn(true); return manager; } protected MemcachedSessionService newMemcachedSessionService(final SessionManager manager) { return new MemcachedSessionService(manager); } private static MemcachedBackupSession createSession( final SessionManager manager, final String id ) { final MemcachedBackupSession session = manager.getMemcachedSessionService().createEmptySession(); session.setId( id ); session.setValid( true ); return session; }} 
protected SessionManager createSessionManager ( ) { final SessionManager manager = mock ( SessionManager . class ) ; final StandardContext context = createContext ( ) ; when ( manager . getContext ( ) ) . thenReturn ( context ) ; needed for createSession when( manager.getContainer() ).thenReturn(context); needed for createSession when( manager.getMemcachedSessionService() ).thenReturn(newMemcachedSessionService(manager)); when( manager.newMemcachedBackupSession() ).thenReturn( new MemcachedBackupSession( manager ) ); when( manager.willAttributeDistribute(anyString(), anyObject())).thenReturn(true); return manager; } 
public boolean contextHasFormBasedSecurityConstraint ( ) { if ( _contextHasFormBasedSecurityConstraint ! = null ) { return _contextHasFormBasedSecurityConstraint . booleanValue ( ) ; } final Context context = getContext ( ) ; final SecurityConstraint [ ] constraints = context . findConstraints ( ) ; final LoginConfig loginConfig = context . getLoginConfig ( ) ; _contextHasFormBasedSecurityConstraint = constraints ! = null & & constraints . length > 0 & & loginConfig ! = null & & Constants . FORM_METHOD . equals ( loginConfig . getAuthMethod ( ) ) ; return _contextHasFormBasedSecurityConstraint ; } 
protected SessionManager createSessionManager ( Context context ) { MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContainer ( context ) ; return manager ; } 
protected SessionManager createSessionManager ( Context context ) { MemcachedBackupSessionManager manager = new MemcachedBackupSessionManager ( ) ; manager . setContext ( context ) ; return manager ; } 
protected String generateCookieString ( javax . servlet . http . Cookie cookie ) { return COOKIE_PROCESSOR . generateHeader ( cookie ) ; } 
public boolean isMaxInactiveIntervalSet ( ) { return _maxInactiveInterval ! = null ; } 
protected boolean exclude ( final String name , Object value ) { try { if ( legacySessionExcludeMethod ! = null ) { 
protected StorageClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { return null ; } 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final StorageClient memcached , @Nonnull final MemcachedSessionService manager , @Nonnull final MemcachedNodesManager memcachedNodesManager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup , @Nonnull final Statistics stats , @Nonnull final CurrentRequest currentRequest ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : 
protected SessionValidityInfo loadSessionValidityInfoForValidityKey ( @Nonnull final String validityInfoKey ) { final byte [ ] validityInfo = _memcached . get ( validityInfoKey ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; } 
private boolean pingSession ( @Nonnull final String sessionId ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( _storageKeyFormat . format ( sessionId ) , 1 , BYTE_1 ) ; try { if ( touchResult . get ( ) ) { 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _memcached . add ( _storageKeyFormat . format ( session . getIdInternal ( ) ) , 5 , BYTE_1 ) ; try { if ( touchResult . get ( ) ) { 
private void pingSessionBackup ( @Nonnull final MemcachedBackupSession session ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( session . getId ( ) ) ; final Future < Boolean > touchResultFuture = _memcached . add ( key , 5 , BYTE_1 ) ; try { final boolean touchResult = touchResultFuture . get ( _manager . getOperationTimeout ( ) , TimeUnit . MILLISECONDS ) ; 
private boolean pingSessionBackup ( @Nonnull final String sessionId ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( sessionId ) ; final Future < Boolean > touchResultFuture = _memcached . add ( key , 1 , BYTE_1 ) ; try { final boolean touchResult = touchResultFuture . get ( 200 , TimeUnit . MILLISECONDS ) ; 
protected StorageClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final long maxReconnectDelay , final Statistics statistics ) { try { if ( memcachedNodesManager . isRedisConfig ( ) ) { 
public static MemcachedNodesManager createFor ( final String memcachedNodes , final String failoverNodes , final StorageKeyFormat storageKeyFormat , final MemcachedClientCallback memcachedClientCallback ) { tif ( memcachedNodes = = null | | memcachedNodes . trim ( ) . isEmpty ( ) ) { tthrow new IllegalArgumentException ( " null or empty memcachedNodes not allowed. " ) ; } } 
public boolean isRedisConfig ( ) { return _memcachedNodes . startsWith ( " redis: " ) | | _memcachedNodes . startsWith ( " rediss: " ) ; } 
void startInternal ( final MemcachedClient memcachedClient ) throws LifecycleException { if ( memcachedClient = = null ) _memcached = null ; else _memcached = new MemcachedStorageClient ( memcachedClient ) ; startInternal ( ) ; } 
public byte [ ] get ( final String key ) { treturn _memcached . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; } 
protected StorageClient createMemcachedClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } final long maxReconnectDelay = getSystemProperty ( MAX_RECONNECT_DELAY_KEY , 30 ) ; return new MemcachedClientFactory ( ) . createMemcachedClient ( memcachedNodesManager , _memcachedProtocol , _username , _password , _operationTimeout , maxReconnectDelay , statistics ) ; 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final byte [ ] object = _memcached . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { releaseIfLocked ( sessionId , lockStatus ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final TranscoderDeserializationException e ) { _log . warn ( " Could not deserialize session with id " + sessionId + " from memcached, session will be purged from storage. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; _memcached . delete ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; } finally { } return null ; } 
private MemcachedNodesManager reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( _memcached ! = null ) { _memcached . shutdown ( ) ; } _memcached = memcachedClient ; _memcachedNodesManager = memcachedNodesManager ; _backupSessionService = backupSessionService ; initNonStickyLockingMode ( memcachedNodesManager ) ; return memcachedNodesManager ; } 
public Future < Boolean > add ( String key , int exp , byte [ ] o ) { return _memcached . add ( key , exp , o , ByteArrayTranscoder . INSTANCE ) ; } 
public Future < Boolean > set ( String key , int exp , byte [ ] o ) { return _memcached . set ( key , exp , o , ByteArrayTranscoder . INSTANCE ) ; } 
public byte [ ] get ( String key ) { return _memcached . get ( key , ByteArrayTranscoder . INSTANCE ) ; } 
public Future < Boolean > delete ( String key ) { return _memcached . delete ( key ) ; } 
public CachedData encode ( byte [ ] o ) { return new CachedData ( 0 , o , getMaxSize ( ) ) ; } 
public Future < Boolean > add ( final String key , final int exp , final byte [ ] o ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( String . format ( " Adding key to Redis (key=%s, exp=%s, o=%s) " , key , exp , o . getClass ( ) . getName ( ) ) ) ; return _executor . submit ( new RedisCommandCallable < Boolean > ( ) { private volatile boolean _setCompleted ; 
@Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { byte [ ] kb = keyBytes ( key ) ; if ( _setCompleted | | jedis . setnx ( kb , o ) = = 1 ) { _setCompleted = true ; make sure to not call setnx() a second time if connection fails 
public Future < Boolean > set ( final String key , final int exp , final byte [ ] o ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( String . format ( " Setting key in Redis (key=%s, exp=%s, o=%s) " , key , exp , o . getClass ( ) . getName ( ) ) ) ; return _executor . submit ( new RedisCommandCallable < Boolean > ( ) { @Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { 
@Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { if ( exp = = 0 ) return jedis . set ( keyBytes ( key ) , o ) . equals ( " OK " ) ; 
public byte [ ] get ( final String key ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( String . format ( " Getting key from Redis (key=%s) " , key ) ) ; Callable < byte [ ] > callable = new RedisCommandCallable < byte [ ] > ( ) { @Override protected byte [ ] execute ( BinaryJedis jedis ) throws Exception { return jedis . get ( keyBytes ( key ) ) ; } } ; Execute callable synchronously since we need to wait for the result anyway try { return callable.call(); 
@Override protected byte [ ] execute ( BinaryJedis jedis ) throws Exception { return jedis . get ( keyBytes ( key ) ) ; } 
public Future < Boolean > delete ( final String key ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( String . format ( " Deleting key in Redis (key=%s) " , key ) ) ; return _executor . submit ( new RedisCommandCallable < Boolean > ( ) { @Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { 
@Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { return jedis . del ( keyBytes ( key ) ) = = 1 ; } 
private static int convertExp ( int exp ) { if ( exp < = 60 * 60 * 24 * 30 ) thirty days return exp; 
private static byte [ ] keyBytes ( String key ) { return key . getBytes ( StandardCharsets . UTF_8 ) ; } 
public T call ( ) throws Exception { BinaryJedis jedis = null ; Borrow an instance from Jedis without checking it for performance reasons and execute the command on it try { jedis = _pool.borrowInstance(false); return execute(jedis); } catch (JedisConnectionException e) { Connection error occurred with this Jedis connection, so now make sure to get a known-good one The old connection is not given back to the pool since it is defunct anyway if (_log.isDebugEnabled()) _log.debug("Connection error occurred, discarding Jedis connection: " + e.getMessage()); jedis = null; } finally { if (jedis != null) _pool.returnInstance(jedis); } Try to execute the command again with a known-good instance try { jedis = _pool.borrowInstance(true); 
protected abstract T execute ( BinaryJedis jedis ) throws Exception ; } private class JedisPool { private List < BinaryJedis > _instances = new ArrayList < BinaryJedis > ( ) ; public BinaryJedis borrowInstance ( boolean knownGood ) { synchronized ( _instances ) { if ( _instances . isEmpty ( ) ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( String . format ( " Creating new Jedis instance (host=%s, port=%s, ssl=%s) " , _host , _port , _ssl ) ) ; } return createJedisInstance ( ) ; } else { if ( knownGood ) { Check all existing connections until we find a good one BinaryJedis jedis; do { jedis = _instances.remove(_instances.size() - 1); try { jedis.ping(); if (_log.isDebugEnabled()) _log.debug(String.format("Using known-good connection #%d", _instances.size())); return jedis; } catch (Exception e) { if (_log.isDebugEnabled()) { _log.debug(String.format("Removing connection #%d since it cannot be pinged", _instances.size())); } } } while (!_instances.isEmpty()); No existing connections are good, so create new one if (_log.isDebugEnabled()) { _log.debug(String.format("Creating new Jedis instance (host=%s, port=%s, ssl=%s) since all existing connections were bad", _host, _port, _ssl)); } return createJedisInstance(); } else { if (_log.isDebugEnabled()) _log.debug(String.format("Using connection #%d", _instances.size() - 1)); return _instances.remove(_instances.size() - 1); } } } } public void returnInstance(BinaryJedis instance) { synchronized (_instances) { _instances.add(instance); if (_log.isDebugEnabled()) _log.debug(String.format("Returned instance #%d", _instances.size() - 1)); } } public void shutdown() { synchronized (_instances) { if (_log.isDebugEnabled()) _log.debug(String.format("Closing %d remaining Jedis instance(s)", _instances.size())); for (BinaryJedis jedis: _instances) { try { jedis.close(); } catch (Exception e) { } } _instances.clear(); } } private BinaryJedis createJedisInstance() { return new BinaryJedis(_host, _port, _ssl); } }} 
public BinaryJedis borrowInstance ( boolean knownGood ) { synchronized ( _instances ) { if ( _instances . isEmpty ( ) ) { 
public void returnInstance ( BinaryJedis instance ) { synchronized ( _instances ) { _instances . add ( instance ) ; 
public void shutdown ( ) { synchronized ( _instances ) { if ( _log . isDebugEnabled ( ) ) 
private BinaryJedis createJedisInstance ( ) { return new BinaryJedis ( _host , _port , _ssl ) ; } 
Future < Boolean > add ( String key , int exp , byte [ ] o ) ; void shutdown ( ) ; } 
Future < Boolean > set ( String key , int exp , byte [ ] o ) ; void shutdown ( ) ; } 
byte [ ] get ( String key ) ; void shutdown ( ) ; } 
Future < Boolean > delete ( String key ) ; void shutdown ( ) ; } 
public void testBackupSessionInCouchbase ( ) throws InterruptedException , ExecutionException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( mc . get ( sessionId , ByteArrayTranscoder . INSTANCE ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; } 
public void testBackupSessionInCouchbaseCluster ( ) throws Exception { final MemcachedSessionService service = _tomcat1 . getService ( ) ; cluster . add ( setupCouchbase ( getMaxCouchbasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupCouchbaseClient ( ) ; waitForReconnect ( service . getMemcached ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( mc . get ( sessionId , ByteArrayTranscoder . INSTANCE ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; } 
public void testGetNextAvailableNodeId ( ) throws IOException { assertNull ( createFor ( " n1:localhost:11211 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) , " n2 " ) ; final MemcachedClientCallback mcc = mock ( MemcachedClientCallback . class ) ; when ( mcc . get ( anyString ( ) ) ) . thenReturn ( null ) ; when ( mcc . get ( endsWith ( " n2 " ) ) ) . thenThrow ( new OperationTimeoutException ( " SimulatedException " ) ) ; assertNull ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212,n3:localhost:11213 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) , " n3 " ) ; } 
public byte [ ] get ( final String key ) { return _memcached . get ( key , ByteArrayTranscoder . INSTANCE ) ; } 
public void setup ( ) throws Exception { final StandardContext context = createContext ( ) ; context . setBackgroundProcessorDelay ( 1 ) ; needed for test of updateExpiration final SessionManager manager = createSessionManager(context); _service = manager.getMemcachedSessionService(); _service.setMemcachedNodes( "n1:127.0.0.1:11211" ); _service.setSessionBackupAsync( false ); _service.setSticky( true ); _memcachedMock = mock( MemcachedClient.class ); final OperationFuture<Boolean> setResultMock = mock( OperationFuture.class ); when( setResultMock.get( ) ).thenReturn( Boolean.TRUE ); when( setResultMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.TRUE ); when( _memcachedMock.set( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( setResultMock ); final OperationFuture<Boolean> deleteResultMock = mock( OperationFuture.class ); when( deleteResultMock.get() ).thenReturn( Boolean.TRUE ); when( _memcachedMock.delete( anyString() ) ).thenReturn( deleteResultMock ); startInternal( manager, _memcachedMock ); _executor = Executors.newCachedThreadPool(); 
protected abstract SessionManager createSessionManager ( Context context ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( _memcachedMock ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setMemcachedClient(_memcachedMock); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(), any(Transcoder.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105 ( ) throws Exception { _service . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . startInternal ( _memcachedMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > futureMock = mock ( OperationFuture . class ) ; when ( futureMock . get ( ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception. " ) ) ) ; when ( futureMock . get ( anyInt ( ) , any ( TimeUnit . class ) ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception. " ) ) ) ; when ( _memcachedMock . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( futureMock ) ; final BackupResult backupResult = _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . FAILURE ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; } 
public void testOnlySendModifiedSessions ( ) throws InterruptedException , ExecutionException { final MemcachedBackupSession session = createSession ( _service ) ; _service.backupSession( session.getIdInternal(), false, null ).get(); verify( _memcachedMock, times( 2 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) ); 
public void testChangeSessionId ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , TimeoutException { _service . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _service . setLockingMode ( LockingMode . NONE , null , false ) ; } final MemcachedBackupSession session = createSession ( _service ) ; session . setAttribute ( " foo " , " bar " ) ; _service . backupSession ( session . getIdInternal ( ) , false , " foo " ) . get ( ) ; final String oldSessionId = session . getId ( ) ; _service . getManager ( ) . changeSessionId ( session ) ; on session backup we specify sessionIdChanged as false as we're not aware of this fact _service.backupSession( session.getIdInternal(), false, "foo" ); remove session with old id and add it with the new id verify( _memcachedMock, times( 1 ) ).delete( eq( oldSessionId ) ); verify( _memcachedMock, times( 1 ) ).set( eq( session.getId() ), anyInt(), any(), any( Transcoder.class ) ); if ( !stickyness.isSticky() ) { Thread.sleep(200l); 
public void testSessionTimeoutUnlimitedWithSessionLoaded ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , LifecycleException { _service . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(_memcachedMock); we must put in our mock again } final MemcachedBackupSession session = createSession( _service ); session.setMaxInactiveInterval( -1 ); session.access(); session.endAccess(); session.setAttribute( "foo", "bar" ); final String sessionId = session.getId(); _service.backupSession( sessionId, false, null ).get(); verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any(), any( Transcoder.class ) ); if ( !stickyness.isSticky() ) { check validity info 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(_memcachedMock); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ), any ( Transcoder.class) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final OperationFuture<Boolean> futureMock = mock( OperationFuture.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( futureMock ); _service.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any(), any( Transcoder.class ) ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _service.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any(), any( Transcoder.class ) ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any(), any( Transcoder.class ) ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any(), any( Transcoder.class ) ); } 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; _service . setMemcachedClient ( _memcachedMock ) ; _service . startInternal ( ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
abstract TestUtils < ? > getTestUtils ( ) ; @BeforeMethod public void setUp ( final Method testMethod ) throws Throwable { redisProvided = Boolean . parseBoolean ( System . getProperty ( " redis.provided " , " false " ) ) ; final int redisPort = Integer . parseInt ( System . getProperty ( " redis.port " , " 16379 " ) ) ; if ( ! redisProvided ) { embeddedRedisServer = new RedisServer ( redisPort ) ; embeddedRedisServer . start ( ) ; } try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " redis:localhost: " + redisPort ) . sticky ( true ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } redisClient = new BinaryJedis ( " localhost " , redisPort ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _tomcat1 . getManager ( ) ) ) ; } @AfterMethod public void tearDown ( ) throws Exception { if ( redisClient ! = null ) { redisClient . close ( ) ; redisClient = null ; } if ( embeddedRedisServer ! = null ) { embeddedRedisServer . stop ( ) ; embeddedRedisServer = null ; } _tomcat1 . stop ( ) ; } @Test public void testBackupSessionInRedis ( ) throws InterruptedException , ExecutionException , UnsupportedEncodingException , ClassNotFoundException , IOException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( redisClient . get ( sessionId . getBytes ( " UTF-8 " ) ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; } private void checkSession ( final MemcachedBackupSession actual , final MemcachedBackupSession expected ) { assertNotNull ( actual ) ; assertEquals ( actual . getId ( ) , expected . getId ( ) ) ; assertEquals ( actual . getAttributesInternal ( ) , expected . getAttributesInternal ( ) ) ; } } 
public void setUp ( final Method testMethod ) throws Throwable { redisProvided = Boolean . parseBoolean ( System . getProperty ( " redis.provided " , " false " ) ) ; final int redisPort = Integer . parseInt ( System . getProperty ( " redis.port " , " 16379 " ) ) ; if ( ! redisProvided ) { embeddedRedisServer = new RedisServer ( redisPort ) ; embeddedRedisServer . start ( ) ; } try { System . setProperty ( " org.apache.catalina.startup.EXIT_ON_INIT_FAILURE " , " true " ) ; _tomcat1 = getTestUtils ( ) . tomcatBuilder ( ) . port ( _portTomcat1 ) . memcachedNodes ( " redis:localhost: " + redisPort ) . sticky ( true ) . buildAndStart ( ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } redisClient = new BinaryJedis ( " localhost " , redisPort ) ; transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( _tomcat1 . getManager ( ) ) ) ; } 
public void tearDown ( ) throws Exception { if ( redisClient ! = null ) { redisClient . close ( ) ; redisClient = null ; } if ( embeddedRedisServer ! = null ) { embeddedRedisServer . stop ( ) ; embeddedRedisServer = null ; } _tomcat1 . stop ( ) ; } 
public void testBackupSessionInRedis ( ) throws InterruptedException , ExecutionException , UnsupportedEncodingException , ClassNotFoundException , IOException { final MemcachedSessionService service = _tomcat1 . getService ( ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( redisClient . get ( sessionId . getBytes ( " UTF-8 " ) ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; } 
public byte [ ] get ( final String key ) { return _client . get ( key , ByteArrayTranscoder . INSTANCE ) ; } 
public void setUp ( final Method testMethod ) throws Exception { redisProvided = Boolean . parseBoolean ( System . getProperty ( " redis.provided " , " false " ) ) ; redisPort = Integer . parseInt ( System . getProperty ( " redis.port " , " 16379 " ) ) ; if ( ! redisProvided ) { embeddedRedisServer = new RedisServer ( redisPort ) ; 
public void tearDown ( ) throws Exception { if ( embeddedRedisServer ! = null ) { embeddedRedisServer . stop ( ) ; 
public void testFunctions ( ) throws Exception { RedisStorageClient client = createClient ( ) ; Add two keys assertTrue(client.add("key1", 0, toBytes("foo")).get()); assertTrue(client.add("key2", 0, toBytes("bar")).get()); Check that the keys have the given value assertEquals("foo", toString(client.get("key1"))); assertEquals("bar", toString(client.get("key2"))); Check difference between add() and set() assertTrue(client.set("key1", 0, toBytes("baz")).get()); assertFalse(client.add("key2", 0, toBytes("zoom")).get()); assertEquals("baz", toString(client.get("key1"))); assertEquals("bar", toString(client.get("key2"))); Delete key, make sure it is not accessible anymore, but other key should still be there assertTrue(client.delete("key1").get()); assertNull(client.get("key1")); assertEquals("bar", toString(client.get("key2"))); client.shutdown(); } 
public void testExpirationSeconds ( ) throws Exception { RedisStorageClient client = createClient ( ) ; Add a key which expires assertTrue(client.add("exp", 2, toBytes("foo")).get()); Wait some time Thread.sleep(1000); Key should still be there assertEquals("foo", toString(client.get("exp"))); Wait some more time Thread.sleep(2000); Now key should be expired assertNull(client.get("exp")); client.shutdown(); } 
public void testExpirationTime ( ) throws Exception { RedisStorageClient client = createClient ( ) ; Add a key which expires assertTrue(client.add("exp", (int)(2 + (System.currentTimeMillis() / 1000)), toBytes("foo")).get()); assertEquals("foo", toString(client.get("exp"))); Wait some time Thread.sleep(1000); Key should still be there assertEquals("foo", toString(client.get("exp"))); Wait some more time Thread.sleep(2000); Now key should be expired assertNull(client.get("exp")); client.shutdown(); } 
public void testAutoReconnect ( ) throws Exception { RedisStorageClient client = createClient ( ) ; Issue a command to create a connection assertTrue(client.add("key1", 0, toBytes("foo")).get()); assertEquals("foo", toString(client.get("key1"))); Stop and start server to close all connections if (!redisProvided) { embeddedRedisServer.stop(); embeddedRedisServer.start(); } If we now issue commands, the old connection is defunct and will be replaced assertTrue(client.add("key1", 0, toBytes("foo")).get()); assertEquals("foo", toString(client.get("key1"))); client.shutdown(); } 
private RedisStorageClient createClient ( ) { return new RedisStorageClient ( " redis:localhost: " + redisPort ) ; } 
private byte [ ] toBytes ( String s ) { return s . getBytes ( StandardCharsets . UTF_8 ) ; } 
private String toString ( byte [ ] bytes ) { return new String ( bytes , StandardCharsets . UTF_8 ) ; } 
private void storeSessionInMemcached ( final MemcachedBackupSession session , final byte [ ] data ) throws InterruptedException , ExecutionException , TimeoutException { final int expirationTime = session . getMemcachedExpirationTimeToSet ( ) ; final long start = System . currentTimeMillis ( ) ; try { final Future < Boolean > future = _storage . set ( 
protected StorageClient createStorageClient ( final MemcachedNodesManager memcachedNodesManager , final Statistics statistics ) { return null ; } 
protected StorageClientCallback createStorageClientCallback ( ) { treturn new StorageClientCallback ( ) { @Override 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nonnull final StorageClient storage , @Nonnull final MemcachedSessionService manager , @Nonnull final MemcachedNodesManager memcachedNodesManager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup , @Nonnull final Statistics stats , @Nonnull final CurrentRequest currentRequest ) { if ( lockingMode = = null ) { return null ; } switch ( lockingMode ) { case ALL : 
protected void acquireLock ( @Nonnull final String sessionId , final long retryInterval , final long maxRetryInterval , final long timeout , final long start ) throws InterruptedException , ExecutionException , TimeoutException { final Future < Boolean > result = _storage . add ( _sessionIdFormat . createLockName ( sessionId ) , 5 , LOCK_VALUE ) ; if ( result . get ( ) . booleanValue ( ) ) { if ( _log . isDebugEnabled ( ) ) { 
protected SessionValidityInfo loadSessionValidityInfoForValidityKey ( @Nonnull final String validityInfoKey ) { final byte [ ] validityInfo = _storage . get ( validityInfoKey ) ; return validityInfo ! = null ? decode ( validityInfo ) : null ; } 
protected void onAfterDeleteFromMemcached ( @Nonnull final String sessionId ) { final long start = System . currentTimeMillis ( ) ; final String validityInfoKey = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; _storage . delete ( validityInfoKey ) ; if ( _storeSecondaryBackup ) { _storage . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; _storage . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; } _stats . registerSince ( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED , start ) ; } 
private boolean pingSession ( @Nonnull final String sessionId ) throws InterruptedException { final Future < Boolean > touchResult = _storage . add ( _storageKeyFormat . format ( sessionId ) , 1 , BYTE_1 ) ; try { if ( touchResult . get ( ) ) { 
private void pingSession ( @Nonnull final MemcachedBackupSession session , @Nonnull final BackupSessionService backupSessionService ) throws InterruptedException { final Future < Boolean > touchResult = _storage . add ( _storageKeyFormat . format ( session . getIdInternal ( ) ) , 5 , BYTE_1 ) ; try { if ( touchResult . get ( ) ) { 
public void saveValidityBackup ( ) { final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; final int maxInactiveInterval = _session . getMaxInactiveInterval ( ) ; fix for #88, along with the change in session.getMemcachedExpirationTimeToSet final int expiration = maxInactiveInterval <= 0 ? 0 : maxInactiveInterval; _storage.set( backupValidityKey, toMemcachedExpiration(expiration), _validityData ); } 
private void pingSessionBackup ( @Nonnull final MemcachedBackupSession session ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( session . getId ( ) ) ; final Future < Boolean > touchResultFuture = _storage . add ( key , 5 , BYTE_1 ) ; try { final boolean touchResult = touchResultFuture . get ( _manager . getOperationTimeout ( ) , TimeUnit . MILLISECONDS ) ; 
public Void call ( ) throws Exception { pingSession ( _sessionId ) ; if ( _storeSecondaryBackup ) { try { pingSessionBackup ( _sessionId ) ; final String backupValidityKey = _sessionIdFormat . createBackupKey ( _validityKey ) ; fix for #88, along with the change in session.getMemcachedExpirationTimeToSet final int expiration = _maxInactiveInterval <= 0 ? 0 : _maxInactiveInterval; _storage.set( backupValidityKey, toMemcachedExpiration(expiration), _validityData ); } catch( final RuntimeException e ) { _log.info( "Could not store secondary backup of session " + _sessionId, e ); } } return null; } 
private boolean pingSessionBackup ( @Nonnull final String sessionId ) throws InterruptedException { final String key = _sessionIdFormat . createBackupKey ( sessionId ) ; final Future < Boolean > touchResultFuture = _storage . add ( key , 1 , BYTE_1 ) ; try { final boolean touchResult = touchResultFuture . get ( 200 , TimeUnit . MILLISECONDS ) ; 
protected NodeAvailabilityCache < String > createNodeAvailabilityCache ( final int size , final long ttlInMillis , @Nonnull final StorageClientCallback storageClientCallback ) { return new NodeAvailabilityCache < String > ( size , ttlInMillis , new CacheLoader < String > ( ) { 
public boolean isNodeAvailable ( final String key ) { try { tstorageClientCallback . get ( _sessionIdFormat . createSessionId ( " ping " , key ) ) ; 
public static MemcachedNodesManager createFor ( final String memcachedNodes , final String failoverNodes , final StorageKeyFormat storageKeyFormat , final StorageClientCallback storageClientCallback ) { tif ( memcachedNodes = = null | | memcachedNodes . trim ( ) . isEmpty ( ) ) { tthrow new IllegalArgumentException ( " null or empty memcachedNodes not allowed. " ) ; } } 
public void shutdown ( ) { _log . info ( " Stopping services. " ) ; _manager . getContext ( ) . getParent ( ) . getPipeline ( ) . removeValve ( _trackingHostValve ) ; _manager . getContext ( ) . getPipeline ( ) . removeValve ( _trackingContextValve ) ; _backupSessionService . shutdown ( ) ; if ( _lockingStrategy ! = null ) { _lockingStrategy . shutdown ( ) ; } if ( _storage ! = null ) { _storage . shutdown ( ) ; _storage = null ; } _transcoderFactory = null ; _invalidSessionsCache . clear ( ) ; } 
void startInternal ( final StorageClient storage ) throws LifecycleException { if ( storage = = null ) _storage = null ; else _storage = storage ; startInternal ( ) ; } 
void startInternal ( ) throws LifecycleException { _log . info ( getClass ( ) . getSimpleName ( ) + " starts initialization... (configured " + " nodes definition " + _memcachedNodes + " , failover nodes " + _failoverNodes + " ) " ) ; _statistics = Statistics . create ( _enableStatistics ) ; _memcachedNodesManager = createMemcachedNodesManager ( _memcachedNodes , _failoverNodes ) ; if ( _storage = = null ) { _storage = createStorageClient ( _memcachedNodesManager , _statistics ) ; } final String sessionCookieName = _manager . getSessionCookieName ( ) ; _currentRequest = new CurrentRequest ( ) ; _trackingHostValve = createRequestTrackingHostValve ( sessionCookieName , _currentRequest ) ; final Context context = _manager . getContext ( ) ; context . getParent ( ) . getPipeline ( ) . addValve ( _trackingHostValve ) ; _trackingContextValve = createRequestTrackingContextValve ( sessionCookieName ) ; context . getPipeline ( ) . addValve ( _trackingContextValve ) ; initNonStickyLockingMode ( _memcachedNodesManager ) ; _transcoderService = createTranscoderService ( _statistics ) ; _backupSessionService = new BackupSessionService ( _transcoderService , _sessionBackupAsync , _sessionBackupTimeout , _backupThreadCount , _storage , _memcachedNodesManager , _statistics ) ; _log . info ( " -------- n- " + getClass ( ) . getSimpleName ( ) + " finished initialization: " + " n- sticky: " + _sticky + 
tprotected StorageClientCallback createStorageClientCallback ( ) { treturn new StorageClientCallback ( ) { @Override 
public byte [ ] get ( final String key ) { treturn _storage . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( key ) ) ; } 
protected MemcachedNodesManager createMemcachedNodesManager ( final String memcachedNodes , final String failoverNodes ) { final Context context = _manager . getContext ( ) ; final String webappVersion = Reflections . invoke ( context , " getWebappVersion " , null ) ; final StorageKeyFormat storageKeyFormat = StorageKeyFormat . of ( _storageKeyPrefix , context . getParent ( ) . getName ( ) , context . getName ( ) , webappVersion ) ; treturn MemcachedNodesManager . createFor ( memcachedNodes , failoverNodes , storageKeyFormat , _storageClientCallback ) ; } 
protected StorageClient createStorageClient ( final MemcachedNodesManager memcachedNodesManager , tfinal Statistics statistics ) { if ( ! _enabled . get ( ) ) { return null ; } final long maxReconnectDelay = getSystemProperty ( MAX_RECONNECT_DELAY_KEY , 30 ) ; return new StorageClientFactory ( ) . createStorageClient ( memcachedNodesManager , _memcachedProtocol , _username , _password , _operationTimeout , maxReconnectDelay , statistics ) ; 
private MemcachedBackupSession loadFromMemcached ( final String sessionId ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Loading session from memcached: " + sessionId ) ; } LockStatus lockStatus = null ; try { if ( ! _sticky ) { lockStatus = _lockingStrategy . onBeforeLoadFromMemcached ( sessionId ) ; } final long start = System . currentTimeMillis ( ) ; final byte [ ] object = _storage . get ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _memcachedNodesManager . onLoadFromMemcachedSuccess ( sessionId ) ; if ( object ! = null ) { final long startDeserialization = System . currentTimeMillis ( ) ; final MemcachedBackupSession result = _transcoderService . deserialize ( object , _manager ) ; _statistics . registerSince ( SESSION_DESERIALIZATION , startDeserialization ) ; _statistics . registerSince ( LOAD_FROM_MEMCACHED , start ) ; result . setSticky ( _sticky ) ; if ( ! _sticky ) { _lockingStrategy . onAfterLoadFromMemcached ( result , lockStatus ) ; } if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Found session with id " + sessionId ) ; } return result ; } else { releaseIfLocked ( sessionId , lockStatus ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; if ( _log . isDebugEnabled ( ) ) { _log . debug ( " Session " + sessionId + " not found in memcached. " ) ; } return null ; } } catch ( final TranscoderDeserializationException e ) { _log . warn ( " Could not deserialize session with id " + sessionId + " from memcached, session will be purged from storage. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; _storage . delete ( _memcachedNodesManager . getStorageKeyFormat ( ) . format ( sessionId ) ) ; _invalidSessionsCache . put ( sessionId , Boolean . TRUE ) ; } catch ( final Exception e ) { _log . warn ( " Could not load session with id " + sessionId + " from memcached. " , e ) ; releaseIfLocked ( sessionId , lockStatus ) ; } finally { } return null ; } 
private MemcachedNodesManager reloadMemcachedConfig ( final String memcachedNodes , final String failoverNodes ) { if ( _storage ! = null ) { _storage . shutdown ( ) ; } _storage = storage ; _memcachedNodesManager = memcachedNodesManager ; _backupSessionService = backupSessionService ; initNonStickyLockingMode ( memcachedNodesManager ) ; return memcachedNodesManager ; } 
protected StorageClient createStorageClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final long maxReconnectDelay , final Statistics statistics ) { try { if ( memcachedNodesManager . isRedisConfig ( ) ) { 
static MemcachedClient createCouchbaseClient ( final MemcachedNodesManager memcachedNodesManager , final String memcachedProtocol , final String username , final String password , final long operationTimeout , final long maxReconnectDelay , final Statistics statistics ) { try { final CouchbaseClientFactory factory = Class . forName ( " de.javakaffee.web.msm.CouchbaseClientFactory " ) . asSubclass ( CouchbaseClientFactory . class ) . newInstance ( ) ; 
public T call ( ) throws Exception { BinaryJedis jedis = null ; Borrow an instance from Jedis without checking it for performance reasons and execute the command on it try { jedis = _pool.borrowInstance(false); return execute(jedis); } catch (JedisConnectionException e) { Connection error occurred with this Jedis connection, so now make sure to get a known-good one The old connection is not given back to the pool since it is defunct anyway if (_log.isDebugEnabled()) _log.debug("Connection error occurred, discarding Jedis connection: " + e.getMessage()); if (jedis != null) try { jedis.close(); } catch (Exception e2) { } jedis = null; } finally { if (jedis != null) _pool.returnInstance(jedis); } Try to execute the command again with a known-good instance try { jedis = _pool.borrowInstance(true); 
protected abstract T execute ( BinaryJedis jedis ) throws Exception ; } private class JedisPool { private Queue < BinaryJedis > _queue = new ConcurrentLinkedQueue < BinaryJedis > ( ) ; public BinaryJedis borrowInstance ( boolean knownGood ) { BinaryJedis res ; if ( ( res = _queue . poll ( ) ) = = null ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( String . format ( " Creating new Jedis instance (host=%s, port=%s, ssl=%s) " , _host , _port , _ssl ) ) ; } return createJedisInstance ( ) ; } if ( knownGood ) { Check all existing connections until we find a good one do { try { res.ping(); if (_log.isTraceEnabled()) _log.trace(String.format("Using known-good connection #%d", _queue.size())); return res; } catch (Exception e) { if (_log.isDebugEnabled()) _log.debug(String.format("Removing connection #%d since it cannot be pinged", _queue.size())); try { res.close(); } catch (Exception e2) { } } } private BinaryJedis createJedisInstance() { return new BinaryJedis(_host, _port, _timeout, _ssl); } }} 
public BinaryJedis borrowInstance ( boolean knownGood ) { BinaryJedis res ; if ( ( res = _queue . poll ( ) ) = = null ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( String . format ( " Creating new Jedis instance (host=%s, port=%s, ssl=%s) " , _host , _port , _ssl ) ) ; } return createJedisInstance ( ) ; } if ( knownGood ) { Check all existing connections until we find a good one 
public void returnInstance ( BinaryJedis instance ) { _queue . offer ( instance ) ; if ( _log . isTraceEnabled ( ) ) _log . trace ( String . format ( " Returned instance #%d " , _queue . size ( ) ) ) ; 
public void shutdown ( ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( String . format ( " Closing %d Jedis instance(s) " , _queue . size ( ) ) ) ; BinaryJedis instance ; while ( ( instance = _queue . poll ( ) ) ! = null ) { try { instance . close ( ) ; } catch ( Exception e ) { } 
private BinaryJedis createJedisInstance ( ) { return new BinaryJedis ( _host , _port , _timeout , _ssl ) ; } 
public void testBackupSessionInCouchbaseCluster ( ) throws Exception { final MemcachedSessionService service = _tomcat1 . getService ( ) ; cluster . add ( setupCouchbase ( getMaxCouchbasePort ( ) + 1 ) ) ; service . setMemcachedNodes ( getMemcachedNodesConfig ( getURIs ( ) ) ) ; setupCouchbaseClient ( ) ; waitForReconnect ( service . getStorageClient ( ) , cluster . size ( ) , 1000 ) ; waitForReconnect ( mc , cluster . size ( ) , 1000 ) ; final MemcachedBackupSession session = createSession ( service ) ; final String sessionId = " 12345 " ; session . setId ( sessionId ) ; session . setAttribute ( " foo " , " bar " ) ; final BackupResult backupResult = service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . SUCCESS ) ; final MemcachedBackupSession loadedSession = transcoderService . deserialize ( mc . get ( sessionId , ByteArrayTranscoder . INSTANCE ) , _tomcat1 . getManager ( ) ) ; checkSession ( loadedSession , session ) ; } 
private void waitForReconnect ( final StorageClient client , final int expectedServers , final long timeToWait ) throws InterruptedException , RuntimeException { waitForReconnect ( ( ( MemcachedStorageClient ) client ) . getMemcachedClient ( ) , expectedServers , timeToWait ) ; } 
public void testGetNextAvailableNodeId ( ) throws IOException { assertNull ( createFor ( " n1:localhost:11211 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , _mcc ) . getNextAvailableNodeId ( " n1 " ) , " n2 " ) ; final StorageClientCallback mcc = mock ( StorageClientCallback . class ) ; when ( mcc . get ( anyString ( ) ) ) . thenReturn ( null ) ; when ( mcc . get ( endsWith ( " n2 " ) ) ) . thenThrow ( new OperationTimeoutException ( " SimulatedException " ) ) ; assertNull ( createFor ( " n1:localhost:11211,n2:localhost:11212 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) ) ; assertEquals ( createFor ( " n1:localhost:11211,n2:localhost:11212,n3:localhost:11213 " , null , null , mcc ) . getNextAvailableNodeId ( " n1 " ) , " n3 " ) ; } 
private MemcachedClient createMemcachedClient ( final String memcachedNodes , final InetSocketAddress address ) throws IOException , InterruptedException { final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( memcachedNodes , null , null , _storageClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; final MemcachedClient result = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; Wait a little bit, so that the memcached client can connect and is ready when test starts Thread.sleep( 100 ); return result; } 
public void testNotAssociatedSessionGetsAssociatedIssue49 ( ) throws InterruptedException , IOException , ExecutionException , TimeoutException { _daemon . stop ( ) ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setSticky ( true ) ; final SessionIdFormat sessionIdFormat = new SessionIdFormat ( ) ; final Session session = manager . createSession ( null ) ; assertNull ( sessionIdFormat . extractMemcachedId ( session . getId ( ) ) ) ; _daemon . start ( ) ; Wait so that the daemon will be available and the client can reconnect (async get didn't do the trick) waitForReconnect(manager.getMemcachedSessionService().getStorageClient(), 1, 4000); final String newSessionId = manager.getMemcachedSessionService().changeSessionIdOnMemcachedFailover( session.getId() ); assertNotNull( newSessionId ); assertEquals( newSessionId, session.getId() ); assertEquals( sessionIdFormat.extractMemcachedId( newSessionId ), _memcachedNodeId ); 
protected abstract SessionManager createSessionManager ( Context context ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setStorageClient(new MemcachedStorageClient(_memcachedMock)); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(), any(Transcoder.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(new MemcachedStorageClient(_memcachedMock)); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } 
public void testConfigurationFormatMemcachedNodesFeature105 ( ) throws LifecycleException { _service . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , true ) ; _service . shutdown ( ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . getCountNodes ( ) , 1 ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isEncodeNodeIdInSessionId ( ) , true ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456 " ) , false ) ; assertEquals ( _service . getMemcachedNodesManager ( ) . isValidForMemcached ( " 123456-n1 " ) , true ) ; } 
public void testBackupSessionFailureWithoutMemcachedNodeIdConfigured105 ( ) throws Exception { _service . setMemcachedNodes ( " 127.0.0.1:11211 " ) ; _service . setSessionBackupAsync ( false ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; final MemcachedBackupSession session = createSession ( _service ) ; session . access ( ) ; session . endAccess ( ) ; session . setAttribute ( " foo " , " bar " ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > futureMock = mock ( OperationFuture . class ) ; when ( futureMock . get ( ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception. " ) ) ) ; when ( futureMock . get ( anyInt ( ) , any ( TimeUnit . class ) ) ) . thenThrow ( new ExecutionException ( new RuntimeException ( " Simulated exception. " ) ) ) ; when ( _memcachedMock . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( futureMock ) ; final BackupResult backupResult = _service . backupSession ( session . getIdInternal ( ) , false , null ) . get ( ) ; assertEquals ( backupResult . getStatus ( ) , BackupResultStatus . FAILURE ) ; verify ( _memcachedMock , times ( 1 ) ) . set ( eq ( session . getId ( ) ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ; } 
public void testSessionTimeoutUnlimitedWithSessionLoaded ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , LifecycleException { _service . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(new MemcachedStorageClient(_memcachedMock)); we must put in our mock again } final MemcachedBackupSession session = createSession( _service ); session.setMaxInactiveInterval( -1 ); session.access(); session.endAccess(); session.setAttribute( "foo", "bar" ); final String sessionId = session.getId(); _service.backupSession( sessionId, false, null ).get(); verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any(), any( Transcoder.class ) ); if ( !stickyness.isSticky() ) { check validity info 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(new MemcachedStorageClient(_memcachedMock)); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ), any ( Transcoder.class) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final OperationFuture<Boolean> futureMock = mock( OperationFuture.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( futureMock ); _service.backupSession( sessionId, false, null ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any(), any( Transcoder.class ) ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _service.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any(), any( Transcoder.class ) ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any(), any( Transcoder.class ) ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any(), any( Transcoder.class ) ); } 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; _service . setStorageClient ( new MemcachedStorageClient ( _memcachedMock ) ) ; _service . startInternal ( ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137 ( ) throws Exception { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); } 
private void waitForReconnect ( final MemcachedSessionService service , final MemCacheDaemon < ? > value , final long timeToWait ) throws InterruptedException { MemcachedClient client ; InetSocketAddress serverAddress ; try { final Method m = MemcachedSessionService . class . getDeclaredMethod ( " getStorageClient " ) ; m . setAccessible ( true ) ; client = ( ( MemcachedStorageClient ) m . invoke ( service ) ) . getMemcachedClient ( ) ; final Field field = MemCacheDaemon . class . getDeclaredField ( " addr " ) ; field . setAccessible ( true ) ; serverAddress = ( InetSocketAddress ) field . get ( value ) ; } catch ( final Exception e ) { throw new RuntimeException ( e ) ; } waitForReconnect ( client , serverAddress , timeToWait ) ; } 
public void testCookieNotSetWhenRegularMemcachedDownIssue40 ( final SessionAffinityMode sessionAffinity ) throws Exception { _daemon2 . stop ( ) ; TestUtils . waitForReconnect ( _tomcat1 . getService ( ) . getStorageClient ( ) , 1 , 1000l ) ; final Response response1 = get ( _httpClient , _portTomcat1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertNotNull ( response1 . getResponseSessionId ( ) ) ; final String nodeId = extractNodeId ( response1 . getResponseSessionId ( ) ) ; assertEquals ( nodeId , _nodeId1 ) ; final Response response2 = get ( _httpClient , _portTomcat1 , sessionId ) ; assertEquals ( response2 . getSessionId ( ) , sessionId , " SessionId changed " ) ; assertNull ( response2 . getResponseSessionId ( ) ) ; 
public void setUp ( ) throws Throwable { final InetSocketAddress address1 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_1 ) ; _daemon1 = createDaemon ( address1 ) ; _daemon1 . start ( ) ; final InetSocketAddress address2 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_2 ) ; _daemon2 = createDaemon ( address2 ) ; _daemon2 . start ( ) ; try { _tomcat1 = startTomcat ( TC_PORT_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( MEMCACHED_NODES , null , null , _storageClientCallback ) ; _client = new MemcachedClient ( new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) , Arrays . asList ( address1 , address2 ) ) ; final SchemeRegistry schemeRegistry = new SchemeRegistry ( ) ; schemeRegistry . register ( new Scheme ( " http " , 80 , PlainSocketFactory . getSocketFactory ( ) ) ) ; _httpClient = new DefaultHttpClient ( new ThreadSafeClientConnManager ( schemeRegistry ) ) ; _executor = Executors . newCachedThreadPool ( ) ; } 
public void testNonStickySessionSecondaryBackupFailover ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getStorageClient ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; final SessionIdFormat fmt = new SessionIdFormat ( ) ; final String nodeId = fmt . extractMemcachedId ( sessionId1 ) ; final MemCacheDaemon < ? > first = memcachedsByNodeId . get ( nodeId ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( fmt.createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); Request / Update final String sessionId2 = post( _httpClient, TC_PORT_1, sessionId1, "key", "v2" ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Wait for update of nodeAvailabilityNodeCache Thread.sleep(100l); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v2"); 
public void testNonStickySessionSecondaryBackupFailoverForSkippedUpdate ( ) throws IOException , InterruptedException , HttpException { final InetSocketAddress address3 = new InetSocketAddress ( " localhost " , MEMCACHED_PORT_3 ) ; _daemon3 = createDaemon ( address3 ) ; _daemon3 . start ( ) ; final String memcachedNodes = MEMCACHED_NODES + " , " + NODE_ID_3 + " :localhost: " + MEMCACHED_PORT_3 ; final SessionManager manager = _tomcat1 . getManager ( ) ; manager . setMaxInactiveInterval ( 5 ) ; manager . setMemcachedNodes ( memcachedNodes ) ; manager . getMemcachedSessionService ( ) . setSessionBackupAsync ( false ) ; waitForReconnect ( manager . getMemcachedSessionService ( ) . getStorageClient ( ) , 3 , 1000 ) ; final NodeIdList nodeIdList = NodeIdList . create ( NODE_ID_1 , NODE_ID_2 , NODE_ID_3 ) ; final Map < String , MemCacheDaemon < ? > > memcachedsByNodeId = new HashMap < String , MemCacheDaemon < ? > > ( ) ; memcachedsByNodeId . put ( NODE_ID_1 , _daemon1 ) ; memcachedsByNodeId . put ( NODE_ID_2 , _daemon2 ) ; memcachedsByNodeId . put ( NODE_ID_3 , _daemon3 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " key " , " v1 " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; the memcached client writes async, so it's ok to wait a little bit (especially on windows) final SessionIdFormat fmt = new SessionIdFormat(); final String nodeId = fmt.extractMemcachedId( sessionId1 ); final MemCacheDaemon<?> first = memcachedsByNodeId.get(nodeId); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( sessionId1 ) ); assertNotNullElementWaitingWithProxy(0, 100, first.getCache()).get( key( fmt.createValidityInfoKeyName( sessionId1 ) ) ); The executor needs some time to finish the backup... final MemCacheDaemon<?> second = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeId)); assertNotNullElementWaitingWithProxy(0, 4000, second.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, second.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the secondary memcached, so that the next backup should got to the next node second.stop(); Thread.sleep(100); Request / Update final String sessionId2 = get( _httpClient, TC_PORT_1, sessionId1 ).getSessionId(); assertEquals( sessionId2, sessionId1 ); final MemCacheDaemon<?> third = memcachedsByNodeId.get(nodeIdList.getNextNodeId(nodeIdList.getNextNodeId(nodeId))); assertNotNullElementWaitingWithProxy(0, 4000, third.getCache()).get( key( fmt.createBackupKey( sessionId1 ) ) ); assertNotNullElementWaitingWithProxy(0, 200, third.getCache()).get( key( fmt.createBackupKey( fmt.createValidityInfoKeyName( sessionId1 ) ) ) ); Shutdown the first node, so it should be loaded from the 3rd memcached first.stop(); Thread.sleep(100); final Response response3 = get(_httpClient, TC_PORT_1, sessionId1); final String sessionId3 = response3.getResponseSessionId(); assertNotNull(sessionId3); assertFalse(sessionId3.equals(sessionId1)); assertEquals(sessionId3, fmt.createNewSessionId(sessionId1, fmt.extractMemcachedId(sessionId3))); assertEquals(response3.get("key"), "v1"); 
public void testSessionNotLoadedForNoSessionAccess ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getStorageClient ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; 2 for session and validity, if backup would be stored this would be 4 instead assertWaitingWithProxy(equalTo(2), 1000, _daemon1.getCache()).getSetCmds(); no gets at all assertEquals( _daemon1.getCache().getGetHits(), 0 ); a request without session access should not pull the session from memcached but update the validity info (get + set) get( _httpClient, TC_PORT_1, PATH_NO_SESSION_ACCESS, sessionId1 ); assertWaitingWithProxy(equalTo(3), 1000, _daemon1.getCache()).getSetCmds(); For TC7 the session is looked up by AuthenticatorBase.invoke(AuthenticatorBase.java:430) (TC 7.0.67) which seems to be installed and always check the user principal - therefore we have 2 hits for the session and the validity info. And we want to allow context level valves to access the session (issue #286), therefore we load the session even if our context valve has not been passed (i.e. findSession is not directly triggered from the webapp). For TC{6,8} there's no call from AuthenticatorBase, so there's only 1 hit (validity info) assertEquals( _daemon1.getCache().getGetHits(), getExpectedHitsForNoSessionAccess()); } 
public void testFormAuthDontCauseSessionStaleness ( ) throws Exception { _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _tomcat1 = startTomcatWithAuth ( TC_PORT_1 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat2 = startTomcatWithAuth ( TC_PORT_2 , NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 , LockingMode . AUTO , LoginType . FORM ) ; _tomcat1 . setChangeSessionIdOnAuth ( false ) ; _tomcat2 . setChangeSessionIdOnAuth ( false ) ; waitForReconnect ( _tomcat1 . getService ( ) . getStorageClient ( ) , 1 , 1000 ) ; waitForReconnect ( _tomcat2 . getService ( ) . getStorageClient ( ) , 1 , 1000 ) ; final Response response1 = get ( _httpClient , TC_PORT_1 , null ) ; final String sessionId = response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( response1 . getContent ( ) . contains ( " j_security_check " ) , " IllegalState: /j_security_check not found, app is not properly initialized " ) ; Wait some time so that the GET is finished Thread.sleep(200); final Map<String, String> params = new HashMap<String, String>(); params.put( LoginServlet.J_USERNAME, TestUtils.USER_NAME ); params.put( LoginServlet.J_PASSWORD, TestUtils.PASSWORD ); final Response response2 = post( _httpClient, TC_PORT_2, "/j_security_check", sessionId, params, null, true ); assertNull(response2.getResponseSessionId()); assertEquals(response2.getStatusCode(), 200, response2.getContent()); assertEquals(response2.get( TestServlet.ID ), sessionId); final Response response3 = post( _httpClient, TC_PORT_2, "/", sessionId, asMap( "foo", "bar" )); assertEquals(response3.getSessionId(), sessionId); final Response response4 = get(_httpClient, TC_PORT_1, sessionId); assertEquals(response4.getSessionId(), sessionId); assertEquals(response4.get( TestServlet.ID ), sessionId); assertEquals(response4.get( "foo" ), "bar"); 
public static void waitForReconnect ( final StorageClient client , final int expectedNumServers , final long timeToWait ) throws InterruptedException { waitForReconnect ( ( ( MemcachedStorageClient ) client ) . getMemcachedClient ( ) , expectedNumServers , timeToWait ) ; } 
public void setUp ( final Method testMethod ) throws Throwable { final InetSocketAddress address = new InetSocketAddress ( " localhost " , MEMCACHED_PORT ) ; _daemon = createDaemon ( address ) ; _daemon . start ( ) ; final String [ ] testGroups = testMethod . getAnnotation ( Test . class ) . groups ( ) ; final String nodePrefix = testGroups . length = = 0 | | ! GROUP_WITHOUT_NODE_ID . equals ( testGroups [ 0 ] ) ? NODE_ID + " : " : " " ; _memcachedNodes = nodePrefix + " localhost: " + MEMCACHED_PORT ; try { _tomcat1 = startTomcat ( TC_PORT_1 , JVM_ROUTE_1 ) ; _tomcat2 = startTomcat ( TC_PORT_2 , JVM_ROUTE_2 ) ; } catch ( final Throwable e ) { LOG . error ( " could not start tomcat. " , e ) ; throw e ; } final MemcachedNodesManager nodesManager = MemcachedNodesManager . createFor ( _memcachedNodes , null , null , _storageClientCallback ) ; final ConnectionFactory cf = nodesManager . isEncodeNodeIdInSessionId ( ) ? new SuffixLocatorConnectionFactory ( nodesManager , nodesManager . getSessionIdFormat ( ) , Statistics . create ( ) , 1000 , 1000 ) : new DefaultConnectionFactory ( ) ; _client = new MemcachedClient ( cf , Arrays . asList ( address ) ) ; _httpClient = new DefaultHttpClient ( ) ; } 
private RedisStorageClient createClient ( ) { return new RedisStorageClient ( " redis:localhost: " + redisPort , 1000 ) ; } 
protected void startInternal ( final StorageClient storageClient ) throws LifecycleException { _msm . setStorageClient ( storageClient ) ; _msm . startInternal ( ) ; } 
protected void startInternal ( final SessionManager manager , final MemcachedClient memcachedMock ) throws LifecycleException { ( ( MemcachedBackupSessionManager ) manager ) . startInternal ( new MemcachedStorageClient ( memcachedMock ) ) ; } ; 
protected void startInternal ( final SessionManager manager , final MemcachedClient memcachedMock ) throws LifecycleException { manager . getMemcachedSessionService ( ) . setStorageClient ( new MemcachedStorageClient ( memcachedMock ) ) ; ( ( MemcachedBackupSessionManager ) manager ) . start ( ) ; } 
protected abstract String [ ] getSetCookieHeaders ( final Response response ) ; private void logDebugResponseCookie ( final Response response ) { final Collection < String > headers = response . getHeaders ( " Set-Cookie " ) ; if ( headers ! = null ) { for ( final String header : headers ) { if ( header ! = null & & header . contains ( _sessionCookieName ) ) { _log . debug ( " Request finished, with Set-Cookie header: " + header ) ; } } } } } 
private void logDebugResponseCookie ( final Response response ) { final Collection < String > headers = response . getHeaders ( " Set-Cookie " ) ; if ( headers ! = null ) { for ( final String header : headers ) { 
private KryoFactory createKryoFactory ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { KryoBuilder kryoBuilder = new KryoBuilder ( ) { @Override protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return KryoTranscoder . this . createKryo ( classResolver , referenceResolver , streamFactory , classLoader , customConverterClassNames , copyCollectionsForSerialization ) ; } } . withInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; final List < KryoBuilderConfiguration > builderConfigs = load ( KryoBuilderConfiguration . class , customConverterClassNames , classLoader ) ; for ( KryoBuilderConfiguration config : builderConfigs ) { kryoBuilder = config . configure ( kryoBuilder ) ; } final KryoBuilder finalKryoBuilder = kryoBuilder ; return new KryoFactory ( ) { @Override 
public Kryo create ( ) { Kryo kryo = finalKryoBuilder . build ( ) ; kryo . setDefaultSerializer ( new KryoDefaultSerializerFactory . SerializerFactoryAdapter ( _defaultSerializerFactory ) ) ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationRequired(false); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer() ); kryo.register(InvocationHandler.class, new JdkProxySerializer()); UnmodifiableCollectionsSerializer.registerSerializers(kryo); SynchronizedCollectionsSerializer.registerSerializers(kryo); kryo.addDefaultSerializer(EnumMap.class, EnumMapSerializer.class); SubListSerializers.addDefaultSerializers(kryo); final List<KryoCustomization> customizations = load(KryoCustomization.class, customConverterClassNames, classLoader, kryo); if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return kryo; } 
public Kryo build ( ) { return createKryo ( classResolver ! = null ? classResolver : new DefaultClassResolver ( ) , 
protected Kryo buildFrom ( KryoBuilder target ) { we must transfer local fields to the target which creates the Kryo instance. yes, it's a bit hackish, but if s.o. calls the same method twice with different arguments it's kind of bullshit in... if(target.classResolver == null) target.classResolver = classResolver; if(target.referenceResolver == null) target.referenceResolver = referenceResolver; if(target.streamFactory == null) target.streamFactory = streamFactory; return target.build(); } 
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setRegistrationRequired ( registrationRequired ) ; return k ; } 
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setInstantiatorStrategy ( instantiatorStrategy ) ; return k ; } 
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . setReferences ( references ) ; return k ; } 
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; kryoCustomization . customize ( k ) ; return k ; } 
public static Object [ ] [ ] buildKryoProvider ( ) { treturn new Object [ ] [ ] { { new BuildKryo ( " customizationsFirst " ) { 
tKryo build ( DefaultClassResolver classResolver , MapReferenceResolver referenceResolver , DefaultStreamFactory streamFactory , InstantiatorStrategy instantiatorStrategy , KryoCustomization enableAsm , KryoCustomization registerMyCollectionSerializer ) { treturn new KryoBuilder ( ) . withKryoCustomization ( enableAsm ) 
tKryo build ( DefaultClassResolver classResolver , MapReferenceResolver referenceResolver , DefaultStreamFactory streamFactory , InstantiatorStrategy instantiatorStrategy , KryoCustomization enableAsm , KryoCustomization registerMyCollectionSerializer ) { treturn new KryoBuilder ( ) . withClassResolver ( classResolver ) 
public void testKryoBuilder ( BuildKryo buildKryo ) { tDefaultClassResolver classResolver = new DefaultClassResolver ( ) ; tMapReferenceResolver referenceResolver = new MapReferenceResolver ( ) ; tDefaultStreamFactory streamFactory = new DefaultStreamFactory ( ) ; tInstantiatorStrategy instantiatorStrategy = new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ; tKryoCustomization enableAsm = new KryoCustomization ( ) { @Override public void customize ( Kryo kryo ) { tkryo . setAsmEnabled ( true ) ; } 
@Override public void customize ( Kryo kryo ) { tkryo . setAsmEnabled ( true ) ; } 
@Override public void customize ( Kryo kryo ) { tkryo . addDefaultSerializer ( Collection . class , collectionSerializer ) ; } 
tabstract Kryo build ( DefaultClassResolver classResolver , tMapReferenceResolver referenceResolver , tDefaultStreamFactory streamFactory , tInstantiatorStrategy instantiatorStrategy , tKryoCustomization enableAsm , tKryoCustomization registerMyCollectionSerializer ) ; @Override public String toString ( ) { treturn getClass ( ) . getSimpleName ( ) + " ( " + description + " ) " ; } } } 
public String toString ( ) { treturn getClass ( ) . getSimpleName ( ) + " ( " + description + " ) " ; } 
protected abstract String [ ] getSetCookieHeaders ( final Response response ) ; private void logDebugResponseCookie ( final Response response ) { final String [ ] headers = getSetCookieHeaders ( response ) ; if ( headers ! = null ) { for ( final String header : headers ) { if ( header ! = null & & header . contains ( _sessionCookieName ) ) { _log . debug ( " Request finished, with Set-Cookie header: " + header ) ; } } } } } 
private void logDebugResponseCookie ( final Response response ) { final String [ ] headers = getSetCookieHeaders ( response ) ; if ( headers ! = null ) { for ( final String header : headers ) { 
protected void onAfterDeleteFromMemcached ( @Nonnull final String sessionId ) { final long start = System . currentTimeMillis ( ) ; final String validityInfoKey = _sessionIdFormat . createValidityInfoKeyName ( sessionId ) ; _storage . delete ( validityInfoKey ) ; if ( _storeSecondaryBackup ) { try { _storage . delete ( _sessionIdFormat . createBackupKey ( sessionId ) ) ; _storage . delete ( _sessionIdFormat . createBackupKey ( validityInfoKey ) ) ; } catch ( Exception e ) { _log . info ( " Could not delete backup data for session " + sessionId + " (not critical, data will be evicted by memcached automatically). " , e ) ; } } _stats . registerSince ( NON_STICKY_AFTER_DELETE_FROM_MEMCACHED , start ) ; } 
public ConcurrentMap < String , Object > get ( MemcachedBackupSession session ) { return session . attributes ; } 
public static LockingStrategy create ( @Nullable final LockingMode lockingMode , @Nullable final Pattern uriPattern , @Nullable final StorageClient storage , @Nonnull final MemcachedSessionService manager , @Nonnull final MemcachedNodesManager memcachedNodesManager , @Nonnull final LRUCache < String , Boolean > missingSessionsCache , final boolean storeSecondaryBackup , @Nonnull final Statistics stats , @Nonnull final CurrentRequest currentRequest ) { if ( lockingMode = = null | | storage = = null ) { return null ; } switch ( lockingMode ) { case ALL : 
private KryoFactory createKryoFactory ( final ClassLoader classLoader , final String [ ] customConverterClassNames , final boolean copyCollectionsForSerialization ) { return new KryoFactory ( ) { @Override 
public Kryo create ( ) { KryoBuilder kryoBuilder = new KryoBuilder ( ) { @Override protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return KryoTranscoder . this . createKryo ( classResolver , referenceResolver , streamFactory , classLoader , customConverterClassNames , copyCollectionsForSerialization ) ; } } . withInstantiatorStrategy ( new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ) ; final List < KryoBuilderConfiguration > builderConfigs = load ( KryoBuilderConfiguration . class , customConverterClassNames , classLoader ) ; for ( KryoBuilderConfiguration config : builderConfigs ) { kryoBuilder = config . configure ( kryoBuilder ) ; } Kryo kryo = kryoBuilder . build ( ) ; kryo . setDefaultSerializer ( new KryoDefaultSerializerFactory . SerializerFactoryAdapter ( _defaultSerializerFactory ) ) ; if ( classLoader ! = null ) { kryo . setClassLoader ( classLoader ) ; } com.esotericsoftware.minlog.Log.TRACE = true; kryo.setRegistrationRequired(false); kryo.register( Arrays.asList( "" ).getClass(), new ArraysAsListSerializer() ); kryo.register(InvocationHandler.class, new JdkProxySerializer()); UnmodifiableCollectionsSerializer.registerSerializers(kryo); SynchronizedCollectionsSerializer.registerSerializers(kryo); kryo.addDefaultSerializer(EnumMap.class, EnumMapSerializer.class); SubListSerializers.addDefaultSerializers(kryo); final List<KryoCustomization> customizations = load(KryoCustomization.class, customConverterClassNames, classLoader, kryo); if ( customizations != null ) { for( final KryoCustomization customization : customizations ) { try { LOG.info( "Executing KryoCustomization " + customization.getClass().getName() ); customization.customize( kryo ); } catch( final Throwable e ) { LOG.error( "Could not execute customization " + customization, e ); } } } return kryo; } 
protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { return KryoTranscoder . this . createKryo ( classResolver , referenceResolver , streamFactory , classLoader , customConverterClassNames , copyCollectionsForSerialization ) ; 
protected Kryo createKryo ( ClassResolver classResolver , ReferenceResolver referenceResolver , StreamFactory streamFactory ) { Kryo kryo = new Kryo ( classResolver , referenceResolver , streamFactory ) ; Maintain Kryo compatibility (pre version 4) - can turn this off by calling withOptimizedGenerics(false) kryo.getFieldSerializerConfig().setOptimizedGenerics(true); return kryo; } 
public KryoBuilder withOptimizedGenerics ( final boolean optimizedGenerics ) { return new KryoBuilder ( ) { @Override 
public Kryo build ( ) { Kryo k = this . buildFrom ( KryoBuilder . this ) ; k . getFieldSerializerConfig ( ) . setOptimizedGenerics ( optimizedGenerics ) ; return k ; } 
private Serializer < ? > loadCustomSerializer ( final Class < ? > clazz , List < SerializerFactory > serializerFactories ) { if ( serializerFactories ! = null ) { for ( SerializerFactory serializerFactory : serializerFactories ) { final Serializer < ? > serializer = serializerFactory . newSerializer ( clazz ) ; if ( serializer ! = null ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading custom serializer " + serializer . getClass ( ) . getName ( ) + " for class " + clazz ) ; } return serializer ; } } } return null ; } 
private Serializer < ? > loadCopyCollectionSerializer ( final Class < ? > clazz ) { if ( Collection . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateCollectionSerializer for class " + clazz ) ; } return new CopyForIterateCollectionSerializer ( ) ; } if ( Map . class . isAssignableFrom ( clazz ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading CopyForIterateMapSerializer for class " + clazz ) ; } return new CopyForIterateMapSerializer ( ) ; } return null ; } 
public ConcurrentMap < String , Object > deserializeAttributes ( final byte [ ] data ) { final Kryo kryo = _kryoPool . borrow ( ) ; Input in = null ; try { in = kryo . getStreamFactory ( ) . getInput ( data ) ; 
public byte [ ] serializeAttributes ( final MemcachedBackupSession session , final ConcurrentMap < String , Object > attributes ) { final Kryo kryo = _kryoPool . borrow ( ) ; Output out = null ; try { / * * 
private void closeSilently ( Closeable closeable ) { if ( closeable ! = null ) { try { 
public void testKryoBuilder ( BuildKryo buildKryo ) { tDefaultClassResolver classResolver = new DefaultClassResolver ( ) ; tMapReferenceResolver referenceResolver = new MapReferenceResolver ( ) ; tDefaultStreamFactory streamFactory = new DefaultStreamFactory ( ) ; tInstantiatorStrategy instantiatorStrategy = new Kryo . DefaultInstantiatorStrategy ( new StdInstantiatorStrategy ( ) ) ; tKryoCustomization enableAsm = new KryoCustomization ( ) { @Override public void customize ( Kryo kryo ) { tkryo . getFieldSerializerConfig ( ) . setUseAsm ( true ) ; } 
@Override public void customize ( Kryo kryo ) { tkryo . getFieldSerializerConfig ( ) . setUseAsm ( true ) ; } 
protected void acquireLock ( @Nonnull final String sessionId , final long retryInterval , final long maxRetryInterval , final long timeout , final long start ) throws InterruptedException , ExecutionException , TimeoutException { final Future < Boolean > result = _storage . add ( _sessionIdFormat . createLockName ( sessionId ) , _manager . getLockExpiration ( ) , LOCK_VALUE ) ; if ( result . get ( ) . booleanValue ( ) ) { if ( _log . isDebugEnabled ( ) ) { 
private TomcatBuilder < ? > startTomcat ( final int port , final String memcachedNodes , final LockingMode lockingMode ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . sessionTimeout ( 5 ) . memcachedNodes ( memcachedNodes ) . sticky ( false ) . lockingMode ( lockingMode ) . lockExpire ( 5 ) . storageKeyPrefix ( null ) . buildAndStart ( ) ; 
public TomcatBuilder < T > lockExpire ( final int lockExpire ) { this . lockExpire = lockExpire ; return this ; } 
public Tomcat build ( ) throws MalformedURLException , UnknownHostException , LifecycleException { final Tomcat tomcat = new Tomcat ( ) ; final URL root = new URL ( TestUtils . class . getResource ( " / " ) , " ../test-classes " ) ; use file to get correct separator char, replace %20 introduced by URL for spaces final String cleanedRoot = new File( root.getFile().replaceAll("%20", " ") ).toString(); final String fileSeparator = File.separator.equals( "\\" ) ? "\\\\" : File.separator; final String docBase = cleanedRoot + File.separator + TestUtils.class.getPackage().getName().replaceAll( "\\.", fileSeparator ); final Connector connector = tomcat.getConnector(); connector.setPort(port); connector.setProperty("bindOnInit", "false"); sessionManager.getMemcachedSessionService().setMemcachedNodes( memcachedNodes ); sessionManager.getMemcachedSessionService().setFailoverNodes( failoverNodes ); sessionManager.getMemcachedSessionService().setEnabled(enabled); sessionManager.getMemcachedSessionService().setSticky(sticky); if(lockingMode != null) { sessionManager.getMemcachedSessionService().setLockingMode(lockingMode.name()); sessionManager.getMemcachedSessionService().setLockExpiration(lockExpire); } sessionManager.getMemcachedSessionService().setMemcachedProtocol(memcachedProtocol); sessionManager.getMemcachedSessionService().setUsername(username); sessionManager.setMaxInactiveInterval( sessionTimeout ); 1 second sessionManager.getMemcachedSessionService().setSessionBackupAsync( false ); sessionManager.getMemcachedSessionService().setSessionBackupTimeout( 100 ); sessionManager.setProcessExpiresFrequency( 1 ); 1 second (factor for context.setBackgroundProcessorDelay) sessionManager.getMemcachedSessionService().setTranscoderFactoryClass( transcoderFactoryClassName != null ? transcoderFactoryClassName : DEFAULT_TRANSCODER_FACTORY ); sessionManager.getMemcachedSessionService().setRequestUriIgnorePattern(".*\\.(png|gif|jpg|css|js|ico)$"); sessionManager.getMemcachedSessionService().setStorageKeyPrefix(storageKeyPrefix); return tomcat; } 
URI createURI ( String redisUrl ) throws URISyntaxException { URI uri = new URI ( redisUrl ) ; set default port 6379 unless specified. if (uri.getPort() < 0) uri = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), 6379, uri.getPath(), uri.getQuery(), uri.getFragment()); return uri; } 
public Future < Boolean > add ( final String key , final int exp , final byte [ ] o ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( format ( " Adding key to Redis (key=%s, exp=%s, o=%s) " , key , exp , o . getClass ( ) . getName ( ) ) ) ; return _executor . submit ( new RedisCommandCallable < Boolean > ( ) { private volatile boolean _setCompleted ; 
public Future < Boolean > set ( final String key , final int exp , final byte [ ] o ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( format ( " Setting key in Redis (key=%s, exp=%s, o=%s) " , key , exp , o . getClass ( ) . getName ( ) ) ) ; return _executor . submit ( new RedisCommandCallable < Boolean > ( ) { @Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { 
public byte [ ] get ( final String key ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( format ( " Getting key from Redis (key=%s) " , key ) ) ; Callable < byte [ ] > callable = new RedisCommandCallable < byte [ ] > ( ) { @Override protected byte [ ] execute ( BinaryJedis jedis ) throws Exception { return jedis . get ( keyBytes ( key ) ) ; } } ; Execute callable synchronously since we need to wait for the result anyway try { return callable.call(); 
public Future < Boolean > delete ( final String key ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( format ( " Deleting key in Redis (key=%s) " , key ) ) ; return _executor . submit ( new RedisCommandCallable < Boolean > ( ) { @Override protected Boolean execute ( BinaryJedis jedis ) throws Exception { 
protected abstract T execute ( BinaryJedis jedis ) throws Exception ; } private class JedisPool { private Queue < BinaryJedis > _queue = new ConcurrentLinkedQueue < BinaryJedis > ( ) ; public BinaryJedis borrowInstance ( boolean knownGood ) { BinaryJedis res ; if ( ( res = _queue . poll ( ) ) = = null ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( format ( " Creating new Jedis instance (host=%s, port=%s, ssl=%s) " , _uri . getHost ( ) , _uri . getPort ( ) , _uri . getScheme ( ) . startsWith ( " rediss " ) ) ) ; } return createJedisInstance ( ) ; } if ( knownGood ) { Check all existing connections until we find a good one do { try { res.ping(); if (_log.isTraceEnabled()) _log.trace(format("Using known-good connection #%d", _queue.size())); return res; } catch (Exception e) { if (_log.isDebugEnabled()) _log.debug(format("Removing connection #%d since it cannot be pinged", _queue.size())); try { res.close(); } catch (Exception e2) { } } } private BinaryJedis createJedisInstance() { BinaryJedis binaryJedis = new BinaryJedis(_uri); binaryJedis.getClient().setConnectionTimeout(_timeout); binaryJedis.getClient().setSoTimeout(_timeout); return binaryJedis; } }} 
public BinaryJedis borrowInstance ( boolean knownGood ) { BinaryJedis res ; if ( ( res = _queue . poll ( ) ) = = null ) { if ( _log . isDebugEnabled ( ) ) { _log . debug ( format ( " Creating new Jedis instance (host=%s, port=%s, ssl=%s) " , _uri . getHost ( ) , _uri . getPort ( ) , _uri . getScheme ( ) . startsWith ( " rediss " ) ) ) ; } return createJedisInstance ( ) ; } if ( knownGood ) { Check all existing connections until we find a good one 
public void returnInstance ( BinaryJedis instance ) { _queue . offer ( instance ) ; if ( _log . isTraceEnabled ( ) ) _log . trace ( format ( " Returned instance #%d " , _queue . size ( ) ) ) ; 
public void shutdown ( ) { if ( _log . isDebugEnabled ( ) ) _log . debug ( format ( " Closing %d Jedis instance(s) " , _queue . size ( ) ) ) ; BinaryJedis instance ; while ( ( instance = _queue . poll ( ) ) ! = null ) { try { instance . close ( ) ; } catch ( Exception e ) { } 
private BinaryJedis createJedisInstance ( ) { BinaryJedis binaryJedis = new BinaryJedis ( _uri ) ; binaryJedis . getClient ( ) . setConnectionTimeout ( _timeout ) ; binaryJedis . getClient ( ) . setSoTimeout ( _timeout ) ; return binaryJedis ; } 
public void testCreateUri01 ( ) throws Exception { RedisStorageClient client = createClient ( ) ; URI uri = client . createURI ( " redis:user:pwd@localhost " ) ; assertEquals ( uri . getScheme ( ) , " redis " ) ; assertEquals ( uri . getUserInfo ( ) , " user:pwd " ) ; assertEquals ( uri . getHost ( ) , " localhost " ) ; assertTrue ( uri . getPort ( ) = = 6379 ) ; uri = client . createURI ( " rediss::pwd@localhost:9999 " ) ; assertEquals ( uri . getScheme ( ) , " rediss " ) ; assertEquals ( uri . getUserInfo ( ) , " :pwd " ) ; assertTrue ( uri . getPort ( ) = = 9999 ) ; uri = client . createURI ( " redis:localhost " ) ; assertEquals ( uri . getScheme ( ) , " redis " ) ; assertNull ( uri . getUserInfo ( ) ) ; assertTrue ( uri . getPort ( ) = = 6379 ) ; } 
private static byte [ ] keyBytes ( String key ) { try { return key . getBytes ( " UTF-8 " ) ; 
private List < URI > getURIs ( ) throws URISyntaxException { final List < URI > uris = new ArrayList < URI > ( cluster . size ( ) ) ; for ( final CouchbaseMock server : cluster ) { uris . add ( new URI ( " http:localhost: " + server . getHttpPort ( ) + " /pools " ) ) ; } return uris ; } 
private CouchbaseMock setupCouchbase ( final int couchbasePort ) throws IOException { final CouchbaseMock couchbase = new CouchbaseMock ( " localhost " , couchbasePort , 1 , 1 ) ; couchbase.setRequiredHttpAuthorization(null); couchbase.start(); return couchbase; } 
private void tearDownCouchbase ( ) throws InterruptedException { for ( final CouchbaseMock server : cluster ) { server . stop ( ) ; } cluster . clear ( ) ; } 
public void testSessionNotLoadedForNoSessionAccess ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getStorageClient ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; 2 for session and validity, if backup would be stored this would be 4 instead assertWaitingWithProxy(equalTo(2), 1000, _daemon1.getCache()).getSetCmds(); no gets at all assertEquals( _daemon1.getCache().getGetHits(), 0 ); a request without session access should not pull the session from memcached but update the validity info (get + set) get( _httpClient, TC_PORT_1, PATH_NO_SESSION_ACCESS, sessionId1 ); assertWaitingWithProxy(equalTo(3), 1000, _daemon1.getCache()).getSetCmds(); For TC7 the session is looked up by AuthenticatorBase.invoke(AuthenticatorBase.java:430) (TC 7.0.67) which seems to be installed and always check the user principal - therefore we have 2 hits for the session and the validity info. And we want to allow context level valves to access the session (issue #286), therefore we load the session even if our context valve has not been passed (i.e. findSession is not directly triggered from the webapp). For TC{6,7,8} there's no call from AuthenticatorBase, so there's only 1 hit (validity info) assertEquals( _daemon1.getCache().getGetHits(), getExpectedHitsForNoSessionAccess()); } 
public void testSessionNotLoadedForNoSessionAccess ( ) throws IOException , HttpException , InterruptedException { _tomcat1 . getManager ( ) . setMemcachedNodes ( NODE_ID_1 + " :localhost: " + MEMCACHED_PORT_1 ) ; waitForReconnect ( _tomcat1 . getService ( ) . getStorageClient ( ) , 1 , 1000 ) ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , " foo " , " bar " ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; 2 for session and validity, if backup would be stored this would be 4 instead assertWaitingWithProxy(equalTo(2), 1000, _daemon1.getCache()).getSetCmds(); no gets at all assertEquals( _daemon1.getCache().getGetHits(), 0 ); a request without session access should not pull the session from memcached but update the validity info (get + set) get( _httpClient, TC_PORT_1, PATH_NO_SESSION_ACCESS, sessionId1 ); assertWaitingWithProxy(equalTo(3), 1000, _daemon1.getCache()).getSetCmds(); For TC7 the session is looked up by AuthenticatorBase.invoke(AuthenticatorBase.java:430) (TC 7.0.67) which seems to be installed and always check the user principal - therefore we have 2 hits for the session and the validity info. And we want to allow context level valves to access the session (issue #286), therefore we load the session even if our context valve has not been passed (i.e. findSession is not directly triggered from the webapp). For TC{6,7} there's no call from AuthenticatorBase, so there's only 1 hit (validity info) assertEquals( _daemon1.getCache().getGetHits(), getExpectedHitsForNoSessionAccess()); } 
protected abstract SessionManager createSessionManager ( Context context ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setStorageClient(new MemcachedStorageClient(_memcachedMock)); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(), any(Transcoder.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, null); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(new MemcachedStorageClient(_memcachedMock)); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public static String loginWithForm ( final DefaultHttpClient client , final int tcPort ) throws IOException , HttpException { final Response tc1Response1 = get ( client , tcPort , null ) ; final String sessionId = tc1Response1 . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertTrue ( tc1Response1 . getContent ( ) . contains ( " j_security_check " ) , " /j_security_check not found, app is not properly initialized " ) ; final Map < String , String > params = new HashMap < String , String > ( ) ; params . put ( LoginServlet . J_USERNAME , TestUtils . USER_NAME ) ; params . put ( LoginServlet . J_PASSWORD , TestUtils . PASSWORD ) ; final Response tc1Response2 = post ( client , tcPort , " /j_security_check " , sessionId , params ) ; assertEquals ( tc1Response2 . getSessionId ( ) , sessionId ) ; assertEquals ( tc1Response2 . get ( TestServlet . ID ) , sessionId ) ; return tc1Response2 . getSessionId ( ) ; } 
public void testInvalidatedSessionRemovedFromMemcached ( @Nonnull final SessionAffinityMode sessionAffinity ) throws IOException , InterruptedException , HttpException { setStickyness ( sessionAffinity ) ; final String sessionId1 = makeRequest ( _httpClient , _portTomcat1 , null ) ; assertNotNull ( sessionId1 , " No session created. " ) ; final Response response = get ( _httpClient , _portTomcat1 , PATH_INVALIDATE , sessionId1 ) ; assertNull ( response . getResponseSessionId ( ) ) ; assertNull ( _memcached . get ( sessionId1 ) , " Invalidated session still existing in memcached " ) ; if ( ! sessionAffinity . isSticky ( ) ) { Check that ValidityInfo for invalidated session does not exist in memcached 
public Object call ( ) throws Exception { treturn _memcached . get ( new SessionIdFormat ( ) . createValidityInfoKeyName ( sessionId1 ) ) ; } 
abstract TestUtils < ? > getTestUtils ( ) ; private TomcatBuilder < ? > startTomcat ( final int port , final String jvmRoute ) throws Exception { return startTomcat ( port , SessionAffinityMode . STICKY , jvmRoute , null ) ; } private TomcatBuilder < ? > startTomcat ( final int port , final SessionAffinityMode sessionAffinityMode , final String jvmRoute , final LoginType loginType ) throws Exception { return getTestUtils ( ) . tomcatBuilder ( ) . port ( port ) . memcachedNodes ( _memcachedNodes ) . storageKeyPrefix ( null ) . sticky ( sessionAffinityMode . isSticky ( ) ) . jvmRoute ( jvmRoute ) . loginType ( loginType ) . buildAndStart ( ) ; } @AfterMethod public void tearDown ( ) throws Exception { _client . shutdown ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _daemon . stop ( ) ; if ( _daemon2 ! = null ) _daemon2 . stop ( ) ; } final String actualValue = response.get( key ); assertEquals( value, actualValue ); } private MemCacheDaemon<?> startMemcached(final int memcachedPort) throws IOException { final InetSocketAddress address = new InetSocketAddress( "localhost", memcachedPort ); final MemCacheDaemon<?> daemon2 = createDaemon( address ); daemon2.start(); return daemon2; }} 
public void testTomcatFailover ( ) throws IOException , InterruptedException , HttpException { final SessionIdFormat format = new SessionIdFormat ( ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value ) . getSessionId ( ) ; assertEquals ( format . extractJvmRoute ( sessionId1 ) , JVM_ROUTE_1 ) ; await ( ) . until ( new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { return _client . get ( sessionId1 ) ; } } , notNullValue ( ) ) ; final Response response = get ( _httpClient , TC_PORT_2 , sessionId1 ) ; final String sessionId2 = response . getSessionId ( ) ; assertNull ( _client . get ( sessionId1 ) ) ; assertNotNull ( _client . get ( sessionId2 ) ) ; assertEquals ( format . stripJvmRoute ( sessionId1 ) , format . stripJvmRoute ( sessionId2 ) ) ; assertEquals ( format . extractJvmRoute ( sessionId2 ) , JVM_ROUTE_2 ) ; final String actualValue = response . get ( key ) ; assertEquals ( value , actualValue ) ; Thread . sleep ( 10 ) ; 
public Object call ( ) throws Exception { return _client . get ( sessionId1 ) ; } 
public void testTomcatFailoverMovesSessionToNonFailoverNode ( ) throws Exception { _daemon2 = startMemcached ( MEMCACHED_PORT + 1 ) ; final String memcachedNodes = _memcachedNodes + " , " + " n2:localhost: " + ( MEMCACHED_PORT + 1 ) ; _tomcat1 . getService ( ) . setMemcachedNodes ( memcachedNodes ) ; _tomcat1 . getService ( ) . setFailoverNodes ( " n1 " ) ; _tomcat2 . getService ( ) . setMemcachedNodes ( memcachedNodes ) ; _tomcat2 . getService ( ) . setFailoverNodes ( " n2 " ) ; final SessionIdFormat format = new SessionIdFormat ( ) ; final String key = " foo " ; final String value = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value ) . getSessionId ( ) ; assertEquals ( format . extractMemcachedId ( sessionId1 ) , " n2 " ) ; assertEquals ( _daemon . getCache ( ) . getCurrentItems ( ) , 0 ) ; assertEquals ( _daemon2 . getCache ( ) . getCurrentItems ( ) , 1 ) ; final String sessionId2 = response.getSessionId(); assertEquals( format.stripJvmRoute( sessionId1 ).replaceAll("n2", "n1"), format.stripJvmRoute( sessionId2 ) ); final String actualValue = response.get( key ); assertEquals( value, actualValue ); 
public Response call ( ) throws Exception { treturn get ( _httpClient , TC_PORT_2 , sessionId1 ) ; } 
public boolean matchesSafely ( Response response ) { tfinal String sessionId2 = response . getSessionId ( ) ; treturn format . extractMemcachedId ( sessionId2 ) . equals ( " n1 " ) ; } 
public void testReadOnlyRequestsDontLockSessionForAutoLocking ( ) throws IOException , InterruptedException , HttpException , ExecutionException { setLockingMode ( LockingMode . AUTO , null ) ; final String key1 = " k1 " ; final String value1 = " v1 " ; final String sessionId = post ( _httpClient , TC_PORT_1 , null , key1 , value1 ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; perform a readonly request without waiting, we perform this one later again final String path = "/mypath"; final Map<String, String> params = asMap( "foo", "bar" ); final Response response0 = get( _httpClient, TC_PORT_1, path, sessionId, params ); assertEquals( response0.getSessionId(), sessionId ); perform a readonly, waiting request that we can perform again later final long timeToWaitInMillis = 500; final Map<String, String> paramsWait = asMap( PARAM_MILLIS, String.valueOf( timeToWaitInMillis ) ); final Response response1 = get( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, paramsWait ); assertEquals( response1.getSessionId(), sessionId ); now do it again, now in the background, and in parallel start another readonly request, both should not block each other final long start = currentTimeMillis(); final Future<Response> response2 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, paramsWait ); } }); final Future<Response> response3 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, paramsWait ); } }); response2.get(); response3.get(); assertTrue ( ( currentTimeMillis() - start ) < ( 2 * timeToWaitInMillis ), "The time for both requests should be less than 2 * the wait time if they don't block each other." ); assertEquals( response2.get().getSessionId(), sessionId ); assertEquals( response3.get().getSessionId(), sessionId ); now perform a modifying request and a readonly in parallel which should not be blocked final Future<Response> response4 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return post( _httpClient, TC_PORT_1, PATH_WAIT, sessionId, asMap( PARAM_MILLIS, "500", "foo", "bar" ) ); } }); Thread.sleep( 50 ); final Response response5 = get( _httpClient, TC_PORT_1, path, sessionId, params ); assertEquals( response5.getSessionId(), sessionId ); assertFalse( response4.isDone(), "The readonly request should return before the long, session locking one" ); assertEquals( response4.get().getSessionId(), sessionId ); 
public void testRequestsDontLockSessionForNotMatchingUriPattern ( ) throws IOException , InterruptedException , HttpException , ExecutionException { final String pathToLock = " /locksession " ; setLockingMode ( LockingMode . URI_PATTERN , Pattern . compile ( pathToLock + " .* " ) ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; perform a request not matching the uri pattern, and in parallel start another request that should lock the session final long timeToWaitInMillis = 500; final Map<String, String> paramsWait = asMap( PARAM_WAIT, "true", PARAM_MILLIS, String.valueOf( timeToWaitInMillis ) ); final long start = currentTimeMillis(); final Future<Response> response2 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, "/pathNotMatchingLockUriPattern", sessionId, paramsWait ); } }); final Future<Response> response3 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, pathToLock, sessionId, paramsWait ); } }); response2.get(); response3.get(); assertTrue ( ( currentTimeMillis() - start ) < ( 2 * timeToWaitInMillis ), "The time for both requests should be less than 2 * the wait time if they don't block each other." ); assertEquals( response2.get().getSessionId(), sessionId ); assertEquals( response3.get().getSessionId(), sessionId ); now perform a locking request and a not locking in parallel which should also not be blocked final Future<Response> response4 = _executor.submit( new Callable<Response>() { @Override public Response call() throws Exception { return get( _httpClient, TC_PORT_1, pathToLock, sessionId, paramsWait ); } }); Thread.sleep( 50 ); final Response response5 = get( _httpClient, TC_PORT_1, "/pathNotMatchingLockUriPattern", sessionId ); assertEquals( response5.getSessionId(), sessionId ); assertFalse( response4.isDone(), "The non locking request should return before the long, session locking one" ); assertEquals( response4.get().getSessionId(), sessionId ); 
public void testNonStickySessionIsValidEvenWhenAccessedReadonly ( @Nonnull final LockingMode lockingMode , @Nullable final Pattern uriPattern ) throws IOException , InterruptedException , HttpException , ExecutionException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; _tomcat1 . getManager ( ) . setLockingMode ( lockingMode , uriPattern , true ) ; long start = currentTimeMillis ( ) ; final String sessionId = get ( _httpClient , TC_PORT_1 , null ) . getSessionId ( ) ; assertNotNull ( sessionId ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId , " Wrong/new sessionId after " + ( currentTimeMillis ( ) - start ) + " ms. " ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId , " Wrong/new sessionId after " + ( currentTimeMillis ( ) - start ) + " ms. " ) ; Thread . sleep ( 500 ) ; assertEquals ( get ( _httpClient , TC_PORT_1 , sessionId ) . getSessionId ( ) , sessionId , " Wrong/new sessionId after " + ( currentTimeMillis ( ) - start ) + " ms. " ) ; 
protected abstract SessionManager createSessionManager ( Context context ) ; @Test public void testConfigurationFormatMemcachedNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211,n2:127.0.0.1:11212 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @Test public void testConfigurationFormatFailoverNodesFeature44 ( ) throws LifecycleException { _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; _service . setFailoverNodes ( " n1 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1 n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 n3:127.0.0.1:11213 " ) ; _service . setFailoverNodes ( " n1,n2 " ) ; _service . startInternal ( new MemcachedStorageClient ( _memcachedMock ) ) ; Assert . assertEquals ( _service . getFailoverNodeIds ( ) , Arrays . asList ( " n1 " , " n2 " ) ) ; } @SuppressWarnings( { "unchecked", "rawtypes" } ) @Test public void testOnlyFilteredAttributesAreIncludedDuringUpdateExpiration() throws InterruptedException, ExecutionException { final TranscoderService transcoderServiceMock = mock( TranscoderService.class ); final ConcurrentMap<String, Object> anyMap = any( ConcurrentMap.class ); when( transcoderServiceMock.serializeAttributes( any( MemcachedBackupSession.class ), anyMap ) ).thenReturn( new byte[0] ); _service.setTranscoderService( transcoderServiceMock ); final MemcachedBackupSession session = createSession( _service ); _service.setSessionAttributeFilter( "^(foo|bar)$" ); session.setAttribute( "foo", "foo" ); session.setAttribute( "bar", "bar" ); session.setAttribute( "baz", "baz" ); session.access(); session.endAccess(); _service.updateExpirationInMemcached(); capture the supplied argument, alternatively we could have used some Matcher (but there seems to be no MapMatcher). final ArgumentCaptor<ConcurrentMap> model = ArgumentCaptor.forClass( ConcurrentMap.class ); verify( transcoderServiceMock, times( 1 ) ).serializeAttributes( eq( session ), model.capture() ); the serialized attributes must only contain allowed ones assertTrue( model.getValue().containsKey( "foo" ) ); assertTrue( model.getValue().containsKey( "bar" ) ); assertFalse( model.getValue().containsKey( "baz" ) ); } @Test public void testSessionsRefCountHandlingIssue111() throws Exception { _service.setSticky(false); _service.setLockingMode(LockingMode.ALL.name()); final TranscoderService transcoderService = new TranscoderService(new JavaSerializationTranscoder()); _service.setTranscoderService( transcoderService ); _service.setStorageClient(new MemcachedStorageClient(_memcachedMock)); _service.startInternal(); @SuppressWarnings("unchecked") final OperationFuture<Boolean> addResultMock = mock(OperationFuture.class); when(addResultMock.get()).thenReturn(true); when(addResultMock.get(anyLong(), any(TimeUnit.class))).thenReturn(true); when(_memcachedMock.add(anyString(), anyInt(), any(), any(Transcoder.class))).thenReturn(addResultMock); final MemcachedBackupSession session = createSession( _service ); the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, "unused"); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, "unused"); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); } @Test public void testInvalidNonStickySessionDoesNotCallOnBackupWithoutLoadedSessionIssue137() throws Exception { _service.setStickyInternal( false ); _service.setLockingMode( LockingMode.NONE, null, false ); _service.startInternal(new MemcachedStorageClient(_memcachedMock)); we must put in our mock again final String sessionId = "nonStickySessionToTimeOut-n1"; For findSession needed final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); final MemcachedBackupSession session = _service.findSession(sessionId); assertNull(session); _service.backupSession( sessionId, false, null ).get(); check that validity info is not loaded - this would trigger the WARNING: Found no validity info for session id ... final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); verify( _memcachedMock, times( 0 ) ).get( eq( validityKey ) ); }} 
public void testSessionTimeoutUnlimitedWithSessionLoaded ( final SessionAffinityMode stickyness ) throws InterruptedException , ExecutionException , LifecycleException { _service . setStickyInternal ( stickyness . isSticky ( ) ) ; if ( ! stickyness . isSticky ( ) ) { _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(new MemcachedStorageClient(_memcachedMock)); we must put in our mock again } final MemcachedBackupSession session = createSession( _service ); session.setMaxInactiveInterval( -1 ); session.access(); session.endAccess(); session.setAttribute( "foo", "bar" ); final String sessionId = session.getId(); _service.backupSession( sessionId, false, "unused" ).get(); verify( _memcachedMock, times( 1 ) ).set( eq( sessionId ), eq( 0 ), any(), any( Transcoder.class ) ); if ( !stickyness.isSticky() ) { check validity info 
public void testSessionTimeoutUnlimitedWithNonStickySessionNotLoaded ( ) throws InterruptedException , ExecutionException , LifecycleException , TimeoutException { _service . setStickyInternal ( false ) ; _service . setLockingMode ( LockingMode . NONE , null , false ) ; _service . setMemcachedNodes ( " n1:127.0.0.1:11211 n2:127.0.0.1:11212 " ) ; for backup support _service.startInternal(new MemcachedStorageClient(_memcachedMock)); we must put in our mock again final String sessionId = "someSessionNotLoaded-n1"; stub loading of validity info final String validityKey = new SessionIdFormat().createValidityInfoKeyName( sessionId ); final byte[] validityData = encode( -1, System.currentTimeMillis(), System.currentTimeMillis() ); when( _memcachedMock.get( eq( validityKey ), any ( Transcoder.class) ) ).thenReturn( validityData ); stub session (backup) ping @SuppressWarnings( "unchecked" ) final OperationFuture<Boolean> futureMock = mock( OperationFuture.class ); when( futureMock.get() ).thenReturn( Boolean.FALSE ); when( futureMock.get( anyInt(), any( TimeUnit.class ) ) ).thenReturn( Boolean.FALSE ); when( _memcachedMock.add( any( String.class ), anyInt(), any(), any( Transcoder.class ) ) ).thenReturn( futureMock ); _service.backupSession( sessionId, false, "unused" ).get(); update validity info verify( _memcachedMock, times( 1 ) ).set( eq( validityKey ), eq( 0 ), any(), any( Transcoder.class ) ); As the backup is done asynchronously, we shutdown the executor so that we know the backup task is executed/finished. _service.getLockingStrategy().getExecutorService().shutdown(); On windows we need to wait a little bit so that the tasks _really_ have finished (not needed on linux) Thread.sleep(15); ping session verify( _memcachedMock, times( 1 ) ).add( eq( sessionId ), anyInt(), any(), any( Transcoder.class ) ); ping session backup final String backupSessionKey = new SessionIdFormat().createBackupKey( sessionId ); verify( _memcachedMock, times( 1 ) ).add( eq( backupSessionKey ), anyInt(), any(), any( Transcoder.class ) ); update validity backup final String backupValidityKey = new SessionIdFormat().createBackupKey( validityKey ); verify( _memcachedMock, times( 1 ) ).set( eq( backupValidityKey ), eq( 0 ), any(), any( Transcoder.class ) ); } 
public void testSessionsRefCountHandlingIssue111 ( ) throws Exception { _service . setSticky ( false ) ; _service . setLockingMode ( LockingMode . ALL . name ( ) ) ; final TranscoderService transcoderService = new TranscoderService ( new JavaSerializationTranscoder ( ) ) ; _service . setTranscoderService ( transcoderService ) ; _service . setStorageClient ( new MemcachedStorageClient ( _memcachedMock ) ) ; _service . startInternal ( ) ; @SuppressWarnings ( " unchecked " ) final OperationFuture < Boolean > addResultMock = mock ( OperationFuture . class ) ; when ( addResultMock . get ( ) ) . thenReturn ( true ) ; when ( addResultMock . get ( anyLong ( ) , any ( TimeUnit . class ) ) ) . thenReturn ( true ) ; when ( _memcachedMock . add ( anyString ( ) , anyInt ( ) , any ( ) , any ( Transcoder . class ) ) ) . thenReturn ( addResultMock ) ; final MemcachedBackupSession session = createSession ( _service ) ; the session is now already added to the internal session map assertNotNull(session.getId()); Future<BackupResult> result = _service.backupSession(session.getId(), false, "unused"); assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); start another request that loads the session from mc final Request requestMock = mock(Request.class); when(requestMock.getNote(eq(RequestTrackingContextValve.INVOKED))).thenReturn(Boolean.TRUE); _service.getTrackingHostValve().storeRequestThreadLocal(requestMock); when(_memcachedMock.get(eq(session.getId()), any(Transcoder.class))).thenReturn(transcoderService.serialize(session)); final MemcachedBackupSession session2 = _service.findSession(session.getId()); assertTrue(session2.isLocked()); assertEquals(session2.getRefCount(), 1); session2.setAttribute("foo", "bar"); final CyclicBarrier barrier = new CyclicBarrier(2); the session is now in the internal session map, now let's run a concurrent request final Future<BackupResult> request2 = _executor.submit(new Callable<BackupResult>() { @Override public BackupResult call() throws Exception { final MemcachedBackupSession session3 = _service.findSession(session.getId()); assertSame(session3, session2); assertEquals(session3.getRefCount(), 2); let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, "unused"); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } }); barrier.await(); result = _service.backupSession(session.getId(), false, null); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SKIPPED); This is the important point! assertTrue(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 1); now let the other thread proceed barrier.await(); and wait for the result, also to get exceptions/assertion errors. request2.get(); 
public BackupResult call ( ) throws Exception { final MemcachedBackupSession session3 = _service . findSession ( session . getId ( ) ) ; assertSame ( session3 , session2 ) ; assertEquals ( session3 . getRefCount ( ) , 2 ) ; let the other thread proceed (or wait) barrier.await(); and wait again so that the other thread can do some work barrier.await(); final Future<BackupResult> result = _service.backupSession(session.getId(), false, "unused"); _service.getTrackingHostValve().resetRequestThreadLocal(); assertEquals(result.get().getStatus(), BackupResultStatus.SUCCESS); The session should be released now and no longer stored assertFalse(_service.getManager().getSessionsInternal().containsKey(session.getId())); just some double checking on expectations... assertEquals(session2.getRefCount(), 0); return result.get(); } 
public void setup ( ) throws LifecycleException , ClassNotFoundException , tIOException { tsuper . setup ( ) ; final Context context = _manager . getContext ( ) ; twhen ( _manager . getContext ( ) ) . thenReturn ( context ) ; } 
public Tomcat9Builder buildAndStart ( ) throws Exception { tomcat = build ( ) ; tomcat . start ( ) ; return this ; } 
public void tearDown ( ) throws Exception { _client . shutdown ( 10 , SECONDS ) ; _daemon1 . stop ( ) ; _daemon2 . stop ( ) ; if ( _daemon3 ! = null & & _daemon3 . isRunning ( ) ) { _daemon3 . stop ( ) ; } _tomcat1 . stop ( ) ; _tomcat2 . stop ( ) ; _httpClient . getConnectionManager ( ) . shutdown ( ) ; _executor . shutdownNow ( ) ; } 
public void testNoStaleSessionsWithNonStickySessions ( ) throws IOException , InterruptedException , HttpException { _tomcat1 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; _tomcat2 . getManager ( ) . setMaxInactiveInterval ( 1 ) ; final String key = " foo " ; final String value1 = " bar " ; final String sessionId1 = post ( _httpClient , TC_PORT_1 , null , key , value1 ) . getSessionId ( ) ; assertNotNull ( sessionId1 ) ; await ( " session exists in memcached " ) . ignoreExceptions ( ) . until ( new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { return _client . get ( sessionId1 ) ; } } , notNullValue ( ) ) ; final Response response = get ( _httpClient , TC_PORT_1 , sessionId1 ) ; assertEquals ( response . getSessionId ( ) , sessionId1 ) ; assertEquals ( response . get ( key ) , value2 ) ; 
